/**
 * @file rewrite.c
 *
 * @copyright Copyright (c) 2024
 *
 */

/*
 * rewrite.c -- rewriter used for single instr
 */

#include "rewrite.h"
#include "arch.h"
#include "arch_exports.h"
#include "decode.h"
#include "decode_private.h"
#include "disassemble.h"
#include "disassemble_api.h"
#include "dr_ir_utils.h"
#include "dr_tools.h"
#include "globals_api.h"
#include "globals_shared.h"
#include "include/dr_defines.h"
#include "include/dr_ir_macros_x86.h"
#include "include/dr_ir_opcodes_x86.h"
#include "instr.h"
#include "instr_api.h"
#include "instr_create_api.h"
#include "instr_create_shared_api.h"
#include "instrlist_api.h"
#include "opnd.h"
#include "opnd_api.h"
#include "rewrite_utils.h"
// #include "rewrite_analysis.h"
#include <sys/types.h>

dr_zmm_map_ymm_pair_t zmm_to_ymm_pair_mappings[MCXT_NUM_SIMD_SLOTS];
dr_ymm_map_ymm_t ymm_to_ymm_mappings[MCXT_NUM_SIMD_SLOTS];

/**
 * NOTE: replace one rw_func_empty with the actual rewrite function name, once that
 * function implemented
 */

/**
 * @brief rewrite_func
 *
 */
instr_rewrite_func_t *rewrite_funcs[] = {
    /* 1 OP_AVX512_vmovss */ rw_func_vmovss,
    /* 2 OP_AVX512_vmovsd */ rw_func_vmovsd,
    /* 3 OP_AVX512_vmovups */ rw_func_vmovups,
    /* 4 OP_AVX512_vmovupd */ rw_func_vmovupd,
    /* 5 OP_AVX512_vmovlps */ rw_func_vmovlps,
    /* 6 OP_AVX512_vmovsldup */ rw_func_vmovsldup,
    /* 7 OP_AVX512_vmovlpd */ rw_func_vmovlpd,
    /* 8 OP_AVX512_vmovddup */ rw_func_vmovddup,
    /* 9 OP_AVX512_vunpcklps */ rw_func_vunpcklps,
    /* 10 OP_AVX512_vunpcklpd */ rw_func_vunpcklpd,
    /* 11 OP_AVX512_vunpckhps */ rw_func_vunpckhps,
    /* 12 OP_AVX512_vunpckhpd */ rw_func_vunpckhpd,
    /* 13 OP_AVX512_vmovhps */ rw_func_vmovhps,
    /* 14 OP_AVX512_vmovshdup */ rw_func_vmovshdup,
    /* 15 OP_AVX512_vmovhpd */ rw_func_vmovhpd,
    /* 16 OP_AVX512_vmovaps */ rw_func_vmovaps,
    /* 17 OP_AVX512_vmovapd */ rw_func_vmovapd,
    /* 18 OP_AVX512_vcvtsi2ss */ rw_func_vcvtsi2ss,
    /* 19 OP_AVX512_vcvtsi2sd */ rw_func_vcvtsi2sd,
    /* 20 OP_AVX512_vmovntps */ rw_func_vmovntps,
    /* 21 OP_AVX512_vmovntpd */ rw_func_vmovntpd,
    /* 22 OP_AVX512_vcvttss2si */ rw_func_vcvttss2si,
    /* 23 OP_AVX512_vcvttsd2si */ rw_func_vcvttsd2si,
    /* 24 OP_AVX512_vcvtss2si */ rw_func_vcvtss2si,
    /* 25 OP_AVX512_vcvtsd2si */ rw_func_vcvtsd2si,
    /* 26 OP_AVX512_vucomiss */ rw_func_vucomiss,
    /* 27 OP_AVX512_vucomisd */ rw_func_vucomisd,
    /* 28 OP_AVX512_vcomiss */ rw_func_vcomiss,
    /* 29 OP_AVX512_vcomisd */ rw_func_vcomisd,
    /* 30 OP_AVX512_vmovmskps */ rw_func_vmovmskps,
    /* 31 OP_AVX512_vmovmskpd */ rw_func_vmovmskpd,
    /* 32 OP_AVX512_vsqrtps */ rw_func_vsqrtps,
    /* 33 OP_AVX512_vsqrtss */ rw_func_vsqrtss,
    /* 34 OP_AVX512_vsqrtpd */ rw_func_vsqrtpd,
    /* 35 OP_AVX512_vsqrtsd */ rw_func_vsqrtsd,
    /* 36 OP_AVX512_vrsqrtps */ rw_func_empty,
    /* 37 OP_AVX512_vrsqrtss */ rw_func_empty,
    /* 38 OP_AVX512_vrcpps */ rw_func_empty,
    /* 39 OP_AVX512_vrcpss */ rw_func_empty,
    /* 40 OP_AVX512_vandps */ rw_func_empty,
    /* 41 OP_AVX512_vandpd */ rw_func_empty,
    /* 42 OP_AVX512_vandnps */ rw_func_empty,
    /* 43 OP_AVX512_vandnpd */ rw_func_empty,
    /* 44 OP_AVX512_vorps */ rw_func_empty,
    /* 45 OP_AVX512_vorpd */ rw_func_empty,
    /* 46 OP_AVX512_vxorps */ rw_func_empty,
    /* 47 OP_AVX512_vxorpd */ rw_func_empty,
    /* 48 OP_AVX512_vaddps */ rw_func_empty,
    /* 49 OP_AVX512_vaddss */ rw_func_empty,
    /* 50 OP_AVX512_vaddpd */ rw_func_empty,
    /* 51 OP_AVX512_vaddsd */ rw_func_empty,
    /* 52 OP_AVX512_vmulps */ rw_func_empty,
    /* 53 OP_AVX512_vmulss */ rw_func_empty,
    /* 54 OP_AVX512_vmulpd */ rw_func_empty,
    /* 55 OP_AVX512_vmulsd */ rw_func_empty,
    /* 56 OP_AVX512_vcvtps2pd */ rw_func_empty,
    /* 57 OP_AVX512_vcvtss2sd */ rw_func_empty,
    /* 58 OP_AVX512_vcvtpd2ps */ rw_func_empty,
    /* 59 OP_AVX512_vcvtsd2ss */ rw_func_empty,
    /* 60 OP_AVX512_vcvtdq2ps */ rw_func_empty,
    /* 61 OP_AVX512_vcvttps2dq */ rw_func_empty,
    /* 62 OP_AVX512_vcvtps2dq */ rw_func_empty,
    /* 63 OP_AVX512_vsubps */ rw_func_empty,
    /* 64 OP_AVX512_vsubss */ rw_func_empty,
    /* 65 OP_AVX512_vsubpd */ rw_func_empty,
    /* 66 OP_AVX512_vsubsd */ rw_func_empty,
    /* 67 OP_AVX512_vminps */ rw_func_empty,
    /* 68 OP_AVX512_vminss */ rw_func_empty,
    /* 69 OP_AVX512_vminpd */ rw_func_empty,
    /* 70 OP_AVX512_vminsd */ rw_func_empty,
    /* 71 OP_AVX512_vdivps */ rw_func_empty,
    /* 72 OP_AVX512_vdivss */ rw_func_empty,
    /* 73 OP_AVX512_vdivpd */ rw_func_empty,
    /* 74 OP_AVX512_vdivsd */ rw_func_empty,
    /* 75 OP_AVX512_vmaxps */ rw_func_empty,
    /* 76 OP_AVX512_vmaxss */ rw_func_empty,
    /* 77 OP_AVX512_vmaxpd */ rw_func_empty,
    /* 78 OP_AVX512_vmaxsd */ rw_func_empty,
    /* 79 OP_AVX512_vpunpcklbw */ rw_func_empty,
    /* 80 OP_AVX512_vpunpcklwd */ rw_func_empty,
    /* 81 OP_AVX512_vpunpckldq */ rw_func_empty,
    /* 82 OP_AVX512_vpacksswb */ rw_func_empty,
    /* 83 OP_AVX512_vpcmpgtb */ rw_func_empty,
    /* 84 OP_AVX512_vpcmpgtw */ rw_func_empty,
    /* 85 OP_AVX512_vpcmpgtd */ rw_func_empty,
    /* 86 OP_AVX512_vpackuswb */ rw_func_vpackuswb,
    /* 87 OP_AVX512_vpunpckhbw */ rw_func_empty,
    /* 88 OP_AVX512_vpunpckhwd */ rw_func_empty,
    /* 89 OP_AVX512_vpunpckhdq */ rw_func_empty,
    /* 90 OP_AVX512_vpackssdw */ rw_func_empty,
    /* 91 OP_AVX512_vpunpcklqdq */ rw_func_empty,
    /* 92 OP_AVX512_vpunpckhqdq */ rw_func_empty,
    /* 93 OP_AVX512_vmovd */ rw_func_empty,
    /* 94 OP_AVX512_vpshufhw */ rw_func_empty,
    /* 95 OP_AVX512_vpshufd */ rw_func_empty,
    /* 96 OP_AVX512_vpshuflw */ rw_func_empty,
    /* 97 OP_AVX512_vpcmpeqb */ rw_func_empty,
    /* 98 OP_AVX512_vpcmpeqw */ rw_func_empty,
    /* 99 OP_AVX512_vpcmpeqd */ rw_func_empty,
    /* 100 OP_AVX512_vmovq */ rw_func_vmovq,
    /* 101 OP_AVX512_vcmpps */ rw_func_empty,
    /* 102 OP_AVX512_vcmpss */ rw_func_empty,
    /* 103 OP_AVX512_vcmppd */ rw_func_empty,
    /* 104 OP_AVX512_vcmpsd */ rw_func_empty,
    /* 105 OP_AVX512_vpinsrw */ rw_func_empty,
    /* 106 OP_AVX512_vpextrw */ rw_func_empty,
    /* 107 OP_AVX512_vshufps */ rw_func_empty,
    /* 108 OP_AVX512_vshufpd */ rw_func_empty,
    /* 109 OP_AVX512_vpsrlw */ rw_func_empty,
    /* 110 OP_AVX512_vpsrld */ rw_func_empty,
    /* 111 OP_AVX512_vpsrlq */ rw_func_vpsrlq,
    /* 112 OP_AVX512_vpaddq */ rw_func_vpaddq,
    /* 113 OP_AVX512_vpmullw */ rw_func_empty,
    /* 114 OP_AVX512_vpmovmskb */ rw_func_empty,
    /* 115 OP_AVX512_vpsubusb */ rw_func_empty,
    /* 116 OP_AVX512_vpsubusw */ rw_func_empty,
    /* 117 OP_AVX512_vpminub */ rw_func_empty,
    /* 118 OP_AVX512_vpand */ rw_func_empty,
    /* 119 OP_AVX512_vpaddusb */ rw_func_empty,
    /* 120 OP_AVX512_vpaddusw */ rw_func_empty,
    /* 121 OP_AVX512_vpmaxub */ rw_func_empty,
    /* 122 OP_AVX512_vpandn */ rw_func_empty,
    /* 123 OP_AVX512_vpavgb */ rw_func_empty,
    /* 124 OP_AVX512_vpsraw */ rw_func_empty,
    /* 125 OP_AVX512_vpsrad */ rw_func_vpsrad,
    /* 126 OP_AVX512_vpavgw */ rw_func_empty,
    /* 127 OP_AVX512_vpmulhuw */ rw_func_empty,
    /* 128 OP_AVX512_vpmulhw */ rw_func_empty,
    /* 129 OP_AVX512_vcvtdq2pd */ rw_func_empty,
    /* 130 OP_AVX512_vcvttpd2dq */ rw_func_empty,
    /* 131 OP_AVX512_vcvtpd2dq */ rw_func_empty,
    /* 132 OP_AVX512_vmovntdq */ rw_func_empty,
    /* 133 OP_AVX512_vpsubsb */ rw_func_empty,
    /* 134 OP_AVX512_vpsubsw */ rw_func_empty,
    /* 135 OP_AVX512_vpminsw */ rw_func_empty,
    /* 136 OP_AVX512_vpor */ rw_func_empty,
    /* 137 OP_AVX512_vpaddsb */ rw_func_empty,
    /* 138 OP_AVX512_vpaddsw */ rw_func_empty,
    /* 139 OP_AVX512_vpmaxsw */ rw_func_empty,
    /* 140 OP_AVX512_vpxor */ rw_func_empty,
    /* 141 OP_AVX512_vpsllw */ rw_func_vpsllw,
    /* 142 OP_AVX512_vpslld */ rw_func_vpslld,
    /* 143 OP_AVX512_vpsllq */ rw_func_vpsllq,
    /* 144 OP_AVX512_vpmuludq */ rw_func_empty,
    /* 145 OP_AVX512_vpmaddwd */ rw_func_empty,
    /* 146 OP_AVX512_vpsadbw */ rw_func_empty,
    /* 147 OP_AVX512_vmaskmovdqu */ rw_func_empty,
    /* 148 OP_AVX512_vpsubb */ rw_func_vpsubb,
    /* 149 OP_AVX512_vpsubw */ rw_func_vpsubw,
    /* 150 OP_AVX512_vpsubd */ rw_func_vpsubd,
    /* 151 OP_AVX512_vpsubq */ rw_func_empty,
    /* 152 OP_AVX512_vpaddb */ rw_func_empty,
    /* 153 OP_AVX512_vpaddw */ rw_func_vpaddw,
    /* 154 OP_AVX512_vpaddd */ rw_func_vpaddd,
    /* 155 OP_AVX512_vpsrldq */ rw_func_vpsrldq,
    /* 156 OP_AVX512_vpslldq */ rw_func_empty,
    /* 157 OP_AVX512_vmovdqu */ rw_func_empty,
    /* 158 OP_AVX512_vmovdqa */ rw_func_empty,
    /* 159 OP_AVX512_vhaddpd */ rw_func_empty,
    /* 160 OP_AVX512_vhaddps */ rw_func_empty,
    /* 161 OP_AVX512_vhsubpd */ rw_func_empty,
    /* 162 OP_AVX512_vhsubps */ rw_func_empty,
    /* 163 OP_AVX512_vaddsubpd */ rw_func_empty,
    /* 164 OP_AVX512_vaddsubps */ rw_func_empty,
    /* 165 OP_AVX512_vlddqu */ rw_func_empty,
    /* 166 OP_AVX512_vpshufb */ rw_func_empty,
    /* 167 OP_AVX512_vphaddw */ rw_func_empty,
    /* 168 OP_AVX512_vphaddd */ rw_func_empty,
    /* 169 OP_AVX512_vphaddsw */ rw_func_empty,
    /* 170 OP_AVX512_vpmaddubsw */ rw_func_empty,
    /* 171 OP_AVX512_vphsubw */ rw_func_empty,
    /* 172 OP_AVX512_vphsubd */ rw_func_empty,
    /* 173 OP_AVX512_vphsubsw */ rw_func_empty,
    /* 174 OP_AVX512_vpsignb */ rw_func_empty,
    /* 175 OP_AVX512_vpsignw */ rw_func_empty,
    /* 176 OP_AVX512_vpsignd */ rw_func_empty,
    /* 177 OP_AVX512_vpmulhrsw */ rw_func_empty,
    /* 178 OP_AVX512_vpabsb */ rw_func_empty,
    /* 179 OP_AVX512_vpabsw */ rw_func_empty,
    /* 180 OP_AVX512_vpabsd */ rw_func_empty,
    /* 181 OP_AVX512_vpalignr */ rw_func_empty,
    /* 182 OP_AVX512_vpblendvb */ rw_func_empty,
    /* 183 OP_AVX512_vblendvps */ rw_func_empty,
    /* 184 OP_AVX512_vblendvpd */ rw_func_empty,
    /* 185 OP_AVX512_vptest */ rw_func_empty,
    /* 186 OP_AVX512_vpmovsxbw */ rw_func_empty,
    /* 187 OP_AVX512_vpmovsxbd */ rw_func_empty,
    /* 188 OP_AVX512_vpmovsxbq */ rw_func_empty,
    /* 189 OP_AVX512_vpmovsxwd */ rw_func_vpmovsxwd,
    /* 190 OP_AVX512_vpmovsxwq */ rw_func_empty,
    /* 191 OP_AVX512_vpmovsxdq */ rw_func_vpmovsxdq,
    /* 192 OP_AVX512_vpmuldq */ rw_func_empty,
    /* 193 OP_AVX512_vpcmpeqq */ rw_func_empty,
    /* 194 OP_AVX512_vmovntdqa */ rw_func_empty,
    /* 195 OP_AVX512_vpackusdw */ rw_func_empty,
    /* 196 OP_AVX512_vpmovzxbw */ rw_func_vpmovzxbw,
    /* 197 OP_AVX512_vpmovzxbd */ rw_func_vpmovzxbd,
    /* 198 OP_AVX512_vpmovzxbq */ rw_func_vpmovzxbq,
    /* 199 OP_AVX512_vpmovzxwd */ rw_func_vpmovzxwd,
    /* 200 OP_AVX512_vpmovzxwq */ rw_func_vpmovzxwq,
    /* 201 OP_AVX512_vpmovzxdq */ rw_func_vpmovzxdq,
    /* 202 OP_AVX512_vpcmpgtq */ rw_func_empty,
    /* 203 OP_AVX512_vpminsb */ rw_func_empty,
    /* 204 OP_AVX512_vpminsd */ rw_func_empty,
    /* 205 OP_AVX512_vpminuw */ rw_func_empty,
    /* 206 OP_AVX512_vpminud */ rw_func_empty,
    /* 207 OP_AVX512_vpmaxsb */ rw_func_empty,
    /* 208 OP_AVX512_vpmaxsd */ rw_func_empty,
    /* 209 OP_AVX512_vpmaxuw */ rw_func_empty,
    /* 210 OP_AVX512_vpmaxud */ rw_func_empty,
    /* 211 OP_AVX512_vpmulld */ rw_func_empty,
    /* 212 OP_AVX512_vphminposuw */ rw_func_empty,
    /* 213 OP_AVX512_vaesimc */ rw_func_empty,
    /* 214 OP_AVX512_vaesenc */ rw_func_empty,
    /* 215 OP_AVX512_vaesenclast */ rw_func_empty,
    /* 216 OP_AVX512_vaesdec */ rw_func_empty,
    /* 217 OP_AVX512_vaesdeclast */ rw_func_empty,
    /* 218 OP_AVX512_vpextrb */ rw_func_vpextr_,
    /* 219 OP_AVX512_vpextrd */ rw_func_vpextr_,
    /* 220 OP_AVX512_vextractps */ rw_func_empty,
    /* 221 OP_AVX512_vroundps */ rw_func_empty,
    /* 222 OP_AVX512_vroundpd */ rw_func_empty,
    /* 223 OP_AVX512_vroundss */ rw_func_empty,
    /* 224 OP_AVX512_vroundsd */ rw_func_empty,
    /* 225 OP_AVX512_vblendps */ rw_func_empty,
    /* 226 OP_AVX512_vblendpd */ rw_func_empty,
    /* 227 OP_AVX512_vpblendw */ rw_func_empty,
    /* 228 OP_AVX512_vpinsrb */ rw_func_empty,
    /* 229 OP_AVX512_vinsertps */ rw_func_empty,
    /* 230 OP_AVX512_vpinsrd */ rw_func_empty,
    /* 231 OP_AVX512_vdpps */ rw_func_empty,
    /* 232 OP_AVX512_vdppd */ rw_func_empty,
    /* 233 OP_AVX512_vmpsadbw */ rw_func_empty,
    /* 234 OP_AVX512_vpcmpestrm */ rw_func_empty,
    /* 235 OP_AVX512_vpcmpestri */ rw_func_empty,
    /* 236 OP_AVX512_vpcmpistrm */ rw_func_empty,
    /* 237 OP_AVX512_vpcmpistri */ rw_func_empty,
    /* 238 OP_AVX512_vpclmulqdq */ rw_func_empty,
    /* 239 OP_AVX512_vaeskeygenassist */ rw_func_empty,
    /* 240 OP_AVX512_vtestps */ rw_func_empty,
    /* 241 OP_AVX512_vtestpd */ rw_func_empty,
    /* 242 OP_AVX512_vzeroupper */ rw_func_empty,
    /* 243 OP_AVX512_vzeroall */ rw_func_empty,
    /* 244 OP_AVX512_vldmxcsr */ rw_func_empty,
    /* 245 OP_AVX512_vstmxcsr */ rw_func_empty,
    /* 246 OP_AVX512_vbroadcastss */ rw_func_empty,
    /* 247 OP_AVX512_vbroadcastsd */ rw_func_empty,
    /* 248 OP_AVX512_vbroadcastf128 */ rw_func_empty,
    /* 249 OP_AVX512_vmaskmovps */ rw_func_empty,
    /* 250 OP_AVX512_vmaskmovpd */ rw_func_empty,
    /* 251 OP_AVX512_vpermilps */ rw_func_empty,
    /* 252 OP_AVX512_vpermilpd */ rw_func_empty,
    /* 253 OP_AVX512_vperm2f128 */ rw_func_empty,
    /* 254 OP_AVX512_vinsertf128 */ rw_func_empty,
    /* 255 OP_AVX512_vextractf128 */ rw_func_empty,
    /* 256 OP_AVX512_vcvtph2ps */ rw_func_empty,
    /* 257 OP_AVX512_vcvtps2ph */ rw_func_empty,
    /* 258 OP_AVX512_vfmadd132ps */ rw_func_empty,
    /* 259 OP_AVX512_vfmadd132pd */ rw_func_empty,
    /* 260 OP_AVX512_vfmadd213ps */ rw_func_empty,
    /* 261 OP_AVX512_vfmadd213pd */ rw_func_empty,
    /* 262 OP_AVX512_vfmadd231ps */ rw_func_empty,
    /* 263 OP_AVX512_vfmadd231pd */ rw_func_empty,
    /* 264 OP_AVX512_vfmadd132ss */ rw_func_empty,
    /* 265 OP_AVX512_vfmadd132sd */ rw_func_empty,
    /* 266 OP_AVX512_vfmadd213ss */ rw_func_empty,
    /* 267 OP_AVX512_vfmadd213sd */ rw_func_empty,
    /* 268 OP_AVX512_vfmadd231ss */ rw_func_empty,
    /* 269 OP_AVX512_vfmadd231sd */ rw_func_empty,
    /* 270 OP_AVX512_vfmaddsub132ps */ rw_func_empty,
    /* 271 OP_AVX512_vfmaddsub132pd */ rw_func_empty,
    /* 272 OP_AVX512_vfmaddsub213ps */ rw_func_empty,
    /* 273 OP_AVX512_vfmaddsub213pd */ rw_func_empty,
    /* 274 OP_AVX512_vfmaddsub231ps */ rw_func_empty,
    /* 275 OP_AVX512_vfmaddsub231pd */ rw_func_empty,
    /* 276 OP_AVX512_vfmsubadd132ps */ rw_func_empty,
    /* 277 OP_AVX512_vfmsubadd132pd */ rw_func_empty,
    /* 278 OP_AVX512_vfmsubadd213ps */ rw_func_empty,
    /* 279 OP_AVX512_vfmsubadd213pd */ rw_func_empty,
    /* 280 OP_AVX512_vfmsubadd231ps */ rw_func_empty,
    /* 281 OP_AVX512_vfmsubadd231pd */ rw_func_empty,
    /* 282 OP_AVX512_vfmsub132ps */ rw_func_empty,
    /* 283 OP_AVX512_vfmsub132pd */ rw_func_empty,
    /* 284 OP_AVX512_vfmsub213ps */ rw_func_empty,
    /* 285 OP_AVX512_vfmsub213pd */ rw_func_empty,
    /* 286 OP_AVX512_vfmsub231ps */ rw_func_empty,
    /* 287 OP_AVX512_vfmsub231pd */ rw_func_empty,
    /* 288 OP_AVX512_vfmsub132ss */ rw_func_empty,
    /* 289 OP_AVX512_vfmsub132sd */ rw_func_empty,
    /* 290 OP_AVX512_vfmsub213ss */ rw_func_empty,
    /* 291 OP_AVX512_vfmsub213sd */ rw_func_empty,
    /* 292 OP_AVX512_vfmsub231ss */ rw_func_empty,
    /* 293 OP_AVX512_vfmsub231sd */ rw_func_empty,
    /* 294 OP_AVX512_vfnmadd132ps */ rw_func_empty,
    /* 295 OP_AVX512_vfnmadd132pd */ rw_func_empty,
    /* 296 OP_AVX512_vfnmadd213ps */ rw_func_empty,
    /* 297 OP_AVX512_vfnmadd213pd */ rw_func_empty,
    /* 298 OP_AVX512_vfnmadd231ps */ rw_func_empty,
    /* 299 OP_AVX512_vfnmadd231pd */ rw_func_empty,
    /* 300 OP_AVX512_vfnmadd132ss */ rw_func_empty,
    /* 301 OP_AVX512_vfnmadd132sd */ rw_func_empty,
    /* 302 OP_AVX512_vfnmadd213ss */ rw_func_empty,
    /* 303 OP_AVX512_vfnmadd213sd */ rw_func_empty,
    /* 304 OP_AVX512_vfnmadd231ss */ rw_func_empty,
    /* 305 OP_AVX512_vfnmadd231sd */ rw_func_empty,
    /* 306 OP_AVX512_vfnmsub132ps */ rw_func_empty,
    /* 307 OP_AVX512_vfnmsub132pd */ rw_func_empty,
    /* 308 OP_AVX512_vfnmsub213ps */ rw_func_empty,
    /* 309 OP_AVX512_vfnmsub213pd */ rw_func_empty,
    /* 310 OP_AVX512_vfnmsub231ps */ rw_func_empty,
    /* 311 OP_AVX512_vfnmsub231pd */ rw_func_empty,
    /* 312 OP_AVX512_vfnmsub132ss */ rw_func_empty,
    /* 313 OP_AVX512_vfnmsub132sd */ rw_func_empty,
    /* 314 OP_AVX512_vfnmsub213ss */ rw_func_empty,
    /* 315 OP_AVX512_vfnmsub213sd */ rw_func_empty,
    /* 316 OP_AVX512_vfnmsub231ss */ rw_func_empty,
    /* 317 OP_AVX512_vfnmsub231sd */ rw_func_empty,
    /* 318 OP_AVX512_movq2dq */ rw_func_empty,
    /* 319 OP_AVX512_movdq2q */ rw_func_empty,
    /* 320 OP_AVX512_fxsave64 */ rw_func_empty,
    /* 321 OP_AVX512_fxrstor64 */ rw_func_empty,
    /* 322 OP_AVX512_xsave64 */ rw_func_empty,
    /* 323 OP_AVX512_xrstor64 */ rw_func_empty,
    /* 324 OP_AVX512_xsaveopt64 */ rw_func_empty,
    /* 325 OP_AVX512_rdrand */ rw_func_empty,
    /* 326 OP_AVX512_rdfsbase */ rw_func_empty,
    /* 327 OP_AVX512_rdgsbase */ rw_func_empty,
    /* 328 OP_AVX512_wrfsbase */ rw_func_empty,
    /* 329 OP_AVX512_wrgsbase */ rw_func_empty,
    /* 330 OP_AVX512_rdseed */ rw_func_empty,
    /* 331 OP_AVX512_vfmaddsubps */ rw_func_empty,
    /* 332 OP_AVX512_vfmaddsubpd */ rw_func_empty,
    /* 333 OP_AVX512_vfmsubaddps */ rw_func_empty,
    /* 334 OP_AVX512_vfmsubaddpd */ rw_func_empty,
    /* 335 OP_AVX512_vfmaddps */ rw_func_empty,
    /* 336 OP_AVX512_vfmaddpd */ rw_func_empty,
    /* 337 OP_AVX512_vfmaddss */ rw_func_empty,
    /* 338 OP_AVX512_vfmaddsd */ rw_func_empty,
    /* 339 OP_AVX512_vfmsubps */ rw_func_empty,
    /* 340 OP_AVX512_vfmsubpd */ rw_func_empty,
    /* 341 OP_AVX512_vfmsubss */ rw_func_empty,
    /* 342 OP_AVX512_vfmsubsd */ rw_func_empty,
    /* 343 OP_AVX512_vfnmaddps */ rw_func_empty,
    /* 344 OP_AVX512_vfnmaddpd */ rw_func_empty,
    /* 345 OP_AVX512_vfnmaddss */ rw_func_empty,
    /* 346 OP_AVX512_vfnmaddsd */ rw_func_empty,
    /* 347 OP_AVX512_vfnmsubps */ rw_func_empty,
    /* 348 OP_AVX512_vfnmsubpd */ rw_func_empty,
    /* 349 OP_AVX512_vfnmsubss */ rw_func_empty,
    /* 350 OP_AVX512_vfnmsubsd */ rw_func_empty,
    /* 351 OP_AVX512_vfrczps */ rw_func_empty,
    /* 352 OP_AVX512_vfrczpd */ rw_func_empty,
    /* 353 OP_AVX512_vfrczss */ rw_func_empty,
    /* 354 OP_AVX512_vfrczsd */ rw_func_empty,
    /* 355 OP_AVX512_vpcmov */ rw_func_empty,
    /* 356 OP_AVX512_vpcomb */ rw_func_empty,
    /* 357 OP_AVX512_vpcomw */ rw_func_empty,
    /* 358 OP_AVX512_vpcomd */ rw_func_empty,
    /* 359 OP_AVX512_vpcomq */ rw_func_empty,
    /* 360 OP_AVX512_vpcomub */ rw_func_empty,
    /* 361 OP_AVX512_vpcomuw */ rw_func_empty,
    /* 362 OP_AVX512_vpcomud */ rw_func_empty,
    /* 363 OP_AVX512_vpcomuq */ rw_func_empty,
    /* 364 OP_AVX512_vpermil2pd */ rw_func_empty,
    /* 365 OP_AVX512_vpermil2ps */ rw_func_empty,
    /* 366 OP_AVX512_vphaddbw */ rw_func_empty,
    /* 367 OP_AVX512_vphaddbd */ rw_func_empty,
    /* 368 OP_AVX512_vphaddbq */ rw_func_empty,
    /* 369 OP_AVX512_vphaddwd */ rw_func_empty,
    /* 370 OP_AVX512_vphaddwq */ rw_func_empty,
    /* 371 OP_AVX512_vphadddq */ rw_func_empty,
    /* 372 OP_AVX512_vphaddubw */ rw_func_empty,
    /* 373 OP_AVX512_vphaddubd */ rw_func_empty,
    /* 374 OP_AVX512_vphaddubq */ rw_func_empty,
    /* 375 OP_AVX512_vphadduwd */ rw_func_empty,
    /* 376 OP_AVX512_vphadduwq */ rw_func_empty,
    /* 377 OP_AVX512_vphaddudq */ rw_func_empty,
    /* 378 OP_AVX512_vphsubbw */ rw_func_empty,
    /* 379 OP_AVX512_vphsubwd */ rw_func_empty,
    /* 380 OP_AVX512_vphsubdq */ rw_func_empty,
    /* 381 OP_AVX512_vpmacssww */ rw_func_empty,
    /* 382 OP_AVX512_vpmacsswd */ rw_func_empty,
    /* 383 OP_AVX512_vpmacssdql */ rw_func_empty,
    /* 384 OP_AVX512_vpmacssdd */ rw_func_empty,
    /* 385 OP_AVX512_vpmacssdqh */ rw_func_empty,
    /* 386 OP_AVX512_vpmacsww */ rw_func_empty,
    /* 387 OP_AVX512_vpmacswd */ rw_func_empty,
    /* 388 OP_AVX512_vpmacsdql */ rw_func_empty,
    /* 389 OP_AVX512_vpmacsdd */ rw_func_empty,
    /* 390 OP_AVX512_vpmacsdqh */ rw_func_empty,
    /* 391 OP_AVX512_vpmadcsswd */ rw_func_empty,
    /* 392 OP_AVX512_vpmadcswd */ rw_func_empty,
    /* 393 OP_AVX512_vpperm */ rw_func_empty,
    /* 394 OP_AVX512_vprotb */ rw_func_empty,
    /* 395 OP_AVX512_vprotw */ rw_func_empty,
    /* 396 OP_AVX512_vprotd */ rw_func_empty,
    /* 397 OP_AVX512_vprotq */ rw_func_empty,
    /* 398 OP_AVX512_vpshlb */ rw_func_empty,
    /* 399 OP_AVX512_vpshlw */ rw_func_empty,
    /* 400 OP_AVX512_vpshld */ rw_func_empty,
    /* 401 OP_AVX512_vpshlq */ rw_func_empty,
    /* 402 OP_AVX512_vpshab */ rw_func_empty,
    /* 403 OP_AVX512_vpshaw */ rw_func_empty,
    /* 404 OP_AVX512_vpshad */ rw_func_empty,
    /* 405 OP_AVX512_vpshaq */ rw_func_empty,
    /* 406 OP_AVX512_bextr */ rw_func_empty,
    /* 407 OP_AVX512_blcfill */ rw_func_empty,
    /* 408 OP_AVX512_blci */ rw_func_empty,
    /* 409 OP_AVX512_blcic */ rw_func_empty,
    /* 410 OP_AVX512_blcmsk */ rw_func_empty,
    /* 411 OP_AVX512_blcs */ rw_func_empty,
    /* 412 OP_AVX512_blsfill */ rw_func_empty,
    /* 413 OP_AVX512_blsic */ rw_func_empty,
    /* 414 OP_AVX512_t1mskc */ rw_func_empty,
    /* 415 OP_AVX512_tzmsk */ rw_func_empty,
    /* 416 OP_AVX512_llwpcb */ rw_func_empty,
    /* 417 OP_AVX512_slwpcb */ rw_func_empty,
    /* 418 OP_AVX512_lwpins */ rw_func_empty,
    /* 419 OP_AVX512_lwpval */ rw_func_empty,
    /* 420 OP_AVX512_andn */ rw_func_empty,
    /* 421 OP_AVX512_blsr */ rw_func_empty,
    /* 422 OP_AVX512_blsmsk */ rw_func_empty,
    /* 423 OP_AVX512_blsi */ rw_func_empty,
    /* 424 OP_AVX512_tzcnt */ rw_func_empty,
    /* 425 OP_AVX512_bzhi */ rw_func_empty,
    /* 426 OP_AVX512_pext */ rw_func_empty,
    /* 427 OP_AVX512_pdep */ rw_func_empty,
    /* 428 OP_AVX512_sarx */ rw_func_empty,
    /* 429 OP_AVX512_shlx */ rw_func_empty,
    /* 430 OP_AVX512_shrx */ rw_func_empty,
    /* 431 OP_AVX512_rorx */ rw_func_empty,
    /* 432 OP_AVX512_mulx */ rw_func_empty,
    /* 433 OP_AVX512_getsec */ rw_func_empty,
    /* 434 OP_AVX512_vmfunc */ rw_func_empty,
    /* 435 OP_AVX512_invpcid */ rw_func_empty,
    /* 436 OP_AVX512_xabort */ rw_func_empty,
    /* 437 OP_AVX512_xbegin */ rw_func_empty,
    /* 438 OP_AVX512_xend */ rw_func_empty,
    /* 439 OP_AVX512_xtest */ rw_func_empty,
    /* 440 OP_AVX512_vpgatherdd */ rw_func_vpgatherdd,
    /* 441 OP_AVX512_vpgatherdq */ rw_func_vpgatherdq,
    /* 442 OP_AVX512_vpgatherqd */ rw_func_empty,
    /* 443 OP_AVX512_vpgatherqq */ rw_func_vpgatherqq,
    /* 444 OP_AVX512_vgatherdps */ rw_func_empty,
    /* 445 OP_AVX512_vgatherdpd */ rw_func_empty,
    /* 446 OP_AVX512_vgatherqps */ rw_func_empty,
    /* 447 OP_AVX512_vgatherqpd */ rw_func_empty,
    /* 448 OP_AVX512_vbroadcasti128 */ rw_func_empty,
    /* 449 OP_AVX512_vinserti128 */ rw_func_empty,
    /* 450 OP_AVX512_vextracti128 */ rw_func_empty,
    /* 451 OP_AVX512_vpmaskmovd */ rw_func_empty,
    /* 452 OP_AVX512_vpmaskmovq */ rw_func_empty,
    /* 453 OP_AVX512_vperm2i128 */ rw_func_empty,
    /* 454 OP_AVX512_vpermd */ rw_func_empty,
    /* 455 OP_AVX512_vpermps */ rw_func_empty,
    /* 456 OP_AVX512_vpermq */ rw_func_empty,
    /* 457 OP_AVX512_vpermpd */ rw_func_empty,
    /* 458 OP_AVX512_vpblendd */ rw_func_empty,
    /* 459 OP_AVX512_vpsllvd */ rw_func_empty,
    /* 460 OP_AVX512_vpsllvq */ rw_func_empty,
    /* 461 OP_AVX512_vpsravd */ rw_func_empty,
    /* 462 OP_AVX512_vpsrlvd */ rw_func_empty,
    /* 463 OP_AVX512_vpsrlvq */ rw_func_empty,
    /* 464 OP_AVX512_vpbroadcastb */ rw_func_vpbroadcastb,
    /* 465 OP_AVX512_vpbroadcastw */ rw_func_vpbroadcastw,
    /* 466 OP_AVX512_vpbroadcastd */ rw_func_vpbroadcastd,
    /* 467 OP_AVX512_vpbroadcastq */ rw_func_vpbroadcastq,
    /* 468 OP_AVX512_xsavec32 */ rw_func_empty,
    /* 469 OP_AVX512_xsavec64 */ rw_func_empty,
    /* 470 OP_AVX512_adox */ rw_func_empty,
    /* 471 OP_AVX512_adcx */ rw_func_empty,
    /* 472 OP_AVX512_kmovw */ rw_func_kmovw,
    /* 473 OP_AVX512_kmovb */ rw_func_kmovb,
    /* 474 OP_AVX512_kmovq */ rw_func_kmovq,
    /* 475 OP_AVX512_kmovd */ rw_func_kmovd,
    /* 476 OP_AVX512_kandw */ rw_func_kandw,
    /* 477 OP_AVX512_kandb */ rw_func_kandb,
    /* 478 OP_AVX512_kandq */ rw_func_kandq,
    /* 479 OP_AVX512_kandd */ rw_func_kandd,
    /* 480 OP_AVX512_kandnw */ rw_func_kandnw,
    /* 481 OP_AVX512_kandnb */ rw_func_kandnb,
    /* 482 OP_AVX512_kandnq */ rw_func_kandnq,
    /* 483 OP_AVX512_kandnd */ rw_func_kandnd,
    /* 484 OP_AVX512_kunpckbw */ rw_func_kunpckbw,
    /* 485 OP_AVX512_kunpckwd */ rw_func_kunpckwd,
    /* 486 OP_AVX512_kunpckdq */ rw_func_kunpckdq,
    /* 487 OP_AVX512_knotw */ rw_func_knotw,
    /* 488 OP_AVX512_knotb */ rw_func_knotb,
    /* 489 OP_AVX512_knotq */ rw_func_knotq,
    /* 490 OP_AVX512_knotd */ rw_func_knotd,
    /* 491 OP_AVX512_korw */ rw_func_korw,
    /* 492 OP_AVX512_korb */ rw_func_korb,
    /* 493 OP_AVX512_korq */ rw_func_korq,
    /* 494 OP_AVX512_kord */ rw_func_kord,
    /* 495 OP_AVX512_kxnorw */ rw_func_kxnorw,
    /* 496 OP_AVX512_kxnorb */ rw_func_kxnorb,
    /* 497 OP_AVX512_kxnorq */ rw_func_kxnorq,
    /* 498 OP_AVX512_kxnord */ rw_func_kxnord,
    /* 499 OP_AVX512_kxorw */ rw_func_kxorw,
    /* 500 OP_AVX512_kxorb */ rw_func_kxorb,
    /* 501 OP_AVX512_kxorq */ rw_func_kxorq,
    /* 502 OP_AVX512_kxord */ rw_func_kxord,
    /* 503 OP_AVX512_kaddw */ rw_func_kaddw,
    /* 504 OP_AVX512_kaddb */ rw_func_kaddb,
    /* 505 OP_AVX512_kaddq */ rw_func_kaddq,
    /* 506 OP_AVX512_kaddd */ rw_func_kaddd,
    /* 507 OP_AVX512_kortestw */ rw_func_kortestw,
    /* 508 OP_AVX512_kortestb */ rw_func_kortestb,
    /* 509 OP_AVX512_kortestq */ rw_func_kortestq,
    /* 510 OP_AVX512_kortestd */ rw_func_kortestd,
    /* 511 OP_AVX512_kshiftlw */ rw_func_kshiftlw,
    /* 512 OP_AVX512_kshiftlb */ rw_func_kshiftlb,
    /* 513 OP_AVX512_kshiftlq */ rw_func_kshiftlq,
    /* 514 OP_AVX512_kshiftld */ rw_func_kshiftld,
    /* 515 OP_AVX512_kshiftrw */ rw_func_kshiftrw,
    /* 516 OP_AVX512_kshiftrb */ rw_func_kshiftrb,
    /* 517 OP_AVX512_kshiftrq */ rw_func_kshiftrq,
    /* 518 OP_AVX512_kshiftrd */ rw_func_kshiftrd,
    /* 519 OP_AVX512_ktestw */ rw_func_ktestw,
    /* 520 OP_AVX512_ktestb */ rw_func_ktestb,
    /* 521 OP_AVX512_ktestq */ rw_func_ktestq,
    /* 522 OP_AVX512_ktestd */ rw_func_ktestd,
    /* 523 OP_AVX512_valignd */ rw_func_empty,
    /* 524 OP_AVX512_valignq */ rw_func_empty,
    /* 525 OP_AVX512_vblendmpd */ rw_func_empty,
    /* 526 OP_AVX512_vblendmps */ rw_func_empty,
    /* 527 OP_AVX512_vbroadcastf32x2 */ rw_func_empty,
    /* 528 OP_AVX512_vbroadcastf32x4 */ rw_func_empty,
    /* 529 OP_AVX512_vbroadcastf32x8 */ rw_func_empty,
    /* 530 OP_AVX512_vbroadcastf64x2 */ rw_func_empty,
    /* 531 OP_AVX512_vbroadcastf64x4 */ rw_func_empty,
    /* 532 OP_AVX512_vbroadcasti32x2 */ rw_func_empty,
    /* 533 OP_AVX512_vbroadcasti32x4 */ rw_func_empty,
    /* 534 OP_AVX512_vbroadcasti32x8 */ rw_func_empty,
    /* 535 OP_AVX512_vbroadcasti64x2 */ rw_func_empty,
    /* 536 OP_AVX512_vbroadcasti64x4 */ rw_func_empty,
    /* 537 OP_AVX512_vcompresspd */ rw_func_empty,
    /* 538 OP_AVX512_vcompressps */ rw_func_empty,
    /* 539 OP_AVX512_vcvtpd2qq */ rw_func_empty,
    /* 540 OP_AVX512_vcvtpd2udq */ rw_func_empty,
    /* 541 OP_AVX512_vcvtpd2uqq */ rw_func_empty,
    /* 542 OP_AVX512_vcvtps2qq */ rw_func_empty,
    /* 543 OP_AVX512_vcvtps2udq */ rw_func_empty,
    /* 544 OP_AVX512_vcvtps2uqq */ rw_func_empty,
    /* 545 OP_AVX512_vcvtqq2pd */ rw_func_empty,
    /* 546 OP_AVX512_vcvtqq2ps */ rw_func_empty,
    /* 547 OP_AVX512_vcvtsd2usi */ rw_func_empty,
    /* 548 OP_AVX512_vcvtss2usi */ rw_func_empty,
    /* 549 OP_AVX512_vcvttpd2qq */ rw_func_empty,
    /* 550 OP_AVX512_vcvttpd2udq */ rw_func_empty,
    /* 551 OP_AVX512_vcvttpd2uqq */ rw_func_empty,
    /* 552 OP_AVX512_vcvttps2qq */ rw_func_empty,
    /* 553 OP_AVX512_vcvttps2udq */ rw_func_empty,
    /* 554 OP_AVX512_vcvttps2uqq */ rw_func_empty,
    /* 555 OP_AVX512_vcvttsd2usi */ rw_func_vcvttsd2usi,
    /* 556 OP_AVX512_vcvttss2usi */ rw_func_vcvttss2usi,
    /* 557 OP_AVX512_vcvtudq2pd */ rw_func_empty,
    /* 558 OP_AVX512_vcvtudq2ps */ rw_func_empty,
    /* 559 OP_AVX512_vcvtuqq2pd */ rw_func_empty,
    /* 560 OP_AVX512_vcvtuqq2ps */ rw_func_empty,
    /* 561 OP_AVX512_vcvtusi2sd */ rw_func_vcvtusi2sd,
    /* 562 OP_AVX512_vcvtusi2ss */ rw_func_vcvtusi2ss,
    /* 563 OP_AVX512_vdbpsadbw */ rw_func_empty,
    /* 564 OP_AVX512_vexp2pd */ rw_func_empty,
    /* 565 OP_AVX512_vexp2ps */ rw_func_empty,
    /* 566 OP_AVX512_vexpandpd */ rw_func_empty,
    /* 567 OP_AVX512_vexpandps */ rw_func_empty,
    /* 568 OP_AVX512_vextractf32x4 */ rw_func_empty,
    /* 569 OP_AVX512_vextractf32x8 */ rw_func_empty,
    /* 570 OP_AVX512_vextractf64x2 */ rw_func_vextractf64x2,
    /* 571 OP_AVX512_vextractf64x4 */ rw_func_empty,
    /* 572 OP_AVX512_vextracti32x4 */ rw_func_vextracti32x4,
    /* 573 OP_AVX512_vextracti32x8 */ rw_func_empty,
    /* 574 OP_AVX512_vextracti64x2 */ rw_func_vextracti64x2,
    /* 575 OP_AVX512_vextracti64x4 */ rw_func_empty,
    /* 576 OP_AVX512_vfixupimmpd */ rw_func_empty,
    /* 577 OP_AVX512_vfixupimmps */ rw_func_empty,
    /* 578 OP_AVX512_vfixupimmsd */ rw_func_empty,
    /* 579 OP_AVX512_vfixupimmss */ rw_func_empty,
    /* 580 OP_AVX512_vfpclasspd */ rw_func_empty,
    /* 581 OP_AVX512_vfpclassps */ rw_func_empty,
    /* 582 OP_AVX512_vfpclasssd */ rw_func_empty,
    /* 583 OP_AVX512_vfpclassss */ rw_func_empty,
    /* 584 OP_AVX512_vgatherpf0dpd */ rw_func_empty,
    /* 585 OP_AVX512_vgatherpf0dps */ rw_func_empty,
    /* 586 OP_AVX512_vgatherpf0qpd */ rw_func_empty,
    /* 587 OP_AVX512_vgatherpf0qps */ rw_func_empty,
    /* 588 OP_AVX512_vgatherpf1dpd */ rw_func_empty,
    /* 589 OP_AVX512_vgatherpf1dps */ rw_func_empty,
    /* 590 OP_AVX512_vgatherpf1qpd */ rw_func_empty,
    /* 591 OP_AVX512_vgatherpf1qps */ rw_func_empty,
    /* 592 OP_AVX512_vgetexppd */ rw_func_empty,
    /* 593 OP_AVX512_vgetexpps */ rw_func_empty,
    /* 594 OP_AVX512_vgetexpsd */ rw_func_empty,
    /* 595 OP_AVX512_vgetexpss */ rw_func_empty,
    /* 596 OP_AVX512_vgetmantpd */ rw_func_empty,
    /* 597 OP_AVX512_vgetmantps */ rw_func_empty,
    /* 598 OP_AVX512_vgetmantsd */ rw_func_empty,
    /* 599 OP_AVX512_vgetmantss */ rw_func_empty,
    /* 600 OP_AVX512_vinsertf32x4 */ rw_func_empty,
    /* 601 OP_AVX512_vinsertf32x8 */ rw_func_empty,
    /* 602 OP_AVX512_vinsertf64x2 */ rw_func_empty,
    /* 603 OP_AVX512_vinsertf64x4 */ rw_func_empty,
    /* 604 OP_AVX512_vinserti32x4 */ rw_func_empty,
    /* 605 OP_AVX512_vinserti32x8 */ rw_func_empty,
    /* 606 OP_AVX512_vinserti64x2 */ rw_func_empty,
    /* 607 OP_AVX512_vinserti64x4 */ rw_func_vinserti64x4,
    /* 608 OP_AVX512_vmovdqa32 */ rw_func_vmovdqa32,
    /* 609 OP_AVX512_vmovdqa64 */ rw_func_vmovdqa64,
    /* 610 OP_AVX512_vmovdqu16 */ rw_func_vmovdqu16,
    /* 611 OP_AVX512_vmovdqu32 */ rw_func_vmovdqu32,
    /* 612 OP_AVX512_vmovdqu64 */ rw_func_vmovdqu64,
    /* 613 OP_AVX512_vmovdqu8 */ rw_func_vmovdqu8,
    /* 614 OP_AVX512_vpabsq */ rw_func_empty,
    /* 615 OP_AVX512_vpandd */ rw_func_vpandd,
    /* 616 OP_AVX512_vpandnd */ rw_func_empty,
    /* 617 OP_AVX512_vpandnq */ rw_func_empty,
    /* 618 OP_AVX512_vpandq */ rw_func_vpandq,
    /* 619 OP_AVX512_vpblendmb */ rw_func_empty,
    /* 620 OP_AVX512_vpblendmd */ rw_func_empty,
    /* 621 OP_AVX512_vpblendmq */ rw_func_empty,
    /* 622 OP_AVX512_vpblendmw */ rw_func_empty,
    /* 623 OP_AVX512_vpbroadcastmb2q */ rw_func_empty,
    /* 624 OP_AVX512_vpbroadcastmw2d */ rw_func_empty,
    /* 625 OP_AVX512_vpcmpb */ rw_func_empty,
    /* 626 OP_AVX512_vpcmpd */ rw_func_vpcmpd,
    /* 627 OP_AVX512_vpcmpq */ rw_func_vpcmpq,
    /* 628 OP_AVX512_vpcmpub */ rw_func_empty,
    /* 629 OP_AVX512_vpcmpud */ rw_func_vpcmpud,
    /* 630 OP_AVX512_vpcmpuq */ rw_func_empty,
    /* 631 OP_AVX512_vpcmpuw */ rw_func_empty,
    /* 632 OP_AVX512_vpcmpw */ rw_func_vpcmpw,
    /* 633 OP_AVX512_vpcompressd */ rw_func_empty,
    /* 634 OP_AVX512_vpcompressq */ rw_func_empty,
    /* 635 OP_AVX512_vpconflictd */ rw_func_empty,
    /* 636 OP_AVX512_vpconflictq */ rw_func_empty,
    /* 637 OP_AVX512_vpermb */ rw_func_empty,
    /* 638 OP_AVX512_vpermi2b */ rw_func_empty,
    /* 639 OP_AVX512_vpermi2d */ rw_func_empty,
    /* 640 OP_AVX512_vpermi2pd */ rw_func_empty,
    /* 641 OP_AVX512_vpermi2ps */ rw_func_empty,
    /* 642 OP_AVX512_vpermi2q */ rw_func_vpermi2q,
    /* 643 OP_AVX512_vpermi2w */ rw_func_vpermi2w,
    /* 644 OP_AVX512_vpermt2b */ rw_func_empty,
    /* 645 OP_AVX512_vpermt2d */ rw_func_vpermt2d,
    /* 646 OP_AVX512_vpermt2pd */ rw_func_empty,
    /* 647 OP_AVX512_vpermt2ps */ rw_func_vpermt2ps,
    /* 648 OP_AVX512_vpermt2q */ rw_func_vpermt2q,
    /* 649 OP_AVX512_vpermt2w */ rw_func_vpermt2w,
    /* 650 OP_AVX512_vpermw */ rw_func_empty,
    /* 651 OP_AVX512_vpexpandd */ rw_func_empty,
    /* 652 OP_AVX512_vpexpandq */ rw_func_empty,
    /* 653 OP_AVX512_vpextrq */ rw_func_vpextr_,
    /* 654 OP_AVX512_vpinsrq */ rw_func_empty,
    /* 655 OP_AVX512_vplzcntd */ rw_func_empty,
    /* 656 OP_AVX512_vplzcntq */ rw_func_empty,
    /* 657 OP_AVX512_vpmadd52huq */ rw_func_empty,
    /* 658 OP_AVX512_vpmadd52luq */ rw_func_empty,
    /* 659 OP_AVX512_vpmaxsq */ rw_func_empty,
    /* 660 OP_AVX512_vpmaxuq */ rw_func_empty,
    /* 661 OP_AVX512_vpminsq */ rw_func_empty,
    /* 662 OP_AVX512_vpminuq */ rw_func_empty,
    /* 663 OP_AVX512_vpmovb2m */ rw_func_empty,
    /* 664 OP_AVX512_vpmovd2m */ rw_func_empty,
    /* 665 OP_AVX512_vpmovdb */ rw_func_empty,
    /* 666 OP_AVX512_vpmovdw */ rw_func_empty,
    /* 667 OP_AVX512_vpmovm2b */ rw_func_empty,
    /* 668 OP_AVX512_vpmovm2d */ rw_func_empty,
    /* 669 OP_AVX512_vpmovm2q */ rw_func_empty,
    /* 670 OP_AVX512_vpmovm2w */ rw_func_empty,
    /* 671 OP_AVX512_vpmovq2m */ rw_func_empty,
    /* 672 OP_AVX512_vpmovqb */ rw_func_empty,
    /* 673 OP_AVX512_vpmovqd */ rw_func_empty,
    /* 674 OP_AVX512_vpmovqw */ rw_func_empty,
    /* 675 OP_AVX512_vpmovsdb */ rw_func_empty,
    /* 676 OP_AVX512_vpmovsdw */ rw_func_empty,
    /* 677 OP_AVX512_vpmovsqb */ rw_func_empty,
    /* 678 OP_AVX512_vpmovsqd */ rw_func_empty,
    /* 679 OP_AVX512_vpmovsqw */ rw_func_empty,
    /* 680 OP_AVX512_vpmovswb */ rw_func_empty,
    /* 681 OP_AVX512_vpmovusdb */ rw_func_empty,
    /* 682 OP_AVX512_vpmovusdw */ rw_func_empty,
    /* 683 OP_AVX512_vpmovusqb */ rw_func_empty,
    /* 684 OP_AVX512_vpmovusqd */ rw_func_empty,
    /* 685 OP_AVX512_vpmovusqw */ rw_func_empty,
    /* 686 OP_AVX512_vpmovuswb */ rw_func_empty,
    /* 687 OP_AVX512_vpmovw2m */ rw_func_empty,
    /* 688 OP_AVX512_vpmovwb */ rw_func_empty,
    /* 689 OP_AVX512_vpmullq */ rw_func_vpmullq,
    /* 690 OP_AVX512_vpord */ rw_func_empty,
    /* 691 OP_AVX512_vporq */ rw_func_vporq,
    /* 692 OP_AVX512_vprold */ rw_func_empty,
    /* 693 OP_AVX512_vprolq */ rw_func_vprolq,
    /* 694 OP_AVX512_vprolvd */ rw_func_empty,
    /* 695 OP_AVX512_vprolvq */ rw_func_empty,
    /* 696 OP_AVX512_vprord */ rw_func_vprord,
    /* 697 OP_AVX512_vprorq */ rw_func_vprorq,
    /* 698 OP_AVX512_vprorvd */ rw_func_empty,
    /* 699 OP_AVX512_vprorvq */ rw_func_empty,
    /* 700 OP_AVX512_vpscatterdd */ rw_func_vpscatterdd,
    /* 701 OP_AVX512_vpscatterdq */ rw_func_vpscatterdq,
    /* 702 OP_AVX512_vpscatterqd */ rw_func_vpscatterqd,
    /* 703 OP_AVX512_vpscatterqq */ rw_func_vpscatterqq,
    /* 704 OP_AVX512_vpsllvw */ rw_func_empty,
    /* 705 OP_AVX512_vpsraq */ rw_func_empty,
    /* 706 OP_AVX512_vpsravq */ rw_func_empty,
    /* 707 OP_AVX512_vpsravw */ rw_func_empty,
    /* 708 OP_AVX512_vpsrlvw */ rw_func_empty,
    /* 709 OP_AVX512_vpternlogd */ rw_func_empty,
    /* 710 OP_AVX512_vpternlogq */ rw_func_empty,
    /* 711 OP_AVX512_vptestmb */ rw_func_empty,
    /* 712 OP_AVX512_vptestmd */ rw_func_empty,
    /* 713 OP_AVX512_vptestmq */ rw_func_empty,
    /* 714 OP_AVX512_vptestmw */ rw_func_empty,
    /* 715 OP_AVX512_vptestnmb */ rw_func_empty,
    /* 716 OP_AVX512_vptestnmd */ rw_func_empty,
    /* 717 OP_AVX512_vptestnmq */ rw_func_empty,
    /* 718 OP_AVX512_vptestnmw */ rw_func_empty,
    /* 719 OP_AVX512_vpxord */ rw_func_vpxord,
    /* 720 OP_AVX512_vpxorq */ rw_func_vpxorq,
    /* 721 OP_AVX512_vrangepd */ rw_func_empty,
    /* 722 OP_AVX512_vrangeps */ rw_func_empty,
    /* 723 OP_AVX512_vrangesd */ rw_func_empty,
    /* 724 OP_AVX512_vrangess */ rw_func_empty,
    /* 725 OP_AVX512_vrcp14pd */ rw_func_empty,
    /* 726 OP_AVX512_vrcp14ps */ rw_func_empty,
    /* 727 OP_AVX512_vrcp14sd */ rw_func_empty,
    /* 728 OP_AVX512_vrcp14ss */ rw_func_empty,
    /* 729 OP_AVX512_vrcp28pd */ rw_func_empty,
    /* 730 OP_AVX512_vrcp28ps */ rw_func_empty,
    /* 731 OP_AVX512_vrcp28sd */ rw_func_empty,
    /* 732 OP_AVX512_vrcp28ss */ rw_func_empty,
    /* 733 OP_AVX512_vreducepd */ rw_func_empty,
    /* 734 OP_AVX512_vreduceps */ rw_func_empty,
    /* 735 OP_AVX512_vreducesd */ rw_func_empty,
    /* 736 OP_AVX512_vreducess */ rw_func_empty,
    /* 737 OP_AVX512_vrndscalepd */ rw_func_empty,
    /* 738 OP_AVX512_vrndscaleps */ rw_func_vrndscaleps,
    /* 739 OP_AVX512_vrndscalesd */ rw_func_vrndscalesd,
    /* 740 OP_AVX512_vrndscaless */ rw_func_vrndscaless,
    /* 741 OP_AVX512_vrsqrt14pd */ rw_func_empty,
    /* 742 OP_AVX512_vrsqrt14ps */ rw_func_empty,
    /* 743 OP_AVX512_vrsqrt14sd */ rw_func_empty,
    /* 744 OP_AVX512_vrsqrt14ss */ rw_func_empty,
    /* 745 OP_AVX512_vrsqrt28pd */ rw_func_empty,
    /* 746 OP_AVX512_vrsqrt28ps */ rw_func_empty,
    /* 747 OP_AVX512_vrsqrt28sd */ rw_func_empty,
    /* 748 OP_AVX512_vrsqrt28ss */ rw_func_empty,
    /* 749 OP_AVX512_vscalefpd */ rw_func_empty,
    /* 750 OP_AVX512_vscalefps */ rw_func_empty,
    /* 751 OP_AVX512_vscalefsd */ rw_func_empty,
    /* 752 OP_AVX512_vscalefss */ rw_func_empty,
    /* 753 OP_AVX512_vscatterdpd */ rw_func_empty,
    /* 754 OP_AVX512_vscatterdps */ rw_func_empty,
    /* 755 OP_AVX512_vscatterqpd */ rw_func_empty,
    /* 756 OP_AVX512_vscatterqps */ rw_func_empty,
    /* 757 OP_AVX512_vscatterpf0dpd */ rw_func_empty,
    /* 758 OP_AVX512_vscatterpf0dps */ rw_func_empty,
    /* 759 OP_AVX512_vscatterpf0qpd */ rw_func_empty,
    /* 760 OP_AVX512_vscatterpf0qps */ rw_func_empty,
    /* 761 OP_AVX512_vscatterpf1dpd */ rw_func_empty,
    /* 762 OP_AVX512_vscatterpf1dps */ rw_func_empty,
    /* 763 OP_AVX512_vscatterpf1qpd */ rw_func_empty,
    /* 764 OP_AVX512_vscatterpf1qps */ rw_func_empty,
    /* 765 OP_AVX512_vshuff32x4 */ rw_func_empty,
    /* 766 OP_AVX512_vshuff64x2 */ rw_func_empty,
    /* 767 OP_AVX512_vshufi32x4 */ rw_func_vshufi32x4,
    /* 768 OP_AVX512_vshufi64x2 */ rw_func_empty,
};

/* ======================================== *
 * rewrite functions signature
 * ======================================== */

/** @brief binary rewriting driver, single instr as granularity */
instr_t *
exec_rewrite_avx512_instr(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    int avx512_opcode = instr_get_opcode(instr);
    return rewrite_funcs[TO_AVX512_RWFUNC_INDEX(avx512_opcode)](dcontext, ilist, instr, instr_start);
}

/** @brief binary rewriting driver, single bb (which contain avx512 instrs) as granularity */
void
exec_rewrite_avx512_bb(dcontext_t *dcontext, instrlist_t *ilist)
{
    instr_t *instr, *next_instr, *prev_avx512_instr;

    instr_t *first_avx512_instr_prev = NULL;
    instr_t *last_avx512_instr_next = NULL;

#ifdef DEBUG
    REWRITE_DEBUG(STD_OUTF, "==== INSTRs before rewrite ====");
    for (instr = instrlist_first(ilist); instr != instrlist_last(ilist); instr = instr_get_next(instr)) {
        instr_disassemble(dcontext, instr, STD_OUTF);
        NEWLINE(STD_OUTF);
    }
    REWRITE_DEBUG(STD_OUTF, "==== INSTRs before rewrite END ====\n\n");
#endif

    for (instr = ilist->first; instr != NULL; instr = next_instr) {
        next_instr = instr->next;
        if (instr->is_avx512_instr) {
            int avx512_opcode = instr->opcode;
            // get instr before the being rewrited avx512 instr, which serves as the insrt point
            // since the `instr` it self will be removed during the instr rewrite functions call
            prev_avx512_instr = instr->prev;
            if (first_avx512_instr_prev == NULL)
                first_avx512_instr_prev = prev_avx512_instr;
            // every iter will change this, but this will make sure that the last of last is what we need
            last_avx512_instr_next = instr->next;
            instr_t *avx512instrs_rewritten =
                rewrite_funcs[TO_AVX512_RWFUNC_INDEX(avx512_opcode)](dcontext, ilist, instr, instr->translation);
            instrlist_postinsert(ilist, prev_avx512_instr, avx512instrs_rewritten);
        }
    }

    if (ilist->need_spill_simd) {

#define COARSE_SPILL

#ifdef COARSE_SPILL
        // spill all non-avx512 regs to tls
        // before this bb's first avx512 instr, and after this bb's last avx512 instr
        // ------------------------------
        // ilist before first avx512 instr
        // <cmsave ymm0-ymm15 to tls>
        // ------------------------------
        // ilist first avx512 instr
        // ------------------------------
        // ilist last avx512 instr
        // <restore ymm0-ymm15 from tls>
        // ------------------------------
        // ilist remaining instrs
        // ------------------------------
        save_simd_to_tls(dcontext, ilist, first_avx512_instr_prev->next);
        restore_simd_from_tls(dcontext, ilist, last_avx512_instr_next);
#elif FINE_SPILL
#endif /* COARSE_SPILL || FINE_SPILL */
    }
}

instr_t *
rewrite_avx512_instr(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    return exec_rewrite_avx512_instr(dcontext, ilist, instr, instr_start);
}

/* ======================================== *
 * rewrite functions implementations
 * ======================================== */

/** @brief rewrite nothing, a placeholder for unimplemented instr traslation only. */
instr_t *
rw_func_empty(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "Empty rw_func at %p\n:", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
#endif
    instr_t *new_instr = instr_create_0dst_0src(dcontext, OP_nop);
    instr_disassemble(dcontext, new_instr, 1);
    instr_destroy(dcontext, new_instr);
    return new_instr;
}

/**
 * @brief invalid instr that should not be rewrite, in the rewrite funcs array,
 *        we include extra 4 instr(xsavec32, xsavec64, adox, adcx) to calculate
 *        index in rw_funcs based on the index in enum easier.
 */
instr_t *
rw_func_invalid(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "Unsupported rw_func at %p", instr_start);
#endif
    return NULL_INSTR;
}

instr_t* /* 1 */
rw_func_vmovss(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 1));
    reg_id_t src2_reg = opnd_get_reg(instr_get_src(instr, 2));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_XMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 4 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_2src(dcontext, OP_vmovss, op_dst, op_src1, op_src2);;
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = DR_REG_NULL;
        if (src2_reg == dst_reg) {
            spill_src1_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src1_reg = find_available_spill_xmm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vpsubw spill_src1_reg src2_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vmovss, op_dst, op_spill_src1, op_src2);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* src2 need spill */
        reg_id_t spill_src2_reg = DR_REG_NULL;
        if (src1_reg == dst_reg) {
            spill_src2_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src2_reg = find_available_spill_xmm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vmovss src1_reg spill_src2_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vmovss, op_dst, op_src1, op_spill_src2);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_src2 -> tls(spill_src2)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vmovss spill_src1 spill_src2 -> dst
        instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vmovss, op_dst, op_spill_src1, op_spill_src2);;
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 4: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;

        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vmovss src1 src2 -> spill_dst
        instr_t *i2 = instr_create_1dst_2src(dcontext, OP_vmovss, op_spill_dst, op_src1, op_src2);;
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 5: { /* src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovss spill_src1 src2 -> spill_dst
        instr_t *i4 = instr_create_1dst_2src(dcontext, OP_vmovss, op_spill_dst, op_spill_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 6: { /* src2 and dst need spill */
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;

        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_src2 -> tls(spill_src2)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vmovss src1 spill_src2 -> spill_dst
        instr_t *i4 = instr_create_1dst_2src(dcontext, OP_vmovss, op_spill_dst, op_src1, op_spill_src2);;
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 7: { /* all need spill */
        if (src1_reg == dst_reg && src2_reg == dst_reg) {
            reg_id_t spill_reg = XMM_SPILL_SLOT0;
            opnd_t op_spill = opnd_create_reg(spill_reg);
            // spill -> tls_slot(spill)
            instr_t *i1 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
            // tls(src1) -> spill
            instr_t *i2 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // vmovss spill spill -> spill
            instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vmovss, op_spill, op_spill, op_spill);;
            // spill -> tls(dst)
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill) -> spill
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } else if (src1_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vmovss spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vmovss, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else if (src2_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src2_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vmovss spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vmovss, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vmovss spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vmovss, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        }
    } break;
    default: {
        REWRITE_INFO(STD_OUTF, "vmovss xmm and xmm pattern not support\n");
    } break;
    }
    return NULL_INSTR;
}

instr_t* /* 2 */
rw_func_vmovsd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 1));
    reg_id_t src2_reg = opnd_get_reg(instr_get_src(instr, 2));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_XMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 4 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_2src(dcontext, OP_vmovss, op_dst, op_src1, op_src2);;
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = DR_REG_NULL;
        if (src2_reg == dst_reg) {
            spill_src1_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src1_reg = find_available_spill_xmm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vpsubw spill_src1_reg src2_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vmovss, op_dst, op_spill_src1, op_src2);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* src2 need spill */
        reg_id_t spill_src2_reg = DR_REG_NULL;
        if (src1_reg == dst_reg) {
            spill_src2_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src2_reg = find_available_spill_xmm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vmovss src1_reg spill_src2_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vmovss, op_dst, op_src1, op_spill_src2);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_src2 -> tls(spill_src2)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vmovss spill_src1 spill_src2 -> dst
        instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vmovss, op_dst, op_spill_src1, op_spill_src2);;
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 4: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;

        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vmovss src1 src2 -> spill_dst
        instr_t *i2 = instr_create_1dst_2src(dcontext, OP_vmovss, op_spill_dst, op_src1, op_src2);;
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 5: { /* src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovss spill_src1 src2 -> spill_dst
        instr_t *i4 = instr_create_1dst_2src(dcontext, OP_vmovss, op_spill_dst, op_spill_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 6: { /* src2 and dst need spill */
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;

        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_src2 -> tls(spill_src2)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vmovss src1 spill_src2 -> spill_dst
        instr_t *i4 = instr_create_1dst_2src(dcontext, OP_vmovss, op_spill_dst, op_src1, op_spill_src2);;
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 7: { /* all need spill */
        if (src1_reg == dst_reg && src2_reg == dst_reg) {
            reg_id_t spill_reg = XMM_SPILL_SLOT0;
            opnd_t op_spill = opnd_create_reg(spill_reg);
            // spill -> tls_slot(spill)
            instr_t *i1 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
            // tls(src1) -> spill
            instr_t *i2 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // vmovss spill spill -> spill
            instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vmovss, op_spill, op_spill, op_spill);;
            // spill -> tls(dst)
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill) -> spill
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } else if (src1_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vmovss spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vmovss, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else if (src2_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src2_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vmovss spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vmovss, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vmovss spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vmovss, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        }
    } break;
    default: {
        REWRITE_INFO(STD_OUTF, "vmovss xmm and xmm pattern not support\n");
    } break;
    }
    return NULL_INSTR;
}



instr_t* /* 3 */
rw_func_vmovups(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 0));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vmovups, op_dst, op_src1);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovups spill_src1_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_1src(dcontext, OP_vmovups, op_dst, op_spill_src1);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vmovups src1 -> spill_dst
        instr_t *i2 = instr_create_1dst_1src(dcontext, OP_vmovups, op_spill_dst, op_src1);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovups spill_src1 -> spill_dst
        instr_t *i4 = instr_create_1dst_1src(dcontext, OP_vmovups, op_spill_dst, op_spill_src1);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    default:
        return NULL;
    }
}

instr_t* /* 4 */
rw_func_vmovupd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 0));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vmovupd, op_dst, op_src1);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovupd spill_src1_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_1src(dcontext, OP_vmovupd, op_dst, op_spill_src1);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vmovupd src1 -> spill_dst
        instr_t *i2 = instr_create_1dst_1src(dcontext, OP_vmovupd, op_spill_dst, op_src1);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovupd spill_src1 -> spill_dst
        instr_t *i4 = instr_create_1dst_1src(dcontext, OP_vmovupd, op_spill_dst, op_spill_src1);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    default:
        return NULL;
    }
}

instr_t* /* 5 */
rw_func_vmovlps(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 0));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vmovlps, op_dst, op_src1);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovlps spill_src1_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_1src(dcontext, OP_vmovlps, op_dst, op_spill_src1);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vmovlps src1 -> spill_dst
        instr_t *i2 = instr_create_1dst_1src(dcontext, OP_vmovlps, op_spill_dst, op_src1);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovlps spill_src1 -> spill_dst
        instr_t *i4 = instr_create_1dst_1src(dcontext, OP_vmovlps, op_spill_dst, op_spill_src1);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
        } break;
        default:
        return NULL;
    }
}

instr_t* /* 6 */
rw_func_vmovsldup(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 0));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vmovsldup, op_dst, op_src1);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovsldup spill_src1_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_1src(dcontext, OP_vmovsldup, op_dst, op_spill_src1);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vmovsldup src1 -> spill_dst
        instr_t *i2 = instr_create_1dst_1src(dcontext, OP_vmovsldup, op_spill_dst, op_src1);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovsldup spill_src1 -> spill_dst
        instr_t *i4 = instr_create_1dst_1src(dcontext, OP_vmovsldup, op_spill_dst, op_spill_src1);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
        } break;
        default:
        return NULL;
    }
}

instr_t* /* 7 */
rw_func_vmovlpd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 0));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vmovlpd, op_dst, op_src1);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovlpd spill_src1_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_1src(dcontext, OP_vmovlpd, op_dst, op_spill_src1);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vmovlpd src1 -> spill_dst
        instr_t *i2 = instr_create_1dst_1src(dcontext, OP_vmovlpd, op_spill_dst, op_src1);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovlpd spill_src1 -> spill_dst
        instr_t *i4 = instr_create_1dst_1src(dcontext, OP_vmovlpd, op_spill_dst, op_spill_src1);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
        } break;
        default:
         return NULL;
     }
}

instr_t* /* 8 */
rw_func_vmovddup(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 0));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vmovddup, op_dst, op_src1);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovddup spill_src1_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_1src(dcontext, OP_vmovddup, op_dst, op_spill_src1);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vmovddup src1 -> spill_dst
        instr_t *i2 = instr_create_1dst_1src(dcontext, OP_vmovddup, op_spill_dst, op_src1);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovddup spill_src1 -> spill_dst
        instr_t *i4 = instr_create_1dst_1src(dcontext, OP_vmovddup, op_spill_dst, op_spill_src1);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    default:
         return NULL;
     }
}

instr_t* /* 9 */
rw_func_vunpcklps(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 1));
    reg_id_t src2_reg = opnd_get_reg(instr_get_src(instr, 2));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_XMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 4 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_2src(dcontext, OP_vunpcklps, op_dst, op_src1, op_src2);;
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = DR_REG_NULL;
        if (src2_reg == dst_reg) {
            spill_src1_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src1_reg = find_available_spill_xmm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vunpcklps spill_src1_reg src2_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vunpcklps, op_dst, op_spill_src1, op_src2);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* src2 need spill */
        reg_id_t spill_src2_reg = DR_REG_NULL;
        if (src1_reg == dst_reg) {
            spill_src2_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src2_reg = find_available_spill_xmm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vunpcklps src1_reg spill_src2_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vunpcklps, op_dst, op_src1, op_spill_src2);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_src2 -> tls(spill_src2)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vunpcklps spill_src1 spill_src2 -> dst
        instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vunpcklps, op_dst, op_spill_src1, op_spill_src2);;
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 4: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;

        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vunpcklps src1 src2 -> spill_dst
        instr_t *i2 = instr_create_1dst_2src(dcontext, OP_vunpcklps, op_spill_dst, op_src1, op_src2);;
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 5: { /* src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vunpcklps spill_src1 src2 -> spill_dst
        instr_t *i4 = instr_create_1dst_2src(dcontext, OP_vunpcklps, op_spill_dst, op_spill_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 6: { /* src2 and dst need spill */
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;

        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_src2 -> tls(spill_src2)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vunpcklps src1 spill_src2 -> spill_dst
        instr_t *i4 = instr_create_1dst_2src(dcontext, OP_vunpcklps, op_spill_dst, op_src1, op_spill_src2);;
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 7: { /* all need spill */
        if (src1_reg == dst_reg && src2_reg == dst_reg) {
            reg_id_t spill_reg = XMM_SPILL_SLOT0;
            opnd_t op_spill = opnd_create_reg(spill_reg);
            // spill -> tls_slot(spill)
            instr_t *i1 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
            // tls(src1) -> spill
            instr_t *i2 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // vunpcklps spill spill -> spill
            instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vunpcklps, op_spill, op_spill, op_spill);;
            // spill -> tls(dst)
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill) -> spill
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } else if (src1_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vunpcklps spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vunpcklps, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else if (src2_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src2_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vunpcklps spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vunpcklps, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vunpcklps spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vunpcklps, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        }
    } break;
    default:
         return NULL;
     }
}

instr_t* /* 10 */
rw_func_vunpcklpd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 1));
    reg_id_t src2_reg = opnd_get_reg(instr_get_src(instr, 2));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_XMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 4 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_2src(dcontext, OP_vunpcklpd, op_dst, op_src1, op_src2);;
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = DR_REG_NULL;
        if (src2_reg == dst_reg) {
            spill_src1_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src1_reg = find_available_spill_xmm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vunpcklpd spill_src1_reg src2_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vunpcklpd, op_dst, op_spill_src1, op_src2);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* src2 need spill */
        reg_id_t spill_src2_reg = DR_REG_NULL;
        if (src1_reg == dst_reg) {
            spill_src2_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src2_reg = find_available_spill_xmm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vunpcklpd src1_reg spill_src2_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vunpcklpd, op_dst, op_src1, op_spill_src2);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_src2 -> tls(spill_src2)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vunpcklpd spill_src1 spill_src2 -> dst
        instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vunpcklpd, op_dst, op_spill_src1, op_spill_src2);;
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 4: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;

        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vunpcklpd src1 src2 -> spill_dst
        instr_t *i2 = instr_create_1dst_2src(dcontext, OP_vunpcklpd, op_spill_dst, op_src1, op_src2);;
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 5: { /* src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vunpcklpd spill_src1 src2 -> spill_dst
        instr_t *i4 = instr_create_1dst_2src(dcontext, OP_vunpcklpd, op_spill_dst, op_spill_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 6: { /* src2 and dst need spill */
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;

        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_src2 -> tls(spill_src2)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vunpcklpd src1 spill_src2 -> spill_dst
        instr_t *i4 = instr_create_1dst_2src(dcontext, OP_vunpcklpd, op_spill_dst, op_src1, op_spill_src2);;
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 7: { /* all need spill */
        if (src1_reg == dst_reg && src2_reg == dst_reg) {
            reg_id_t spill_reg = XMM_SPILL_SLOT0;
            opnd_t op_spill = opnd_create_reg(spill_reg);
            // spill -> tls_slot(spill)
            instr_t *i1 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
            // tls(src1) -> spill
            instr_t *i2 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // vunpcklpd spill spill -> spill
            instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vunpcklpd, op_spill, op_spill, op_spill);;
            // spill -> tls(dst)
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill) -> spill
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } else if (src1_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vunpcklpd spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vunpcklpd, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else if (src2_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src2_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vunpcklpd spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vunpcklpd, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vunpcklpd spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vunpcklpd, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        }
    } break;
    default:
         return NULL;
     }
}

instr_t* /* 11 */
rw_func_vunpckhps(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 1));
    reg_id_t src2_reg = opnd_get_reg(instr_get_src(instr, 2));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_XMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 4 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_2src(dcontext, OP_vunpckhps, op_dst, op_src1, op_src2);;
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = DR_REG_NULL;
        if (src2_reg == dst_reg) {
            spill_src1_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src1_reg = find_available_spill_xmm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vunpckhps spill_src1_reg src2_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vunpckhps, op_dst, op_spill_src1, op_src2);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* src2 need spill */
        reg_id_t spill_src2_reg = DR_REG_NULL;
        if (src1_reg == dst_reg) {
            spill_src2_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src2_reg = find_available_spill_xmm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vunpckhps src1_reg spill_src2_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vunpckhps, op_dst, op_src1, op_spill_src2);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_src2 -> tls(spill_src2)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vunpckhps spill_src1 spill_src2 -> dst
        instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vunpckhps, op_dst, op_spill_src1, op_spill_src2);;
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 4: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;

        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vunpckhps src1 src2 -> spill_dst
        instr_t *i2 = instr_create_1dst_2src(dcontext, OP_vunpckhps, op_spill_dst, op_src1, op_src2);;
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 5: { /* src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vunpckhps spill_src1 src2 -> spill_dst
        instr_t *i4 = instr_create_1dst_2src(dcontext, OP_vunpckhps, op_spill_dst, op_spill_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 6: { /* src2 and dst need spill */
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;

        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_src2 -> tls(spill_src2)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vunpckhps src1 spill_src2 -> spill_dst
        instr_t *i4 = instr_create_1dst_2src(dcontext, OP_vunpckhps, op_spill_dst, op_src1, op_spill_src2);;
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 7: { /* all need spill */
        if (src1_reg == dst_reg && src2_reg == dst_reg) {
            reg_id_t spill_reg = XMM_SPILL_SLOT0;
            opnd_t op_spill = opnd_create_reg(spill_reg);
            // spill -> tls_slot(spill)
            instr_t *i1 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
            // tls(src1) -> spill
            instr_t *i2 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // vunpckhps spill spill -> spill
            instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vunpckhps, op_spill, op_spill, op_spill);;
            // spill -> tls(dst)
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill) -> spill
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } else if (src1_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vunpckhps spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vunpckhps, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else if (src2_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src2_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vunpckhps spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vunpckhps, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vunpckhps spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vunpckhps, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        }
    } break;
    default:
         return NULL;
     }
}

instr_t* /* 12 */
rw_func_vunpckhpd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 1));
    reg_id_t src2_reg = opnd_get_reg(instr_get_src(instr, 2));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_XMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 4 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_2src(dcontext, OP_vunpckhpd, op_dst, op_src1, op_src2);;
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = DR_REG_NULL;
        if (src2_reg == dst_reg) {
            spill_src1_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src1_reg = find_available_spill_xmm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vunpckhpd spill_src1_reg src2_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vunpckhpd, op_dst, op_spill_src1, op_src2);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* src2 need spill */
        reg_id_t spill_src2_reg = DR_REG_NULL;
        if (src1_reg == dst_reg) {
            spill_src2_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src2_reg = find_available_spill_xmm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vunpckhpd src1_reg spill_src2_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vunpckhpd, op_dst, op_src1, op_spill_src2);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_src2 -> tls(spill_src2)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vunpckhpd spill_src1 spill_src2 -> dst
        instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vunpckhpd, op_dst, op_spill_src1, op_spill_src2);;
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 4: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;

        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vunpckhpd src1 src2 -> spill_dst
        instr_t *i2 = instr_create_1dst_2src(dcontext, OP_vunpckhpd, op_spill_dst, op_src1, op_src2);;
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 5: { /* src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vunpckhpd spill_src1 src2 -> spill_dst
        instr_t *i4 = instr_create_1dst_2src(dcontext, OP_vunpckhpd, op_spill_dst, op_spill_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 6: { /* src2 and dst need spill */
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;

        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_src2 -> tls(spill_src2)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vunpckhpd src1 spill_src2 -> spill_dst
        instr_t *i4 = instr_create_1dst_2src(dcontext, OP_vunpckhpd, op_spill_dst, op_src1, op_spill_src2);;
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 7: { /* all need spill */
        if (src1_reg == dst_reg && src2_reg == dst_reg) {
            reg_id_t spill_reg = XMM_SPILL_SLOT0;
            opnd_t op_spill = opnd_create_reg(spill_reg);
            // spill -> tls_slot(spill)
            instr_t *i1 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
            // tls(src1) -> spill
            instr_t *i2 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // vunpckhpd spill spill -> spill
            instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vunpckhpd, op_spill, op_spill, op_spill);;
            // spill -> tls(dst)
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill) -> spill
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } else if (src1_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vunpckhpd spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vunpckhpd, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else if (src2_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src2_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vunpckhpd spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vunpckhpd, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vunpckhpd spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vunpckhpd, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        }
    } break;
    default:
         return NULL;
     }
}

instr_t* /* 13 */
rw_func_vmovhps(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 0));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vmovhps, op_dst, op_src1);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovhps spill_src1_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_1src(dcontext, OP_vmovhps, op_dst, op_spill_src1);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vmovhps src1 -> spill_dst
        instr_t *i2 = instr_create_1dst_1src(dcontext, OP_vmovhps, op_spill_dst, op_src1);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovhps spill_src1 -> spill_dst
        instr_t *i4 = instr_create_1dst_1src(dcontext, OP_vmovhps, op_spill_dst, op_spill_src1);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    default:
         return NULL;
     }
}

instr_t* /* 14 */
rw_func_vmovshdup(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 0));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vmovshdup, op_dst, op_src1);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovshdup spill_src1_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_1src(dcontext, OP_vmovshdup, op_dst, op_spill_src1);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vmovshdup src1 -> spill_dst
        instr_t *i2 = instr_create_1dst_1src(dcontext, OP_vmovshdup, op_spill_dst, op_src1);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovshdup spill_src1 -> spill_dst
        instr_t *i4 = instr_create_1dst_1src(dcontext, OP_vmovshdup, op_spill_dst, op_spill_src1);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    default:
         return NULL;
     }
}

instr_t* /* 15 */
rw_func_vmovhpd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 0));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vmovhpd, op_dst, op_src1);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovhpd spill_src1_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_1src(dcontext, OP_vmovhpd, op_dst, op_spill_src1);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vmovhpd src1 -> spill_dst
        instr_t *i2 = instr_create_1dst_1src(dcontext, OP_vmovhpd, op_spill_dst, op_src1);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovhpd spill_src1 -> spill_dst
        instr_t *i4 = instr_create_1dst_1src(dcontext, OP_vmovhpd, op_spill_dst, op_spill_src1);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    default:
         return NULL;
     }
}

/* ==============================================
 *         Helper func for vmovaps
 * ============================================= */
instr_t *
vmovaps_zmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t dst_reg,
                        reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_ZMM(src1_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_ZMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        // Convert ZMM to YMM pairs for both src and dst
        reg_id_t src1_lower = ZMM_TO_YMM(src1_reg);
        reg_id_t src1_upper = find_one_available_spill_ymm(src1_lower);
        reg_id_t dst_lower = ZMM_TO_YMM(dst_reg);
        reg_id_t dst_upper = find_one_available_spill_ymm(dst_lower);

        opnd_t op_src1_lower = create_mapping_ymm_opnd(dcontext, src1_lower);
        opnd_t op_src1_upper = create_mapping_ymm_opnd(dcontext, src1_upper);
        opnd_t op_dst_lower = create_mapping_ymm_opnd(dcontext, dst_lower);
        opnd_t op_dst_upper = create_mapping_ymm_opnd(dcontext, dst_upper);

        // src1_upper -> tls(src1_upper)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src1_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_upper)), OPSZ_32);
        // dst_upper -> tls(dst_upper)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_upper)), OPSZ_32);
        // tls(src1_upper) -> src1_upper (restore src1 high part)
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)) + SIZE_OF_YMM, OPSZ_32);
        // tls(dst_upper) -> dst_upper (restore dst high part)
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_32);
        // vmovaps src1_lower -> dst_lower
        instr_t *i5 = INSTR_CREATE_vmovaps(dcontext, op_dst_lower, op_src1_lower);
        // vmovaps src1_upper -> dst_upper
        instr_t *i6 = INSTR_CREATE_vmovaps(dcontext, op_dst_upper, op_src1_upper);
        // dst_lower -> tls(dst_lower)
        instr_t *i7 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_lower,
                                             TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_32);
        // dst_upper -> tls(dst_upper)
        instr_t *i8 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_upper,
                                             TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_32);
        // tls(src1_upper) -> src1_upper (restore original)
        instr_t *i9 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_upper,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_upper)), OPSZ_32);
        // tls(dst_upper) -> dst_upper (restore original)
        instr_t *i10 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_upper)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 10, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);
#endif
        instrlist_concat_next_instr(ilist, 10, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);
        return i1;
    } break;
    case 1: /* src1 need spill */
    case 2: /* dst need spill */
    case 3: { /* both src1 and dst need spill */
        // For spill cases, use two YMM spill slots
        reg_id_t spill_src1_lower = find_one_available_spill_ymm(DR_REG_NULL);
        reg_id_t spill_src1_upper = find_one_available_spill_ymm(spill_src1_lower);
        reg_id_t spill_dst_lower = find_one_available_spill_ymm(spill_src1_upper);
        reg_id_t spill_dst_upper = find_one_available_spill_ymm(spill_dst_lower);

        opnd_t op_spill_src1_lower = create_mapping_ymm_opnd(dcontext, spill_src1_lower);
        opnd_t op_spill_src1_upper = create_mapping_ymm_opnd(dcontext, spill_src1_upper);
        opnd_t op_spill_dst_lower = create_mapping_ymm_opnd(dcontext, spill_dst_lower);
        opnd_t op_spill_dst_upper = create_mapping_ymm_opnd(dcontext, spill_dst_upper);

        // Save all spill registers
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_lower)), OPSZ_32);
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_upper)), OPSZ_32);
        instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_32);
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_upper)), OPSZ_32);
        // Load source ZMM parts into spill registers
        instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_lower,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)), OPSZ_32);
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)) + SIZE_OF_YMM, OPSZ_32);
        // vmovaps spill_src1_lower -> spill_dst_lower
        instr_t *i7 = INSTR_CREATE_vmovaps(dcontext, op_spill_dst_lower, op_spill_src1_lower);
        // vmovaps spill_src1_upper -> spill_dst_upper
        instr_t *i8 = INSTR_CREATE_vmovaps(dcontext, op_spill_dst_upper, op_spill_src1_upper);
        // Store result to destination ZMM
        instr_t *i9 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower,
                                             TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_32);
        instr_t *i10 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_upper,
                                              TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_32);
        // Restore all spill registers
        instr_t *i11 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_lower)), OPSZ_32);
        instr_t *i12 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_upper)), OPSZ_32);
        instr_t *i13 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_32);
        instr_t *i14 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_upper)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 14, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14);
#endif
        instrlist_concat_next_instr(ilist, 14, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14);
        return i1;
    } break;
    }
    return NULL_INSTR;
}

instr_t *
vmovaps_ymm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t dst_reg,
                        reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_YMM(src1_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_YMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t src1_opnd = create_mapping_ymm_opnd(dcontext, src1_reg);
        opnd_t dst_opnd = create_mapping_ymm_opnd(dcontext, dst_reg);
        // VEX.256.0F.WIG 28 /r VMOVAPS ymm1, ymm2/m256
        instr_t *i1 = INSTR_CREATE_vmovaps(dcontext, dst_opnd, src1_opnd);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = find_one_available_spill_ymm(dst_reg);
        opnd_t spill_src1_opnd = create_mapping_ymm_opnd(dcontext, spill_src1_reg);
        opnd_t dst_opnd = create_mapping_ymm_opnd(dcontext, dst_reg);

        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
        // VMOVAPS ymm1, ymm2/m256
        instr_t *i3 = INSTR_CREATE_vmovaps(dcontext, dst_opnd, spill_src1_opnd);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        reg_id_t spill_dst_reg = find_one_available_spill_ymm(src1_reg);
        opnd_t spill_dst_opnd = create_mapping_ymm_opnd(dcontext, spill_dst_reg);
        opnd_t src1_opnd = create_mapping_ymm_opnd(dcontext, src1_reg);

        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        // VMOVAPS ymm1, ymm2/m256
        instr_t *i2 = INSTR_CREATE_vmovaps(dcontext, spill_dst_opnd, src1_opnd);
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src1 and dst need spill */
        reg_id_t spill_reg = YMM_SPILL_SLOT0;
        opnd_t spill_opnd = create_mapping_ymm_opnd(dcontext, spill_reg);

        // spill_reg -> tls(spill_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_reg)), OPSZ_32);
        // tls(src1_reg) -> spill_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
        // VMOVAPS ymm1, ymm2/m256
        instr_t *i3 = INSTR_CREATE_vmovaps(dcontext, spill_opnd, spill_opnd);
        // spill_reg -> tls(dst_reg)
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls(spill_reg) -> spill_reg
        instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    }
    return NULL_INSTR;
}

instr_t *
vmovaps_xmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t dst_reg,
                        reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t src1_opnd = opnd_create_reg(src1_reg);
        opnd_t dst_opnd = opnd_create_reg(dst_reg);
        // VEX.128.0F.WIG 28 /r VMOVAPS xmm1, xmm2/m128
        instr_t *i1 = INSTR_CREATE_vmovaps(dcontext, dst_opnd, src1_opnd);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);
        opnd_t dst_opnd = opnd_create_reg(dst_reg);

        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg, 
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // VMOVAPS xmm1, xmm2/m128
        instr_t *i3 = INSTR_CREATE_vmovaps(dcontext, dst_opnd, spill_src1_opnd);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        reg_id_t spill_dst_reg = find_one_available_spill_xmm(src1_reg);
        opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
        opnd_t src1_opnd = opnd_create_reg(src1_reg);

        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // VMOVAPS xmm1, xmm2/m128
        instr_t *i2 = INSTR_CREATE_vmovaps(dcontext, spill_dst_opnd, src1_opnd);
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src1 and dst need spill */
        reg_id_t spill_reg = XMM_SPILL_SLOT0;
        opnd_t spill_opnd = opnd_create_reg(spill_reg);

        // spill_reg -> tls(spill_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // VMOVAPS xmm1, xmm2/m128
        instr_t *i3 = INSTR_CREATE_vmovaps(dcontext, spill_opnd, spill_opnd);
        // spill_reg -> tls(dst_reg)
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_reg) -> spill_reg
        instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    }
    return NULL_INSTR;
}

instr_t *
vmovaps_zmm_reg2disp_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, opnd_t dst_opnd,
                         reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    reg_id_t base_reg = opnd_get_base(dst_opnd);
    reg_id_t index_reg = opnd_get_index(dst_opnd);
    int scale = opnd_get_scale(dst_opnd);
    int disp = opnd_get_disp(dst_opnd);

    const uint src1_need_spill_flag = NEED_SPILL_ZMM(src1_reg) ? 1 : 0;

    switch (src1_need_spill_flag) {
    case 0: { /* no spill */
        // Convert ZMM to YMM for lower and upper halves
        reg_id_t src1_lower = ZMM_TO_YMM(src1_reg);
        reg_id_t src1_upper = find_one_available_spill_ymm(src1_lower);

        opnd_t op_src1_lower = create_mapping_ymm_opnd(dcontext, src1_lower);
        opnd_t op_src1_upper = create_mapping_ymm_opnd(dcontext, src1_upper);

        // src1_upper -> tls(src1_upper)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src1_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_upper)), OPSZ_32);
        // tls(src1_upper_half) -> src1_upper
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)) + SIZE_OF_YMM, OPSZ_32);
        // vmovaps src1_lower -> dst_lower
        instr_t *i3 = INSTR_CREATE_vmovaps(dcontext,
                                           opnd_create_base_disp(base_reg, index_reg, scale, disp, OPSZ_32),
                                           op_src1_lower);
        // vmovaps src1_upper -> dst_upper
        instr_t *i4 = INSTR_CREATE_vmovaps(dcontext,
                                           opnd_create_base_disp(base_reg, index_reg, scale, disp + SIZE_OF_YMM, OPSZ_32),
                                           op_src1_upper);
        // tls(src1_upper) -> src1_upper
        instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_upper,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_upper)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    case 1: { /* src1 need spill */
        // Use two spill YMM slots for ZMM
        reg_id_t spill_src1_lower = find_one_available_spill_ymm(DR_REG_NULL);
        reg_id_t spill_src1_upper = find_one_available_spill_ymm(spill_src1_lower);

        opnd_t op_spill_src1_lower = create_mapping_ymm_opnd(dcontext, spill_src1_lower);
        opnd_t op_spill_src1_upper = create_mapping_ymm_opnd(dcontext, spill_src1_upper);

        // spill_src1_lower -> tls(spill_src1_lower)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_lower)), OPSZ_32);
        // spill_src1_upper -> tls(spill_src1_upper)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_upper)), OPSZ_32);
        // tls(src1_lower) -> spill_src1_lower
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_lower,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)), OPSZ_32);
        // tls(src1_upper) -> spill_src1_upper
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)) + SIZE_OF_YMM, OPSZ_32);
        // vmovaps spill_src1_lower -> dst_lower
        instr_t *i5 = INSTR_CREATE_vmovaps(dcontext,
                                           opnd_create_base_disp(base_reg, index_reg, scale, disp, OPSZ_32),
                                           op_spill_src1_lower);
        // vmovaps spill_src1_upper -> dst_upper
        instr_t *i6 = INSTR_CREATE_vmovaps(dcontext,
                                           opnd_create_base_disp(base_reg, index_reg, scale, disp + SIZE_OF_YMM, OPSZ_32),
                                           op_spill_src1_upper);
        // tls(spill_src1_lower) -> spill_src1_lower
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_lower,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_lower)), OPSZ_32);
        // tls(spill_src1_upper) -> spill_src1_upper
        instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_upper,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_upper)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
        instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
        return i1;
    } break;
    }
    return NULL_INSTR;
}

instr_t *
vmovaps_ymm_reg2disp_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, opnd_t dst_opnd,
                         reg_id_t mask_reg)
{
    opnd_t src1_opnd = create_mapping_ymm_opnd(dcontext, src1_reg);
    // VEX.256.0F.WIG 28 /r VMOVAPS ymm1, ymm2/m256
    instr_t *i1 = INSTR_CREATE_vmovaps(dcontext, dst_opnd, src1_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return i1;
}

instr_t *
vmovaps_xmm_reg2disp_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, opnd_t dst_opnd,
                         reg_id_t mask_reg)
{

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill = NEED_SPILL_XMM(src1_reg) ? 1 : 0;

    switch (src1_need_spill) {
    case 0: {
        // don't need spill
        {
            opnd_t src1_opnd = opnd_create_reg(src1_reg);
            // VEX.128.0F.WIG 29 /r VMOVAPS xmm2/m128, xmm1
            instr_t *i1 = INSTR_CREATE_vmovaps(dcontext, dst_opnd, src1_opnd);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
            return i1;
        }
    } break;
    case 1: {
        // src1 need spill
        {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);

            // spill_src1_reg -> tls(spill_src1_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(src1_reg) -> spill_src1_reg
            instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // VMOVAPS xmm2/m128, xmm1
            instr_t *i3 = INSTR_CREATE_vmovaps(dcontext, dst_opnd, spill_src1_opnd);
            // tls(spill_src1_reg) -> spill_src1_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
            instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
            return i1;
        }
    } break;
    }
    return NULL_INSTR;
}

instr_t *
vmovaps_zmm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src1_opnd, reg_id_t dst_reg,
                         reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    reg_id_t src_base_reg = opnd_get_base(src1_opnd); // src_reg is now DR_REG_RSP
    reg_id_t src_index_reg = opnd_get_index(src1_opnd);
    int scale = opnd_get_scale(src1_opnd);
    int disp = opnd_get_disp(src1_opnd);

    const uint dst_need_spill = NEED_SPILL_ZMM(dst_reg) ? 1 : 0;
    switch (dst_need_spill) {
    case 0: { /* no spill */
        reg_id_t dst_reg_lower = ZMM_TO_YMM(dst_reg);
        reg_id_t dst_reg_upper = find_one_available_spill_ymm(dst_reg_lower);

        opnd_t op_dst_reg_lower = opnd_create_reg(dst_reg_lower);
        opnd_t op_dst_reg_upper = opnd_create_reg(dst_reg_upper);

        // dst_reg_upper -> tls(dst_reg_upper)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);
        // vmovaps src_low -> dst_reg_lower
        instr_t *i2 = INSTR_CREATE_vmovaps(dcontext, op_dst_reg_lower,
                                           opnd_create_base_disp(src_base_reg, src_index_reg, scale, disp, OPSZ_32));
        // vmovaps src_high -> dst_reg_upper
        instr_t *i3 = INSTR_CREATE_vmovaps(
            dcontext, op_dst_reg_upper,
            opnd_create_base_disp(src_base_reg, src_index_reg, scale, disp + SIZE_OF_YMM, OPSZ_32));
        // dst_reg_lower -> tls(dst_lower)
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_32);
        // dst_reg_upper -> tls(dst_upper)
        instr_t *i5 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_32);
        // tls(dst_reg_upper) -> dst_reg_upper
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 6, i1, i2, i3, i4, i5, i6);
#endif
        instrlist_concat_next_instr(ilist, 6, i1, i2, i3, i4, i5, i6);
        return i1;
    } break;
    case 1: { /* dst need spill */
        reg_id_t spill_dst_reg = find_one_available_spill_ymm(DR_REG_NULL);
        reg_id_t spill_dst_reg_upper = find_one_available_spill_ymm(spill_dst_reg);

        opnd_t op_spill_dst_reg = opnd_create_reg(spill_dst_reg);
        opnd_t op_spill_dst_reg_upper = opnd_create_reg(spill_dst_reg_upper);

        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        // spill_dst_reg_upper -> tls(spill_dst_reg_upper)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg_upper)), OPSZ_32);
        // vmovaps src_low -> spill_dst_reg
        instr_t *i3 = INSTR_CREATE_vmovaps(dcontext, op_spill_dst_reg,
                                           opnd_create_base_disp(src_base_reg, src_index_reg, scale, disp, OPSZ_32));
        // vmovaps src_high -> spill_dst_reg_upper
        instr_t *i4 = INSTR_CREATE_vmovaps(
            dcontext, op_spill_dst_reg_upper,
            opnd_create_base_disp(src_base_reg, src_index_reg, scale, disp + SIZE_OF_YMM, OPSZ_32));
        // spill_dst_reg -> tls(dst_lower)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_32);
        // spill_dst_reg_upper -> tls(dst_upper)
        instr_t *i6 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_32);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        // tls(spill_dst_reg_upper) -> spill_dst_reg_upper
        instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg_upper)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
        instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
        return i1;
    } break;
    }
    return NULL_INSTR;
}

instr_t *
vmovaps_ymm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src1_opnd, reg_id_t dst_reg,
                         reg_id_t mask_reg)
{
    opnd_t dst_opnd = opnd_create_reg(dst_reg); 

    // VEX.256.0F.WIG 28 /r VMOVAPS ymm1, ymm2/m256
    instr_t *new_instr1 = INSTR_CREATE_vmovaps(dcontext, dst_opnd, src1_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vmovaps_xmm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src1_opnd, reg_id_t dst_reg,
                         reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint dst_need_spill = NEED_SPILL_XMM(dst_reg) ? 1 : 0;

    switch (dst_need_spill) {
    case 0: // don't need spill
    {
        opnd_t dst_opnd = opnd_create_reg(dst_reg);
        // VEX.128.0F.WIG 29 /r VMOVAPS xmm2/m128, xmm1
        instr_t *new_instr1 = INSTR_CREATE_vmovaps(dcontext, dst_opnd, src1_opnd);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
        return new_instr1;
    } break;
    case 1: { // dst need spill
        reg_id_t spill_dst_reg = find_available_spill_xmm_avoiding(dst_reg, DR_REG_NULL, DR_REG_NULL);
        opnd_t spill_dst_opnd = create_mapping_xmm_opnd(dcontext, spill_dst_reg);

        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *new_instr1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // VMOVAPS xmm2/m128, xmm1
        instr_t *new_instr2 = INSTR_CREATE_vmovaps(dcontext, spill_dst_opnd, src1_opnd);
        // spill_dst_reg -> tls(dst_reg)
        instr_t *new_instr3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *new_instr4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                          TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, new_instr1, new_instr2, new_instr3, new_instr4);
#endif
        instrlist_concat_next_instr(ilist, 4, new_instr1, new_instr2, new_instr3, new_instr4);
        return new_instr1;
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vmovaps_xmm_disp2reg_gen except 0 or 1"); return NULL_INSTR;
    }
    return NULL_INSTR;
}

/**
 * @brief rewrite vmovaps
 */
instr_t *
rw_func_vmovaps(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vmovaps {%k0} %xmm28 -> 0x90(%rsp)[16byte]
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src1_opnd = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vmovaps", true, true, false, true);
#endif
    switch (src1_opnd.kind) {
    case REG_kind: {                     // VMOVAPS xyzmm1 {k1}{z}, xyzmm2/m{128,256,512}
        if (dst_opnd.kind == REG_kind) { // xyzmm -> xyzmm
            reg_id_t dst_reg = opnd_get_reg(dst_opnd);
            reg_id_t src1_reg = opnd_get_reg(src1_opnd);
            if (IS_XMM_REG(dst_reg))
                return vmovaps_xmm_reg2reg_gen(dcontext, ilist, instr, src1_reg, dst_reg, mask_reg);
            if (IS_YMM_REG(dst_reg))
                return vmovaps_ymm_reg2reg_gen(dcontext, ilist, instr, src1_reg, dst_reg, mask_reg);
            if (IS_ZMM_REG(dst_reg))
                return vmovaps_zmm_reg2reg_gen(dcontext, ilist, instr, src1_reg, dst_reg, mask_reg);
        } else { // xyzmm -> m{128, 256, 512}
            reg_id_t src1_reg = opnd_get_reg(src1_opnd);
            if (IS_XMM_REG(src1_reg))
                return vmovaps_xmm_reg2disp_gen(dcontext, ilist, instr, src1_reg, dst_opnd, mask_reg);
            if (IS_YMM_REG(src1_reg))
                return vmovaps_ymm_reg2disp_gen(dcontext, ilist, instr, src1_reg, dst_opnd, mask_reg);
            if (IS_ZMM_REG(src1_reg))
                return vmovaps_zmm_reg2disp_gen(dcontext, ilist, instr, src1_reg, dst_opnd, mask_reg);
        }
    } break;
    case BASE_DISP_kind: { // VVMOVAPS m{128,256,512} {k1}{z}, xyzmm1
        // m{128, 256, 512} -> xyzmm
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_XMM_REG(dst_reg))
            return vmovaps_xmm_disp2reg_gen(dcontext, ilist, instr, src1_opnd, dst_reg, mask_reg);
        if (IS_YMM_REG(dst_reg))
            return vmovaps_ymm_disp2reg_gen(dcontext, ilist, instr, src1_opnd, dst_reg, mask_reg);
        if (IS_ZMM_REG(dst_reg))
            return vmovaps_zmm_disp2reg_gen(dcontext, ilist, instr, src1_opnd, dst_reg, mask_reg);
    } break;
    default: print_file(STD_OUTF, "[WARN]: vmovaps pattern not support\n");
    }
    return NULL_INSTR;
}


instr_t* /* 17 */
rw_func_vmovapd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 0));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vmovapd, op_dst, op_src1);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovapd spill_src1_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_1src(dcontext, OP_vmovapd, op_dst, op_spill_src1);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vmovapd src1 -> spill_dst
        instr_t *i2 = instr_create_1dst_1src(dcontext, OP_vmovapd, op_spill_dst, op_src1);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovapd spill_src1 -> spill_dst
        instr_t *i4 = instr_create_1dst_1src(dcontext, OP_vmovapd, op_spill_dst, op_spill_src1);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    default:
        return NULL;
    }
}

instr_t* /* 18 */
rw_func_vcvtsi2ss(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 1));
    reg_id_t src2_reg = opnd_get_reg(instr_get_src(instr, 2));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_XMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 4 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_2src(dcontext, OP_vcvtsi2ss, op_dst, op_src1, op_src2);;
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = DR_REG_NULL;
        if (src2_reg == dst_reg) {
            spill_src1_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src1_reg = find_available_spill_xmm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vcvtsi2ss spill_src1_reg src2_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vcvtsi2ss, op_dst, op_spill_src1, op_src2);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* src2 need spill */
        reg_id_t spill_src2_reg = DR_REG_NULL;
        if (src1_reg == dst_reg) {
            spill_src2_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src2_reg = find_available_spill_xmm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vcvtsi2ss src1_reg spill_src2_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vcvtsi2ss, op_dst, op_src1, op_spill_src2);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_src2 -> tls(spill_src2)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vcvtsi2ss spill_src1 spill_src2 -> dst
        instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vcvtsi2ss, op_dst, op_spill_src1, op_spill_src2);;
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 4: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;

        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vcvtsi2ss src1 src2 -> spill_dst
        instr_t *i2 = instr_create_1dst_2src(dcontext, OP_vcvtsi2ss, op_spill_dst, op_src1, op_src2);;
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 5: { /* src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vcvtsi2ss spill_src1 src2 -> spill_dst
        instr_t *i4 = instr_create_1dst_2src(dcontext, OP_vcvtsi2ss, op_spill_dst, op_spill_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 6: { /* src2 and dst need spill */
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;

        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_src2 -> tls(spill_src2)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vcvtsi2ss src1 spill_src2 -> spill_dst
        instr_t *i4 = instr_create_1dst_2src(dcontext, OP_vcvtsi2ss, op_spill_dst, op_src1, op_spill_src2);;
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 7: { /* all need spill */
        if (src1_reg == dst_reg && src2_reg == dst_reg) {
            reg_id_t spill_reg = XMM_SPILL_SLOT0;
            opnd_t op_spill = opnd_create_reg(spill_reg);
            // spill -> tls_slot(spill)
            instr_t *i1 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
            // tls(src1) -> spill
            instr_t *i2 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // vcvtsi2ss spill spill -> spill
            instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vcvtsi2ss, op_spill, op_spill, op_spill);;
            // spill -> tls(dst)
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill) -> spill
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } else if (src1_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vcvtsi2ss spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vcvtsi2ss, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else if (src2_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src2_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vcvtsi2ss spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vcvtsi2ss, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vcvtsi2ss spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vcvtsi2ss, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        }
    } break;
    default:
        return NULL;
    }
    return NULL;
}

instr_t* /* 19 */
rw_func_vcvtsi2sd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 1));
    reg_id_t src2_reg = opnd_get_reg(instr_get_src(instr, 2));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_XMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 4 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_2src(dcontext, OP_vcvtsi2sd, op_dst, op_src1, op_src2);;
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = DR_REG_NULL;
        if (src2_reg == dst_reg) {
            spill_src1_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src1_reg = find_available_spill_xmm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vcvtsi2sd spill_src1_reg src2_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vcvtsi2sd, op_dst, op_spill_src1, op_src2);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* src2 need spill */
        reg_id_t spill_src2_reg = DR_REG_NULL;
        if (src1_reg == dst_reg) {
            spill_src2_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src2_reg = find_available_spill_xmm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vcvtsi2sd src1_reg spill_src2_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vcvtsi2sd, op_dst, op_src1, op_spill_src2);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_src2 -> tls(spill_src2)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vcvtsi2sd spill_src1 spill_src2 -> dst
        instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vcvtsi2sd, op_dst, op_spill_src1, op_spill_src2);;
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 4: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;

        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vcvtsi2sd src1 src2 -> spill_dst
        instr_t *i2 = instr_create_1dst_2src(dcontext, OP_vcvtsi2sd, op_spill_dst, op_src1, op_src2);;
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 5: { /* src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vcvtsi2sd spill_src1 src2 -> spill_dst
        instr_t *i4 = instr_create_1dst_2src(dcontext, OP_vcvtsi2sd, op_spill_dst, op_spill_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 6: { /* src2 and dst need spill */
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;

        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_src2 -> tls(spill_src2)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vcvtsi2sd src1 spill_src2 -> spill_dst
        instr_t *i4 = instr_create_1dst_2src(dcontext, OP_vcvtsi2sd, op_spill_dst, op_src1, op_spill_src2);;
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 7: { /* all need spill */
        if (src1_reg == dst_reg && src2_reg == dst_reg) {
            reg_id_t spill_reg = XMM_SPILL_SLOT0;
            opnd_t op_spill = opnd_create_reg(spill_reg);
            // spill -> tls_slot(spill)
            instr_t *i1 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
            // tls(src1) -> spill
            instr_t *i2 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // vcvtsi2sd spill spill -> spill
            instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vcvtsi2sd, op_spill, op_spill, op_spill);;
            // spill -> tls(dst)
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill) -> spill
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } else if (src1_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vcvtsi2sd spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vcvtsi2sd, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else if (src2_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src2_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vcvtsi2sd spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vcvtsi2sd, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vcvtsi2sd spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vcvtsi2sd, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        }
    } break;
    default:
        return NULL;
    }
    return NULL;
}

instr_t* /* 20 */
rw_func_vmovntps(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 0));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vmovntps, op_dst, op_src1);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovntps spill_src1_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_1src(dcontext, OP_vmovntps, op_dst, op_spill_src1);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vmovntps src1 -> spill_dst
        instr_t *i2 = instr_create_1dst_1src(dcontext, OP_vmovntps, op_spill_dst, op_src1);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovntps spill_src1 -> spill_dst
        instr_t *i4 = instr_create_1dst_1src(dcontext, OP_vmovntps, op_spill_dst, op_spill_src1);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    default:
        return NULL;
    }
}

instr_t* /* 21 */
rw_func_vmovntpd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 0));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vmovntpd, op_dst, op_src1);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovntpd spill_src1_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_1src(dcontext, OP_vmovntpd, op_dst, op_spill_src1);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vmovntpd src1 -> spill_dst
        instr_t *i2 = instr_create_1dst_1src(dcontext, OP_vmovntpd, op_spill_dst, op_src1);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovntpd spill_src1 -> spill_dst
        instr_t *i4 = instr_create_1dst_1src(dcontext, OP_vmovntpd, op_spill_dst, op_spill_src1);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    default:
        return NULL;
    }
}

instr_t* /* 22 */
rw_func_vcvttss2si(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 0));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vcvttss2si, op_dst, op_src1);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vcvttss2si spill_src1_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_1src(dcontext, OP_vcvttss2si, op_dst, op_spill_src1);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vcvttss2si src1 -> spill_dst
        instr_t *i2 = instr_create_1dst_1src(dcontext, OP_vcvttss2si, op_spill_dst, op_src1);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vcvttss2si spill_src1 -> spill_dst
        instr_t *i4 = instr_create_1dst_1src(dcontext, OP_vcvttss2si, op_spill_dst, op_spill_src1);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    default:
        return NULL;
    }
}

instr_t * /* 26 */
rw_func_vucomiss(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 0));
    reg_id_t src2_reg = opnd_get_reg(instr_get_src(instr, 1));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_XMM(src2_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        instr_t *i1 = instr_create_0dst_2src(dcontext, OP_vucomiss, op_src1, op_src2);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = find_one_available_spill_xmm(src2_reg);
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vucomiss spill_src1_reg src2_reg
        instr_t *i3 = instr_create_0dst_2src(dcontext, OP_vucomiss, op_spill_src1, op_src2);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* src2 need spill */
        reg_id_t spill_src2_reg = find_one_available_spill_xmm(src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vucomiss src1_reg spill_src2_reg
        instr_t *i3 = instr_create_0dst_2src(dcontext, OP_vucomiss, op_src1, op_spill_src2);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_src2 -> tls(spill_src2)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vucomiss spill_src1 spill_src2
        instr_t *i5 = instr_create_0dst_2src(dcontext, OP_vucomiss, op_spill_src1, op_spill_src2);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    default:
        return NULL;
    }
}

instr_t * /* 27 */
rw_func_vucomisd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 0));
    reg_id_t src2_reg = opnd_get_reg(instr_get_src(instr, 1));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_XMM(src2_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        instr_t *i1 = instr_create_0dst_2src(dcontext, OP_vucomisd, op_src1, op_src2);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = find_one_available_spill_xmm(src2_reg);
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vucomisd spill_src1_reg src2_reg
        instr_t *i3 = instr_create_0dst_2src(dcontext, OP_vucomisd, op_spill_src1, op_src2);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* src2 need spill */
        reg_id_t spill_src2_reg = find_one_available_spill_xmm(src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vucomisd src1_reg spill_src2_reg
        instr_t *i3 = instr_create_0dst_2src(dcontext, OP_vucomisd, op_src1, op_spill_src2);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_src2 -> tls(spill_src2)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vucomisd spill_src1 spill_src2
        instr_t *i5 = instr_create_0dst_2src(dcontext, OP_vucomisd, op_spill_src1, op_spill_src2);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    default:
        return NULL;
    }
}

instr_t * /* 28 */
rw_func_vcomiss(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 0));
    reg_id_t src2_reg = opnd_get_reg(instr_get_src(instr, 1));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_XMM(src2_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        instr_t *i1 = instr_create_0dst_2src(dcontext, OP_vcomiss, op_src1, op_src2);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = find_one_available_spill_xmm(src2_reg);
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vcomiss spill_src1_reg src2_reg
        instr_t *i3 = instr_create_0dst_2src(dcontext, OP_vcomiss, op_spill_src1, op_src2);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* src2 need spill */
        reg_id_t spill_src2_reg = find_one_available_spill_xmm(src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vcomiss src1_reg spill_src2_reg
        instr_t *i3 = instr_create_0dst_2src(dcontext, OP_vcomiss, op_src1, op_spill_src2);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_src2 -> tls(spill_src2)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vcomiss spill_src1 spill_src2
        instr_t *i5 = instr_create_0dst_2src(dcontext, OP_vcomiss, op_spill_src1, op_spill_src2);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    default:
        return NULL;
    }
}

instr_t * /* 29 */
rw_func_vcomisd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 0));
    reg_id_t src2_reg = opnd_get_reg(instr_get_src(instr, 1));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_XMM(src2_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        instr_t *i1 = instr_create_0dst_2src(dcontext, OP_vcomisd, op_src1, op_src2);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = find_one_available_spill_xmm(src2_reg);
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vcomisd spill_src1_reg src2_reg
        instr_t *i3 = instr_create_0dst_2src(dcontext, OP_vcomisd, op_spill_src1, op_src2);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* src2 need spill */
        reg_id_t spill_src2_reg = find_one_available_spill_xmm(src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vcomisd src1_reg spill_src2_reg
        instr_t *i3 = instr_create_0dst_2src(dcontext, OP_vcomisd, op_src1, op_spill_src2);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_src2 -> tls(spill_src2)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vcomisd spill_src1 spill_src2
        instr_t *i5 = instr_create_0dst_2src(dcontext, OP_vcomisd, op_spill_src1, op_spill_src2);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    default:
        return NULL;
    }
}

instr_t * /* 30 */
rw_func_vmovmskps(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 0));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vmovmskps, op_dst, op_src1);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovmskps spill_src1_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_1src(dcontext, OP_vmovmskps, op_dst, op_spill_src1);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vmovmskps src1 -> spill_dst
        instr_t *i2 = instr_create_1dst_1src(dcontext, OP_vmovmskps, op_spill_dst, op_src1);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovmskps spill_src1 -> spill_dst
        instr_t *i4 = instr_create_1dst_1src(dcontext, OP_vmovmskps, op_spill_dst, op_spill_src1);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    default:
        return NULL;
    }
}

instr_t * /* 31 */
rw_func_vmovmskpd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 0));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vmovmskpd, op_dst, op_src1);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovmskpd spill_src1_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_1src(dcontext, OP_vmovmskpd, op_dst, op_spill_src1);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vmovmskpd src1 -> spill_dst
        instr_t *i2 = instr_create_1dst_1src(dcontext, OP_vmovmskpd, op_spill_dst, op_src1);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vmovmskpd spill_src1 -> spill_dst
        instr_t *i4 = instr_create_1dst_1src(dcontext, OP_vmovmskpd, op_spill_dst, op_spill_src1);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    default:
        return NULL;
    }
}

instr_t * /* 32 */
rw_func_vsqrtps(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 0));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vsqrtps, op_dst, op_src1);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vsqrtps spill_src1_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_1src(dcontext, OP_vsqrtps, op_dst, op_spill_src1);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vsqrtps src1 -> spill_dst
        instr_t *i2 = instr_create_1dst_1src(dcontext, OP_vsqrtps, op_spill_dst, op_src1);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vsqrtps spill_src1 -> spill_dst
        instr_t *i4 = instr_create_1dst_1src(dcontext, OP_vsqrtps, op_spill_dst, op_spill_src1);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    default:
        return NULL;
    }
}

instr_t * /* 33 */
rw_func_vsqrtss(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 1));
    reg_id_t src2_reg = opnd_get_reg(instr_get_src(instr, 2));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_XMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 4 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_2src(dcontext, OP_vsqrtss, op_dst, op_src1, op_src2);;
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = DR_REG_NULL;
        if (src2_reg == dst_reg) {
            spill_src1_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src1_reg = find_available_spill_xmm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vsqrtss spill_src1_reg src2_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vsqrtss, op_dst, op_spill_src1, op_src2);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* src2 need spill */
        reg_id_t spill_src2_reg = DR_REG_NULL;
        if (src1_reg == dst_reg) {
            spill_src2_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src2_reg = find_available_spill_xmm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vsqrtss src1_reg spill_src2_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vsqrtss, op_dst, op_src1, op_spill_src2);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_src2 -> tls(spill_src2)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vsqrtss spill_src1 spill_src2 -> dst
        instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vsqrtss, op_dst, op_spill_src1, op_spill_src2);;
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 4: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;

        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vsqrtss src1 src2 -> spill_dst
        instr_t *i2 = instr_create_1dst_2src(dcontext, OP_vsqrtss, op_spill_dst, op_src1, op_src2);;
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 5: { /* src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vsqrtss spill_src1 src2 -> spill_dst
        instr_t *i4 = instr_create_1dst_2src(dcontext, OP_vsqrtss, op_spill_dst, op_spill_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 6: { /* src2 and dst need spill */
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;

        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_src2 -> tls(spill_src2)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vsqrtss src1 spill_src2 -> spill_dst
        instr_t *i4 = instr_create_1dst_2src(dcontext, OP_vsqrtss, op_spill_dst, op_src1, op_spill_src2);;
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 7: { /* all need spill */
        if (src1_reg == dst_reg && src2_reg == dst_reg) {
            reg_id_t spill_reg = XMM_SPILL_SLOT0;
            opnd_t op_spill = opnd_create_reg(spill_reg);
            // spill -> tls_slot(spill)
            instr_t *i1 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
            // tls(src1) -> spill
            instr_t *i2 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // vsqrtss spill spill -> spill
            instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vsqrtss, op_spill, op_spill, op_spill);;
            // spill -> tls(dst)
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill) -> spill
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } else if (src1_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vsqrtss spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vsqrtss, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else if (src2_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src2_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vsqrtss spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vsqrtss, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vsqrtss spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vsqrtss, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        }
    } break;
    default:
        return NULL;
    }
    return NULL;
}

instr_t * /* 34 */
rw_func_vsqrtpd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 0));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vsqrtpd, op_dst, op_src1);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vsqrtpd spill_src1_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_1src(dcontext, OP_vsqrtpd, op_dst, op_spill_src1);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vsqrtpd src1 -> spill_dst
        instr_t *i2 = instr_create_1dst_1src(dcontext, OP_vsqrtpd, op_spill_dst, op_src1);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vsqrtpd spill_src1 -> spill_dst
        instr_t *i4 = instr_create_1dst_1src(dcontext, OP_vsqrtpd, op_spill_dst, op_spill_src1);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    default:
        return NULL;
    }
}

instr_t * /* 35 */
rw_func_vsqrtsd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    
    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 1));
    reg_id_t src2_reg = opnd_get_reg(instr_get_src(instr, 2));
    reg_id_t dst_reg = opnd_get_reg(instr_get_dst(instr, 0));
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_XMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 4 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_2src(dcontext, OP_vsqrtsd, op_dst, op_src1, op_src2);;
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = DR_REG_NULL;
        if (src2_reg == dst_reg) {
            spill_src1_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src1_reg = find_available_spill_xmm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vsqrtsd spill_src1_reg src2_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vsqrtsd, op_dst, op_spill_src1, op_src2);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* src2 need spill */
        reg_id_t spill_src2_reg = DR_REG_NULL;
        if (src1_reg == dst_reg) {
            spill_src2_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src2_reg = find_available_spill_xmm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vsqrtsd src1_reg spill_src2_reg -> dst_reg
        instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vsqrtsd, op_dst, op_src1, op_spill_src2);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_src2 -> tls(spill_src2)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vsqrtsd spill_src1 spill_src2 -> dst
        instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vsqrtsd, op_dst, op_spill_src1, op_spill_src2);;
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 4: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;

        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vsqrtsd src1 src2 -> spill_dst
        instr_t *i2 = instr_create_1dst_2src(dcontext, OP_vsqrtsd, op_spill_dst, op_src1, op_src2);;
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 5: { /* src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vsqrtsd spill_src1 src2 -> spill_dst
        instr_t *i4 = instr_create_1dst_2src(dcontext, OP_vsqrtsd, op_spill_dst, op_spill_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 6: { /* src2 and dst need spill */
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;

        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // spill_src2 -> tls(spill_src2)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vsqrtsd src1 spill_src2 -> spill_dst
        instr_t *i4 = instr_create_1dst_2src(dcontext, OP_vsqrtsd, op_spill_dst, op_src1, op_spill_src2);;
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 7: { /* all need spill */
        if (src1_reg == dst_reg && src2_reg == dst_reg) {
            reg_id_t spill_reg = XMM_SPILL_SLOT0;
            opnd_t op_spill = opnd_create_reg(spill_reg);
            // spill -> tls_slot(spill)
            instr_t *i1 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
            // tls(src1) -> spill
            instr_t *i2 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // vsqrtsd spill spill -> spill
            instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vsqrtsd, op_spill, op_spill, op_spill);;
            // spill -> tls(dst)
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill) -> spill
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } else if (src1_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vsqrtsd spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vsqrtsd, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else if (src2_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src2_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vsqrtsd spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vsqrtsd, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vsqrtsd spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vsqrtsd, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        }
    } break;
    default:
        return NULL;
    }
    return NULL;
}


/**
 * @brief rewrite vcvttsd2si
 */
instr_t *
rw_func_vcvttsd2si(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vcvtsd2si", true, true, false, true);
#endif
    // VEX.LIG.F2.0F.W1 2C /r 1 VCVTTSD2SI r64, xmm1/m64
    return instr;
}

/* ==============================================
 *                vpakcuswb
 * ============================================== */

instr_t *
vpackuswb_xmm_reg_reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg,
                          reg_id_t src2_reg, reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_XMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 4 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { // no spill
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = INSTR_CREATE_vpackuswb(dcontext, op_dst, op_src1, op_src2);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { // src1 need spill
        reg_id_t spill_src1_reg = find_available_spill_xmm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vpackuswb spill_src1, src2 -> dst
        instr_t *i3 = INSTR_CREATE_vpackuswb(dcontext, op_dst, op_spill_src1, op_src2);
        // tls(spill_src1) -> spill_src1
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { // src2 need spill
        reg_id_t spill_src2_reg = find_available_spill_xmm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);

        // spill_src2 -> tls(spill_src2)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vpackuswb src1, spill_src2 -> dst
        instr_t *i3 = INSTR_CREATE_vpackuswb(dcontext, op_dst, op_src1, op_spill_src2);
        // tls(spill_src2) -> spill_src2
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { // src1 and src2 need spill
        reg_id_t spill_src1_reg = find_one_available_spill_xmm(dst_reg);
        reg_id_t spill_src2_reg = find_available_spill_xmm_avoiding(spill_src1_reg, dst_reg, DR_REG_NULL);

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_src2 -> tls(spill_src2)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vpackuswb spill_src1, spill_src2 -> dst
        instr_t *i5 = INSTR_CREATE_vpackuswb(dcontext, op_dst, op_spill_src1, op_spill_src2);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 4: { // dst need spill
        reg_id_t spill_dst_reg = find_available_spill_xmm_avoiding(src1_reg, src2_reg, DR_REG_NULL);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);

        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vpackuswb src1, src2 -> spill_dst
        instr_t *i2 = INSTR_CREATE_vpackuswb(dcontext, op_spill_dst, op_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 5: { // src1 and dst need spill
        reg_id_t tmp_reg = find_one_available_spill_xmm(src2_reg);
        opnd_t op_src1 = opnd_create_reg(tmp_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(tmp_reg);

        // tmp -> spill(tmp)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, tmp_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(tmp_reg)), OPSZ_16);
        // spill(src1) -> tmp
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, tmp_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vpackuswb tmp, src2 -> tmp
        instr_t *i3 = INSTR_CREATE_vpackuswb(dcontext, op_dst, op_src1, op_src2);
        // tmp -> tls(dst)
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, tmp_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // spill(tmp) -> tmp
        instr_t *i5 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, tmp_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(tmp_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    case 6: { // src2 and dst need spill
        reg_id_t tmp_reg = find_one_available_spill_xmm(src1_reg);
        opnd_t op_src2 = opnd_create_reg(tmp_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(tmp_reg);

        // tmp -> spill(tmp)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, tmp_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(tmp_reg)), OPSZ_16);
        // spill(src2) -> tmp
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, tmp_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vpackuswb src1, tmp -> tmp
        instr_t *i3 = INSTR_CREATE_vpackuswb(dcontext, op_dst, op_src1, op_src2);
        // tmp -> tls(dst)
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, tmp_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // spill(tmp) -> tmp
        instr_t *i5 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, tmp_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(tmp_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    case 7: { // src1, src2 and dst need spill
        reg_id_t spill_src1 = XMM_SPILL_SLOT0;
        reg_id_t spill_src2 = XMM_SPILL_SLOT1;
        reg_id_t spill_dst = spill_src1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2);
        opnd_t op_spill_dst = op_spill_src1;

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1)), OPSZ_16);
        // spill_src2 -> tls(spill_src2)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i4 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vpackuswb spill_src1, spill_src2 -> spill_dst
        instr_t *i5 = INSTR_CREATE_vpackuswb(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
        // spill_dst -> tls(dst)
        instr_t *i6 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i7 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i8 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
        instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
        return i1;
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpackuswb_xmm_reg_reg_gen except 0, 1, 2, 3, 4, 5, 6, 7"); return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t *
vpackuswb_ymm_reg_reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg,
                          reg_id_t src2_reg, reg_id_t dst_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpackuswb_zmm_reg_reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg,
                          reg_id_t src2_reg, reg_id_t dst_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 81 */
rw_func_vpackuswb(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vpackuswb {%k0} %xmm24 %xmm22 -> %xmm22
    // vpackuswb {%k0} %xmm8 %xmm4 -> %xmm29
    // mask: %k0
    // src1: %xmm8
    // src2: %xmm4
    // dst: %xmm29
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src1_opnd = instr_get_src(instr, 1);
    opnd_t src2_opnd = instr_get_src(instr, 2);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpackuswb", true, true, true, true);
#endif
    reg_id_t src1_reg = opnd_get_reg(src1_opnd);
    reg_id_t src2_reg = opnd_get_reg(src2_opnd);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    if (IS_XMM_REG(dst_reg)) {
        return vpackuswb_xmm_reg_reg_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
    }
    if (IS_YMM_REG(dst_reg)) {
        return vpackuswb_ymm_reg_reg_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
    }
    if (IS_ZMM_REG(dst_reg)) {
        return vpackuswb_zmm_reg_reg_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
    }
    return NULL_INSTR;
}

instr_t * /* 100 */
rw_func_vmovq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vmovq  %xmm28[8byte] -> 0x00000100(%r8)[8byte]
    opnd_t src_opnd = instr_get_src(instr, 0);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vmovq", true, false, false, true);
#endif
    reg_id_t src_reg = opnd_get_reg(src_opnd);
    opnd_t src_mapping_opnd = opnd_create_reg(src_reg);
    // VEX.128.66.0F.WIG D6 /r VMOVQ xmm1/m64, xmm2
    instr_t *i1 = INSTR_CREATE_vmovq(dcontext, dst_opnd, src_mapping_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return i1;
}

instr_t *
vpsrlq_ymm_reg_reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg)
{
    return NULL_INSTR;
}

instr_t *
vpsrlq_xmm_reg_reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg)
{
    return NULL_INSTR;
}

instr_t *
vpsrlq_zmm_reg_reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg)
{
    return NULL_INSTR;
}

instr_t *
vpsrlq_ymm_disp_reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src1_opnd, reg_id_t src2_reg,
                        reg_id_t dst_reg)
{
    return NULL_INSTR;
}

instr_t *
vpsrlq_xmm_disp_reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src1_opnd, reg_id_t src2_reg,
                        reg_id_t dst_reg)
{
    return NULL_INSTR;
}

instr_t *
vpsrlq_zmm_disp_reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src1_opnd, reg_id_t src2_reg,
                        reg_id_t dst_reg)
{
    return NULL_INSTR;
}

instr_t *
vpsrlq_ymm_imm_reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t imm8_opnd, opnd_t src2_opnd,
                       opnd_t dst_opnd, reg_id_t src2_reg, reg_id_t dst_reg)
{

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    // vpsrlq {%k0} $0x07 %ymm22 -> %ymm22
    const uint src2_need_spill_flag = NEED_SPILL_YMM(src2_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_YMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src2_need_spill_flag | dst_need_spill_flag; // res is 0, 1, 2, 3

    switch (need_spill_flag) {
    case 0: { // no spill
        instr_t *i1 = INSTR_CREATE_vpsrlq(dcontext, dst_opnd, imm8_opnd, src2_opnd);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { // src2 need spill
        reg_id_t spill_src2_reg = find_one_available_spill_ymm(dst_reg);
        opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);

        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
        // VEX.256.66.0F.WIG 71 /3 ib VPSRLQ dst_reg, spill_src2_reg, imm8
        instr_t *i3 = INSTR_CREATE_vpsrlq(dcontext, dst_opnd, imm8_opnd, spill_src2_opnd);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { // dst need spill
        reg_id_t spill_dst_reg = find_one_available_spill_ymm(src2_reg);
        opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);

        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        // VEX.256.66.0F.WIG 71 /3 ib VPSRLQ dst_reg, spill_dst_reg, imm8
        instr_t *i2 = INSTR_CREATE_vpsrlq(dcontext, spill_dst_opnd, imm8_opnd, src2_opnd);
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { // src2 and dst need spill
        // src2 and dst can use the same register
        reg_id_t spill_src2_reg = YMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = spill_src2_reg;
        opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);
        opnd_t spill_dst_opnd = spill_src2_opnd;

        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
        // VEX.256.66.0F.WIG 71 /3 ib VPSRLQ spill_dst_reg, spill_src2_reg, imm8
        instr_t *i3 = INSTR_CREATE_vpsrlq(dcontext, spill_dst_opnd, imm8_opnd, spill_src2_opnd);
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpsrlq_ymm_imm_reg_gen except 0, 1, 2, 3"); return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t *
vpsrlq_xmm_imm_reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t imm8_opnd, opnd_t src2_opnd,
                       opnd_t dst_opnd, reg_id_t src2_reg, reg_id_t dst_reg)
{
    return NULL_INSTR;
}

instr_t *
vpsrlq_zmm_imm_reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t imm8_opnd, opnd_t src2_opnd,
                       opnd_t dst_opnd, reg_id_t src2_reg, reg_id_t dst_reg)
{
    return NULL_INSTR;
}

instr_t * /* 111 */
rw_func_vpsrlq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vpsrlq {%k0} $0x07 %ymm22 -> %ymm22
    // opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src1_opnd = instr_get_src(instr, 1);
    opnd_t src2_opnd = instr_get_src(instr, 2);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpsrlq", true, true, true, true);
#endif
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    switch (src1_opnd.kind) {
    case REG_kind: {
        reg_id_t src1_reg = opnd_get_reg(src1_opnd);
        reg_id_t src2_reg = opnd_get_reg(src2_opnd);
        if (IS_YMM_REG(dst_reg)) {
            return vpsrlq_ymm_reg_reg_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg);
        }
        if (IS_XMM_REG(dst_reg)) {
            return vpsrlq_xmm_reg_reg_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg);
        }
        if (IS_ZMM_REG(dst_reg)) {
            return vpsrlq_zmm_reg_reg_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg);
        }
    } break;
    case BASE_DISP_kind: {
        reg_id_t src2_reg = opnd_get_reg(src2_opnd);
        if (IS_YMM_REG(dst_reg)) {
            return vpsrlq_ymm_disp_reg_gen(dcontext, ilist, instr, src1_opnd, src2_reg, dst_reg);
        }
        if (IS_XMM_REG(dst_reg)) {
            return vpsrlq_xmm_disp_reg_gen(dcontext, ilist, instr, src1_opnd, src2_reg, dst_reg);
        }
        if (IS_ZMM_REG(dst_reg)) {
            return vpsrlq_zmm_disp_reg_gen(dcontext, ilist, instr, src1_opnd, src2_reg, dst_reg);
        }
    } break;
    case IMMED_INTEGER_kind: {
        reg_id_t src2_reg = opnd_get_reg(src2_opnd);
        if (IS_YMM_REG(dst_reg)) {
            return vpsrlq_ymm_imm_reg_gen(dcontext, ilist, instr, src1_opnd, src2_opnd, dst_opnd, src2_reg, dst_reg);
        }
        if (IS_XMM_REG(dst_reg)) {
            return vpsrlq_xmm_imm_reg_gen(dcontext, ilist, instr, src1_opnd, src2_opnd, dst_opnd, src2_reg, dst_reg);
        }
        if (IS_ZMM_REG(dst_reg)) {
            return vpsrlq_zmm_imm_reg_gen(dcontext, ilist, instr, src1_opnd, src2_opnd, dst_opnd, src2_reg, dst_reg);
        }
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpsrlq pattern not supported"); return NULL_INSTR;
    }
    return NULL_INSTR;
}

/* ==============================================
 * vpaddq
 * ============================================== */

instr_t *
vpaddq_ymm_reg_reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpaddq_xmm_reg_reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpaddq_zmm_reg_reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpaddq_ymm_mem_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, opnd_t src2_opnd,
                   reg_id_t dst_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpaddq_xmm_mem_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, opnd_t src2_opnd,
                   reg_id_t dst_reg, reg_id_t mask_reg)
{
    // vpaddq {%k0} %xmm25 0x00007520(%r12)[16byte] -> %xmm25
    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | dst_need_spill_flag; // res is 0, 1, 2, 3

    switch (need_spill_flag) {
    case 0: { // no spill
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);

        // VEX.128.66.0F.WIG 7C /r VPADDQ xmm1, xmm2, xmm3/m128/m64bcst
        instr_t *i1 = INSTR_CREATE_vpaddq(dcontext, op_dst, op_src1, src2_opnd);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { // src1 need spill
        reg_id_t spill_src1_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vpaddq dst, spill_src1, src2
        instr_t *i3 = INSTR_CREATE_vpaddq(dcontext, op_dst, op_spill_src1, src2_opnd);
        // tls(spill_src1) -> spill_src1
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { // dst need spill
        reg_id_t spill_dst_reg = find_one_available_spill_xmm(src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);

        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vpaddq spill_dst, src1, src2
        instr_t *i2 = INSTR_CREATE_vpaddq(dcontext, op_spill_dst, op_src1, src2_opnd);
        // spilL_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { // src1 and dst need spill
        reg_id_t tmp_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_src1_reg = tmp_reg;
        reg_id_t spill_dst_reg = tmp_reg;

        opnd_t op_tmp = opnd_create_reg(tmp_reg);
        opnd_t op_spill_src1 = op_tmp;
        opnd_t op_spill_dst = op_tmp;

        // spill_tmp -> tls(spill_tmp)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, tmp_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(tmp_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vpaddq
        instr_t *i3 = INSTR_CREATE_vpaddq(dcontext, op_spill_dst, op_spill_src1, src2_opnd);
        // spill_dst -> tls(dst)
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_tmp) -> spill_tmp
        instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpaddq pattern not supported"); return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t *
vpaddq_zmm_mem_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, opnd_t src2_opnd,
                   reg_id_t dst_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 112 */
rw_func_vpaddq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t op_mask = instr_get_src(instr, 0);
    opnd_t op_src1 = instr_get_src(instr, 1); // %xyzmm{i}
    opnd_t op_src2 = instr_get_src(instr, 2); // %xyzmm{j}
    opnd_t op_dst = instr_get_dst(instr, 0);  // %xyzmm{k}
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpaddq", true, true, true, true);
#endif
    reg_id_t mask_reg = opnd_get_reg(op_mask);
    reg_id_t src1_reg = opnd_get_reg(op_src1);
    reg_id_t dst_reg = opnd_get_reg(op_dst);
    if (op_src2.kind == REG_kind) {
        reg_id_t src2_reg = opnd_get_reg(op_src2);
        if (IS_YMM_REG(dst_reg)) {
            return vpaddq_ymm_reg_reg_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
        }
        if (IS_XMM_REG(dst_reg)) {
            return vpaddq_xmm_reg_reg_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
        }
        if (IS_ZMM_REG(dst_reg)) {
            return vpaddq_zmm_reg_reg_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
        }
    } else if (op_src2.kind == BASE_DISP_kind) {
        if (IS_YMM_REG(dst_reg)) {
            return vpaddq_ymm_mem_gen(dcontext, ilist, instr, src1_reg, op_src2, dst_reg, mask_reg);
        }
        if (IS_XMM_REG(dst_reg)) {
            return vpaddq_xmm_mem_gen(dcontext, ilist, instr, src1_reg, op_src2, dst_reg, mask_reg);
        }
        if (IS_ZMM_REG(dst_reg)) {
            return vpaddq_zmm_mem_gen(dcontext, ilist, instr, src1_reg, op_src2, dst_reg, mask_reg);
        }
    }
    return NULL_INSTR;
}

/* ==============================================
 * vpsrad
 * ============================================== */

instr_t *
vpsrad_ymm2ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg, opnd_t imm8_opnd,
                   reg_id_t src1_reg, reg_id_t dst_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_YMM(src1_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_YMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | dst_need_spill_flag; // res is 0, 1, 2, 3

    switch (need_spill_flag) {
    case 0: { // no spill
        opnd_t dst_opnd = opnd_create_reg(dst_reg);
        opnd_t src1_opnd = opnd_create_reg(src1_reg);

        // VEX.256.66.0F.WIG 71 /3 ib VPSRAD ymm1, ymm2, imm8
        instr_t *i1 = INSTR_CREATE_vpsrad(dcontext, dst_opnd, imm8_opnd, src1_opnd);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { // src1 need spill
        reg_id_t src1_spill_reg = find_one_available_spill_ymm(dst_reg);
        opnd_t src1_spill_opnd = opnd_create_reg(src1_spill_reg);
        opnd_t dst_opnd = opnd_create_reg(dst_reg);

        // src_spill_reg -> tls(src_spill_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src1_spill_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_spill_reg)), OPSZ_32);
        // tls(src_reg) -> src_spill_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_spill_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
        // VEX.256.66.0F.WIG 71 /3 ib VPSRAD dst_reg, src_spill_reg, imm8
        instr_t *i3 = INSTR_CREATE_vpsrad(dcontext, dst_opnd, imm8_opnd, src1_spill_opnd);
        // tls(src_spill_reg) -> src_spill_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_spill_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_spill_reg)), OPSZ_32);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { // dst need spill
        reg_id_t spill_dst_reg = find_one_available_spill_ymm(dst_reg);
        opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
        opnd_t src1_opnd = opnd_create_reg(src1_reg);

        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        // VEX.256.66.0F.WIG 71 /3 ib VPSRAD spill_dst_reg, src_reg, imm8
        instr_t *i2 = INSTR_CREATE_vpsrad(dcontext, spill_dst_opnd, imm8_opnd, src1_opnd);
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { // src1 and dst need spill
        reg_id_t spill_src1_reg = YMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = YMM_SPILL_SLOT1;
        opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);
        opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);

        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
        // VEX.256.66.0F.WIG 71 /3 ib VPSRAD spill_dst_reg, spill_src1_reg, imm8
        instr_t *i4 = INSTR_CREATE_vpsrad(dcontext, spill_dst_opnd, imm8_opnd, spill_src1_opnd);
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpsrad_ymm2ymm_gen except 0, 1, 2, 3"); return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t *
vpsrad_xmm2xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg, opnd_t imm8_opnd,
                   reg_id_t src1_reg, reg_id_t dst_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src1_need_spill_flag | dst_need_spill_flag; // res is 0, 1, 2, 3

    switch (need_spill_flag) {
    case 0: { // no spill
        opnd_t dst_opnd = opnd_create_reg(dst_reg);
        opnd_t src1_opnd = opnd_create_reg(src1_reg);

        // VEX.256.66.0F.WIG 71 /3 ib VPSRAD xmm1, xmm2, imm8
        instr_t *i1 = INSTR_CREATE_vpsrad(dcontext, dst_opnd, imm8_opnd, src1_opnd);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { // src1 need spill
        reg_id_t src1_spill_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t src1_spill_opnd = opnd_create_reg(src1_spill_reg);
        opnd_t dst_opnd = opnd_create_reg(dst_reg);

        // src_spill_reg -> tls(src_spill_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src1_spill_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_spill_reg)), OPSZ_16);
        // tls(src_reg) -> src_spill_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_spill_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // VEX.256.66.0F.WIG 71 /3 ib VPSRAD dst_reg, src_spill_reg, imm8
        instr_t *i3 = INSTR_CREATE_vpsrad(dcontext, dst_opnd, imm8_opnd, src1_spill_opnd);
        // tls(src_spill_reg) -> src_spill_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_spill_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_spill_reg)), OPSZ_16);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { // dst need spill
        reg_id_t spill_dst_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
        opnd_t src1_opnd = opnd_create_reg(src1_reg);

        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // VEX.256.66.0F.WIG 71 /3 ib VPSRAD spill_dst_reg, src_reg, imm8
        instr_t *i2 = INSTR_CREATE_vpsrad(dcontext, spill_dst_opnd, imm8_opnd, src1_opnd);
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { // src1 and dst need spill
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;
        opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);
        opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);

        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // VEX.256.66.0F.WIG 71 /3 ib VPSRAD spill_dst_reg, spill_src1_reg, imm8
        instr_t *i4 = INSTR_CREATE_vpsrad(dcontext, spill_dst_opnd, imm8_opnd, spill_src1_opnd);
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpsrad_xmm2xmm_gen except 0, 1, 2, 3"); return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t *
vpsrad_zmm2zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg, opnd_t imm8_opnd,
                   reg_id_t src1_reg, reg_id_t dst_reg)
{
    return NULL_INSTR;
}

instr_t *
rw_func_vpsrad(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{

    // vpsrad {%k0} $0x03 %ymm30 -> %ymm0
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t imm8_opnd = instr_get_src(instr, 1);
    opnd_t src1_opnd = instr_get_src(instr, 2);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpsrad", true, true, true, true);
#endif
    if (src1_opnd.kind == REG_kind) {
        reg_id_t mask_reg = opnd_get_reg(mask_opnd);
        reg_id_t src1_reg = opnd_get_reg(src1_opnd);
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_YMM_REG(dst_reg)) {
            return vpsrad_ymm2ymm_gen(dcontext, ilist, instr, mask_reg, imm8_opnd, src1_reg, dst_reg);
        }
        if (IS_XMM_REG(dst_reg)) {
            return vpsrad_xmm2xmm_gen(dcontext, ilist, instr, mask_reg, imm8_opnd, src1_reg, dst_reg);
        }
        if (IS_ZMM_REG(dst_reg)) {
            return vpsrad_zmm2zmm_gen(dcontext, ilist, instr, mask_reg, imm8_opnd, src1_reg, dst_reg);
        }
    } else {
        REWRITE_ERROR(STD_ERRF, "vpsrad pattern not supported");
        return NULL_INSTR;
    }
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vpsrldq
 * ============================================= */

instr_t *
vpsrldq_zmm2zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t imm8_opnd, reg_id_t src2_reg,
                    reg_id_t dst_reg)
{
    return NULL_INSTR;
}

instr_t *
vpsrldq_disp2zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t imm8_opnd, opnd_t src2_opnd,
                     reg_id_t dst_reg)
{
    return NULL_INSTR;
}

instr_t *
vpsrldq_ymm2ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t imm8_opnd, reg_id_t src2_reg,
                    reg_id_t dst_reg)
{
    opnd_t dst_opnd = opnd_create_reg(dst_reg);
    opnd_t src2_opnd = opnd_create_reg(src2_reg);

    // VEX.256.66.0F.WIG 73 /3 ib VPSRLDQ ymm1, ymm2, imm8
    instr_t *new_instr1 = INSTR_CREATE_vpsrldq(dcontext, dst_opnd, imm8_opnd, src2_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vpsrldq_disp2ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t imm8_opnd, opnd_t src2_opnd,
                     reg_id_t dst_reg)
{
    opnd_t dst_opnd = opnd_create_reg(dst_reg);

    // VEX.256.66.0F.WIG 73 /3 ib VPSRLDQ ymm1, m256, imm8
    instr_t *new_instr1 = INSTR_CREATE_vpsrldq(dcontext, dst_opnd, imm8_opnd, src2_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vpsrldq_xmm2xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t imm8_opnd, reg_id_t src2_reg,
                    reg_id_t dst_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src2_need_spill_flag = NEED_SPILL_XMM(src2_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src2_need_spill_flag | dst_need_spill_flag; // res is 0, 1, 2, 3

    switch (need_spill_flag) {
    case 0: { // no spill
        opnd_t dst_opnd = opnd_create_reg(dst_reg);
        opnd_t src2_opnd = opnd_create_reg(src2_reg);

        // VEX.128.66.0F.WIG 73 /3 ib VPSRLDQ xmm1, xmm2, imm8
        instr_t *i1 = INSTR_CREATE_vpsrldq(dcontext, dst_opnd, imm8_opnd, src2_opnd);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { // src2 need spill
        reg_id_t spill_src2_reg = find_available_spill_xmm_avoiding(dst_reg, DR_REG_NULL, DR_REG_NULL);
        opnd_t dst_opnd = opnd_create_reg(dst_reg);
        opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);

        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // VEX.128.66.0F.WIG 73 /3 ib VPSRLDQ xmm1, xmm2, imm8
        instr_t *i3 = INSTR_CREATE_vpsrldq(dcontext, dst_opnd, imm8_opnd, spill_src2_opnd);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { // dst need spill
        reg_id_t spill_dst_reg = find_one_available_spill_xmm(src2_reg);
        opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
        opnd_t src2_opnd = opnd_create_reg(src2_reg);

        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // VEX.128.66.0F.WIG 73 /3 ib VPSRLDQ xmm1, xmm2, imm8
        instr_t *i2 = INSTR_CREATE_vpsrldq(dcontext, spill_dst_opnd, imm8_opnd, src2_opnd);
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { // src2 and dst need spill, both spill
        spill_reg_pair_t spill_pair = find_two_available_spill_xmms(src2_reg, dst_reg);
        reg_id_t spill_src2_reg = spill_pair.reg1;
        reg_id_t spill_dst_reg = spill_pair.reg2;
        opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);
        opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);

        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // VEX.128.66.0F.WIG 73 /3 ib VPSRLDQ xmm1, xmm2, imm8
        instr_t *i4 = INSTR_CREATE_vpsrldq(dcontext, spill_dst_opnd, imm8_opnd, spill_src2_opnd);
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpsrldq_xmm2xmm_gen pattern not supported"); return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t *
vpsrldq_disp2xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t imm8_opnd, opnd_t src2_opnd,
                     reg_id_t dst_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 1 : 0;

    switch (dst_need_spill_flag) {
    case 0: { // no spill
        // find one available spill xmm reg, avoiding dst_reg, used as spill reg for src2_opnd original value in mem
        reg_id_t spill_src2_reg = find_available_spill_xmm_avoiding(dst_reg, DR_REG_NULL, DR_REG_NULL);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);

        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // vmovdqu m128 -> spill_src2_reg
        instr_t *i2 = INSTR_CREATE_vmovdqu(dcontext, op_spill_src2, src2_opnd);
        // VEX.128.66.0F.WIG 73 /3 ib VPSRLDQ xmm1, xmm2, imm8
        instr_t *i3 = INSTR_CREATE_vpsrldq(dcontext, op_dst, imm8_opnd, op_spill_src2);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 1: { // dst need spill
        // vpsrldq $0x08 (%rsp)[16byte] -> %xmm28
        // src2_opnd = (%rsp)[16byte] => spill_src2_reg,  %xmm28 => spill_dst_reg
        // find one available has already taken xmm != dst_reg into account
        spill_reg_pair_t spill_pair = find_two_available_spill_xmms(dst_reg, DR_REG_NULL);
        reg_id_t spill_dst_reg = spill_pair.reg1;
        reg_id_t spill_src2_reg = spill_pair.reg2;

        opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
        opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);

        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // vmovdqu m128 -> spill_src2_reg
        instr_t *i3 = INSTR_CREATE_vmovdqu(dcontext, spill_src2_opnd, src2_opnd);
        // VEX.128.66.0F.WIG 73 /3 ib VPSRLDQ xmm1, xmm2, imm8
        instr_t *i4 = INSTR_CREATE_vpsrldq(dcontext, spill_dst_opnd, imm8_opnd, spill_src2_opnd);
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpsrldq_disp2xmm_gen except 0 or 1"); return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t * /* 155 */
rw_func_vpsrldq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vpsrldq $0x08 %xmm16 -> %xmm7
    opnd_t imm8_opnd = instr_get_src(instr, 0);
    opnd_t src2_opnd = instr_get_src(instr, 1); // src2 can be m128/256/512
    opnd_t dst_opnd = instr_get_dst(instr, 0);  // dst can only be xyzmm
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpsrldq", true, true, false, true);
#endif
    switch (src2_opnd.kind) {
    case BASE_DISP_kind: {
        if (IS_XMM_REG(dst_reg)) {
            return vpsrldq_disp2xmm_gen(dcontext, ilist, instr, imm8_opnd, src2_opnd, dst_reg);
        }
        if (IS_YMM_REG(dst_reg)) {
            return vpsrldq_disp2ymm_gen(dcontext, ilist, instr, imm8_opnd, src2_opnd, dst_reg);
        }
        if (IS_ZMM_REG(dst_reg)) {
            return vpsrldq_disp2zmm_gen(dcontext, ilist, instr, imm8_opnd, src2_opnd, dst_reg);
        }
    } break;
    case REG_kind: {
        reg_id_t src2_reg = opnd_get_reg(src2_opnd);
        if (IS_XMM_REG(dst_reg)) {
            return vpsrldq_xmm2xmm_gen(dcontext, ilist, instr, imm8_opnd, src2_reg, dst_reg);
        }
        if (IS_YMM_REG(dst_reg)) {
            return vpsrldq_ymm2ymm_gen(dcontext, ilist, instr, imm8_opnd, src2_reg, dst_reg);
        }
        if (IS_ZMM_REG(dst_reg)) {
            return vpsrldq_zmm2zmm_gen(dcontext, ilist, instr, imm8_opnd, src2_reg, dst_reg);
        }
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpsrldq except imm or src opnd kind not support"); return NULL_INSTR;
    }
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vpsllw
 * ============================================= */

instr_t *
vpsllw_zmm2zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                   reg_id_t dst_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpsllw_immed2zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t imm8_opnd, reg_id_t src2_reg,
                     reg_id_t dst_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpsllw_ymm2ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                   reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    opnd_t op_dst = opnd_create_reg(dst_reg);
    opnd_t op_src1 = opnd_create_reg(src1_reg);
    opnd_t op_src2 = opnd_create_reg(src2_reg);

    // VEX.256.66.0F.WIG 72 /6 ib VPSLLW ymm1, ymm2, imm8
    instr_t *i1 = INSTR_CREATE_vpsllw(dcontext, op_dst, op_src1, op_src2);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
    return i1;
}

instr_t *
vpsllw_immed2ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t imm8_opnd, reg_id_t src2_reg,
                     reg_id_t dst_reg, reg_id_t mask_reg)
{
    // vpsllw {%k0} $0x02 %ymm16 -> %ymm16
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src2_need_spill_flag = NEED_SPILL_YMM(src2_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_YMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src2_need_spill_flag | dst_need_spill_flag; // res is 0, 1, 2, 3

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_dst = opnd_create_reg(dst_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        // VEX.256.66.0F.WIG F1 /r VPSLLW ymm1, ymm2, xmm3/m128
        instr_t *new_instr1 = INSTR_CREATE_vpsllw(dcontext, op_dst, imm8_opnd, op_src2);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
        return new_instr1;
    } break;
    case 1: { /* src2 need spill */
        reg_id_t spill_src2_reg = find_one_available_spill_ymm(dst_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);

        // spill_src2 -> tls(spill_src2)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
        // tls(src2) -> spill_src2
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
        // vpsllw op_dst, imm8_opnd, spill_src2_reg
        instr_t *i3 = INSTR_CREATE_vpsllw(dcontext, op_dst, imm8_opnd, op_spill_src2);
        // tls(spill_src2) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        reg_id_t spill_dst_reg = find_one_available_spill_ymm(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);

        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        // vpsllw spill_dst_reg, imm8_opnd, src2_reg
        instr_t *i2 = INSTR_CREATE_vpsllw(dcontext, op_spill_dst, imm8_opnd, op_src2);
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls(spill_dst) -> spill_dst_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* src2 and dst need spill */
        reg_id_t spill_src2_reg = DR_REG_NULL;
        reg_id_t spill_dst_reg = DR_REG_NULL;
        if (src2_reg == dst_reg) {
            spill_src2_reg = spill_dst_reg = find_one_available_spill_ymm(src2_reg);
            spill_dst_reg = spill_src2_reg;

            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);

            // spill_src2_reg -> tls(spill_src2_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
            // tls(src2) -> spill_src2
            instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
            // vpsllw spill_dst_reg, imm8_opnd, spill_src2_reg
            instr_t *i3 = INSTR_CREATE_vpsllw(dcontext, op_spill_dst, imm8_opnd, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill_src2_reg) -> spill_src2_reg
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } else { // vpsllw {%k0} $0x02 %ymm16 -> %ymm17
            spill_src2_reg = YMM_SPILL_SLOT0;

            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);

            // spill_src2_reg -> tls(spill_src2_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
            // tls(src2) -> spill_src2
            instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
            // vpsllw spill_dst_reg, imm8_opnd, spill_src2_reg
            instr_t *i3 = INSTR_CREATE_vpsllw(dcontext, op_spill_src2, imm8_opnd, op_spill_src2);
            // spill_src2 -> tls(dst)
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill_src2_reg) -> spill_src2_reg
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        }

    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpsllw_immed2ymm_gen except 0, 1, 2, 3"); return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t *
vpsllw_xmm2xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                   reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    opnd_t dst_opnd = opnd_create_reg(dst_reg);
    opnd_t src2_opnd = opnd_create_reg(src2_reg);
    opnd_t src1_opnd = opnd_create_reg(src1_reg);

    // VEX.128.66.0F.WIG F2 /r VPSLLW xmm1, xmm2, xmm3/m128
    instr_t *new_instr1 = INSTR_CREATE_vpsllw(dcontext, dst_opnd, src1_opnd, src2_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    return new_instr1;
}

instr_t *
vpsllw_immed2xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t imm8_opnd, reg_id_t src2_reg,
                     reg_id_t dst_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
rw_func_vpsllw(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vpsllw {%k0} $0x18 %xmm9 -> %xmm31
    //         mask  src1  src2     dst
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t imm8_or_src1_opnd = instr_get_src(instr, 1);
    opnd_t src2_opnd = instr_get_src(instr, 2);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpsllw", true, true, true, true);
#endif
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t src2_reg = opnd_get_reg(src2_opnd);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);

    switch (imm8_or_src1_opnd.kind) {
    case IMMED_INTEGER_kind: { // VPSLLW xyzmm1, xyzmm2, imm8
        if (IS_XMM_REG(dst_reg)) {
            return vpsllw_immed2xmm_gen(dcontext, ilist, instr, imm8_or_src1_opnd, src2_reg, dst_reg, mask_reg);
        }
        if (IS_YMM_REG(dst_reg)) {
            return vpsllw_immed2ymm_gen(dcontext, ilist, instr, imm8_or_src1_opnd, src2_reg, dst_reg, mask_reg);
        }
        if (IS_ZMM_REG(dst_reg)) {
            return vpsllw_immed2zmm_gen(dcontext, ilist, instr, imm8_or_src1_opnd, src2_reg, dst_reg, mask_reg);
        }
    } break;
    case REG_kind: { // VPSLLW xyzmm1, xyzmm2, xyzmm3 / m128/256/512
        reg_id_t src1_reg = opnd_get_reg(imm8_or_src1_opnd);
        if (IS_XMM_REG(dst_reg)) {
            return vpsllw_xmm2xmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
        }
        if (IS_YMM_REG(dst_reg)) {
            return vpsllw_ymm2ymm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
        }
        if (IS_ZMM_REG(dst_reg)) {
            return vpsllw_zmm2zmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
        }
    } break;
    }
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vpslld
 * ============================================= */

instr_t *
vpslld_zmm2zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                   reg_id_t dst_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpslld_immed2zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t imm8_opnd, reg_id_t src2_reg,
                     reg_id_t dst_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpslld_ymm2ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                   reg_id_t dst_reg, reg_id_t mask_reg)
{
    opnd_t dst_opnd = opnd_create_reg(dst_reg);
    opnd_t src1_opnd = opnd_create_reg(src1_reg);
    opnd_t src2_opnd = opnd_create_reg(src2_reg);

    // VEX.256.66.0F.WIG 72 /6 ib VPSLLD ymm1, ymm2, imm8
    instr_t *new_instr1 = INSTR_CREATE_vpslld(dcontext, dst_opnd, src1_opnd, src2_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vpslld_immed2ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t imm8_opnd, reg_id_t src2_reg,
                     reg_id_t dst_reg, reg_id_t mask_reg)
{
    const uint src2_need_spill_flag = NEED_SPILL_YMM(src2_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_YMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src2_need_spill_flag | dst_need_spill_flag; // res is 0, 1, 2, 3

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    switch (need_spill_flag) {
    case 0: {
        opnd_t dst_opnd = opnd_create_reg(dst_reg);
        opnd_t src2_opnd = opnd_create_reg(src2_reg);
        // VEX.256.66.0F.WIG F1 /r VPSLLW ymm1, ymm2, xmm3/m128
        instr_t *i1 = INSTR_CREATE_vpslld(dcontext, dst_opnd, imm8_opnd, src2_opnd);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { // src2 need spill
        opnd_t dst_opnd = opnd_create_reg(dst_reg);
        reg_id_t spill_src2_reg = find_one_available_spill_ymm(dst_reg);
        opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);

        // save spill reg to tls
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
        // move src2 reg value in src2 reg tls slot to spill_src_reg, since src2_reg must be written by some other instr
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
        // rewrite instr
        instr_t *i3 = INSTR_CREATE_vpslld(dcontext, dst_opnd, imm8_opnd, spill_src2_opnd);
        // restore spill reg from tls
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { // dst need spill
        opnd_t src2_opnd = opnd_create_reg(src2_reg);
        reg_id_t spill_dst_reg = find_one_available_spill_ymm(src2_reg);
        opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);

        // save spill reg to tls
        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        // since dst need spill, so dst will be written at the end of the instr, so we just restore it's value at last
        // rewrite instr
        instr_t *i2 = INSTR_CREATE_vpslld(dcontext, spill_dst_opnd, imm8_opnd, src2_opnd);
        // save spill dst reg value to dst reg tls slot
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // restore spill reg from tls
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { // dst and src2 need spill
        if (src2_reg == dst_reg) {
            reg_id_t spill_src2_reg = YMM_SPILL_SLOT0;
            reg_id_t spill_dst_reg = spill_src2_reg;
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = op_spill_src2;

            // spill_src2 -> tls(spill_src2)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
            // tls(src2) -> spill_src2
            instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
            // vpslld %imm8 spill_src2 -> spill_dst
            instr_t *i3 = INSTR_CREATE_vpslld(dcontext, op_spill_dst, imm8_opnd, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill_src2) -> spill_src2
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } else { /* src2 != dst */
            reg_id_t spill_dst_reg = YMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = YMM_SPILL_SLOT1;
            opnd_t op_dst_spill = opnd_create_reg(spill_dst_reg);
            opnd_t op_src2_spill = opnd_create_reg(spill_src2_reg);

            // save spill reg to tls
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
            // save spill reg to tls
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
            // move src2 reg value in tls_slot to spill src2 reg
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
            // rewrite instr
            instr_t *i4 = INSTR_CREATE_vpslld(dcontext, op_dst_spill, imm8_opnd, op_src2_spill);
            // save spill dst reg value to dst reg tls slot
            instr_t *i5 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // restore spill reg from tls
            instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
            instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
            return i1;
        }
    } break;
    }
    return NULL_INSTR;
}

instr_t *
vpslld_xmm2xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                   reg_id_t dst_reg, reg_id_t mask_reg)
{
    opnd_t dst_opnd = opnd_create_reg(dst_reg);
    opnd_t src2_opnd = opnd_create_reg(src2_reg);
    opnd_t src1_opnd = opnd_create_reg(src1_reg);

    // VEX.128.66.0F.WIG F2 /r VPSLLD xmm1, xmm2, xmm3/m128
    instr_t *new_instr1 = INSTR_CREATE_vpslld(dcontext, dst_opnd, src1_opnd, src2_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vpslld_immed2xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t imm8_opnd, reg_id_t src2_reg,
                     reg_id_t dst_reg, reg_id_t mask_reg)
{
    const uint src2_need_spill_flag = NEED_SPILL_XMM(src2_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src2_need_spill_flag | dst_need_spill_flag; // res is 0, 1, 2, 3

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    switch (need_spill_flag) {
    case 0: { // no spill
        opnd_t dst_opnd = opnd_create_reg(dst_reg);
        opnd_t src2_opnd = opnd_create_reg(src2_reg);
        // VEX.128.66.0F.WIG 72 /6 ib VPSLLD xmm1, xmm2, imm8
        instr_t *i1 = INSTR_CREATE_vpslld(dcontext, dst_opnd, imm8_opnd, src2_opnd);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { // src2 need spill
        opnd_t dst_opnd = opnd_create_reg(dst_reg);
        reg_id_t spill_src2_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);

        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vpslld %imm8 spill_src2_reg -> dst_reg
        instr_t *i3 = INSTR_CREATE_vpslld(dcontext, dst_opnd, imm8_opnd, spill_src2_opnd);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { // dst need spill
        opnd_t src2_opnd = opnd_create_reg(src2_reg);
        reg_id_t spill_dst_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);

        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vpslld %imm8 src2_reg -> spill_dst_reg
        instr_t *i2 = INSTR_CREATE_vpslld(dcontext, spill_dst_opnd, imm8_opnd, src2_opnd);
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { // dst and src2 need spill, both spill
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_src2_reg = spill_dst_reg;
        opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
        opnd_t spill_src2_opnd = spill_dst_opnd;

        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vpslld %imm8 spill_src2_reg -> spill_dst_reg
        instr_t *i3 = INSTR_CREATE_vpslld(dcontext, spill_dst_opnd, imm8_opnd, spill_src2_opnd);
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    }
    return NULL_INSTR;
}

/**
 * @brief
 * vpslld {%k0} $0x18 %xmm24 -> %xmm24
 */
instr_t *
rw_func_vpslld(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vpslld {%k0} $0x18 %xmm9 -> %xmm31
    //         mask  src1  src2     dst
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t imm8_or_src1_opnd = instr_get_src(instr, 1);
    opnd_t src2_opnd = instr_get_src(instr, 2);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpslld", true, true, true, true);
#endif
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t src2_reg = opnd_get_reg(src2_opnd);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);

    switch (imm8_or_src1_opnd.kind) {
    case IMMED_INTEGER_kind: { // VPSLLD xyzmm1, xyzmm2, imm8
        if (IS_XMM_REG(dst_reg)) {
            return vpslld_immed2xmm_gen(dcontext, ilist, instr, imm8_or_src1_opnd, src2_reg, dst_reg, mask_reg);
        }
        if (IS_YMM_REG(dst_reg)) {
            return vpslld_immed2ymm_gen(dcontext, ilist, instr, imm8_or_src1_opnd, src2_reg, dst_reg, mask_reg);
        }
        if (IS_ZMM_REG(dst_reg)) {
            return vpslld_immed2zmm_gen(dcontext, ilist, instr, imm8_or_src1_opnd, src2_reg, dst_reg, mask_reg);
        }
    } break;
    case REG_kind: { // VPSLLD xyzmm1, xyzmm2, xyzmm3 / m128/256/512
        reg_id_t src1_reg = opnd_get_reg(imm8_or_src1_opnd);
        if (IS_XMM_REG(dst_reg)) {
            return vpslld_xmm2xmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
        }
        if (IS_YMM_REG(dst_reg)) {
            return vpslld_ymm2ymm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
        }
        if (IS_ZMM_REG(dst_reg)) {
            return vpslld_zmm2zmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
        }
    } break;
    }
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vpslld
 * ============================================= */

instr_t *
vpsllq_zmm2zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                   reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_ZMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_ZMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_ZMM(dst_reg) ? 4 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = INSTR_CREATE_vpsllq(dcontext, op_dst, op_src1, op_src2);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    default: {
        REWRITE_INFO(STD_OUTF, "vpsllq zmm2zmm pattern not support\n");
    } break;
    }
    return NULL_INSTR;
}

instr_t *
vpsllq_immed2zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t imm8_opnd, reg_id_t src2_reg,
                     reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src2_need_spill_flag = NEED_SPILL_ZMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_ZMM(dst_reg) ? 4 : 0;
    const uint need_spill_flag = src2_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = INSTR_CREATE_vpsllq(dcontext, op_dst, op_src2, imm8_opnd);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    default: {
        REWRITE_INFO(STD_OUTF, "vpsllq immed2zmm pattern not support\n");
    } break;
    }
    return NULL_INSTR;
}

instr_t *
vpsllq_ymm2ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                   reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_YMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_YMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_YMM(dst_reg) ? 4 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = INSTR_CREATE_vpsllq(dcontext, op_dst, op_src1, op_src2);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    default: {
        REWRITE_INFO(STD_OUTF, "vpsllq ymm2ymm pattern not support\n");
    } break;
    }
    return NULL_INSTR;
}

instr_t *
vpsllq_immed2ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t imm8_opnd, reg_id_t src2_reg,
                     reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    opnd_t dst_opnd = opnd_create_reg(dst_reg);
    opnd_t src2_opnd = opnd_create_reg(src2_reg);

    // VEX.128.66.0F.WIG 73 /6 ib VPSLLQ xmm1, xmm2, imm8
    instr_t *new_instr1 = INSTR_CREATE_vpsllq(dcontext, dst_opnd, imm8_opnd, src2_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    return new_instr1;
}

instr_t *
vpsllq_xmm2xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                   reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_XMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 4 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = INSTR_CREATE_vpsllq(dcontext, op_dst, op_src1, op_src2);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = DR_REG_NULL;
        if (src2_reg == dst_reg) {
            spill_src1_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src1_reg = find_available_spill_xmm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vpsllq spill_src1_reg src2_reg -> dst_reg
        instr_t *i3 = INSTR_CREATE_vpsllq(dcontext, op_dst, op_spill_src1, op_src2);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* src2 need spill */
        reg_id_t spill_src2_reg = DR_REG_NULL;
        if (src1_reg == dst_reg) {
            spill_src2_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src2_reg = find_available_spill_xmm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vpsllq src1_reg spill_src2_reg -> dst_reg
        instr_t *i3 = INSTR_CREATE_vpsllq(dcontext, op_dst, op_src1, op_spill_src2);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;


        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);


        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_src2 -> tls(spill_src2)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vpsllq spill_src1 spill_src2 -> dst
        instr_t *i5 = INSTR_CREATE_vpsllq(dcontext, op_dst, op_spill_src1, op_spill_src2);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 4: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;


        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);


        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vpsllq src1 src2 -> spill_dst
        instr_t *i2 = INSTR_CREATE_vpsllq(dcontext, op_spill_dst, op_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 5: { /* src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;


        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);


        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vpsllq spill_src1 src2 -> spill_dst
        instr_t *i4 = INSTR_CREATE_vpsllq(dcontext, op_spill_dst, op_spill_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 6: { /* src2 and dst need spill */
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;


        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);


        // spill_src2 -> tls(spill_src2)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vpsllq src1 spill_src2 -> spill_dst
        instr_t *i4 = INSTR_CREATE_vpsllq(dcontext, op_spill_dst, op_src1, op_spill_src2);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 7: { /* all need spill */
        if (src1_reg == dst_reg && src2_reg == dst_reg) {
            reg_id_t spill_reg = XMM_SPILL_SLOT0;
            opnd_t op_spill = opnd_create_reg(spill_reg);
            // spill -> tls_slot(spill)
            instr_t *i1 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
            // tls(src1) -> spill
            instr_t *i2 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // vpsllq spill spill -> spill
            instr_t *i3 = INSTR_CREATE_vpsllq(dcontext, op_spill, op_spill, op_spill);
            // spill -> tls(dst)
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill) -> spill
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } else if (src1_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vpsllq spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpsllq(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else if (src2_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src2_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vpsllq spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpsllq(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vpsllq spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpsllq(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        }
    } break;
    default: {
        REWRITE_INFO(STD_OUTF, "vpsllq xmm2xmm pattern not support\n");
    } break;
    }
    return NULL_INSTR;
}

instr_t *
vpsllq_immed2xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t imm8_opnd, reg_id_t src2_reg,
                     reg_id_t dst_reg, reg_id_t mask_reg)
{
    const uint src_need_spill_flag = NEED_SPILL_XMM(src2_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src_need_spill_flag | dst_need_spill_flag;

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    switch (need_spill_flag) {
    case 0: { // no spill
        opnd_t dst_opnd = opnd_create_reg(dst_reg);
        opnd_t src2_opnd = opnd_create_reg(src2_reg);
        // vpsllq %imm8 src2_reg -> dst_reg
        instr_t *new_instr1 = INSTR_CREATE_vpsllq(dcontext, dst_opnd, imm8_opnd, src2_opnd);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
        return new_instr1;
    } break;
    case 1: { // src2 need spill
        opnd_t dst_opnd = opnd_create_reg(dst_reg);
        reg_id_t spill_src2_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);

        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vpsllq %imm8 spill_src2_reg -> dst_reg
        instr_t *i3 = INSTR_CREATE_vpsllq(dcontext, dst_opnd, imm8_opnd, spill_src2_opnd);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { // dst need spill
        opnd_t src2_opnd = opnd_create_reg(src2_reg);
        reg_id_t spill_dst_reg = find_one_available_spill_xmm(src2_reg);
        opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);

        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vpsllq %imm8 src2_reg -> spill_dst_reg
        instr_t *i2 = INSTR_CREATE_vpsllq(dcontext, spill_dst_opnd, imm8_opnd, src2_opnd);
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { // dst and src2 need spill, both spill
        if (src2_reg == dst_reg) {
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_dst_reg = spill_src2_reg;
            opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);
            opnd_t spill_dst_opnd = spill_src2_opnd;

            // spill_src2_reg -> tls(spill_src2_reg)
            instr_t *new_instr1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                         TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src2_reg) -> spill_src2_reg
            instr_t *new_instr2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                              TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vpsllq %imm8 spill_src2_reg -> spill_dst_reg, which they are the same register
            instr_t *new_instr3 = INSTR_CREATE_vpsllq(dcontext, spill_dst_opnd, imm8_opnd, spill_src2_opnd);
            // spill_dst_reg -> tls(spill_dst_reg), it's the same as save spill_src2_reg to tls(spill_src2_reg)
            instr_t *new_instr4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src2_reg) -> spill_src2_reg
            instr_t *new_instr5 = RESTORE_SIMD_FROM_SIZED_TLS(
                dcontext, spill_src2_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5);
#endif
            instrlist_concat_next_instr(ilist, 5, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5);
            return new_instr1;
        } else {
            reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
            opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);

            // spill_dst_reg -> tls(spill_dst_reg)
            instr_t *new_instr1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                         TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
            // spill_src2_reg -> tls(spill_src2_reg)
            instr_t *new_instr2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                         TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src2_reg) -> spill_src2_reg
            instr_t *new_instr3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                              TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vpsllq %imm8 spill_src2_reg -> spill_dst_reg
            instr_t *new_instr4 = INSTR_CREATE_vpsllq(dcontext, spill_dst_opnd, imm8_opnd, spill_src2_opnd);
            // spill_dst_reg -> tls(dst_reg)
            instr_t *new_instr5 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_dst_reg) -> spill_dst_reg
            instr_t *new_instr6 = RESTORE_SIMD_FROM_SIZED_TLS(
                dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
            // tls(spill_src2_reg) -> spill_src2_reg
            instr_t *new_instr7 = RESTORE_SIMD_FROM_SIZED_TLS(
                dcontext, spill_src2_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 7, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5,
                                         new_instr6, new_instr7);
#endif
            instrlist_concat_next_instr(ilist, 7, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5,
                                        new_instr6, new_instr7);
            return new_instr1;
        }
    } break;
    }
    return NULL_INSTR;
}

/**
 * @brief
 * vpsllq {%k0} $0x28 %xmm28 -> %xmm28
 */
instr_t *
rw_func_vpsllq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t imm8_or_src1_opnd = instr_get_src(instr, 1);
    opnd_t src2_opnd = instr_get_src(instr, 2);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpsllq", true, true, true, true);
#endif
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t src2_reg = opnd_get_reg(src2_opnd);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);

    switch (imm8_or_src1_opnd.kind) {
    case IMMED_INTEGER_kind: {
        if (IS_XMM_REG(dst_reg)) {
            return vpsllq_immed2xmm_gen(dcontext, ilist, instr, imm8_or_src1_opnd, src2_reg, dst_reg, mask_reg);
        }
        if (IS_YMM_REG(dst_reg)) {
            return vpsllq_immed2ymm_gen(dcontext, ilist, instr, imm8_or_src1_opnd, src2_reg, dst_reg, mask_reg);
        }
        if (IS_ZMM_REG(dst_reg)) {
            return vpsllq_immed2zmm_gen(dcontext, ilist, instr, imm8_or_src1_opnd, src2_reg, dst_reg, mask_reg);
        }
    } break;
    case REG_kind: {
        reg_id_t src1_reg = opnd_get_reg(imm8_or_src1_opnd);
        if (IS_XMM_REG(dst_reg)) {
            return vpsllq_xmm2xmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
        }
        if (IS_YMM_REG(dst_reg)) {
            return vpsllq_ymm2ymm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
        }
        if (IS_ZMM_REG(dst_reg)) {
            return vpsllq_zmm2zmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
        }

    } break;
    }
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vpsubb
 * ============================================= */

instr_t *
vpsubb_xmm_and_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_XMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 4 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: {
        instr_t *i1 = INSTR_CREATE_vpsubb(dcontext, opnd_create_reg(dst_reg), opnd_create_reg(src1_reg),
                                          opnd_create_reg(src2_reg));
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* spill src1 */
        reg_id_t spill = (src2_reg == dst_reg) ? find_one_available_spill_xmm(src2_reg)
                                               : find_available_spill_xmm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
        opnd_t sop = opnd_create_reg(spill), dop = opnd_create_reg(dst_reg);
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill)), OPSZ_16);
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        instr_t *i3 = INSTR_CREATE_vpsubb(dcontext, dop, sop, opnd_create_reg(src2_reg));
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* spill src2 */
        reg_id_t spill = (src1_reg == dst_reg) ? find_one_available_spill_xmm(src2_reg)
                                               : find_available_spill_xmm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
        opnd_t sop = opnd_create_reg(spill), dop = opnd_create_reg(dst_reg);
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill)), OPSZ_16);
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        instr_t *i3 = INSTR_CREATE_vpsubb(dcontext, dop, opnd_create_reg(src1_reg), sop);
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    default:
        REWRITE_INFO(STD_OUTF, "vpsubb xmm and xmm pattern not support (need_spill_flag=%u)\n", need_spill_flag);
        return NULL_INSTR;
    }
}

instr_t *
vpsubb_ymm_and_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_YMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_YMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_YMM(dst_reg) ? 4 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = INSTR_CREATE_vpsubb(dcontext, op_dst, op_src1, op_src2);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;

    case 1: { /* spill src1 */
        reg_id_t spill_src1 = (src2_reg == dst_reg) ? find_one_available_spill_ymm(src2_reg)
                                                    : find_available_spill_ymm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);

        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1)), OPSZ_32);
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
        instr_t *i3 = INSTR_CREATE_vpsubb(dcontext, op_dst, op_spill_src1, op_src2);
        instr_t *i4 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;

    case 2: { /* spill src2 */
        reg_id_t spill_src2 = (src1_reg == dst_reg) ? find_one_available_spill_ymm(src2_reg)
                                                    : find_available_spill_ymm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2);
        opnd_t op_dst = opnd_create_reg(dst_reg);

        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2)), OPSZ_32);
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
        instr_t *i3 = INSTR_CREATE_vpsubb(dcontext, op_dst, op_src1, op_spill_src2);
        instr_t *i4 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;

    case 7: { /* all need spill (src1, src2, dst) */
        /* Reuse the robust triple-spill templates you already use for vpaddw/vpsubd */
        reg_id_t spill_src1 = YMM_SPILL_SLOT0;
        reg_id_t spill_src2 = YMM_SPILL_SLOT1;
        reg_id_t spill_dst = spill_src1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst);

        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1)), OPSZ_32);
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2)), OPSZ_32);
        instr_t *i3 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
        instr_t *i4 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
        instr_t *i5 = INSTR_CREATE_vpsubb(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
        instr_t *i6 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        instr_t *i7 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1)), OPSZ_32);
        instr_t *i8 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
        instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
        return i1;
    } break;

    default:
        REWRITE_INFO(STD_OUTF, "vpsubb ymm and ymm pattern not support (need_spill_flag=%u)\n", need_spill_flag);
        return NULL_INSTR;
    }
}

instr_t * /* 148 */
rw_func_vpsubb(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src1_opnd = instr_get_src(instr, 1);
    opnd_t src2_opnd = instr_get_src(instr, 2);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpsubb", true, true, true, true);
#endif
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t src1_reg = opnd_get_reg(src1_opnd);
    reg_id_t src2_reg = opnd_get_reg(src2_opnd);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);

    if (IS_YMM_REG(dst_reg))
        return vpsubb_ymm_and_ymm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
    if (IS_XMM_REG(dst_reg))
        return vpsubb_xmm_and_xmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
    if (IS_ZMM_REG(dst_reg)) {
        REWRITE_INFO(STD_OUTF, "vpsubb zmm not implemented\n");
        return NULL_INSTR; /* or split zmmtwo ymm, like vpsubd_zmm_and_zmm_gen */
    }
    REWRITE_INFO(STD_OUTF, "vpsubb pattern not support\n");
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vpsubw
 * ============================================= */

instr_t *
vpsubw_xmm_and_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_XMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 4 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = INSTR_CREATE_vpsubw(dcontext, op_dst, op_src1, op_src2);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        reg_id_t spill_src1_reg = DR_REG_NULL;
        if (src2_reg == dst_reg) {
            spill_src1_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src1_reg = find_available_spill_xmm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vpsubw spill_src1_reg src2_reg -> dst_reg
        instr_t *i3 = INSTR_CREATE_vpsubw(dcontext, op_dst, op_spill_src1, op_src2);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* src2 need spill */
        reg_id_t spill_src2_reg = DR_REG_NULL;
        if (src1_reg == dst_reg) {
            spill_src2_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src2_reg = find_available_spill_xmm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vpsubw src1_reg spill_src2_reg -> dst_reg
        instr_t *i3 = INSTR_CREATE_vpsubw(dcontext, op_dst, op_src1, op_spill_src2);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;


        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);


        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_src2 -> tls(spill_src2)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vpsubw spill_src1 spill_src2 -> dst
        instr_t *i5 = INSTR_CREATE_vpsubw(dcontext, op_dst, op_spill_src1, op_spill_src2);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 4: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;


        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);


        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vpsubw src1 src2 -> spill_dst
        instr_t *i2 = INSTR_CREATE_vpsubw(dcontext, op_spill_dst, op_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 5: { /* src1 and dst need spill */
        reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;


        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);


        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vpsubw spill_src1 src2 -> spill_dst
        instr_t *i4 = INSTR_CREATE_vpsubw(dcontext, op_spill_dst, op_spill_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 6: { /* src2 and dst need spill */
        reg_id_t spill_src2_reg = XMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;


        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);


        // spill_src2 -> tls(spill_src2)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // tls(src2) -> spill_src2
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vpsubw src1 spill_src2 -> spill_dst
        instr_t *i4 = INSTR_CREATE_vpsubw(dcontext, op_spill_dst, op_src1, op_spill_src2);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 7: { /* all need spill */
        if (src1_reg == dst_reg && src2_reg == dst_reg) {
            reg_id_t spill_reg = XMM_SPILL_SLOT0;
            opnd_t op_spill = opnd_create_reg(spill_reg);
            // spill -> tls_slot(spill)
            instr_t *i1 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
            // tls(src1) -> spill
            instr_t *i2 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // vpsubw spill spill -> spill
            instr_t *i3 = INSTR_CREATE_vpsubw(dcontext, op_spill, op_spill, op_spill);
            // spill -> tls(dst)
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill) -> spill
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } else if (src1_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vpsubw spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpsubw(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else if (src2_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src2_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vpsubw spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpsubw(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vpsubw spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpsubw(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        }
    } break;
    default: {
        REWRITE_INFO(STD_OUTF, "vpsubw xmm and xmm pattern not support\n");
    } break;
    }
    return NULL_INSTR;
}

instr_t *
vpsubw_ymm_and_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_YMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_YMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_YMM(dst_reg) ? 4 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = INSTR_CREATE_vpsubw(dcontext, op_dst, op_src1, op_src2);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        // vpsubw {%k0} %ymm23 %ymm13 -> %ymm13
        reg_id_t spill_src1_reg = DR_REG_NULL;
        if (src2_reg == dst_reg) {
            spill_src1_reg = find_one_available_spill_ymm(src2_reg);
        } else {
            spill_src1_reg = find_available_spill_ymm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
        // vpsubw spill_src1_reg src2_reg -> dst_reg
        instr_t *i3 = INSTR_CREATE_vpsubw(dcontext, op_dst, op_spill_src1, op_src2);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* src2 need spill */
        // vpsubw {%k0} %ymm11 %ymm23 -> %ymm11
        reg_id_t spill_src2_reg = DR_REG_NULL;
        if (src1_reg == dst_reg) {
            spill_src2_reg = find_one_available_spill_ymm(src2_reg);
        } else {
            spill_src2_reg = find_available_spill_ymm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
        // vpsubw src1_reg spill_src2_reg -> dst_reg
        instr_t *i3 = INSTR_CREATE_vpsubw(dcontext, op_dst, op_src1, op_spill_src2);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src need spill */
        reg_id_t spill_src1_reg = YMM_SPILL_SLOT0;
        reg_id_t spill_src2_reg = YMM_SPILL_SLOT1;


        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);


        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
        // spill_src2 -> tls(spill_src2)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
        // tls(src2) -> spill_src2
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
        // vpsubw spill_src1 spill_src2 -> dst
        instr_t *i5 = INSTR_CREATE_vpsubw(dcontext, op_dst, op_spill_src1, op_spill_src2);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
        // tls(spill_src2) -> spill_src2
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 4: { /* dst need spill */
        reg_id_t spill_dst_reg = YMM_SPILL_SLOT0;


        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);


        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        // vpsubw src1 src2 -> spill_dst
        instr_t *i2 = INSTR_CREATE_vpsubw(dcontext, op_spill_dst, op_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 5: { /* src1 and dst need spill */
        reg_id_t spill_src1_reg = YMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = YMM_SPILL_SLOT1;


        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);


        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
        // vpsubw spill_src1 src2 -> spill_dst
        instr_t *i4 = INSTR_CREATE_vpsubw(dcontext, op_spill_dst, op_spill_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 6: { /* src2 and dst need spill */
        reg_id_t spill_src2_reg = YMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = YMM_SPILL_SLOT1;


        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);


        // spill_src2 -> tls(spill_src2)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        // tls(src2) -> spill_src2
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
        // vpsubw src1 spill_src2 -> spill_dst
        instr_t *i4 = INSTR_CREATE_vpsubw(dcontext, op_spill_dst, op_src1, op_spill_src2);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls(spill_src2) -> spill_src2
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 7: { /* all need spill */
        if (src1_reg == dst_reg && src2_reg == dst_reg) {
            reg_id_t spill_reg = YMM_SPILL_SLOT0;
            opnd_t op_spill = opnd_create_reg(spill_reg);
            // spill -> tls_slot(spill)
            instr_t *i1 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_reg)), OPSZ_32);
            // tls(src1) -> spill
            instr_t *i2 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
            // vpsubw spill spill -> spill
            instr_t *i3 = INSTR_CREATE_vpsubw(dcontext, op_spill, op_spill, op_spill);
            // spill -> tls(dst)
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill) -> spill
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } else if (src1_reg == dst_reg) {
            reg_id_t spill_src1_reg = YMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = YMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
            // vpsubw spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpsubw(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else if (src2_reg == dst_reg) {
            reg_id_t spill_src1_reg = YMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = YMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src2_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
            // vpsubw spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpsubw(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else {
            reg_id_t spill_src1_reg = YMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = YMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
            // vpsubw spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpsubw(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        }
    } break;
    default: {
        REWRITE_INFO(STD_OUTF, "vpsubw ymm and ymm pattern not support\n");
    } break;
    }
    return NULL_INSTR;
}

instr_t *
vpsubw_zmm_and_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    reg_id_t src1_reg_lower = DR_REG_NULL;
    reg_id_t src1_reg_upper = DR_REG_NULL;
    reg_id_t src2_reg_lower = DR_REG_NULL;
    reg_id_t src2_reg_upper = DR_REG_NULL;
    reg_id_t dst_reg_lower = DR_REG_NULL;
    reg_id_t dst_reg_upper = DR_REG_NULL;

    const uint src1_need_spill = NEED_SPILL_ZMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill = NEED_SPILL_ZMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill = NEED_SPILL_ZMM(dst_reg) ? 4 : 0;
    const uint need_spill = src1_need_spill | src2_need_spill | dst_need_spill;

    switch (need_spill) {
    case 0: { /* no spill */
        if (src1_reg == dst_reg) {
            src1_reg_lower = ZMM_TO_YMM(src1_reg);
            src2_reg_lower = ZMM_TO_YMM(src2_reg);
            dst_reg_lower = src1_reg_lower;
            src1_reg_upper = find_available_spill_ymm_avoiding_variadic(2, src1_reg_lower, src2_reg_lower);
            src2_reg_upper =
                find_available_spill_ymm_avoiding_variadic(3, src1_reg_lower, src2_reg_lower, src1_reg_upper);
            dst_reg_upper = src1_reg_upper;

            // save src1-up -> tls(src1-up)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src1_reg_upper,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_16);
            // save src2-up -> tls(src2-up)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src2_reg_upper,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_16);

            // tls(src1-up) -> src1-up
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(
                dcontext, src1_reg_upper, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)) + SIZE_OF_YMM, OPSZ_16);
            // tls(src2-up) -> src2-up
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(
                dcontext, src2_reg_upper, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)) + SIZE_OF_YMM, OPSZ_16);
            // vpsubw
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vpsubw, opnd_create_reg(dst_reg_lower),
                                                 opnd_create_reg(src1_reg_lower), opnd_create_reg(src2_reg_lower));
            instr_t *i6 = instr_create_1dst_2src(dcontext, OP_vpsubw, opnd_create_reg(dst_reg_upper),
                                                 opnd_create_reg(src1_reg_upper), opnd_create_reg(src2_reg_upper));
            // dst-low -> tls(dst-low)
            instr_t *i7 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_16);
            // dst-up -> tls(dst-up)
            instr_t *i8 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper,
                                                 TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_16);
            // restore src1-up from tls(src1-up)
            instr_t *i9 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_16);
            // restore src2-up from tls(src2-up)
            instr_t *i10 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 10, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);
#endif
            instrlist_concat_next_instr(ilist, 10, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);
            return i1;
        } else {
            src1_reg_lower = ZMM_TO_YMM(src1_reg);
            src2_reg_lower = ZMM_TO_YMM(src2_reg);
            dst_reg_lower = ZMM_TO_YMM(dst_reg);
            src1_reg_upper =
                find_available_spill_ymm_avoiding_variadic(3, src1_reg_lower, src2_reg_lower, dst_reg_lower);
            src2_reg_upper = find_available_spill_ymm_avoiding_variadic(4, src1_reg_lower, src2_reg_lower,
                                                                        dst_reg_lower, src1_reg_upper);
            dst_reg_upper = find_available_spill_ymm_avoiding_variadic(5, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                       src1_reg_upper, src2_reg_upper);

            // save src1-up -> tls(src1-up)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src1_reg_upper,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_16);
            // save src2-up -> tls(src2-up)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src2_reg_upper,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_16);
            // save dst-up -> tls(dst-up)
            instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_16);

            // tls(src1-up) -> src1-up
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(
                dcontext, src1_reg_upper, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)) + SIZE_OF_YMM, OPSZ_16);
            // tls(src2-up) -> src2-up
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(
                dcontext, src2_reg_upper, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)) + SIZE_OF_YMM, OPSZ_16);
            // vpsubw
            instr_t *i6 = instr_create_1dst_2src(dcontext, OP_vpsubw, opnd_create_reg(dst_reg_lower),
                                                 opnd_create_reg(src1_reg_lower), opnd_create_reg(src2_reg_lower));
            instr_t *i7 = instr_create_1dst_2src(dcontext, OP_vpsubw, opnd_create_reg(dst_reg_upper),
                                                 opnd_create_reg(src1_reg_upper), opnd_create_reg(src2_reg_upper));
            // dst-low -> tls(dst-low)
            instr_t *i8 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_16);
            // dst-up -> tls(dst-up)
            instr_t *i9 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper,
                                                 TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_16);
            // restore src1-up from tls(src1-up)
            instr_t *i10 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_16);
            // restore src2-up from tls(src2-up)
            instr_t *i11 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_16);
            // restore dst-up from tls(dst-up)
            instr_t *i12 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg_upper,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 12, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12);
#endif
            instrlist_concat_next_instr(ilist, 12, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12);
            return i1;
        }
    } break;
    case 1: { /* src1 need spill */
        src1_reg_lower = ZMM_TO_YMM(src1_reg);
        src2_reg_lower = ZMM_TO_YMM(src2_reg);
        dst_reg_lower = ZMM_TO_YMM(dst_reg);

        // Find spill registers - src1 needs special handling
        reg_id_t spill_src1_lower =
            find_available_spill_ymm_avoiding_variadic(3, src1_reg_lower, src2_reg_lower, dst_reg_lower);
        src1_reg_upper = find_available_spill_ymm_avoiding_variadic(4, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_src1_lower);
        src2_reg_upper = find_available_spill_ymm_avoiding_variadic(5, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_src1_lower, src1_reg_upper);
        dst_reg_upper = find_available_spill_ymm_avoiding_variadic(6, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                   spill_src1_lower, src1_reg_upper, src2_reg_upper);

        // Save spill registers
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_lower)), OPSZ_16);
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src1_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_16);
        instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src2_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_16);
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_16);

        // Load src1 lower and upper parts to spill registers
        instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_lower,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)), OPSZ_16);
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)) + SIZE_OF_YMM, OPSZ_16);

        // Load src2 upper part
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)) + SIZE_OF_YMM, OPSZ_16);

        // Perform operations
        instr_t *i8 = instr_create_1dst_2src(dcontext, OP_vpsubw, opnd_create_reg(dst_reg_lower),
                                             opnd_create_reg(spill_src1_lower), opnd_create_reg(src2_reg_lower));
        instr_t *i9 = instr_create_1dst_2src(dcontext, OP_vpsubw, opnd_create_reg(dst_reg_upper),
                                             opnd_create_reg(src1_reg_upper), opnd_create_reg(src2_reg_upper));

        // Store results
        instr_t *i10 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_16);
        instr_t *i11 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper,
                                              TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_16);

        // Restore spill registers
        instr_t *i12 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_lower)), OPSZ_16);
        instr_t *i13 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_16);
        instr_t *i14 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_16);
        instr_t *i15 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_16);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 15, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15);
#endif
        instrlist_concat_next_instr(ilist, 15, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15);
        return i1;
    } break;
    case 2: { /* src2 need spill */
        src1_reg_lower = ZMM_TO_YMM(src1_reg);
        src2_reg_lower = ZMM_TO_YMM(src2_reg);
        dst_reg_lower = ZMM_TO_YMM(dst_reg);

        // Find spill registers - src2 needs special handling
        reg_id_t spill_src2_lower =
            find_available_spill_ymm_avoiding_variadic(3, src1_reg_lower, src2_reg_lower, dst_reg_lower);
        src1_reg_upper = find_available_spill_ymm_avoiding_variadic(4, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_src2_lower);
        src2_reg_upper = find_available_spill_ymm_avoiding_variadic(5, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_src2_lower, src1_reg_upper);
        dst_reg_upper = find_available_spill_ymm_avoiding_variadic(6, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                   spill_src2_lower, src1_reg_upper, src2_reg_upper);

        // Save spill registers
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_lower)), OPSZ_16);
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src1_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_16);
        instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src2_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_16);
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_16);

        // Load src1 upper part
        instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)) + SIZE_OF_YMM, OPSZ_16);

        // Load src2 lower and upper parts to spill registers
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_lower,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)), OPSZ_16);
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)) + SIZE_OF_YMM, OPSZ_16);

        // Perform operations
        instr_t *i8 = instr_create_1dst_2src(dcontext, OP_vpsubw, opnd_create_reg(dst_reg_lower),
                                             opnd_create_reg(src1_reg_lower), opnd_create_reg(spill_src2_lower));
        instr_t *i9 = instr_create_1dst_2src(dcontext, OP_vpsubw, opnd_create_reg(dst_reg_upper),
                                             opnd_create_reg(src1_reg_upper), opnd_create_reg(src2_reg_upper));

        // Store results
        instr_t *i10 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_16);
        instr_t *i11 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper,
                                              TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_16);

        // Restore spill registers
        instr_t *i12 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_lower)), OPSZ_16);
        instr_t *i13 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_16);
        instr_t *i14 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_16);
        instr_t *i15 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_16);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 15, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15);
#endif
        instrlist_concat_next_instr(ilist, 15, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15);
        return i1;
    } break;
    case 3: { /* both src1 and src2 need spill */
        src1_reg_lower = ZMM_TO_YMM(src1_reg);
        src2_reg_lower = ZMM_TO_YMM(src2_reg);
        dst_reg_lower = ZMM_TO_YMM(dst_reg);

        // Find spill registers - both src1 and src2 need special handling
        reg_id_t spill_src1_lower =
            find_available_spill_ymm_avoiding_variadic(3, src1_reg_lower, src2_reg_lower, dst_reg_lower);
        reg_id_t spill_src2_lower = find_available_spill_ymm_avoiding_variadic(4, src1_reg_lower, src2_reg_lower,
                                                                               dst_reg_lower, spill_src1_lower);
        src1_reg_upper = find_available_spill_ymm_avoiding_variadic(5, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_src1_lower, spill_src2_lower);
        src2_reg_upper = find_available_spill_ymm_avoiding_variadic(6, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_src1_lower, spill_src2_lower, src1_reg_upper);
        dst_reg_upper = find_available_spill_ymm_avoiding_variadic(7, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                   spill_src1_lower, spill_src2_lower, src1_reg_upper,
                                                                   src2_reg_upper);

        // Save spill registers
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_lower)), OPSZ_16);
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_lower)), OPSZ_16);
        instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src1_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_16);
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src2_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_16);
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_16);

        // Load src1 lower and upper parts to spill registers
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_lower,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)), OPSZ_16);
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)) + SIZE_OF_YMM, OPSZ_16);

        // Load src2 lower and upper parts to spill registers
        instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_lower,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)), OPSZ_16);
        instr_t *i9 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)) + SIZE_OF_YMM, OPSZ_16);

        // Perform operations
        instr_t *i10 = instr_create_1dst_2src(dcontext, OP_vpsubw, opnd_create_reg(dst_reg_lower),
                                              opnd_create_reg(spill_src1_lower), opnd_create_reg(spill_src2_lower));
        instr_t *i11 = instr_create_1dst_2src(dcontext, OP_vpsubw, opnd_create_reg(dst_reg_upper),
                                              opnd_create_reg(src1_reg_upper), opnd_create_reg(src2_reg_upper));

        // Store results
        instr_t *i12 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_16);
        instr_t *i13 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper,
                                              TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_16);

        // Restore spill registers
        instr_t *i14 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_lower)), OPSZ_16);
        instr_t *i15 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_lower)), OPSZ_16);
        instr_t *i16 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_16);
        instr_t *i17 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_16);
        instr_t *i18 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_16);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 18, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18);
#endif
        instrlist_concat_next_instr(ilist, 18, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18);
        return i1;
    } break;
    case 4: { /* dst need spill */
        src1_reg_lower = ZMM_TO_YMM(src1_reg);
        src2_reg_lower = ZMM_TO_YMM(src2_reg);
        dst_reg_lower = ZMM_TO_YMM(dst_reg);

        // Find spill registers - dst needs special handling
        reg_id_t spill_dst_lower =
            find_available_spill_ymm_avoiding_variadic(3, src1_reg_lower, src2_reg_lower, dst_reg_lower);
        src1_reg_upper = find_available_spill_ymm_avoiding_variadic(4, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_dst_lower);
        src2_reg_upper = find_available_spill_ymm_avoiding_variadic(5, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_dst_lower, src1_reg_upper);
        dst_reg_upper = find_available_spill_ymm_avoiding_variadic(6, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                   spill_dst_lower, src1_reg_upper, src2_reg_upper);

        // Save spill registers
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_16);
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src1_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_16);
        instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src2_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_16);
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_16);

        // Load upper parts of source registers
        instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)) + SIZE_OF_YMM, OPSZ_16);
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)) + SIZE_OF_YMM, OPSZ_16);

        // Perform operations
        instr_t *i7 = instr_create_1dst_2src(dcontext, OP_vpsubw, opnd_create_reg(spill_dst_lower),
                                             opnd_create_reg(src1_reg_lower), opnd_create_reg(src2_reg_lower));
        instr_t *i8 = instr_create_1dst_2src(dcontext, OP_vpsubw, opnd_create_reg(dst_reg_upper),
                                             opnd_create_reg(src1_reg_upper), opnd_create_reg(src2_reg_upper));

        // Store results to dst TLS slots
        instr_t *i9 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_16);
        instr_t *i10 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper,
                                              TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_16);

        // Restore spill registers
        instr_t *i11 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_16);
        instr_t *i12 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_16);
        instr_t *i13 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_16);
        instr_t *i14 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_16);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 14, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14);
#endif
        instrlist_concat_next_instr(ilist, 14, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14);
        return i1;
    } break;
    case 5: { /* both src1 and dst need spill */
        src1_reg_lower = ZMM_TO_YMM(src1_reg);
        src2_reg_lower = ZMM_TO_YMM(src2_reg);
        dst_reg_lower = ZMM_TO_YMM(dst_reg);

        // Find spill registers - both src1 and dst need special handling
        reg_id_t spill_src1_lower =
            find_available_spill_ymm_avoiding_variadic(3, src1_reg_lower, src2_reg_lower, dst_reg_lower);
        reg_id_t spill_dst_lower = find_available_spill_ymm_avoiding_variadic(4, src1_reg_lower, src2_reg_lower,
                                                                              dst_reg_lower, spill_src1_lower);
        src1_reg_upper = find_available_spill_ymm_avoiding_variadic(5, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_src1_lower, spill_dst_lower);
        src2_reg_upper = find_available_spill_ymm_avoiding_variadic(6, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_src1_lower, spill_dst_lower, src1_reg_upper);
        dst_reg_upper = find_available_spill_ymm_avoiding_variadic(7, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                   spill_src1_lower, spill_dst_lower, src1_reg_upper,
                                                                   src2_reg_upper);

        // Save spill registers
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_lower)), OPSZ_16);
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_16);
        instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src1_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_16);
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src2_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_16);
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_16);

        // Load src1 lower and upper parts to spill registers
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_lower,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)), OPSZ_16);
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)) + SIZE_OF_YMM, OPSZ_16);

        // Load src2 upper part
        instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)) + SIZE_OF_YMM, OPSZ_16);

        // Perform operations
        instr_t *i9 = instr_create_1dst_2src(dcontext, OP_vpsubw, opnd_create_reg(spill_dst_lower),
                                             opnd_create_reg(spill_src1_lower), opnd_create_reg(src2_reg_lower));
        instr_t *i10 = instr_create_1dst_2src(dcontext, OP_vpsubw, opnd_create_reg(dst_reg_upper),
                                              opnd_create_reg(src1_reg_upper), opnd_create_reg(src2_reg_upper));

        // Store results to dst TLS slots
        instr_t *i11 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_16);
        instr_t *i12 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper,
                                              TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_16);

        // Restore spill registers
        instr_t *i13 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_lower)), OPSZ_16);
        instr_t *i14 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_16);
        instr_t *i15 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_16);
        instr_t *i16 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_16);
        instr_t *i17 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_16);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 17, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17);
#endif
        instrlist_concat_next_instr(ilist, 17, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17);
        return i1;
    } break;
    case 6: { /* both src2 and dst need spill */
        src1_reg_lower = ZMM_TO_YMM(src1_reg);
        src2_reg_lower = ZMM_TO_YMM(src2_reg);
        dst_reg_lower = ZMM_TO_YMM(dst_reg);

        // Find spill registers - both src2 and dst need special handling
        reg_id_t spill_src2_lower =
            find_available_spill_ymm_avoiding_variadic(3, src1_reg_lower, src2_reg_lower, dst_reg_lower);
        reg_id_t spill_dst_lower = find_available_spill_ymm_avoiding_variadic(4, src1_reg_lower, src2_reg_lower,
                                                                              dst_reg_lower, spill_src2_lower);
        src1_reg_upper = find_available_spill_ymm_avoiding_variadic(5, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_src2_lower, spill_dst_lower);
        src2_reg_upper = find_available_spill_ymm_avoiding_variadic(6, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_src2_lower, spill_dst_lower, src1_reg_upper);
        dst_reg_upper = find_available_spill_ymm_avoiding_variadic(7, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                   spill_src2_lower, spill_dst_lower, src1_reg_upper,
                                                                   src2_reg_upper);

        // Save spill registers
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_lower)), OPSZ_16);
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_16);
        instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src1_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_16);
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src2_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_16);
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_16);

        // Load src1 upper part
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)) + SIZE_OF_YMM, OPSZ_16);

        // Load src2 lower and upper parts to spill registers
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_lower,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)), OPSZ_16);
        instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)) + SIZE_OF_YMM, OPSZ_16);

        // Perform operations
        instr_t *i9 = instr_create_1dst_2src(dcontext, OP_vpsubw, opnd_create_reg(spill_dst_lower),
                                             opnd_create_reg(src1_reg_lower), opnd_create_reg(spill_src2_lower));
        instr_t *i10 = instr_create_1dst_2src(dcontext, OP_vpsubw, opnd_create_reg(dst_reg_upper),
                                              opnd_create_reg(src1_reg_upper), opnd_create_reg(src2_reg_upper));

        // Store results to dst TLS slots
        instr_t *i11 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_16);
        instr_t *i12 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper,
                                              TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_16);

        // Restore spill registers
        instr_t *i13 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_lower)), OPSZ_16);
        instr_t *i14 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_16);
        instr_t *i15 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_16);
        instr_t *i16 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_16);
        instr_t *i17 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_16);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 17, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17);
#endif
        instrlist_concat_next_instr(ilist, 17, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17);
        return i1;
    } break;
    case 7: { /* all src1, src2 and dst need spill */
        src1_reg_lower = ZMM_TO_YMM(src1_reg);
        src2_reg_lower = ZMM_TO_YMM(src2_reg);
        dst_reg_lower = ZMM_TO_YMM(dst_reg);

        // Find spill registers - all registers need special handling
        reg_id_t spill_src1_lower =
            find_available_spill_ymm_avoiding_variadic(3, src1_reg_lower, src2_reg_lower, dst_reg_lower);
        reg_id_t spill_src2_lower = find_available_spill_ymm_avoiding_variadic(4, src1_reg_lower, src2_reg_lower,
                                                                               dst_reg_lower, spill_src1_lower);
        reg_id_t spill_dst_lower = find_available_spill_ymm_avoiding_variadic(
            5, src1_reg_lower, src2_reg_lower, dst_reg_lower, spill_src1_lower, spill_src2_lower);
        src1_reg_upper = find_available_spill_ymm_avoiding_variadic(
            6, src1_reg_lower, src2_reg_lower, dst_reg_lower, spill_src1_lower, spill_src2_lower, spill_dst_lower);
        src2_reg_upper = find_available_spill_ymm_avoiding_variadic(7, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_src1_lower, spill_src2_lower, spill_dst_lower,
                                                                    src1_reg_upper);
        dst_reg_upper = find_available_spill_ymm_avoiding_variadic(8, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                   spill_src1_lower, spill_src2_lower, spill_dst_lower,
                                                                   src1_reg_upper, src2_reg_upper);

        // Save spill registers
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_lower)), OPSZ_16);
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_lower)), OPSZ_16);
        instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_16);
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src1_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_16);
        instr_t *i5 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src2_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_16);
        instr_t *i6 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_16);

        // Load src1 lower and upper parts to spill registers
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_lower,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)), OPSZ_16);
        instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)) + SIZE_OF_YMM, OPSZ_16);

        // Load src2 lower and upper parts to spill registers
        instr_t *i9 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_lower,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)), OPSZ_16);
        instr_t *i10 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)) + SIZE_OF_YMM, OPSZ_16);

        // Perform operations
        instr_t *i11 = instr_create_1dst_2src(dcontext, OP_vpsubw, opnd_create_reg(spill_dst_lower),
                                              opnd_create_reg(spill_src1_lower), opnd_create_reg(spill_src2_lower));
        instr_t *i12 = instr_create_1dst_2src(dcontext, OP_vpsubw, opnd_create_reg(dst_reg_upper),
                                              opnd_create_reg(src1_reg_upper), opnd_create_reg(src2_reg_upper));

        // Store results to dst TLS slots
        instr_t *i13 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_16);
        instr_t *i14 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper,
                                              TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_16);

        // Restore spill registers
        instr_t *i15 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_lower)), OPSZ_16);
        instr_t *i16 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_lower)), OPSZ_16);
        instr_t *i17 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_16);
        instr_t *i18 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_16);
        instr_t *i19 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_16);
        instr_t *i20 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_16);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 20, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20);
#endif
        instrlist_concat_next_instr(ilist, 20, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20);
        return i1;
    } break;
    }
    return NULL_INSTR;
}

instr_t * /* 149 */
rw_func_vpsubw(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src_opnd1 = instr_get_src(instr, 1); // %xyzmm{i}
    opnd_t src_opnd2 = instr_get_src(instr, 2); // %xyzmm{j}
    opnd_t dst_opnd = instr_get_dst(instr, 0);  // %xyzmm{k}
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpsubw", true, true, true, true);
#endif
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t src1_reg = opnd_get_reg(src_opnd1);
    reg_id_t src2_reg = opnd_get_reg(src_opnd2);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    if (IS_YMM_REG(dst_reg))
        return vpsubw_ymm_and_ymm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
    if (IS_XMM_REG(dst_reg))
        return vpsubw_xmm_and_xmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
    if (IS_ZMM_REG(dst_reg))
        return vpsubw_zmm_and_zmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
    REWRITE_INFO(STD_OUTF, "vpsubw pattern not support\n");
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vpsubd
 * ============================================= */

instr_t *
vpsubd_xmm_and_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_XMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 4 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = INSTR_CREATE_vpsubd(dcontext, op_dst, op_src1, op_src2);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        // vpsubd {%k0} %xmm23 %xmm13 -> %xmm13
        reg_id_t spill_src1_reg = DR_REG_NULL;
        if (src2_reg == dst_reg) {
            spill_src1_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src1_reg = find_available_spill_xmm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vpsubd spill_src1_reg src2_reg -> dst_reg
        instr_t *i3 = INSTR_CREATE_vpsubd(dcontext, op_dst, op_spill_src1, op_src2);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* src2 need spill */
        // vpsubd {%k0} %xmm11 %xmm23 -> %xmm11
        reg_id_t spill_src2_reg = DR_REG_NULL;
        if (src1_reg == dst_reg) {
            spill_src2_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src2_reg = find_available_spill_xmm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vpsubd src1_reg spill_src2_reg -> dst_reg
        instr_t *i3 = INSTR_CREATE_vpsubd(dcontext, op_dst, op_src1, op_spill_src2);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src need spill */
        reg_id_t spill_src1 = find_one_available_spill_xmm(dst_reg);
        reg_id_t spill_src2 = find_available_spill_xmm_avoiding(spill_src1, dst_reg, DR_REG_NULL);

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2);
        opnd_t op_dst = opnd_create_reg(dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1)), OPSZ_16);
        // spill_src2 -> tls(spill_src2)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // tls(src2) -> spill_srrc2
        instr_t *i4 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vpsubd spill_src1 spill_src2 -> dst
        instr_t *i5 = INSTR_CREATE_vpsubd(dcontext, op_dst, op_spill_src1, op_spill_src2);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i7 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 4: { /* dst need spill */
        // vpsubd {%k0} %xmm5 %xmm0 -> %xmm22
        reg_id_t spill_dst_reg = find_available_spill_xmm_avoiding(src1_reg, src2_reg, DR_REG_NULL);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);

        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vpsubd src1 src2 -> spill_dst
        instr_t *i2 = INSTR_CREATE_vpsubd(dcontext, op_spill_dst, op_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 5: { /* src1 and dst need spill */
        // vpsubd {%k0} %xmm22 %xmm1 -> %xmm22
        reg_id_t spill_src1 = find_one_available_spill_xmm(src2_reg);
        reg_id_t spill_dst = spill_src1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vpsubd spill_src1 src2 -> spill_src1
        instr_t *i3 = INSTR_CREATE_vpsubd(dcontext, op_spill_dst, op_spill_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i5 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    case 6: { /* src2 and dst need spill */
        // vpsubd {%k0} %xmm1 %xmm22 -> %xmm22
        reg_id_t spill_src2 = find_one_available_spill_xmm(src1_reg);
        reg_id_t spill_dst = spill_src2;

        opnd_t op_spill_src2 = opnd_create_reg(spill_src2);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vpsubd spill_src1 src2 -> spill_src1
        instr_t *i3 = INSTR_CREATE_vpsubd(dcontext, op_spill_dst, op_src1, op_spill_src2);
        // spill_dst -> tls(dst)
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i5 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    case 7: { /* all need spill */
        if (src1_reg == dst_reg && src2_reg == dst_reg) {
            reg_id_t spill_reg = XMM_SPILL_SLOT0;
            opnd_t op_spill = opnd_create_reg(spill_reg);
            // spill -> tls_slot(spill)
            instr_t *i1 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
            // tls(src1) -> spill
            instr_t *i2 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // vpsubd spill spill -> spill
            instr_t *i3 = INSTR_CREATE_vpsubd(dcontext, op_spill, op_spill, op_spill);
            // spill -> tls(dst)
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill) -> spill
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } else if (src1_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vpsubd spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpsubd(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else if (src2_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src2_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vpsubd spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpsubd(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vpsubd spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpsubd(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        }
    } break;
    default: {
        REWRITE_INFO(STD_OUTF, "vpsubd xmm and xmm pattern not support\n");
    } break;
    }
    return NULL_INSTR;
}

instr_t *
vpsubd_ymm_and_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_YMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_YMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_YMM(dst_reg) ? 4 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = INSTR_CREATE_vpsubd(dcontext, op_dst, op_src1, op_src2);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        // vpsubd {%k0} %ymm23 %ymm13 -> %ymm13
        reg_id_t spill_src1_reg = DR_REG_NULL;
        if (src2_reg == dst_reg) {
            spill_src1_reg = find_one_available_spill_ymm(src2_reg);
        } else {
            spill_src1_reg = find_available_spill_ymm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
        // vpsubd spill_src1_reg src2_reg -> dst_reg
        instr_t *i3 = INSTR_CREATE_vpsubd(dcontext, op_dst, op_spill_src1, op_src2);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* src2 need spill */
        // vpsubd {%k0} %ymm11 %ymm23 -> %ymm11
        reg_id_t spill_src2_reg = DR_REG_NULL;
        if (src1_reg == dst_reg) {
            spill_src2_reg = find_one_available_spill_ymm(src2_reg);
        } else {
            spill_src2_reg = find_available_spill_ymm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
        // vpsubd src1_reg spill_src2_reg -> dst_reg
        instr_t *i3 = INSTR_CREATE_vpsubd(dcontext, op_dst, op_src1, op_spill_src2);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src need spill */
        reg_id_t spill_src1_reg = YMM_SPILL_SLOT0;
        reg_id_t spill_src2_reg = YMM_SPILL_SLOT1;


        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);


        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
        // spill_src2 -> tls(spill_src2)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
        // tls(src2) -> spill_src2
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
        // vpsubd spill_src1 spill_src2 -> dst
        instr_t *i5 = INSTR_CREATE_vpsubd(dcontext, op_dst, op_spill_src1, op_spill_src2);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
        // tls(spill_src2) -> spill_src2
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 4: { /* dst need spill */
        reg_id_t spill_dst_reg = YMM_SPILL_SLOT0;


        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);


        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        // vpsubd src1 src2 -> spill_dst
        instr_t *i2 = INSTR_CREATE_vpsubd(dcontext, op_spill_dst, op_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 5: { /* src1 and dst need spill */
        reg_id_t spill_src1_reg = YMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = YMM_SPILL_SLOT1;


        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);


        // spill_src1 -> tls(spill_src1)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        // tls(src1) -> spill_src1
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
        // vpsubd spill_src1 src2 -> spill_dst
        instr_t *i4 = INSTR_CREATE_vpsubd(dcontext, op_spill_dst, op_spill_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 6: { /* src2 and dst need spill */
        reg_id_t spill_src2_reg = YMM_SPILL_SLOT0;
        reg_id_t spill_dst_reg = YMM_SPILL_SLOT1;


        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);


        // spill_src2 -> tls(spill_src2)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
        // spill_dst -> tls(spill_dst)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        // tls(src2) -> spill_src2
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
        // vpsubd src1 spill_src2 -> spill_dst
        instr_t *i4 = INSTR_CREATE_vpsubd(dcontext, op_spill_dst, op_src1, op_spill_src2);
        // spill_dst -> tls(dst)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls(spill_src2) -> spill_src2
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
        // tls(spill_dst) -> spill_dst
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 7: { /* all need spill */
        if (src1_reg == dst_reg && src2_reg == dst_reg) {
            reg_id_t spill_reg = YMM_SPILL_SLOT0;
            opnd_t op_spill = opnd_create_reg(spill_reg);
            // spill -> tls_slot(spill)
            instr_t *i1 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_reg)), OPSZ_32);
            // tls(src1) -> spill
            instr_t *i2 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
            // vpsubd spill spill -> spill
            instr_t *i3 = INSTR_CREATE_vpsubd(dcontext, op_spill, op_spill, op_spill);
            // spill -> tls(dst)
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill) -> spill
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } else if (src1_reg == dst_reg) {
            reg_id_t spill_src1_reg = YMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = YMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
            // vpsubd spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpsubd(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else if (src2_reg == dst_reg) {
            reg_id_t spill_src1_reg = YMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = YMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src2_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
            // vpsubd spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpsubd(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else {
            reg_id_t spill_src1_reg = YMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = YMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
            // vpsubd spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpsubd(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        }
    } break;
    default: {
        REWRITE_INFO(STD_OUTF, "vpsubd ymm and ymm pattern not support\n");
    } break;
    }
    return NULL_INSTR;
}

instr_t *
vpsubd_zmm_and_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 150 */
rw_func_vpsubd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src_opnd1 = instr_get_src(instr, 1); // %xyzmm{i}
    opnd_t src_opnd2 = instr_get_src(instr, 2); // %xyzmm{j}
    opnd_t dst_opnd = instr_get_dst(instr, 0);  // %xyzmm{k}
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpsubd", true, true, true, true);
#endif
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t src1_reg = opnd_get_reg(src_opnd1);
    reg_id_t src2_reg = opnd_get_reg(src_opnd2);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    if (IS_YMM_REG(dst_reg))
        return vpsubd_ymm_and_ymm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
    if (IS_XMM_REG(dst_reg))
        return vpsubd_xmm_and_xmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
    if (IS_ZMM_REG(dst_reg))
        return vpsubd_zmm_and_zmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
    REWRITE_INFO(STD_OUTF, "vpsubd pattern not support\n");
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vpaddw
 * ============================================= */

instr_t *
vpaddw_xmm_and_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpaddw_ymm_and_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_YMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_YMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_YMM(dst_reg) ? 4 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = INSTR_CREATE_vpaddw(dcontext, op_dst, op_src1, op_src2);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        // vpaddw {%k0} %ymm23 %ymm13 -> %ymm13
        reg_id_t spill_src1_reg = DR_REG_NULL;
        if (src2_reg == dst_reg) {
            spill_src1_reg = find_one_available_spill_ymm(src2_reg);
        } else {
            spill_src1_reg = find_available_spill_ymm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
        // vpaddw spill_src1_reg src2_reg -> dst_reg
        instr_t *i3 = INSTR_CREATE_vpaddw(dcontext, op_dst, op_spill_src1, op_src2);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* src2 need spill */
        // vpaddw {%k0} %ymm11 %ymm23 -> %ymm11
        reg_id_t spill_src2_reg = DR_REG_NULL;
        if (src1_reg == dst_reg) {
            spill_src2_reg = find_one_available_spill_ymm(src2_reg);
        } else {
            spill_src2_reg = find_available_spill_ymm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
        // vpaddw src1_reg spill_src2_reg -> dst_reg
        instr_t *i3 = INSTR_CREATE_vpaddw(dcontext, op_dst, op_src1, op_spill_src2);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src need spill */ REWRITE_INFO(STD_OUTF, "both src need spill\n"); return NULL_INSTR;
    } break;
    case 4: { /* dst need spill */ REWRITE_INFO(STD_OUTF, "dst need spill\n"); return NULL_INSTR;
    } break;
    case 5: { /* src1 and dst need spill */
        if (src1_reg == dst_reg) {
            reg_id_t spill_reg = find_one_available_spill_ymm(src2_reg);
            opnd_t op_spill = opnd_create_reg(spill_reg);
            opnd_t op_src2 = opnd_create_reg(src2_reg);
            opnd_t op_dst = op_spill;
            // spill_reg -> tls(spill_reg)
            instr_t *i1 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_reg)), OPSZ_32);
            // tls(src1) -> spill_reg
            instr_t *i2 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
            // vpaddw spill_reg src2_reg -> dst_reg
            instr_t *i3 = INSTR_CREATE_vpaddw(dcontext, op_dst, op_spill, op_src2);
            // spill_reg -> tls(dst)
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill_reg) -> spill_reg
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } else {
            reg_id_t src1_spill_reg = find_one_available_spill_ymm(src2_reg);
            reg_id_t dst_spill_reg = find_available_spill_ymm_avoiding(src2_reg, src1_spill_reg, DR_REG_NULL);
            opnd_t op_src1_spill = opnd_create_reg(src1_spill_reg);
            opnd_t op_dst_spill = opnd_create_reg(dst_spill_reg);
            opnd_t op_src2 = opnd_create_reg(src2_reg);

            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src1_spill_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_spill_reg)), OPSZ_32);
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_spill_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_spill_reg)), OPSZ_32);
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
            instr_t *i4 = INSTR_CREATE_vpaddw(dcontext, op_dst_spill, op_src1_spill, op_src2);
            instr_t *i5 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_spill_reg)), OPSZ_32);
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_spill_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
            instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
            return i1;
        }
    } break;
    case 6: { /* src2 and dst need spill */ REWRITE_INFO(STD_OUTF, "src2 and dst need spill\n"); return NULL_INSTR;
    } break;
    case 7: { /* all need spill */
        if (src1_reg == dst_reg && src2_reg == dst_reg) {
            reg_id_t spill_reg = YMM_SPILL_SLOT0;
            opnd_t op_spill = opnd_create_reg(spill_reg);
            // spill -> tls_slot(spill)
            instr_t *i1 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_reg)), OPSZ_32);
            // tls(src1) -> spill
            instr_t *i2 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
            // vpaddw spill spill -> spill
            instr_t *i3 = INSTR_CREATE_vpaddw(dcontext, op_spill, op_spill, op_spill);
            // spill -> tls(dst)
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill) -> spill
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } else if (src1_reg == dst_reg) {
            reg_id_t spill_src1_reg = YMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = YMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
            // vpaddw spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpaddw(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else if (src2_reg == dst_reg) {
            reg_id_t spill_src1_reg = YMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = YMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src2_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
            // vpaddw spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpaddw(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else {
            reg_id_t spill_src1_reg = YMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = YMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
            // vpaddw spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpaddw(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        }
        break;
    default: {
        REWRITE_INFO(STD_OUTF, "vpaddw ymm and ymm pattern not support\n");
    } break;
    }
    }
    return NULL_INSTR;
}

instr_t *
vpaddw_zmm_and_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 153 */
rw_func_vpaddw(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src_opnd1 = instr_get_src(instr, 1); // %xyzmm{i}
    opnd_t src_opnd2 = instr_get_src(instr, 2); // %xyzmm{j}
    opnd_t dst_opnd = instr_get_dst(instr, 0);  // %xyzmm{k}
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpaddw", true, true, true, true);
#endif
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t src1_reg = opnd_get_reg(src_opnd1);
    reg_id_t src2_reg = opnd_get_reg(src_opnd2);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    if (IS_ZMM_REG(dst_reg))
        return vpaddw_zmm_and_zmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
    if (IS_YMM_REG(dst_reg))
        return vpaddw_ymm_and_ymm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
    if (IS_XMM_REG(dst_reg))
        return vpaddw_xmm_and_xmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
    REWRITE_INFO(STD_OUTF, "vpaddw pattern not support\n");
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vpaddw
 * ============================================= */

instr_t *
vpaddd_xmm_and_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_XMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 4 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = INSTR_CREATE_vpaddd(dcontext, op_dst, op_src1, op_src2);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        // vpaddd {%k0} %xmm23 %xmm13 -> %xmm13
        reg_id_t spill_src1_reg = DR_REG_NULL;
        if (src2_reg == dst_reg) {
            spill_src1_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src1_reg = find_available_spill_xmm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vpaddd spill_src1_reg src2_reg -> dst_reg
        instr_t *i3 = INSTR_CREATE_vpaddd(dcontext, op_dst, op_spill_src1, op_src2);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* src2 need spill */
        // vpaddd {%k0} %xmm11 %xmm23 -> %xmm11
        reg_id_t spill_src2_reg = DR_REG_NULL;
        if (src1_reg == dst_reg) {
            spill_src2_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src2_reg = find_available_spill_xmm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vpaddd src1_reg spill_src2_reg -> dst_reg
        instr_t *i3 = INSTR_CREATE_vpaddd(dcontext, op_dst, op_src1, op_spill_src2);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src need spill */
        reg_id_t spill_src1 = find_one_available_spill_xmm(dst_reg);
        reg_id_t spill_src2 = find_available_spill_xmm_avoiding(spill_src1, dst_reg, DR_REG_NULL);

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2);
        opnd_t op_dst = opnd_create_reg(dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1)), OPSZ_16);
        // spill_src2 -> tls(spill_src2)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // tls(src2) -> spill_srrc2
        instr_t *i4 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vpaddd spill_src1 spill_src2 -> dst
        instr_t *i5 = INSTR_CREATE_vpaddd(dcontext, op_dst, op_spill_src1, op_spill_src2);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i7 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 4: { /* dst need spill */
        // vpaddd {%k0} %xmm5 %xmm0 -> %xmm22
        reg_id_t spill_dst_reg = find_available_spill_xmm_avoiding(src1_reg, src2_reg, DR_REG_NULL);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);

        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vpadd src1 src2 -> spill_dst
        instr_t *i2 = INSTR_CREATE_vpaddd(dcontext, op_spill_dst, op_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 5: { /* src1 and dst need spill */
        // vpaddd {%k0} %xmm22 %xmm1 -> %xmm22
        reg_id_t spill_src1 = find_one_available_spill_xmm(src2_reg);
        reg_id_t spill_dst = spill_src1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vpaddd spill_src1 src2 -> spill_src1
        instr_t *i3 = INSTR_CREATE_vpaddd(dcontext, op_spill_dst, op_spill_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i5 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    case 6: { /* src2 and dst need spill */
        // vpaddd {%k0} %xmm1 %xmm22 -> %xmm22
        reg_id_t spill_src2 = find_one_available_spill_xmm(src1_reg);
        reg_id_t spill_dst = spill_src2;

        opnd_t op_spill_src2 = opnd_create_reg(spill_src2);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vpaddd spill_src1 src2 -> spill_src1
        instr_t *i3 = INSTR_CREATE_vpaddd(dcontext, op_spill_dst, op_src1, op_spill_src2);
        // spill_dst -> tls(dst)
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i5 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    case 7: { /* all need spill */
        if (src1_reg == dst_reg && src2_reg == dst_reg) {
            reg_id_t spill_reg = XMM_SPILL_SLOT0;
            opnd_t op_spill = opnd_create_reg(spill_reg);
            // spill -> tls_slot(spill)
            instr_t *i1 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
            // tls(src1) -> spill
            instr_t *i2 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // vpadd spill spill -> spill
            instr_t *i3 = INSTR_CREATE_vpaddd(dcontext, op_spill, op_spill, op_spill);
            // spill -> tls(dst)
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill) -> spill
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } else if (src1_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vpaddd spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpaddd(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else if (src2_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src2_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vpaddd spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpaddd(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vpaddd spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpaddd(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        }
    } break;
    default: {
        REWRITE_INFO(STD_OUTF, "vpaddd xmm and xmm pattern not support\n");
    } break;
    }
    return NULL_INSTR;
}

instr_t *
vpaddd_ymm_and_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_YMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_YMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_YMM(dst_reg) ? 4 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = INSTR_CREATE_vpaddd(dcontext, op_dst, op_src1, op_src2);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        // vpaddd {%k0} %ymm23 %ymm13 -> %ymm13
        reg_id_t spill_src1_reg = DR_REG_NULL;
        if (src2_reg == dst_reg) {
            spill_src1_reg = find_one_available_spill_ymm(src2_reg);
        } else {
            spill_src1_reg = find_available_spill_ymm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
        // vpaddd spill_src1_reg src2_reg -> dst_reg
        instr_t *i3 = INSTR_CREATE_vpaddd(dcontext, op_dst, op_spill_src1, op_src2);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* src2 need spill */
        // vpaddd {%k0} %ymm11 %ymm23 -> %ymm11
        reg_id_t spill_src2_reg = DR_REG_NULL;
        if (src1_reg == dst_reg) {
            spill_src2_reg = find_one_available_spill_ymm(src2_reg);
        } else {
            spill_src2_reg = find_available_spill_ymm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
        // vpaddd src1_reg spill_src2_reg -> dst_reg
        instr_t *i3 = INSTR_CREATE_vpaddd(dcontext, op_dst, op_src1, op_spill_src2);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src need spill */
        // Both src1 and src2 need spill, dst doesn't
        reg_id_t spill_src1_reg = find_available_spill_ymm_avoiding(dst_reg, DR_REG_NULL, DR_REG_NULL);
        reg_id_t spill_src2_reg = find_available_spill_ymm_avoiding(dst_reg, spill_src1_reg, DR_REG_NULL);

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);

        // Save spill registers to TLS
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);

        // Load src1 and src2 from TLS to spill registers
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);

        // Perform the operation
        instr_t *i5 = INSTR_CREATE_vpaddd(dcontext, op_dst, op_spill_src1, op_spill_src2);

        // Restore spill registers from TLS
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 4: { /* dst need spill */
        // vpaddd {%k0} %ymm5 %ymm0 -> %ymm22
        reg_id_t spill_dst_reg = find_available_spill_ymm_avoiding(src1_reg, src2_reg, DR_REG_NULL);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);

        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        // vpadd src1 src2 -> spill_dst
        instr_t *i2 = INSTR_CREATE_vpaddd(dcontext, op_spill_dst, op_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 5: { /* src1 and dst need spill */
        // Both src1 and dst need spill, src2 doesn't
        reg_id_t spill_src1_reg = find_available_spill_ymm_avoiding(src2_reg, DR_REG_NULL, DR_REG_NULL);
        reg_id_t spill_dst_reg = find_available_spill_ymm_avoiding(src2_reg, spill_src1_reg, DR_REG_NULL);

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // Save spill registers to TLS
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);

        // Load src1 from TLS to spill register
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);

        // Perform the operation
        instr_t *i4 = INSTR_CREATE_vpaddd(dcontext, op_spill_dst, op_spill_src1, op_src2);

        // Store dst result to TLS
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);

        // Restore spill registers from TLS
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 6: { /* src2 and dst need spill */
        // Both src2 and dst need spill, src1 doesn't
        reg_id_t spill_src2_reg = find_available_spill_ymm_avoiding(src1_reg, DR_REG_NULL, DR_REG_NULL);
        reg_id_t spill_dst_reg = find_available_spill_ymm_avoiding(src1_reg, spill_src2_reg, DR_REG_NULL);

        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

        // Save spill registers to TLS
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);

        // Load src2 from TLS to spill register
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);

        // Perform the operation
        instr_t *i4 = INSTR_CREATE_vpaddd(dcontext, op_spill_dst, op_src1, op_spill_src2);

        // Store dst result to TLS
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);

        // Restore spill registers from TLS
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 7: { /* all need spill */
        if (src1_reg == dst_reg && src2_reg == dst_reg) {
            reg_id_t spill_reg = YMM_SPILL_SLOT0;
            opnd_t op_spill = opnd_create_reg(spill_reg);
            // spill -> tls_slot(spill)
            instr_t *i1 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_reg)), OPSZ_32);
            // tls(src1) -> spill
            instr_t *i2 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
            // vpadd spill spill -> spill
            instr_t *i3 = INSTR_CREATE_vpaddd(dcontext, op_spill, op_spill, op_spill);
            // spill -> tls(dst)
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill) -> spill
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } else if (src1_reg == dst_reg) {
            reg_id_t spill_src1_reg = YMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = YMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
            // vpaddd spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpaddd(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else if (src2_reg == dst_reg) {
            reg_id_t spill_src1_reg = YMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = YMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src2_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
            // vpaddd spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpaddd(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else {
            reg_id_t spill_src1_reg = YMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = YMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
            // vpaddd spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpaddd(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        }
    } break;
    default: {
        REWRITE_INFO(STD_OUTF, "vpaddd ymm and ymm pattern not support\n");
    } break;
    }
    return NULL_INSTR;
}

instr_t *
vpaddd_zmm_and_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    reg_id_t src1_reg_lower = DR_REG_NULL;
    reg_id_t src1_reg_upper = DR_REG_NULL;
    reg_id_t src2_reg_lower = DR_REG_NULL;
    reg_id_t src2_reg_upper = DR_REG_NULL;
    reg_id_t dst_reg_lower = DR_REG_NULL;
    reg_id_t dst_reg_upper = DR_REG_NULL;

    const uint src1_need_spill = NEED_SPILL_ZMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill = NEED_SPILL_ZMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill = NEED_SPILL_ZMM(dst_reg) ? 4 : 0;
    const uint need_spill = src1_need_spill | src2_need_spill | dst_need_spill;

    switch (need_spill) {
    case 0: { /* no spill */
        if (src1_reg == dst_reg) {
            src1_reg_lower = ZMM_TO_YMM(src1_reg);
            src2_reg_lower = ZMM_TO_YMM(src2_reg);
            dst_reg_lower = src1_reg_lower;
            src1_reg_upper = find_available_spill_ymm_avoiding_variadic(2, src1_reg_lower, src2_reg_lower);
            src2_reg_upper =
                find_available_spill_ymm_avoiding_variadic(3, src1_reg_lower, src2_reg_lower, src1_reg_upper);
            dst_reg_upper = src1_reg_upper;

            // save src1-up -> tls(src1-up)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src1_reg_upper,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_32);
            // save src2-up -> tls(src2-up)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src2_reg_upper,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_32);

            // tls(src1-up) -> src1-up
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(
                dcontext, src1_reg_upper, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)) + SIZE_OF_YMM, OPSZ_32);
            // tls(src2-up) -> src2-up
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(
                dcontext, src2_reg_upper, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)) + SIZE_OF_YMM, OPSZ_32);
            // vaddd
            instr_t *i5 = instr_create_1dst_2src(dcontext, OP_vpaddd, opnd_create_reg(dst_reg_lower),
                                                 opnd_create_reg(src1_reg_lower), opnd_create_reg(src2_reg_lower));
            instr_t *i6 = instr_create_1dst_2src(dcontext, OP_vpaddd, opnd_create_reg(dst_reg_upper),
                                                 opnd_create_reg(src1_reg_upper), opnd_create_reg(src2_reg_upper));
            // dst-low -> tls(dst-low)
            instr_t *i7 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_32);
            // dst-up -> tls(dst-up)
            instr_t *i8 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper,
                                                 TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_32);
            // restore src1-up from tls(src1-up)
            instr_t *i9 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_32);
            // restore src2-up from tls(src2-up)
            instr_t *i10 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 10, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);
#endif
            instrlist_concat_next_instr(ilist, 10, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);
            return i1;
        } else {
            src1_reg_lower = ZMM_TO_YMM(src1_reg);
            src2_reg_lower = ZMM_TO_YMM(src2_reg);
            dst_reg_lower = ZMM_TO_YMM(dst_reg);
            src1_reg_upper =
                find_available_spill_ymm_avoiding_variadic(3, src1_reg_lower, src2_reg_lower, dst_reg_lower);
            src2_reg_upper = find_available_spill_ymm_avoiding_variadic(4, src1_reg_lower, src2_reg_lower,
                                                                        dst_reg_lower, src1_reg_upper);
            dst_reg_upper = find_available_spill_ymm_avoiding_variadic(5, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                       src1_reg_upper, src2_reg_upper);

            // save src1-up -> tls(src1-up)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src1_reg_upper,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_32);
            // save src2-up -> tls(src2-up)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src2_reg_upper,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_32);
            // save dst-up -> tls(dst-up)
            instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);

            // tls(src1-up) -> src1-up
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(
                dcontext, src1_reg_upper, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)) + SIZE_OF_YMM, OPSZ_32);
            // tls(src2-up) -> src2-up
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(
                dcontext, src2_reg_upper, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)) + SIZE_OF_YMM, OPSZ_32);
            // vaddd
            instr_t *i6 = instr_create_1dst_2src(dcontext, OP_vpaddd, opnd_create_reg(dst_reg_lower),
                                                 opnd_create_reg(src1_reg_lower), opnd_create_reg(src2_reg_lower));
            instr_t *i7 = instr_create_1dst_2src(dcontext, OP_vpaddd, opnd_create_reg(dst_reg_upper),
                                                 opnd_create_reg(src1_reg_upper), opnd_create_reg(src2_reg_upper));
            // dst-low -> tls(dst-low)
            instr_t *i8 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_32);
            // dst-up -> tls(dst-up)
            instr_t *i9 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper,
                                                 TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_32);
            // restore src1-up from tls(src1-up)
            instr_t *i10 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_32);
            // restore src2-up from tls(src2-up)
            instr_t *i11 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_32);
            // restore dst-up from tls(dst-up)
            instr_t *i12 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg_upper,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 12, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12);
#endif
            instrlist_concat_next_instr(ilist, 12, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12);
            return i1;
        }
    } break;
    case 1: { /* src1 need spill */
        src1_reg_lower = ZMM_TO_YMM(src1_reg);
        src2_reg_lower = ZMM_TO_YMM(src2_reg);
        dst_reg_lower = ZMM_TO_YMM(dst_reg);

        // Find spill registers - src1 needs special handling
        reg_id_t spill_src1_lower =
            find_available_spill_ymm_avoiding_variadic(3, src1_reg_lower, src2_reg_lower, dst_reg_lower);
        src1_reg_upper = find_available_spill_ymm_avoiding_variadic(4, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_src1_lower);
        src2_reg_upper = find_available_spill_ymm_avoiding_variadic(5, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_src1_lower, src1_reg_upper);
        dst_reg_upper = find_available_spill_ymm_avoiding_variadic(6, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                   spill_src1_lower, src1_reg_upper, src2_reg_upper);

        // Save spill registers
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_lower)), OPSZ_32);
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src1_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_32);
        instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src2_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_32);
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);

        // Load src1 lower and upper parts to spill registers
        instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_lower,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)), OPSZ_32);
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)) + SIZE_OF_YMM, OPSZ_32);

        // Load src2 upper part
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)) + SIZE_OF_YMM, OPSZ_32);

        // Perform operations
        instr_t *i8 = instr_create_1dst_2src(dcontext, OP_vpaddd, opnd_create_reg(dst_reg_lower),
                                             opnd_create_reg(spill_src1_lower), opnd_create_reg(src2_reg_lower));
        instr_t *i9 = instr_create_1dst_2src(dcontext, OP_vpaddd, opnd_create_reg(dst_reg_upper),
                                             opnd_create_reg(src1_reg_upper), opnd_create_reg(src2_reg_upper));

        // Store results
        instr_t *i10 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_32);
        instr_t *i11 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper,
                                              TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_32);

        // Restore spill registers
        instr_t *i12 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_lower)), OPSZ_32);
        instr_t *i13 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_32);
        instr_t *i14 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_32);
        instr_t *i15 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 15, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15);
#endif
        instrlist_concat_next_instr(ilist, 15, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15);
        return i1;
    } break;
    case 2: { /* src2 need spill */
        src1_reg_lower = ZMM_TO_YMM(src1_reg);
        src2_reg_lower = ZMM_TO_YMM(src2_reg);
        dst_reg_lower = ZMM_TO_YMM(dst_reg);

        // Find spill registers - src2 needs special handling
        reg_id_t spill_src2_lower =
            find_available_spill_ymm_avoiding_variadic(3, src1_reg_lower, src2_reg_lower, dst_reg_lower);
        src1_reg_upper = find_available_spill_ymm_avoiding_variadic(4, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_src2_lower);
        src2_reg_upper = find_available_spill_ymm_avoiding_variadic(5, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_src2_lower, src1_reg_upper);
        dst_reg_upper = find_available_spill_ymm_avoiding_variadic(6, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                   spill_src2_lower, src1_reg_upper, src2_reg_upper);

        // Save spill registers
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_lower)), OPSZ_32);
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src1_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_32);
        instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src2_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_32);
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);

        // Load src1 upper part
        instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)) + SIZE_OF_YMM, OPSZ_32);

        // Load src2 lower and upper parts to spill registers
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_lower,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)), OPSZ_32);
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)) + SIZE_OF_YMM, OPSZ_32);

        // Perform operations
        instr_t *i8 = instr_create_1dst_2src(dcontext, OP_vpaddd, opnd_create_reg(dst_reg_lower),
                                             opnd_create_reg(src1_reg_lower), opnd_create_reg(spill_src2_lower));
        instr_t *i9 = instr_create_1dst_2src(dcontext, OP_vpaddd, opnd_create_reg(dst_reg_upper),
                                             opnd_create_reg(src1_reg_upper), opnd_create_reg(src2_reg_upper));

        // Store results
        instr_t *i10 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_32);
        instr_t *i11 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper,
                                              TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_32);

        // Restore spill registers
        instr_t *i12 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_lower)), OPSZ_32);
        instr_t *i13 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_32);
        instr_t *i14 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_32);
        instr_t *i15 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 15, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15);
#endif
        instrlist_concat_next_instr(ilist, 15, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15);
        return i1;
    } break;
    case 3: { /* both src1 and src2 need spill */
        src1_reg_lower = ZMM_TO_YMM(src1_reg);
        src2_reg_lower = ZMM_TO_YMM(src2_reg);
        dst_reg_lower = ZMM_TO_YMM(dst_reg);

        // Find spill registers - both src1 and src2 need special handling
        reg_id_t spill_src1_lower =
            find_available_spill_ymm_avoiding_variadic(3, src1_reg_lower, src2_reg_lower, dst_reg_lower);
        reg_id_t spill_src2_lower = find_available_spill_ymm_avoiding_variadic(4, src1_reg_lower, src2_reg_lower,
                                                                               dst_reg_lower, spill_src1_lower);
        src1_reg_upper = find_available_spill_ymm_avoiding_variadic(5, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_src1_lower, spill_src2_lower);
        src2_reg_upper = find_available_spill_ymm_avoiding_variadic(6, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_src1_lower, spill_src2_lower, src1_reg_upper);
        dst_reg_upper = find_available_spill_ymm_avoiding_variadic(7, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                   spill_src1_lower, spill_src2_lower, src1_reg_upper,
                                                                   src2_reg_upper);

        // Save spill registers
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_lower)), OPSZ_32);
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_lower)), OPSZ_32);
        instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src1_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_32);
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src2_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_32);
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);

        // Load src1 lower and upper parts to spill registers
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_lower,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)), OPSZ_32);
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)) + SIZE_OF_YMM, OPSZ_32);

        // Load src2 lower and upper parts to spill registers
        instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_lower,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)), OPSZ_32);
        instr_t *i9 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)) + SIZE_OF_YMM, OPSZ_32);

        // Perform operations
        instr_t *i10 = instr_create_1dst_2src(dcontext, OP_vpaddd, opnd_create_reg(dst_reg_lower),
                                              opnd_create_reg(spill_src1_lower), opnd_create_reg(spill_src2_lower));
        instr_t *i11 = instr_create_1dst_2src(dcontext, OP_vpaddd, opnd_create_reg(dst_reg_upper),
                                              opnd_create_reg(src1_reg_upper), opnd_create_reg(src2_reg_upper));

        // Store results
        instr_t *i12 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_32);
        instr_t *i13 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper,
                                              TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_32);

        // Restore spill registers
        instr_t *i14 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_lower)), OPSZ_32);
        instr_t *i15 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_lower)), OPSZ_32);
        instr_t *i16 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_32);
        instr_t *i17 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_32);
        instr_t *i18 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 18, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18);
#endif
        instrlist_concat_next_instr(ilist, 18, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18);
        return i1;
    } break;
    case 4: { /* dst need spill */
        src1_reg_lower = ZMM_TO_YMM(src1_reg);
        src2_reg_lower = ZMM_TO_YMM(src2_reg);
        dst_reg_lower = ZMM_TO_YMM(dst_reg);

        // Find spill registers - dst needs special handling
        reg_id_t spill_dst_lower =
            find_available_spill_ymm_avoiding_variadic(3, src1_reg_lower, src2_reg_lower, dst_reg_lower);
        src1_reg_upper = find_available_spill_ymm_avoiding_variadic(4, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_dst_lower);
        src2_reg_upper = find_available_spill_ymm_avoiding_variadic(5, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_dst_lower, src1_reg_upper);
        dst_reg_upper = find_available_spill_ymm_avoiding_variadic(6, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                   spill_dst_lower, src1_reg_upper, src2_reg_upper);

        // Save spill registers
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_32);
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src1_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_32);
        instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src2_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_32);
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);

        // Load upper parts of source registers
        instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)) + SIZE_OF_YMM, OPSZ_32);
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)) + SIZE_OF_YMM, OPSZ_32);

        // Perform operations
        instr_t *i7 = instr_create_1dst_2src(dcontext, OP_vpaddd, opnd_create_reg(spill_dst_lower),
                                             opnd_create_reg(src1_reg_lower), opnd_create_reg(src2_reg_lower));
        instr_t *i8 = instr_create_1dst_2src(dcontext, OP_vpaddd, opnd_create_reg(dst_reg_upper),
                                             opnd_create_reg(src1_reg_upper), opnd_create_reg(src2_reg_upper));

        // Store results to dst TLS slots
        instr_t *i9 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_32);
        instr_t *i10 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper,
                                              TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_32);

        // Restore spill registers
        instr_t *i11 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_32);
        instr_t *i12 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_32);
        instr_t *i13 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_32);
        instr_t *i14 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 14, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14);
#endif
        instrlist_concat_next_instr(ilist, 14, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14);
        return i1;
    } break;
    case 5: { /* both src1 and dst need spill */
        src1_reg_lower = ZMM_TO_YMM(src1_reg);
        src2_reg_lower = ZMM_TO_YMM(src2_reg);
        dst_reg_lower = ZMM_TO_YMM(dst_reg);

        // Find spill registers - both src1 and dst need special handling
        reg_id_t spill_src1_lower =
            find_available_spill_ymm_avoiding_variadic(3, src1_reg_lower, src2_reg_lower, dst_reg_lower);
        reg_id_t spill_dst_lower = find_available_spill_ymm_avoiding_variadic(4, src1_reg_lower, src2_reg_lower,
                                                                              dst_reg_lower, spill_src1_lower);
        src1_reg_upper = find_available_spill_ymm_avoiding_variadic(5, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_src1_lower, spill_dst_lower);
        src2_reg_upper = find_available_spill_ymm_avoiding_variadic(6, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_src1_lower, spill_dst_lower, src1_reg_upper);
        dst_reg_upper = find_available_spill_ymm_avoiding_variadic(7, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                   spill_src1_lower, spill_dst_lower, src1_reg_upper,
                                                                   src2_reg_upper);

        // Save spill registers
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_lower)), OPSZ_32);
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_32);
        instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src1_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_32);
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src2_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_32);
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);

        // Load src1 lower and upper parts to spill registers
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_lower,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)), OPSZ_32);
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)) + SIZE_OF_YMM, OPSZ_32);

        // Load src2 upper part
        instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)) + SIZE_OF_YMM, OPSZ_32);

        // Perform operations
        instr_t *i9 = instr_create_1dst_2src(dcontext, OP_vpaddd, opnd_create_reg(spill_dst_lower),
                                             opnd_create_reg(spill_src1_lower), opnd_create_reg(src2_reg_lower));
        instr_t *i10 = instr_create_1dst_2src(dcontext, OP_vpaddd, opnd_create_reg(dst_reg_upper),
                                              opnd_create_reg(src1_reg_upper), opnd_create_reg(src2_reg_upper));

        // Store results to dst TLS slots
        instr_t *i11 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_32);
        instr_t *i12 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper,
                                              TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_32);

        // Restore spill registers
        instr_t *i13 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_lower)), OPSZ_32);
        instr_t *i14 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_32);
        instr_t *i15 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_32);
        instr_t *i16 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_32);
        instr_t *i17 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 17, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17);
#endif
        instrlist_concat_next_instr(ilist, 17, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17);
        return i1;
    } break;
    case 6: { /* both src2 and dst need spill */
        src1_reg_lower = ZMM_TO_YMM(src1_reg);
        src2_reg_lower = ZMM_TO_YMM(src2_reg);
        dst_reg_lower = ZMM_TO_YMM(dst_reg);

        // Find spill registers - both src2 and dst need special handling
        reg_id_t spill_src2_lower =
            find_available_spill_ymm_avoiding_variadic(3, src1_reg_lower, src2_reg_lower, dst_reg_lower);
        reg_id_t spill_dst_lower = find_available_spill_ymm_avoiding_variadic(4, src1_reg_lower, src2_reg_lower,
                                                                              dst_reg_lower, spill_src2_lower);
        src1_reg_upper = find_available_spill_ymm_avoiding_variadic(5, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_src2_lower, spill_dst_lower);
        src2_reg_upper = find_available_spill_ymm_avoiding_variadic(6, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_src2_lower, spill_dst_lower, src1_reg_upper);
        dst_reg_upper = find_available_spill_ymm_avoiding_variadic(7, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                   spill_src2_lower, spill_dst_lower, src1_reg_upper,
                                                                   src2_reg_upper);

        // Save spill registers
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_lower)), OPSZ_32);
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_32);
        instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src1_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_32);
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src2_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_32);
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);

        // Load src1 upper part
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)) + SIZE_OF_YMM, OPSZ_32);

        // Load src2 lower and upper parts to spill registers
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_lower,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)), OPSZ_32);
        instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)) + SIZE_OF_YMM, OPSZ_32);

        // Perform operations
        instr_t *i9 = instr_create_1dst_2src(dcontext, OP_vpaddd, opnd_create_reg(spill_dst_lower),
                                             opnd_create_reg(src1_reg_lower), opnd_create_reg(spill_src2_lower));
        instr_t *i10 = instr_create_1dst_2src(dcontext, OP_vpaddd, opnd_create_reg(dst_reg_upper),
                                              opnd_create_reg(src1_reg_upper), opnd_create_reg(src2_reg_upper));

        // Store results to dst TLS slots
        instr_t *i11 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_32);
        instr_t *i12 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper,
                                              TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_32);

        // Restore spill registers
        instr_t *i13 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_lower)), OPSZ_32);
        instr_t *i14 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_32);
        instr_t *i15 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_32);
        instr_t *i16 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_32);
        instr_t *i17 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 17, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17);
#endif
        instrlist_concat_next_instr(ilist, 17, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17);
        return i1;
    } break;
    case 7: { /* all src1, src2 and dst need spill */
        src1_reg_lower = ZMM_TO_YMM(src1_reg);
        src2_reg_lower = ZMM_TO_YMM(src2_reg);
        dst_reg_lower = ZMM_TO_YMM(dst_reg);

        // Find spill registers - all registers need special handling
        reg_id_t spill_src1_lower =
            find_available_spill_ymm_avoiding_variadic(3, src1_reg_lower, src2_reg_lower, dst_reg_lower);
        reg_id_t spill_src2_lower = find_available_spill_ymm_avoiding_variadic(4, src1_reg_lower, src2_reg_lower,
                                                                               dst_reg_lower, spill_src1_lower);
        reg_id_t spill_dst_lower = find_available_spill_ymm_avoiding_variadic(
            5, src1_reg_lower, src2_reg_lower, dst_reg_lower, spill_src1_lower, spill_src2_lower);
        src1_reg_upper = find_available_spill_ymm_avoiding_variadic(
            6, src1_reg_lower, src2_reg_lower, dst_reg_lower, spill_src1_lower, spill_src2_lower, spill_dst_lower);
        src2_reg_upper = find_available_spill_ymm_avoiding_variadic(7, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                    spill_src1_lower, spill_src2_lower, spill_dst_lower,
                                                                    src1_reg_upper);
        dst_reg_upper = find_available_spill_ymm_avoiding_variadic(8, src1_reg_lower, src2_reg_lower, dst_reg_lower,
                                                                   spill_src1_lower, spill_src2_lower, spill_dst_lower,
                                                                   src1_reg_upper, src2_reg_upper);

        // Save spill registers
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_lower)), OPSZ_32);
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_lower)), OPSZ_32);
        instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_32);
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src1_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_32);
        instr_t *i5 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src2_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_32);
        instr_t *i6 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);

        // Load src1 lower and upper parts to spill registers
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_lower,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)), OPSZ_32);
        instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_reg)) + SIZE_OF_YMM, OPSZ_32);

        // Load src2 lower and upper parts to spill registers
        instr_t *i9 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_lower,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)), OPSZ_32);
        instr_t *i10 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_reg)) + SIZE_OF_YMM, OPSZ_32);

        // Perform operations
        instr_t *i11 = instr_create_1dst_2src(dcontext, OP_vpaddd, opnd_create_reg(spill_dst_lower),
                                              opnd_create_reg(spill_src1_lower), opnd_create_reg(spill_src2_lower));
        instr_t *i12 = instr_create_1dst_2src(dcontext, OP_vpaddd, opnd_create_reg(dst_reg_upper),
                                              opnd_create_reg(src1_reg_upper), opnd_create_reg(src2_reg_upper));

        // Store results to dst TLS slots
        instr_t *i13 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_32);
        instr_t *i14 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper,
                                              TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_32);

        // Restore spill registers
        instr_t *i15 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_lower)), OPSZ_32);
        instr_t *i16 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_lower)), OPSZ_32);
        instr_t *i17 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_lower,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_32);
        instr_t *i18 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg_upper)), OPSZ_32);
        instr_t *i19 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src2_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg_upper)), OPSZ_32);
        instr_t *i20 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg_upper,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 20, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20);
#endif
        instrlist_concat_next_instr(ilist, 20, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20);
        return i1;
    } break;
    }
    return NULL_INSTR;
    return NULL_INSTR;
}

/**
 * @brief rewrite vpaddd
 */
instr_t *
rw_func_vpaddd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src_opnd1 = instr_get_src(instr, 1); // %xyzmm{i}
    opnd_t src_opnd2 = instr_get_src(instr, 2); // %xyzmm{j}
    opnd_t dst_opnd = instr_get_dst(instr, 0);  // %xyzmm{k}
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpaddd", true, true, true, true);
#endif
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t src1_reg = opnd_get_reg(src_opnd1);
    reg_id_t src2_reg = opnd_get_reg(src_opnd2);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    if (IS_ZMM_REG(dst_reg))
        return vpaddd_zmm_and_zmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
    if (IS_YMM_REG(dst_reg))
        return vpaddd_ymm_and_ymm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
    if (IS_XMM_REG(dst_reg))
        return vpaddd_xmm_and_xmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
    REWRITE_INFO(STD_OUTF, "vpaddd pattern not support\n");
    return NULL_INSTR;
}

/* ==============================================
 *            Helper func for vpmovsxwd
 * ============================================= */

instr_t *
vpmovsxwd_zmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "vpmovsxwd_zmm_reg2reg_gen not implemented");
#endif
    return NULL_INSTR;
}

instr_t *
vpmovsxwd_ymm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src_need_spill_flag = NEED_SPILL_YMM(src_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_YMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src = opnd_create_reg(src_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // VEX.256.66.0F38.WIG 23 /r VPMOVSXWD ymm1, xmm2/m128
        instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vpmovsxwd, op_dst, op_src);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src need spill */
        reg_id_t src_spill_reg = find_one_available_spill_ymm(dst_reg);
        opnd_t op_src_spill = opnd_create_reg(src_spill_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // src_spill -> tls_slot(src_spill)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, src_spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_spill_reg)), OPSZ_32);
        // tls_slot(src) -> src_spill
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg)), OPSZ_32);
        // vpmovsxwd src_spill -> dst
        instr_t *i3 = INSTR_CREATE_vpmovsxwd(dcontext, op_dst, op_src_spill);
        // tls_slot(src_spill) -> src_spill
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_spill_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_spill_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        reg_id_t dst_spill_reg = find_one_available_spill_ymm(src_reg);
        opnd_t op_dst_spill = opnd_create_reg(dst_spill_reg);
        opnd_t op_src = opnd_create_reg(src_reg);

        // dst_spill -> tls_slot(dst_spill)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_spill_reg)), OPSZ_32);
        // vpmovsxwd src -> dst_spill
        instr_t *i2 = INSTR_CREATE_vpmovsxwd(dcontext, op_dst_spill, op_src);
        // dst_spill -> tls_slot(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls_slot(dst) -> dst_spill
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_spill_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_spill_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src and dst need spill */
        reg_id_t spill_reg = YMM_SPILL_SLOT0;
        opnd_t op_spill = opnd_create_reg(spill_reg);
        // spill -> tls_slot(spill)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_reg)), OPSZ_32);
        // tls_slot(src) -> spill
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg)), OPSZ_32);
        // vpmovsxwd spill -> spill
        instr_t *i3 = INSTR_CREATE_vpmovsxwd(dcontext, op_spill, op_spill);
        // spill -> tls_slot(dst)
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls_slot(spill) -> spill
        instr_t *i5 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    }
    return NULL_INSTR;
}

instr_t *
vpmovsxwd_xmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src_need_spill_flag = NEED_SPILL_XMM(src_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src = opnd_create_reg(src_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // VEX.128.66.0F38.WIG 23 /r VPMOVSXWD mm1, xmm2/m128
        instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vpmovsxwd, op_dst, op_src);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src need spill */
        reg_id_t src_spill_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t op_src_spill = opnd_create_reg(src_spill_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // src_spill -> tls_slot(src_spill)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, src_spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_spill_reg)), OPSZ_16);
        // tls_slot(src) -> src_spill
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_reg)), OPSZ_16);
        // vpmovsxwd src_spill -> dst
        instr_t *i3 = INSTR_CREATE_vpmovsxwd(dcontext, op_dst, op_src_spill);
        // tls_slot(src_spill) -> src_spill
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_spill_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_spill_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        reg_id_t dst_spill_reg = find_one_available_spill_xmm(src_reg);
        opnd_t op_dst_spill = opnd_create_reg(dst_spill_reg);
        opnd_t op_src = opnd_create_reg(src_reg);

        // dst_spill -> tls_slot(dst_spill)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_spill_reg)), OPSZ_16);
        // vpmovsxwd src -> dst_spill
        instr_t *i2 = INSTR_CREATE_vpmovsxwd(dcontext, op_dst_spill, op_src);
        // dst_spill -> tls_slot(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls_slot(dst) -> dst_spill
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_spill_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_spill_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src and dst need spill */
        reg_id_t spill_reg = XMM_SPILL_SLOT0;
        opnd_t op_spill = opnd_create_reg(spill_reg);
        // spill -> tls_slot(spill)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
        // tls_slot(src) -> spill
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_reg)), OPSZ_16);
        // vpmovsxwd spill -> spill
        instr_t *i3 = INSTR_CREATE_vpmovsxwd(dcontext, op_spill, op_spill);
        // spill -> tls_slot(dst)
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls_slot(spill) -> spill
        instr_t *i5 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    }
    return NULL_INSTR;
}

instr_t * /* 189 */
rw_func_vpmovsxwd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t mask_opnd = instr_get_src(instr, 0);
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    opnd_t src_opnd = instr_get_src(instr, 1); // %{x,y,z}mm or disp(base, index, scale)[nbyte]
    opnd_t dst_opnd = instr_get_dst(instr, 0); // %{x,y,z}mm
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpmovsxwd", true, true, false, true);
#endif
    switch (src_opnd.kind) {
    case REG_kind: {
        reg_id_t src_reg = opnd_get_reg(src_opnd);
        switch (dst_opnd.kind) {
        case REG_kind: {
            reg_id_t dst_reg = opnd_get_reg(dst_opnd);
            if (IS_YMM_REG(dst_reg))
                return vpmovsxwd_ymm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
            if (IS_XMM_REG(dst_reg))
                return vpmovsxwd_xmm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
            if (IS_ZMM_REG(dst_reg))
                return vpmovsxwd_zmm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
        } break;
        default: REWRITE_INFO(STD_OUTF, "vpmovsxwd pattern not support");
        }
    } break;
    default: REWRITE_INFO(STD_OUTF, "vpmovsxwd pattern not support");
    }
    return NULL_INSTR;
}

/* ==============================================
 *            Helper func for vpmovsxdq
 * ============================================= */

instr_t *
vpmovsxdq_zmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "vpmovsxdq_zmm_reg2reg_gen not implemented");
#endif
    return NULL_INSTR;
}

instr_t *
vpmovsxdq_ymm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src_need_spill_flag = NEED_SPILL_YMM(src_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_YMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src = opnd_create_reg_partial(src_reg, OPSZ_16);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // VEX.256.66.0F38.WIG 25 /r VPMOVSXDQ ymm1, xmm2/m128
        instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vpmovsxdq, op_dst, op_src);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src need spill */
        reg_id_t src_spill_reg = find_one_available_spill_ymm(dst_reg);
        opnd_t op_src_spill_xmm = opnd_create_reg_partial(src_spill_reg, OPSZ_16);
        opnd_t op_dst = opnd_create_reg(dst_reg);

        // src_spill -> tls_slot(src_spill)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, src_spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_spill_reg)), OPSZ_32);
        // tls_slot(src) -> src_spill
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg)), OPSZ_32);
        // vpmovsxdq src_spill -> dst
        instr_t *i3 = INSTR_CREATE_vpmovsxdq(dcontext, op_dst, op_src_spill_xmm);
        // tls_slot(src_spill) -> src_spill
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_spill_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_spill_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        reg_id_t dst_spill_reg = find_one_available_spill_ymm(src_reg);
        opnd_t op_dst_spill = opnd_create_reg(dst_spill_reg);
        opnd_t op_src = opnd_create_reg_partial(src_reg, OPSZ_16);

        // dst_spill -> tls_slot(dst_spill)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_spill_reg)), OPSZ_32);
        // vpmovsxdq src_xmm -> dst_spill
        instr_t *i2 = INSTR_CREATE_vpmovsxdq(dcontext, op_dst_spill, op_src);
        // dst_spill -> tls_slot(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls_slot(dst) -> dst_spill
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_spill_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_spill_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src and dst need spill */
        reg_id_t spill_reg = YMM_SPILL_SLOT0;
        opnd_t op_spill = opnd_create_reg(spill_reg);
        opnd_t op_spill_xmm = opnd_create_reg_partial(spill_reg, OPSZ_16);

        // spill -> tls_slot(spill)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_reg)), OPSZ_32);
        // tls_slot(src) -> spill
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg)), OPSZ_32);
        // vpmovsxdq spill -> spill
        instr_t *i3 = INSTR_CREATE_vpmovsxdq(dcontext, op_spill, op_spill_xmm);
        // spill -> tls_slot(dst)
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls_slot(spill) -> spill
        instr_t *i5 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    }
    return NULL_INSTR;
}

instr_t *
vpmovsxdq_xmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src_need_spill_flag = NEED_SPILL_XMM(src_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src = opnd_create_reg(src_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // VEX.128.66.0F38.WIG 23 /r VPMOVSXWD mm1, xmm2/m128
        instr_t *i1 = INSTR_CREATE_vpmovsxdq(dcontext, op_dst, op_src);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src need spill */
        reg_id_t src_spill_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t op_src_spill = opnd_create_reg(src_spill_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // src_spill -> tls_slot(src_spill)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, src_spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_spill_reg)), OPSZ_16);
        // tls_slot(src) -> src_spill
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_reg)), OPSZ_16);
        // vpmovsxwd src_spill -> dst
        instr_t *i3 = INSTR_CREATE_vpmovsxdq(dcontext, op_dst, op_src_spill);
        // tls_slot(src_spill) -> src_spill
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_spill_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_spill_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        reg_id_t dst_spill_reg = find_one_available_spill_xmm(src_reg);
        opnd_t op_dst_spill = opnd_create_reg(dst_spill_reg);
        opnd_t op_src = opnd_create_reg(src_reg);

        // dst_spill -> tls_slot(dst_spill)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_spill_reg)), OPSZ_16);
        // vpmovsxwd src -> dst_spill
        instr_t *i2 = INSTR_CREATE_vpmovsxdq(dcontext, op_dst_spill, op_src);
        // dst_spill -> tls_slot(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls_slot(dst) -> dst_spill
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_spill_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_spill_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src and dst need spill */
        reg_id_t spill_reg = XMM_SPILL_SLOT0;
        opnd_t op_spill = opnd_create_reg(spill_reg);
        // spill -> tls_slot(spill)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
        // tls_slot(src) -> spill
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_reg)), OPSZ_16);
        // vpmovsxwd spill -> spill
        instr_t *i3 = INSTR_CREATE_vpmovsxdq(dcontext, op_spill, op_spill);
        // spill -> tls_slot(dst)
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls_slot(spill) -> spill
        instr_t *i5 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    }
    return NULL_INSTR;
}

instr_t * /* 191 */
rw_func_vpmovsxdq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t mask_opnd = instr_get_src(instr, 0);
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    opnd_t src_opnd = instr_get_src(instr, 1); // %{x,y,z}mm or disp(base, index, scale)[nbyte]
    opnd_t dst_opnd = instr_get_dst(instr, 0); // %{x,y,z}mm
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpmovsxdq", true, true, false, true);
#endif
    switch (src_opnd.kind) {
    case REG_kind: {
        reg_id_t src_reg = opnd_get_reg(src_opnd);
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_YMM_REG(dst_reg))
            return vpmovsxdq_ymm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
        if (IS_XMM_REG(dst_reg))
            return vpmovsxdq_xmm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
        if (IS_ZMM_REG(dst_reg))
            return vpmovsxdq_zmm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
    }
    case BASE_DISP_kind: {
    } break;
    default: REWRITE_INFO(STD_OUTF, "vpmovsxdq pattern not support");
    }
    return NULL_INSTR;
}

/* ==============================================
 *            Helper func for vpmovzxbw
 * ============================================= */

instr_t *
vpmovzxbw_zmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "vmovzxbw_zmm_reg2reg_gen not implemented");
#endif
    return NULL_INSTR;
}

instr_t *
vpmovzxbw_ymm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src_need_spill_flag = NEED_SPILL_YMM(src_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_YMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src = opnd_create_reg(src_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // VEX.256.66.0F38.WIG 23 /r VPMOVSXWD ymm1, xmm2/m128
        instr_t *i1 = INSTR_CREATE_vpmovzxbw(dcontext, op_dst, op_src);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src need spill */
        reg_id_t src_spill_reg = find_one_available_spill_ymm(dst_reg);
        opnd_t op_src_spill = opnd_create_reg(src_spill_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // src_spill -> tls_slot(src_spill)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, src_spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_spill_reg)), OPSZ_32);
        // tls_slot(src) -> src_spill
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg)), OPSZ_32);
        // vpmovsxwd src_spill -> dst
        instr_t *i3 = INSTR_CREATE_vpmovzxbw(dcontext, op_dst, op_src_spill);
        // tls_slot(src_spill) -> src_spill
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_spill_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_spill_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        reg_id_t dst_spill_reg = find_one_available_spill_ymm(src_reg);
        opnd_t op_dst_spill = opnd_create_reg(dst_spill_reg);
        opnd_t op_src = opnd_create_reg(src_reg);

        // dst_spill -> tls_slot(dst_spill)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_spill_reg)), OPSZ_32);
        // vpmovsxwd src -> dst_spill
        instr_t *i2 = INSTR_CREATE_vpmovzxbw(dcontext, op_dst_spill, op_src);
        // dst_spill -> tls_slot(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls_slot(dst) -> dst_spill
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_spill_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_spill_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src and dst need spill */
        reg_id_t spill_reg = YMM_SPILL_SLOT0;
        opnd_t op_spill = opnd_create_reg(spill_reg);
        // spill -> tls_slot(spill)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_reg)), OPSZ_32);
        // tls_slot(src) -> spill
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg)), OPSZ_32);
        // vpmovsxwd spill -> spill
        instr_t *i3 = INSTR_CREATE_vpmovzxbw(dcontext, op_spill, op_spill);
        // spill -> tls_slot(dst)
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls_slot(spill) -> spill
        instr_t *i5 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    }
    return NULL_INSTR;
}

instr_t *
vpmovzxbw_xmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src_need_spill_flag = NEED_SPILL_XMM(src_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t src_opnd = opnd_create_reg(src_reg);
        opnd_t dst_opnd = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vpmovzxbw, dst_opnd, src_opnd);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src need spill */
        opnd_t dst_opnd = opnd_create_reg(dst_reg);
        reg_id_t spill_src_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t spill_src_opnd = opnd_create_reg(spill_src_reg);
        // spill_src -> tls(spill_src)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src_reg)), OPSZ_16);
        // tls(src) -> spill_src
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_reg)), OPSZ_16);
        // vpmovzxbw
        instr_t *i3 = INSTR_CREATE_vpmovzxbw(dcontext, dst_opnd, spill_src_opnd);
        // tls(spill_src) -> spill_src
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        opnd_t src_opnd = opnd_create_reg(src_reg);
        reg_id_t spill_dst_reg = find_one_available_spill_xmm(src_reg);
        opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);

        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vpmovzxbw
        instr_t *i2 = INSTR_CREATE_vpmovzxbw(dcontext, spill_dst_opnd, src_opnd);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src and dst need spill */
        reg_id_t xmm_tmp_reg = XMM_SPILL_SLOT0;
        opnd_t op_xmm_tmp = opnd_create_reg(xmm_tmp_reg);

        // tmp -> tls(tmp)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_tmp_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_tmp_reg)), OPSZ_16);
        // tls(src) -> tmp
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_tmp_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_reg)), OPSZ_16);
        // vpmovzxbw tmp -> tmp
        instr_t *i3 = INSTR_CREATE_vpmovzxbw(dcontext, op_xmm_tmp, op_xmm_tmp);
        // tmp -> tls(dst)
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_tmp_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(tmp) -> tmp
        instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_tmp_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_tmp_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    }
    return NULL_INSTR;
}

/**
 * @brief rewrite vpmovzxbw
 * vpmovzxbw {%k0} %xmm7[8byte] -> %xmm16
 */
instr_t * /* 196 */
rw_func_vpmovzxbw(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t mask_opnd = instr_get_src(instr, 0);
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    opnd_t src_opnd = instr_get_src(instr, 1); // %{x,y,z}mm or disp(base, index, scale)[nbyte]
    opnd_t dst_opnd = instr_get_dst(instr, 0); // %{x,y,z}mm
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpmovzxbw", true, true, false, true);
#endif
    switch (src_opnd.kind) {
    case REG_kind: {
        reg_id_t src_reg = opnd_get_reg(src_opnd);
        switch (dst_opnd.kind) {
        case REG_kind: {
            reg_id_t dst_reg = opnd_get_reg(dst_opnd);
            if (IS_ZMM_REG(dst_reg))
                return vpmovzxbw_zmm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
            if (IS_YMM_REG(dst_reg))
                return vpmovzxbw_ymm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
            if (IS_XMM_REG(dst_reg))
                return vpmovzxbw_xmm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
        } break;
        default: REWRITE_INFO(STD_OUTF, "vpmovzxbw pattern not support");
        }
    } break;
    default: REWRITE_INFO(STD_OUTF, "vpmovzxbw pattern not support");
    }
    return NULL_INSTR;
}

/**
 * @brief rewrite vpmovzxbd
 */
instr_t * /* 197 */
rw_func_vpmovzxbd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    return NULL_INSTR;
}

/**
 * @brief rewrite vpmovzxbq
 */
instr_t * /* 198 */
rw_func_vpmovzxbq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    return NULL_INSTR;
}

/* ==============================================
 *           Helper func for vpmovaxwd
 * ============================================= */

instr_t *
vpmovzxwd_zmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "vmovzxwd_zmm_reg2reg_gen not implemented");
#endif
    return NULL_INSTR;
}

instr_t *
vpmovzxwd_ymm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{
    opnd_t src_opnd = create_mapping_ymm_opnd(dcontext, src_reg);
    opnd_t dst_opnd = create_mapping_ymm_opnd(dcontext, dst_reg);
    instr_t *new_instr1 = instr_create_1dst_1src(dcontext, OP_vpmovzxwd, dst_opnd, src_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vpmovzxwd_xmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{
    const uint src_need_spill_flag = NEED_SPILL_XMM(src_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src_need_spill_flag | dst_need_spill_flag;

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    switch (need_spill_flag) {
    case 0: { // no need spill, both src and dst are xyzmm0~xyzmm15
        opnd_t op_src = opnd_create_reg(src_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = INSTR_CREATE_vpmovzxwd(dcontext, op_dst, op_src);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { // src need spill
        opnd_t op_dst = opnd_create_reg(dst_reg);
        reg_id_t spill_src_reg = find_one_available_spill_xmm(src_reg);
        opnd_t op_src_spill = opnd_create_reg(spill_src_reg);

        // spill_src_reg -> tls(spill_src_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src_reg)), OPSZ_16);
        // tls(src_reg) -> spill_src_reg
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_reg)), OPSZ_16);
        // rewrite instr
        instr_t *i3 = INSTR_CREATE_vpmovzxwd(dcontext, op_dst, op_src_spill);
        // tls(spill_src_reg) -> spill_src_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { // dst need spill
        opnd_t op_src = opnd_create_reg(src_reg);
        reg_id_t spill_dst_reg = find_one_available_spill_xmm(src_reg);
        opnd_t op_dst_spill = opnd_create_reg(spill_dst_reg);

        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // rewrite instr
        instr_t *i2 = INSTR_CREATE_vpmovzxwd(dcontext, op_dst_spill, op_src);
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);

        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        return i1;
    } break;
    case 3: { // both need spill
        reg_id_t xmm_tmp_reg = XMM_SPILL_SLOT0;
        opnd_t op_xmm_tmp = opnd_create_reg(xmm_tmp_reg);

        // tmp -> tls(tmp)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_tmp_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_tmp_reg)), OPSZ_16);
        // tls(src) -> tmp
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_tmp_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_reg)), OPSZ_16);
        // vpmovzxwd tmp -> tmp
        instr_t *i3 = INSTR_CREATE_vpmovzxwd(dcontext, op_xmm_tmp, op_xmm_tmp);
        // tmp -> tls(dst)
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_tmp_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(tmp) -> tmp
        instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_tmp_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_tmp_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    }
    return NULL_INSTR;
}

/**
 * @brief rewrite vpmovzxwd
 */
instr_t * /* 199 */
rw_func_vpmovzxwd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t mask_opnd = instr_get_src(instr, 0);
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    opnd_t src_opnd = instr_get_src(instr, 1); // %{x,y,z}mm or disp(base, index, scale)[nbyte]
    opnd_t dst_opnd = instr_get_dst(instr, 0); // %{x,y,z}mm
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpmovzxwd", true, true, false, true);
#endif
    switch (src_opnd.kind) {
    case REG_kind: {
        reg_id_t src_reg = opnd_get_reg(src_opnd);
        switch (dst_opnd.kind) {
        case REG_kind: {
            reg_id_t dst_reg = opnd_get_reg(dst_opnd);
            if (IS_YMM_REG(dst_reg))
                return vpmovzxwd_ymm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
            if (IS_XMM_REG(dst_reg))
                return vpmovzxwd_xmm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
            if (IS_ZMM_REG(dst_reg))
                return vpmovzxwd_zmm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
        } break;
        default: REWRITE_INFO(STD_OUTF, "vpmovzxwd pattern not support");
        }
    } break;
    default: REWRITE_INFO(STD_OUTF, "vpmovzxwd pattern not support");
    }
    return NULL_INSTR;
}

/**
 * @brief rewrite vpmovzxwq
 */
instr_t * /* 200 */
rw_func_vpmovzxwq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    return NULL_INSTR;
}

/* ==============================================
 *    Helper func for vpmovaxdq
 * ============================================= */

instr_t *
vpmovzxdq_zmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "vmovzxdq_zmm_reg2reg_gen not implemented");
#endif
    return NULL_INSTR;
}

instr_t *
vpmovzxdq_ymm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src_need_spill = NEED_SPILL_YMM(src_reg) ? 1 : 0;
    const uint dst_need_spill = NEED_SPILL_YMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src_need_spill | dst_need_spill;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src = opnd_create_reg(src_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = INSTR_CREATE_vpmovzxdq(dcontext, op_dst, op_src);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src need spill */
        opnd_t op_dst = opnd_create_reg(dst_reg);
        reg_id_t spill_src_reg = find_one_available_spill_ymm(dst_reg);
        opnd_t op_src_spill = opnd_create_reg(spill_src_reg);

        // spill_src_reg -> tls(spill_src_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg)), OPSZ_32);
        // tls(src_reg) -> spill_src_reg
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg)), OPSZ_32);
        // vpmovzxdq spill_src_reg -> dst_reg
        instr_t *i3 = INSTR_CREATE_vpmovzxdq(dcontext, op_dst, op_src_spill);
        // tls(spill_src_reg) -> spill_src_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* dst need spill */
        opnd_t src_opnd = opnd_create_reg(src_reg);
        reg_id_t spill_dst_reg = find_one_available_spill_ymm(src_reg);
        opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);

        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        // vpmovzxdq src_reg -> spill_dst_reg
        instr_t *i2 = INSTR_CREATE_vpmovzxdq(dcontext, spill_dst_opnd, src_opnd);
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* src and dst need spill */
        // we don't need to care whether src and dst are the same register or not
        reg_id_t spill_tmp_reg = YMM_SPILL_SLOT0;
        opnd_t spill_tmp_opnd = opnd_create_reg(spill_tmp_reg);

        // spill_tmp_reg -> tls(spill_tmp_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_tmp_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_tmp_reg)), OPSZ_32);
        // tls(src_reg) -> spill_tmp_reg  get source
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_tmp_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg)), OPSZ_32);
        // vpmovzxdq spill_tmp_reg -> spill_tmp_reg
        instr_t *i3 = INSTR_CREATE_vpmovzxdq(dcontext, spill_tmp_opnd, spill_tmp_opnd);
        // spill_tmp_reg -> tls(dst_reg) | store destination
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_tmp_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls(spill_tmp_reg) -> spill_tmp_reg
        instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_tmp_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_tmp_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    default: {
        REWRITE_ERROR(STD_ERRF, "vpmovzxdq_ymm_reg2reg_gen not support pattern");
    }
        return NULL_INSTR;
    }
}

instr_t *
vpmovzxdq_xmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{

    const uint src_need_spill_flag = NEED_SPILL_XMM(src_reg) ? 1 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src_need_spill_flag | dst_need_spill_flag;

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    switch (need_spill_flag) {
    case 0: { // no need spill
        opnd_t src_opnd = opnd_create_reg(src_reg);
        opnd_t dst_opnd = opnd_create_reg(dst_reg);
        instr_t *i1 = INSTR_CREATE_vpmovzxdq(dcontext, dst_opnd, src_opnd);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { // src need spill
        opnd_t dst_opnd = opnd_create_reg(dst_reg);
        reg_id_t spill_src_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t spill_src_opnd = opnd_create_reg(spill_src_reg);

        // spill_src_reg -> tls(spill_src_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src_reg)), OPSZ_16);
        // tls(src_reg) -> spill_src_reg
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_reg)), OPSZ_16);
        // vpmovzxdq spill_src_reg -> dst_reg
        instr_t *i3 = INSTR_CREATE_vpmovzxdq(dcontext, dst_opnd, spill_src_opnd);
        // tls(spill_src_reg) -> spill_src_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { // dst need spill
        opnd_t src_opnd = opnd_create_reg(src_reg);
        reg_id_t spill_dst_reg = find_one_available_spill_xmm(src_reg);
        opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);

        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vpmovzxdq src_reg -> spill_dst_reg
        instr_t *i2 = INSTR_CREATE_vpmovzxdq(dcontext, spill_dst_opnd, src_opnd);
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);

        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        return i1;
    } break;
    case 3: { // both src and dst need spill
        reg_id_t spill_tmp_reg = XMM_SPILL_SLOT0;
        opnd_t spill_tmp_opnd = opnd_create_reg(spill_tmp_reg);

        // spill_tmp_reg -> tls(spill_tmp_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_tmp_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_tmp_reg)), OPSZ_16);
        // tls(src_reg) -> spill_tmp_reg | get source
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_tmp_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_reg)), OPSZ_16);
        // vpmovzxdq spill_tmp_reg -> spill_tmp_reg
        instr_t *i3 = INSTR_CREATE_vpmovzxdq(dcontext, spill_tmp_opnd, spill_tmp_opnd);
        // spill_tmp_reg -> tls(dst_reg) | store destination
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_tmp_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_tmp_reg) -> spill_tmp_reg
        instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_tmp_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_tmp_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    }
    return NULL_INSTR;
}

/**
 * @brief rewrite vpmovzxdq
 */
instr_t * /* 201 */
rw_func_vpmovzxdq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t mask_opnd = instr_get_src(instr, 0);
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    opnd_t src_opnd = instr_get_src(instr, 1); // %{x,y,z}mm or disp(base, index, scale)[nbyte]
    opnd_t dst_opnd = instr_get_dst(instr, 0); // %{x,y,z}mm
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpmovzxdq", true, true, false, true);
#endif
    switch (src_opnd.kind) {
    case REG_kind: {
        reg_id_t src_reg = opnd_get_reg(src_opnd);
        switch (dst_opnd.kind) {
        case REG_kind: {
            reg_id_t dst_reg = opnd_get_reg(dst_opnd);
            if (IS_XMM_REG(dst_reg))
                return vpmovzxdq_xmm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
            if (IS_YMM_REG(dst_reg))
                return vpmovzxdq_ymm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
            if (IS_ZMM_REG(dst_reg))
                return vpmovzxdq_zmm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
        } break;
        default: REWRITE_INFO(STD_OUTF, "vpmovzxdq pattern not support");
        }
    } break;
    default: REWRITE_INFO(STD_OUTF, "vpmovzxdq pattern not support");
    }
    return NULL_INSTR;
}

/* ==============================================
 *    Helper func for vpgatherdq
 * ============================================= */

instr_t *
vpgatherdq_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src1_opnd, reg_id_t dst1_reg,
                   reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpgatherdq_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src1_opnd, reg_id_t dst1_reg,
                   reg_id_t mask_reg)
{
    int k_idx = TO_K_REG_INDEX(mask_reg);
    reg_id_t index_ymm_reg = opnd_get_index(src1_opnd);

    reg_id_t base_gpr = opnd_get_base(src1_opnd);

    /* Select scratch registers */
    reg_id_t scratch_gpr_reg = DR_REG_R11;
    if (base_gpr == scratch_gpr_reg) {
        scratch_gpr_reg = DR_REG_R12;
    }
    reg_id_t scratch_ymm_mask = find_available_spill_ymm_avoiding_variadic(2, index_ymm_reg, dst1_reg);
    reg_id_t scratch_ymm_low = find_available_spill_ymm_avoiding_variadic(3, index_ymm_reg, dst1_reg, scratch_ymm_mask);
    reg_id_t scratch_ymm_high =
        find_available_spill_ymm_avoiding_variadic(4, index_ymm_reg, dst1_reg, scratch_ymm_mask, scratch_ymm_low);
    /* Corresponding XMM registers */
    reg_id_t scratch_xmm_mask = scratch_ymm_mask - DR_REG_YMM0 + DR_REG_XMM0;
    reg_id_t scratch_xmm_low = scratch_ymm_low - DR_REG_YMM0 + DR_REG_XMM0;
    reg_id_t scratch_xmm_high = scratch_ymm_high - DR_REG_YMM0 + DR_REG_XMM0;

    /* Operand wrapping */
    opnd_t gpr_opnd = opnd_create_reg(scratch_gpr_reg);
    // opnd_t gpr32_opnd   = opnd_create_reg(GPR64_TO_GPR32(scratch_gpr_reg));
    opnd_t xmm_mask_opnd = opnd_create_reg(scratch_xmm_mask);
    opnd_t ymm_mask_opnd = opnd_create_reg(scratch_ymm_mask);
    opnd_t xmm_low_opnd = opnd_create_reg(scratch_xmm_low);
    opnd_t ymm_low_opnd = opnd_create_reg(scratch_ymm_low);
    opnd_t xmm_high_opnd = opnd_create_reg(scratch_xmm_high);
    opnd_t ymm_high_opnd = opnd_create_reg(scratch_ymm_high);

    /* 1) Save caller-saved registers */
    instr_t *i1 = INSTR_CREATE_pushf(dcontext);
    instr_t *i2 = INSTR_CREATE_push(dcontext, gpr_opnd);
    instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, scratch_ymm_mask,
                                         TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(scratch_ymm_mask)), OPSZ_32);
    instr_t *i4 =
        SAVE_SIMD_TO_SIZED_TLS(dcontext, scratch_ymm_low, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(scratch_ymm_low)), OPSZ_32);
    instr_t *i5 = SAVE_SIMD_TO_SIZED_TLS(dcontext, scratch_ymm_high,
                                         TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(scratch_ymm_high)), OPSZ_32);

    /* 2) Load k register from TLS -> GPR -> XMM -> broadcast to YMM */
    instr_t *i6 = RESTORE_FROM_TLS(dcontext, scratch_gpr_reg, TLS_K_idx_SLOT(k_idx)); /* RAX  k */
    instr_t *i7 = INSTR_CREATE_vmovq(dcontext, xmm_mask_opnd, opnd_create_reg(scratch_gpr_reg));
    instr_t *i8 = instr_create_1dst_1src(dcontext, OP_vpbroadcastq, ymm_mask_opnd, xmm_mask_opnd);

    /* Clear destination dst1_reg to ensure gather generates 0 when mask is 0 */
    instr_t *i9 = instr_create_1dst_2src(dcontext, OP_vpxor, opnd_create_reg(dst1_reg), opnd_create_reg(dst1_reg),
                                         opnd_create_reg(dst1_reg));

    /* 3) Construct 4x64bit pattern {1,2,4,8} */
    /* Lower half (elements 0/1) */
    instr_t *i10 = INSTR_CREATE_mov_imm(dcontext, gpr_opnd, opnd_create_immed_int(1, OPSZ_8));
    instr_t *i11 =
        instr_create_1dst_2src(dcontext, OP_pinsrq, xmm_low_opnd, gpr_opnd, opnd_create_immed_int(0, OPSZ_1));
    instr_t *i12 = INSTR_CREATE_mov_imm(dcontext, gpr_opnd, opnd_create_immed_int(2, OPSZ_8));
    instr_t *i13 =
        instr_create_1dst_2src(dcontext, OP_pinsrq, xmm_low_opnd, gpr_opnd, opnd_create_immed_int(1, OPSZ_1));
    /* Upper half (elements 2/3) */
    instr_t *i14 = INSTR_CREATE_mov_imm(dcontext, gpr_opnd, opnd_create_immed_int(4, OPSZ_8));
    instr_t *i15 =
        instr_create_1dst_2src(dcontext, OP_pinsrq, xmm_high_opnd, gpr_opnd, opnd_create_immed_int(0, OPSZ_1));
    instr_t *i16 = INSTR_CREATE_mov_imm(dcontext, gpr_opnd, opnd_create_immed_int(8, OPSZ_8));
    instr_t *i17 =
        instr_create_1dst_2src(dcontext, OP_pinsrq, xmm_high_opnd, gpr_opnd, opnd_create_immed_int(1, OPSZ_1));
    /* Merge into complete 256bit pattern */
    instr_t *i18 = instr_create_1dst_3src(dcontext, OP_vinserti128, ymm_low_opnd, ymm_low_opnd, xmm_high_opnd,
                                          opnd_create_immed_int(1, OPSZ_1));

    /* 4) Mask AND pattern, then CMP -> all 1s/0s mask */
    instr_t *i19 = instr_create_1dst_2src(dcontext, OP_vpand, ymm_mask_opnd, ymm_mask_opnd, ymm_low_opnd);
    instr_t *i20 = instr_create_1dst_2src(dcontext, OP_vpxor, ymm_high_opnd, ymm_high_opnd, ymm_high_opnd);
    instr_t *i21 = instr_create_1dst_2src(dcontext, OP_vpcmpgtq, ymm_mask_opnd, ymm_mask_opnd, ymm_high_opnd);

    /* 5) Call AVX2 vpgatherdq */
    instr_t *i22 = INSTR_CREATE_vpgatherdq(dcontext, opnd_create_reg(dst1_reg), src1_opnd, ymm_mask_opnd);

    /* 6) Clear k-slot */
    instr_t *i23 = INSTR_CREATE_xor(dcontext, gpr_opnd, gpr_opnd);
    instr_t *i24 = SAVE_TO_TLS(dcontext, scratch_gpr_reg, TLS_K_idx_SLOT(k_idx));

    /* 7) Restore scratch registers & pop */
    instr_t *i25 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, scratch_ymm_high,
                                               TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(scratch_ymm_high)), OPSZ_32);
    instr_t *i26 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, scratch_ymm_low,
                                               TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(scratch_ymm_low)), OPSZ_32);
    instr_t *i27 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, scratch_ymm_mask,
                                               TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(scratch_ymm_mask)), OPSZ_32);
    instr_t *i28 = INSTR_CREATE_pop(dcontext, gpr_opnd);
    instr_t *i29 = INSTR_CREATE_popf(dcontext);

    /* Replace original instruction */
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    instrlist_concat_next_instr(ilist, 29, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17,
                                i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29);

    return i1;
}

instr_t *
vpgatherdq_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src1_opnd, reg_id_t dst1_reg,
                   reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 441 */
rw_func_vpgatherdq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{

    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src1_opnd = instr_get_src(instr, 1);
    opnd_t dst1_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting vpgatherdd at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, mask_opnd, "  mask:");
    dr_print_opnd(dcontext, STD_OUTF, src1_opnd, "  src1:");
    dr_print_opnd(dcontext, STD_OUTF, dst1_opnd, "  dst1:");
    // theoretically, dst2 is the mask_finished_opnd, and should be the same reg as mask_reg
    opnd_t mask_finished_opnd = instr_get_dst(instr, 1);
    dr_print_opnd(dcontext, STD_OUTF, mask_finished_opnd, "  dst2:");
#endif
    /* Method1: all into scalar */
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t dst1_reg = opnd_get_reg(dst1_opnd);
    if (IS_YMM_REG(dst1_reg)) {
        return vpgatherdq_ymm_gen(dcontext, ilist, instr, src1_opnd, dst1_reg, mask_reg);
    }
    if (IS_XMM_REG(dst1_reg)) {
        return vpgatherdq_xmm_gen(dcontext, ilist, instr, src1_opnd, dst1_reg, mask_reg);
    }
    if (IS_ZMM_REG(dst1_reg)) {
        return vpgatherdq_zmm_gen(dcontext, ilist, instr, src1_opnd, dst1_reg, mask_reg);
    }
    return NULL_INSTR;
}

/* ==============================================
 *    Helper func for vpgatherdd
 * ============================================= */

instr_t *
vpgatherdd_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src1_opnd, reg_id_t dst1_reg,
                   reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpgatherdd_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src1_opnd, reg_id_t dst1_reg,
                   reg_id_t mask_reg)
{
    /* vpgatherdd {%k5} (%rdi,%ymm1,4)[4byte] -> %ymm3 %k5
         mask: %k5
         src1: (%rdi,%ymm1,4)
         dst1: %ymm3
         dst2: %k5
    */
    int k_idx = TO_K_REG_INDEX(mask_reg);

    /* ---- basic sizes & bookkeeping ---- */
    // opnd_size_t scalar_index_size = OPSZ_4;
    // opnd_size_t scalar_value_size = OPSZ_4;

    reg_id_t index_ymm_reg = opnd_get_index(src1_opnd);
    reg_id_t base_gpr = opnd_get_base(src1_opnd);

    /* ---- scratch register selection ---- */
    reg_id_t scratch_gpr_reg = DR_REG_RAX;
    if (scratch_gpr_reg == base_gpr) {
        scratch_gpr_reg = DR_REG_RBX;
    }
    reg_id_t scratch_ymm_mask_reg = find_available_spill_ymm_avoiding_variadic(2, index_ymm_reg, dst1_reg);
    reg_id_t scratch_ymm_lower_reg =
        find_available_spill_ymm_avoiding_variadic(3, index_ymm_reg, dst1_reg, scratch_ymm_mask_reg);
    reg_id_t scratch_ymm_upper_reg = find_available_spill_ymm_avoiding_variadic(
        4, index_ymm_reg, dst1_reg, scratch_ymm_mask_reg, scratch_ymm_lower_reg);

#ifdef DEBUG
    print_file(STD_OUTF, "scratch_ymm_mask_reg:  ymm%d\n", scratch_ymm_mask_reg - DR_REG_YMM0);
    print_file(STD_OUTF, "scratch_ymm_lower_reg: ymm%d\n", scratch_ymm_lower_reg - DR_REG_YMM0);
    print_file(STD_OUTF, "scratch_ymm_upper_reg: ymm%d\n", scratch_ymm_upper_reg - DR_REG_YMM0);
#endif

    /* xmm counterparts */
    reg_id_t scratch_xmm_mask_reg = scratch_ymm_mask_reg - DR_REG_YMM0 + DR_REG_XMM0;
    reg_id_t scratch_xmm_lower_reg = scratch_ymm_lower_reg - DR_REG_YMM0 + DR_REG_XMM0;
    reg_id_t scratch_xmm_upper_reg = scratch_ymm_upper_reg - DR_REG_YMM0 + DR_REG_XMM0;

    /* handy opnds */
    opnd_t gpr_opnd = opnd_create_reg(scratch_gpr_reg);
    opnd_t gpr32_opnd = opnd_create_reg(GPR64_TO_GPR32(scratch_gpr_reg));
    opnd_t xmm_mask_opnd = opnd_create_reg(scratch_xmm_mask_reg);
    opnd_t ymm_mask_opnd = opnd_create_reg(scratch_ymm_mask_reg);
    opnd_t xmm_lower_opnd = opnd_create_reg(scratch_xmm_lower_reg);
    opnd_t ymm_lower_opnd = opnd_create_reg(scratch_ymm_lower_reg);
    opnd_t xmm_upper_opnd = opnd_create_reg(scratch_xmm_upper_reg);
    opnd_t ymm_upper_opnd = opnd_create_reg(scratch_ymm_upper_reg);

    /* ---- 1) save caller-live scratch regs ---- */
    instr_t *i1 = INSTR_CREATE_pushf(dcontext);
    instr_t *i2 = INSTR_CREATE_push(dcontext, gpr_opnd);
    instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, scratch_ymm_mask_reg,
                                         TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(scratch_ymm_mask_reg)), OPSZ_32);
    instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, scratch_ymm_lower_reg,
                                         TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(scratch_ymm_lower_reg)), OPSZ_32);
    instr_t *i5 = SAVE_SIMD_TO_SIZED_TLS(dcontext, scratch_ymm_upper_reg,
                                         TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(scratch_ymm_upper_reg)), OPSZ_32);

    /* ---- 2) read k-mask -> broadcast -> ymm_mask_reg ---- */
    instr_t *i6 = RESTORE_FROM_TLS(dcontext, scratch_gpr_reg, TLS_K_idx_SLOT(k_idx)); /* RAX  k-slot */

    /* vmovd xmm_mask, eax  (lower 32 bits are enough) */
    instr_t *i7 = INSTR_CREATE_vmovd(dcontext, xmm_mask_opnd, opnd_create_reg(DR_REG_EAX));

    /* vpbroadcastd ymm_mask, xmm_mask */
    instr_t *i8 = instr_create_1dst_1src(dcontext, OP_vpbroadcastd, ymm_mask_opnd, xmm_mask_opnd);

    /* ---- 3) build the lane pattern [1..128] in two halves ---- */
    /* lower 128 bits: 1,2,4,8 */
    // 1
    instr_t *i9 = INSTR_CREATE_mov_imm(dcontext, gpr32_opnd, opnd_create_immed_int(0x01, OPSZ_4));
    instr_t *i10 =
        instr_create_1dst_2src(dcontext, OP_pinsrd, xmm_lower_opnd, gpr32_opnd, opnd_create_immed_int(0x0, OPSZ_1));
    // 2
    instr_t *i11 = INSTR_CREATE_mov_imm(dcontext, gpr32_opnd, opnd_create_immed_int(0x02, OPSZ_4));
    instr_t *i12 =
        instr_create_1dst_2src(dcontext, OP_pinsrd, xmm_lower_opnd, gpr32_opnd, opnd_create_immed_int(0x1, OPSZ_1));
    // 4
    instr_t *i13 = INSTR_CREATE_mov_imm(dcontext, gpr32_opnd, opnd_create_immed_int(0x04, OPSZ_4));
    instr_t *i14 =
        instr_create_1dst_2src(dcontext, OP_pinsrd, xmm_lower_opnd, gpr32_opnd, opnd_create_immed_int(0x2, OPSZ_1));
    // 8
    instr_t *i15 = INSTR_CREATE_mov_imm(dcontext, gpr32_opnd, opnd_create_immed_int(0x08, OPSZ_4));
    instr_t *i16 =
        instr_create_1dst_2src(dcontext, OP_pinsrd, xmm_lower_opnd, gpr32_opnd, opnd_create_immed_int(0x3, OPSZ_1));

    /* upper 128 bits: 16,32,64,128 */
    // 16
    instr_t *i17 = INSTR_CREATE_mov_imm(dcontext, gpr32_opnd, opnd_create_immed_int(0x10, OPSZ_4));
    instr_t *i18 =
        instr_create_1dst_2src(dcontext, OP_pinsrd, xmm_upper_opnd, gpr32_opnd, opnd_create_immed_int(0x0, OPSZ_1));
    // 32
    instr_t *i19 = INSTR_CREATE_mov_imm(dcontext, gpr32_opnd, opnd_create_immed_int(0x20, OPSZ_4));
    instr_t *i20 =
        instr_create_1dst_2src(dcontext, OP_pinsrd, xmm_upper_opnd, gpr32_opnd, opnd_create_immed_int(0x1, OPSZ_1));
    // 64
    instr_t *i21 = INSTR_CREATE_mov_imm(dcontext, gpr32_opnd, opnd_create_immed_int(0x40, OPSZ_4));
    instr_t *i22 =
        instr_create_1dst_2src(dcontext, OP_pinsrd, xmm_upper_opnd, gpr32_opnd, opnd_create_immed_int(0x2, OPSZ_1));
    // 128
    instr_t *i23 = INSTR_CREATE_mov_imm(dcontext, gpr32_opnd, opnd_create_immed_int(0x80, OPSZ_4));
    instr_t *i24 =
        instr_create_1dst_2src(dcontext, OP_pinsrd, xmm_upper_opnd, gpr32_opnd, opnd_create_immed_int(0x3, OPSZ_1));

    /* merge halves: YMM_lower  [lower128|upper128] */
    instr_t *i25 = instr_create_1dst_3src(dcontext, OP_vinserti128, ymm_lower_opnd, ymm_lower_opnd, xmm_upper_opnd,
                                          opnd_create_immed_int(0x1, OPSZ_1)); /* insert as upper half */

    /* ---- 4) transform k value to all-1/all-0 YMM mask ---- */
    instr_t *i26 = instr_create_1dst_2src(dcontext, OP_vpand, ymm_mask_opnd, ymm_mask_opnd, ymm_lower_opnd);

    instr_t *i27 =
        instr_create_1dst_2src(dcontext, OP_vpxor, ymm_upper_opnd, ymm_upper_opnd, ymm_upper_opnd); /* ymm_upper = 0 */

    instr_t *i28 = instr_create_1dst_2src(dcontext, OP_vpcmpgtd, ymm_mask_opnd, ymm_mask_opnd,
                                          ymm_upper_opnd); /* >0 ? 0xFFFFFFFF:0 */

    /* ---- 5) actual AVX2 gather ---- */
    instr_t *i29 = INSTR_CREATE_vpgatherdd(dcontext, opnd_create_reg(dst1_reg), src1_opnd, ymm_mask_opnd);

    /* ---- 6) clear k-slot (matches original algorithm) ---- */
    instr_t *i30 = INSTR_CREATE_xor(dcontext, gpr_opnd, gpr_opnd);
    instr_t *i31 = SAVE_TO_TLS(dcontext, scratch_gpr_reg, TLS_K_idx_SLOT(k_idx));

    /* ---- 7) restore scratch regs ---- */
    instr_t *i32 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, scratch_ymm_upper_reg,
                                               TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(scratch_ymm_upper_reg)), OPSZ_32);
    instr_t *i33 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, scratch_ymm_lower_reg,
                                               TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(scratch_ymm_lower_reg)), OPSZ_32);
    instr_t *i34 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, scratch_ymm_mask_reg,
                                               TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(scratch_ymm_mask_reg)), OPSZ_32);
    instr_t *i35 = INSTR_CREATE_pop(dcontext, gpr_opnd);
    instr_t *i36 = INSTR_CREATE_popf(dcontext);

#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 36, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                 i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32, i33,
                                 i34, i35, i36);
#endif

    /* splice in & retire original */
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    instrlist_concat_next_instr(ilist, 36, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17,
                                i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32, i33, i34,
                                i35, i36);

    return i1; /* first new instruction */
}

instr_t *
vpgatherdd_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src1_opnd, reg_id_t dst1_reg,
                   reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
rw_func_vpgatherdd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src1_opnd = instr_get_src(instr, 1);
    opnd_t dst1_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting vpgatherdd at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, mask_opnd, "  mask:");
    dr_print_opnd(dcontext, STD_OUTF, src1_opnd, "  src1:");
    dr_print_opnd(dcontext, STD_OUTF, dst1_opnd, "  dst1:");
    // theoretically, dst2 is the mask_finished_opnd, and should be the same reg as mask_reg
    opnd_t mask_finished_opnd = instr_get_dst(instr, 1);
    dr_print_opnd(dcontext, STD_OUTF, mask_finished_opnd, "  dst2:");
#endif
    /* Method1: all into scalar */
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t dst1_reg = opnd_get_reg(dst1_opnd);
    if (IS_YMM_REG(dst1_reg)) {
        return vpgatherdd_ymm_gen(dcontext, ilist, instr, src1_opnd, dst1_reg, mask_reg);
    }
    if (IS_XMM_REG(dst1_reg)) {
        return vpgatherdd_xmm_gen(dcontext, ilist, instr, src1_opnd, dst1_reg, mask_reg);
    }
    if (IS_ZMM_REG(dst1_reg)) {
        return vpgatherdd_zmm_gen(dcontext, ilist, instr, src1_opnd, dst1_reg, mask_reg);
    }
    return NULL_INSTR;
}

/* ==============================================
 *    Helper func for vpgatherqq
 * ============================================= */

instr_t *
vpgatherqq_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src1_opnd, reg_id_t dst1_reg,
                   reg_id_t mask_reg)
{

    return NULL_INSTR;
}

instr_t *
vpgatherqq_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src1_opnd, reg_id_t dst1_reg,
                   reg_id_t mask_reg)
{
    /* vpgatherqq {%k3} (%rdi,%ymm5,8)[8byte] -> %ymm1 %k3
         mask: %k3
         src1: (%rdi,%ymm5,8)
         dst1: %ymm1
         dst2: %k3
    */

    int k_idx = TO_K_REG_INDEX(mask_reg);

    reg_id_t index_ymm_reg = opnd_get_index(src1_opnd);
    reg_id_t base_gpr = opnd_get_base(src1_opnd);

    // save: rax, ymm_mask_reg, ymm_lower_reg, ymm_upper_reg
    // e.g. for simplicity to explain the algorithm, which is not the ymm regs used in codegen. The true ymm regs uesd
    //      is determined by the find available ymm regs function.
    // we use ymm0 as the scratch ymm mask register
    // and ymm3 as the scratch ymm lane register

    reg_id_t scratch_gpr_reg = DR_REG_RAX;
    if (scratch_gpr_reg == base_gpr) {
        scratch_gpr_reg = DR_REG_RBX;
    }
    // ymm mask reg: used to mask the value in the VEX.256 vpgatherqq
    reg_id_t scratch_ymm_mask_reg = find_available_spill_ymm_avoiding_variadic(2, index_ymm_reg, dst1_reg);
    // xmm lower reg: used to tmp store the lower 128bits of mask value, we use ymm now since
    reg_id_t scratch_ymm_lower_reg =
        find_available_spill_ymm_avoiding_variadic(3, index_ymm_reg, dst1_reg, scratch_ymm_mask_reg);
    // xmm upper reg: used to tmp store the upper 128bits of mask value
    reg_id_t scratch_ymm_upper_reg = find_available_spill_ymm_avoiding_variadic(
        4, index_ymm_reg, dst1_reg, scratch_ymm_mask_reg, scratch_ymm_lower_reg);

#ifdef DEBUG
    print_file(STD_OUTF, "scratch_ymm_mask_reg: ymm%d\n", scratch_ymm_mask_reg - DR_REG_YMM0);
    print_file(STD_OUTF, "scratch_ymm_lower_reg: ymm%d\n", scratch_ymm_lower_reg - DR_REG_YMM0);
    print_file(STD_OUTF, "scratch_ymm_upper_reg: ymm%d\n", scratch_ymm_upper_reg - DR_REG_YMM0);
#endif

    // xmm counterpart of the ymm lower and upper reg
    reg_id_t scratch_xmm_mask_reg = scratch_ymm_mask_reg - DR_REG_YMM0 + DR_REG_XMM0;
    reg_id_t scratch_xmm_lower_reg = scratch_ymm_lower_reg - DR_REG_YMM0 + DR_REG_XMM0;
    reg_id_t scratch_xmm_upper_reg = scratch_ymm_upper_reg - DR_REG_YMM0 + DR_REG_XMM0;

    // opnds of scratch regs
    opnd_t scratch_gpr_opnd = opnd_create_reg(scratch_gpr_reg);
    opnd_t scratch_xmm_mask_opnd = opnd_create_reg(scratch_xmm_mask_reg);
    opnd_t scratch_ymm_mask_opnd = opnd_create_reg(scratch_ymm_mask_reg);
    opnd_t scratch_xmm_lower_opnd = opnd_create_reg(scratch_xmm_lower_reg);
    opnd_t scratch_ymm_lower_opnd = opnd_create_reg(scratch_ymm_lower_reg);
    opnd_t scratch_xmm_upper_opnd = opnd_create_reg(scratch_xmm_upper_reg);
    opnd_t scratch_ymm_upper_opnd = opnd_create_reg(scratch_ymm_upper_reg);

    /* save scratch regs */
    instr_t *new_instr0 = INSTR_CREATE_pushf(dcontext);
    instr_t *new_instr1 = INSTR_CREATE_push(dcontext, opnd_create_reg(scratch_gpr_reg));
    instr_t *new_instr2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, scratch_ymm_mask_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(scratch_ymm_mask_reg)), OPSZ_32);
    instr_t *new_instr3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, scratch_ymm_lower_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(scratch_ymm_lower_reg)), OPSZ_32);
    instr_t *new_instr4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, scratch_ymm_upper_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(scratch_ymm_upper_reg)), OPSZ_32);

    /* Read Mask value and broadcast to ymm mask reg */
    // tls to scratch gpr: rax
    // mov tls_slot(mask_reg) -> %rax
    instr_t *new_instr5 = RESTORE_FROM_TLS(dcontext, scratch_gpr_reg, TLS_K_idx_SLOT(k_idx));

    // tls to scratch ymm: ymm mask reg |  XMM2[63:0]  k3
    // vmovq tls_slot(mask_reg) -> %xmm_spill_reg; vmovq tls_slot(mask_reg) -> xmm2
    instr_t *new_instr6 = instr_create_1dst_1src(dcontext, OP_vmovq, scratch_xmm_mask_opnd,
                                                 opnd_create_tls_slot(os_tls_offset(TLS_K_idx_SLOT(k_idx))));

    // broadcast %xmm_mask_reg-> %ymm_mask_reg; vpbroadcastq xmm2, ymm2 | YMM2 = [k3,k3,k3,k3]
    instr_t *new_instr7 =
        instr_create_1dst_1src(dcontext, OP_vpbroadcastq, scratch_ymm_mask_opnd, scratch_xmm_mask_opnd);

    /* Use Register trick to construct the mask ymm register,
       two phase, one for lower 128bits, another for upper 128bits */
    // mov $1 -> %rax
    instr_t *new_instr8 = INSTR_CREATE_mov_imm(dcontext, scratch_gpr_opnd, opnd_create_immed_int(0x01, OPSZ_8));

    // pinsrq $0, %rax, %xmm3 | XMM3.qword[0]  1
    instr_t *new_instr9 = instr_create_1dst_2src(dcontext, OP_pinsrq, scratch_xmm_lower_opnd, scratch_gpr_opnd,
                                                 opnd_create_immed_int(0x0, OPSZ_1));

    // mov $2 -> %rax
    instr_t *new_instr10 = INSTR_CREATE_mov_imm(dcontext, scratch_gpr_opnd, opnd_create_immed_int(0x02, OPSZ_8));

    // pinsrq $1, %rax, %xmm3 | XMM3.qword[1]  2
    instr_t *new_instr11 = instr_create_1dst_2src(dcontext, OP_pinsrq, scratch_xmm_lower_opnd, scratch_gpr_opnd,
                                                  opnd_create_immed_int(0x1, OPSZ_1));

    // mov $4 -> %rax
    instr_t *new_instr12 = INSTR_CREATE_mov_imm(dcontext, scratch_gpr_opnd, opnd_create_immed_int(0x04, OPSZ_8));

    // pinsrq $0, %rax, %xmm4 | XMM4.qword[0]  4
    instr_t *new_instr13 = instr_create_1dst_2src(dcontext, OP_pinsrq, scratch_xmm_upper_opnd, scratch_gpr_opnd,
                                                  opnd_create_immed_int(0x2, OPSZ_1));

    // mov $8 -> %rax
    instr_t *new_instr14 = INSTR_CREATE_mov_imm(dcontext, scratch_gpr_opnd, opnd_create_immed_int(0x08, OPSZ_8));

    // pinsrq $1, %rax, %xmm4 | XMM4.qword[1]  8
    instr_t *new_instr15 = instr_create_1dst_2src(dcontext, OP_pinsrq, scratch_xmm_upper_opnd, scratch_gpr_opnd,
                                                  opnd_create_immed_int(0x3, OPSZ_1));

    /* merge the ymm lower and upper regs to the ymm mask reg */
    // VEX.256.66.0F3A.W0 38 /r ib VINSERTI128 ymm1, ymm2, xmm3/m128, imm8: Insert 128 bits of integer data from
    // xmm3/m128 and the remaining values from ymm2 into ymm1.
    // vinserti128 $0x1, %xmm4, %ymm3, %ymm3 // think about 0x0 or 0x1, 0 is to lower, 1 is to upper
    // YMM3[255:128]  XMM4, YMM3[127:0]  XMM3
    instr_t *new_instr16 =
        instr_create_1dst_3src(dcontext, OP_vinserti128, scratch_ymm_lower_opnd, scratch_ymm_lower_opnd,
                               scratch_xmm_upper_opnd, opnd_create_immed_int(0x1, OPSZ_1));
    // after this instr, ymm upper is not longer used, we can use it as a scratch reg

    /* generate all 1, all 0 mask ymm reg */
    // vpand %ymm3, %ymm2, %ymm2 | YMM2  YMM2  YMM3
    instr_t *new_instr17 = instr_create_1dst_2src(dcontext, OP_vpand, scratch_ymm_mask_opnd, scratch_ymm_mask_opnd,
                                                  scratch_ymm_lower_opnd);

    // vpxor %ymm4, %ymm4, %ym m4 | YMM4  YMM4  YMM4, here we resue ymm4, since it's not used
    instr_t *new_instr18 = instr_create_1dst_2src(dcontext, OP_vpxor, scratch_ymm_upper_opnd, scratch_ymm_upper_opnd,
                                                  scratch_ymm_upper_opnd);

    // vpcmpgtq %ymm4, %ymm2, %ymm2 | YMM2  YMM2 <cmp> YMM4
    //                                       src1       src2
    instr_t *new_instr19 = instr_create_1dst_2src(dcontext, OP_vpcmpgtq, scratch_ymm_mask_opnd, scratch_ymm_mask_opnd,
                                                  scratch_ymm_upper_opnd);

    // after this instr, ymm mask reg is set conform to the k register value, we can use avx2 vpgatherqq now
    instr_t *new_instr20 =
        INSTR_CREATE_vpgatherqq(dcontext, opnd_create_reg(dst1_reg), src1_opnd, scratch_ymm_mask_opnd);

    // xor %rax, %rax
    instr_t *new_instr21 = INSTR_CREATE_xor(dcontext, scratch_gpr_opnd, scratch_gpr_opnd);

    // mov %rax -> tls_slot(mask_reg)
    instr_t *new_instr22 = SAVE_TO_TLS(dcontext, scratch_gpr_reg, TLS_K_idx_SLOT(k_idx));

    instr_t *new_instr23 = RESTORE_SIMD_FROM_SIZED_TLS(
        dcontext, scratch_ymm_upper_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(scratch_ymm_upper_reg)), OPSZ_32);
    instr_t *new_instr24 = RESTORE_SIMD_FROM_SIZED_TLS(
        dcontext, scratch_ymm_lower_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(scratch_ymm_lower_reg)), OPSZ_32);
    instr_t *new_instr25 = RESTORE_SIMD_FROM_SIZED_TLS(
        dcontext, scratch_ymm_mask_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(scratch_ymm_mask_reg)), OPSZ_32);
    instr_t *new_instr26 = INSTR_CREATE_pop(dcontext, scratch_gpr_opnd);
    instr_t *new_instr27 = INSTR_CREATE_popf(dcontext);

#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 28, new_instr0, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5,
                                 new_instr6, new_instr7, new_instr8, new_instr9, new_instr10, new_instr11, new_instr12,
                                 new_instr13, new_instr14, new_instr15, new_instr16, new_instr17, new_instr18,
                                 new_instr19, new_instr20, new_instr21, new_instr22, new_instr23, new_instr24,
                                 new_instr25, new_instr26, new_instr27);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    instrlist_concat_next_instr(ilist, 28, new_instr0, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5,
                                new_instr6, new_instr7, new_instr8, new_instr9, new_instr10, new_instr11, new_instr12,
                                new_instr13, new_instr14, new_instr15, new_instr16, new_instr17, new_instr18,
                                new_instr19, new_instr20, new_instr21, new_instr22, new_instr23, new_instr24,
                                new_instr25, new_instr26, new_instr27);
    return new_instr0;
}

instr_t *
vpgatherqq_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src1_opnd, reg_id_t dst1_reg,
                   reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
rw_func_vpgatherqq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{

    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src1_opnd = instr_get_src(instr, 1);
    opnd_t dst1_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting vpgatherqq at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, mask_opnd, "  mask:");
    dr_print_opnd(dcontext, STD_OUTF, src1_opnd, "  src1:");
    dr_print_opnd(dcontext, STD_OUTF, dst1_opnd, "  dst1:");
    // theoretically, dst2 is the mask_finished_opnd, and should be the same reg as mask_reg
    opnd_t mask_finished_opnd = instr_get_dst(instr, 1);
    dr_print_opnd(dcontext, STD_OUTF, mask_finished_opnd, "  dst2:");
#endif
    /* Method1: all into scalar */
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t dst1_reg = opnd_get_reg(dst1_opnd);
    if (IS_YMM_REG(dst1_reg)) {
        return vpgatherqq_ymm_gen(dcontext, ilist, instr, src1_opnd, dst1_reg, mask_reg);
    }
    if (IS_XMM_REG(dst1_reg)) {
        return vpgatherqq_xmm_gen(dcontext, ilist, instr, src1_opnd, dst1_reg, mask_reg);
    }
    if (IS_ZMM_REG(dst1_reg)) {
        return vpgatherqq_zmm_gen(dcontext, ilist, instr, src1_opnd, dst1_reg, mask_reg);
    }
    return NULL_INSTR;
}

/* ==============================================
 *    Helper func for vpbroadcastb
 * ============================================= */

instr_t *
vpbroadcastb_zmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd, opnd_t dst_opnd,
                             reg_id_t src_reg, reg_id_t dst_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpbroadcastb_ymm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd, opnd_t dst_opnd,
                             reg_id_t src_reg, reg_id_t dst_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpbroadcastb_xmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd, opnd_t dst_opnd,
                             reg_id_t src_reg, reg_id_t dst_reg, reg_id_t mask_reg)
{
    // vpbroadcastb {%k0} %ebx -> %xmm2
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    if (mask_reg == DR_REG_K0) { // no mask needed
        instr_t *i1 = INSTR_CREATE_vpinsrb(dcontext, dst_opnd, dst_opnd, src_opnd, opnd_create_immed_int(0x0, OPSZ_1));
        instr_t *i2 = INSTR_CREATE_vpbroadcastb(dcontext, dst_opnd, dst_opnd);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 2, i1, i2);
#endif
        instrlist_concat_next_instr(ilist, 2, i1, i2);
        return i1;
    } else { // need mask
    }
    return NULL_INSTR;
}

instr_t *
vpbroadcastb_zmm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              opnd_t dst_opnd, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpbroadcastb_ymm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpbroadcastb_xmm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 464 */
rw_func_vpbroadcastb(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vpbroadcastb {%k0} %ebx -> %xmm2
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src_opnd = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpbroadcastb", true, true, false, true);
#endif
    switch (src_opnd.kind) {
    case REG_kind: { // vpbroadcast_d{%k0} %eax -> %xyzmm0
        reg_id_t src_reg = opnd_get_reg(src_opnd);
        if (IS_32GPR_REG(src_reg) || IS_64GPR_REG(src_reg)) {
            reg_id_t dst_reg = opnd_get_reg(dst_opnd);
            if (IS_XMM_REG(dst_reg)) { // %eax -> %xmm
                return vpbroadcastb_xmm_reg2reg_gen(dcontext, ilist, instr, src_opnd, dst_opnd, src_reg, dst_reg,
                                                    mask_reg);
            }
            if (IS_YMM_REG(dst_reg)) { // %eax -> %ymm
                return vpbroadcastb_ymm_reg2reg_gen(dcontext, ilist, instr, src_opnd, dst_opnd, src_reg, dst_reg,
                                                    mask_reg);
            }
            if (IS_ZMM_REG(dst_reg)) { // %eax -> %zmm
                return vpbroadcastb_zmm_reg2reg_gen(dcontext, ilist, instr, src_opnd, dst_opnd, src_reg, dst_reg,
                                                    mask_reg);
            }
        }
    } break;
    case BASE_DISP_kind: { // disp(base, index, scale)[1,2,4,8byte] -> %zmm{i}
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_XMM_REG(dst_reg)) {
            return vpbroadcastb_xmm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        }
        if (IS_YMM_REG(dst_reg)) {
            return vpbroadcastb_ymm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        }
        if (IS_ZMM_REG(dst_reg)) {
            return vpbroadcastb_zmm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_opnd, mask_reg);
        }
    } break;
    default: REWRITE_INFO(STD_OUTF, "vpbroadcastb pattern not support");
    }
    return NULL_INSTR;
}

/* ==============================================
 *    Helper func for vpbroadcastw
 * ============================================= */
instr_t *
vpbroadcastw_zmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                             reg_id_t src_reg, reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint dst_need_spill = NEED_SPILL_ZMM(dst_reg) ? 1 : 0;

    switch (dst_need_spill) {
    case 0: { // don't need spill
        reg_id_t dst_reg_lower = ZMM_TO_YMM(dst_reg);
        opnd_t op_dst_lower = opnd_create_reg(dst_reg_lower);
        opnd_t op_dst_xmm = opnd_create_reg(YMM_TO_XMM(dst_reg_lower));
        // vmovd src_opnd -> dst_xmm
        instr_t *i1 = INSTR_CREATE_vmovd(dcontext, op_dst_xmm, src_opnd);
        // vpbroadcastw dst_xmm -> dst_reg_lower
        instr_t *i2 = INSTR_CREATE_vpbroadcastw(dcontext, op_dst_lower, op_dst_xmm);
        // vmovdqu16 dst_reg_lower -> tls(dst_lower)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_16);
        // vmovdqu16 dst_reg_lower -> tls(dst_upper)
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_lower,
                                             TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 1: { // dst need spill
        reg_id_t spill_dst_lower = YMM_SPILL_SLOT0;
        opnd_t op_spill_dst_lower = opnd_create_reg(spill_dst_lower);
        opnd_t op_spill_dst_xmm = opnd_create_reg(YMM_TO_XMM(spill_dst_lower));

        // spill_dst_lower -> tls(spill_dst_lower)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_16);
        // vmovd src_opnd -> spill_dst_xmm
        instr_t *i2 = INSTR_CREATE_vmovd(dcontext, op_spill_dst_xmm, src_opnd);
        // vpbroadcastw spill_dst_xmm -> spill_dst_lower
        instr_t *i3 = INSTR_CREATE_vpbroadcastw(dcontext, op_spill_dst_lower, op_spill_dst_xmm);
        // vmovdqu16 spill_dst_lower -> tls(dst_lower)
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_16);
        // vmovdqu16 spill_dst_lower -> tls(dst_upper)
        instr_t *i5 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower,
                                             TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_16);
        // tls(spill_dst_lower) -> spill_dst_lower
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_lower,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 6, i1, i2, i3, i4, i5, i6);
#endif
        instrlist_concat_next_instr(ilist, 6, i1, i2, i3, i4, i5, i6);
        return i1;
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpbroadcastw_zmm_reg2reg_gen except 0 or 1"); return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t *
vpbroadcastw_ymm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                             reg_id_t src_reg, reg_id_t dst_reg, reg_id_t mask_reg)
{
    // vpbroadcastw {%k0} %r12d -> %ymm9
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint dst_need_spill = NEED_SPILL_YMM(dst_reg) ? 1 : 0;
    switch (dst_need_spill) {
    case 0: {
        opnd_t op_dst_ymm = opnd_create_reg(dst_reg);
        opnd_t op_dst_xmm = opnd_create_reg(YMM_TO_XMM(dst_reg));
        instr_t *i1 = INSTR_CREATE_vmovd(dcontext, op_dst_xmm, src_opnd);
        instr_t *i2 = INSTR_CREATE_vpbroadcastw(dcontext, op_dst_ymm, op_dst_xmm);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 2, i1, i2);
#endif
        instrlist_concat_next_instr(ilist, 2, i1, i2);
        return i1;
    } break;
    case 1: {
        reg_id_t spill_dst_reg = YMM_SPILL_SLOT0;
        opnd_t op_spill_dst_ymm = opnd_create_reg(spill_dst_reg);
        opnd_t op_spill_dst_xmm = opnd_create_reg(YMM_TO_XMM(spill_dst_reg));
        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vmovd
        instr_t *i2 = INSTR_CREATE_vmovd(dcontext, op_spill_dst_xmm, src_opnd);
        // vpbroadcastw
        instr_t *i3 = INSTR_CREATE_vpbroadcastw(dcontext, op_spill_dst_ymm, op_spill_dst_xmm);
        // spill_dst -> tls(dst)
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpbroadcastw pattern not supported");
    }
    return NULL_INSTR;
}

instr_t *
vpbroadcastw_xmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                             reg_id_t src_reg, reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint dst_need_spill = NEED_SPILL_XMM(dst_reg) ? 1 : 0;
    switch (dst_need_spill) {
    case 0: {
        opnd_t op_dst_xmm = opnd_create_reg(dst_reg);
        instr_t *i1 = INSTR_CREATE_vmovd(dcontext, op_dst_xmm, src_opnd);
        instr_t *i2 = INSTR_CREATE_vpbroadcastw(dcontext, op_dst_xmm, op_dst_xmm);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 2, i1, i2);
#endif
        instrlist_concat_next_instr(ilist, 2, i1, i2);
        return i1;
    } break;
    case 1: {
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
        opnd_t op_spill_dst_xmm = opnd_create_reg(spill_dst_reg);
        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vmovd
        instr_t *i2 = INSTR_CREATE_vmovd(dcontext, op_spill_dst_xmm, src_opnd);
        // vpbroadcastw
        instr_t *i3 = INSTR_CREATE_vpbroadcastw(dcontext, op_spill_dst_xmm, op_spill_dst_xmm);
        // spill_dst -> tls(dst)
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpbroadcastw pattern not supported");
    }
    return NULL_INSTR;
}

instr_t *
vpbroadcastw_zmm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              opnd_t dst_opnd, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    reg_id_t dst_reg = opnd_get_reg(dst_opnd); // dst_reg is now DR_REG_ZMM0

    const uint dst_need_spill = NEED_SPILL_ZMM(dst_reg) ? 1 : 0;

    switch (dst_need_spill) {
    case 0: { // don't need spill
        reg_id_t dst_reg_lower = ZMM_TO_YMM(dst_reg);
        opnd_t op_dst_lower = opnd_create_reg(dst_reg_lower);
        // vpbroadcastw src_opnd -> dst_reg_lower
        instr_t *i1 = INSTR_CREATE_vpbroadcastw(dcontext, op_dst_lower, src_opnd);
        // vmovdqu16 dst_reg_lower -> tls(dst_lower)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_16);
        // vmovdqu16 dst_reg_lower -> tls(dst_upper)
        instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_lower,
                                             TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 3, i1, i2, i3);
#endif
        instrlist_concat_next_instr(ilist, 3, i1, i2, i3);
        return i1;
    } break;
    case 1: { // dst need spill
        reg_id_t spill_dst_lower = YMM_SPILL_SLOT0;
        opnd_t op_spill_dst_lower = opnd_create_reg(spill_dst_lower);

        // spill_dst_lower -> tls(spill_dst_lower)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_16);
        // vpbroadcastw src_opnd -> spill_dst_lower
        instr_t *i2 = INSTR_CREATE_vpbroadcastw(dcontext, op_spill_dst_lower, src_opnd);
        // vmovdqu16 spill_dst_lower -> tls(dst_lower)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_16);
        // vmovdqu16 spill_dst_lower -> tls(dst_upper)
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower,
                                             TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_16);
        // tls(spill_dst_lower) -> spill_dst_lower
        instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_lower,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpbroadcastw_zmm_disp2reg_gen except 0 or 1"); return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t *
vpbroadcastw_ymm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint dst_need_spill = NEED_SPILL_YMM(dst_reg) ? 1 : 0;

    switch (dst_need_spill) {
    case 0: { // don't need spill
        opnd_t op_dst_ymm = opnd_create_reg(dst_reg);
        // vpbroadcastw src_opnd -> dst_reg
        instr_t *i1 = INSTR_CREATE_vpbroadcastw(dcontext, op_dst_ymm, src_opnd);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        instrlist_concat_next_instr(ilist, 1, i1);
        return i1;
    } break;
    case 1: { // dst need spill
        reg_id_t spill_dst_reg = YMM_SPILL_SLOT0;
        opnd_t op_spill_dst_ymm = opnd_create_reg(spill_dst_reg);

        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vpbroadcastw src_opnd -> spill_dst
        instr_t *i2 = INSTR_CREATE_vpbroadcastw(dcontext, op_spill_dst_ymm, src_opnd);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpbroadcastw_ymm_disp2reg_gen except 0 or 1"); return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t *
vpbroadcastw_xmm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint dst_need_spill = NEED_SPILL_XMM(dst_reg) ? 1 : 0;

    switch (dst_need_spill) {
    case 0: { // don't need spill
        opnd_t op_dst_xmm = opnd_create_reg(dst_reg);
        // vpbroadcastw src_opnd -> dst_reg
        instr_t *i1 = INSTR_CREATE_vpbroadcastw(dcontext, op_dst_xmm, src_opnd);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        instrlist_concat_next_instr(ilist, 1, i1);
        return i1;
    } break;
    case 1: { // dst need spill
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
        opnd_t op_spill_dst_xmm = opnd_create_reg(spill_dst_reg);

        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vpbroadcastw src_opnd -> spill_dst
        instr_t *i2 = INSTR_CREATE_vpbroadcastw(dcontext, op_spill_dst_xmm, src_opnd);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpbroadcastw_xmm_disp2reg_gen except 0 or 1"); return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t * /* 465 */
rw_func_vpbroadcastw(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src_opnd = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpbroadcastw", true, true, false, true);
#endif
    switch (src_opnd.kind) {
    case REG_kind: { // vpbroadcast_d{%k0} %eax -> %xyzmm0
        reg_id_t src_reg = opnd_get_reg(src_opnd);
        if (IS_32GPR_REG(src_reg) || IS_64GPR_REG(src_reg)) {
            reg_id_t dst_reg = opnd_get_reg(dst_opnd);
            if (IS_ZMM_REG(dst_reg)) { // %eax -> %zmm
                return vpbroadcastw_zmm_reg2reg_gen(dcontext, ilist, instr, src_opnd, src_reg, dst_reg, mask_reg);
            }
            if (IS_YMM_REG(dst_reg)) { // %eax -> %ymm
                return vpbroadcastw_ymm_reg2reg_gen(dcontext, ilist, instr, src_opnd, src_reg, dst_reg, mask_reg);
            }
            if (IS_XMM_REG(dst_reg)) { // %eax -> %xmm
                return vpbroadcastw_xmm_reg2reg_gen(dcontext, ilist, instr, src_opnd, src_reg, dst_reg, mask_reg);
            }
        }
    } break;
    case BASE_DISP_kind: { // disp(base, index, scale)[1,2,4,8byte] -> %zmm{i}
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_ZMM_REG(dst_reg)) {
            return vpbroadcastw_zmm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_opnd, mask_reg);
        }
        if (IS_YMM_REG(dst_reg)) {
            return vpbroadcastw_ymm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        }
        if (IS_XMM_REG(dst_reg)) {
            return vpbroadcastw_xmm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        }
    } break;
    default: REWRITE_INFO(STD_OUTF, "vpbroadcastd pattern not support");
    }
    return NULL_INSTR;
}

/* ==============================================
 *    Helper func for vpbroadcastd
 * ============================================= */

instr_t *
vpbroadcastd_zmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                             reg_id_t dst_reg, reg_id_t mask_reg)
{
    dr_ymm_pair_t dst_ymm_pair = { EMPTY, EMPTY };
    if (get_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(dst_reg), &dst_ymm_pair) == NOT_GET) {
        if (find_and_set_unused_ymm_pair(dcontext, &dst_ymm_pair) == NOT_FIND) {
#ifdef DEBUG
            REWRITE_ERROR(STD_ERRF, "find_and_set_unused_ymm_pair failed");
#endif
            return NULL_INSTR;
        }
        add_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(dst_reg), &dst_ymm_pair);
    }

    reg_id_t dst_reg_lower = TO_YMM_REG_ID_NUM(dst_ymm_pair.ymm_lower);
    reg_id_t dst_reg_upper = TO_YMM_REG_ID_NUM(dst_ymm_pair.ymm_upper);
    // can't directly broadcast a gpr to simd in avx2, should first mov gpr to a simd and then broadcast
    opnd_t ymm_down_mapping_opnd = opnd_create_reg(YMM_INDEX_TO_XMM_INDEX(dst_reg_lower));
    opnd_t lower_ymm_opnd = opnd_create_reg(dst_reg_lower);
    opnd_t upper_ymm_opnd = opnd_create_reg(dst_reg_upper);
    instr_t *new_instr1 = instr_create_1dst_1src(dcontext, OP_vmovd, ymm_down_mapping_opnd, src_opnd);
    instr_t *new_instr2 = instr_create_1dst_1src(dcontext, OP_vpbroadcastd, lower_ymm_opnd, ymm_down_mapping_opnd);
    instr_t *new_instr3 = instr_create_1dst_1src(dcontext, OP_vmovdqa, upper_ymm_opnd, lower_ymm_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 3, new_instr1, new_instr2, new_instr3);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    new_instr1->next = new_instr2;
    new_instr2->next = new_instr3;
    return new_instr1;
}

instr_t *
vpbroadcastd_ymm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                             reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    opnd_t ymm_opnd = create_mapping_ymm_opnd(dcontext, dst_reg);
    reg_id_t ymm_reg = opnd_get_reg(ymm_opnd);
    opnd_t ymm_down_mapping_opnd = opnd_create_reg(YMM_INDEX_TO_XMM_INDEX(ymm_reg));
    instr_t *new_instr1 = instr_create_1dst_1src(dcontext, OP_vmovd, ymm_down_mapping_opnd, src_opnd);
    instr_t *new_instr2 = instr_create_1dst_1src(dcontext, OP_vpbroadcastd, ymm_opnd, ymm_down_mapping_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 2, new_instr1, new_instr2);
#endif
    new_instr1->next = new_instr2;
    return new_instr1;
}

instr_t *
vpbroadcastd_xmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                             reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    opnd_t xmm_opnd = create_mapping_xmm_opnd(dcontext, dst_reg);
    instr_t *new_instr1 = instr_create_1dst_1src(dcontext, OP_vmovd, xmm_opnd, src_opnd);
    instr_t *new_instr2 = instr_create_1dst_1src(dcontext, OP_vpbroadcastd, xmm_opnd, xmm_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 2, new_instr1, new_instr2);
#endif
    new_instr1->next = new_instr2;
    return new_instr1;
}

instr_t *
vpbroadcastd_zmm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              opnd_t dst_opnd, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    reg_id_t dst_reg = opnd_get_reg(dst_opnd); // dst_reg is now DR_REG_ZMM0

    const uint dst_need_spill = NEED_SPILL_ZMM(dst_reg) ? 1 : 0;

    switch (dst_need_spill) {
    case 0: { // don't need spill
        reg_id_t dst_reg_lower = ZMM_TO_YMM(dst_reg);
        opnd_t op_dst_lower = opnd_create_reg(dst_reg_lower);
        // vpbroadcastd src_opnd -> dst_reg_lower
        instr_t *i1 = INSTR_CREATE_vpbroadcastd(dcontext, op_dst_lower, src_opnd);
        // vmovdqu32 dst_reg_lower -> tls(dst_lower)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_32);
        // vmovdqu32 dst_reg_lower -> tls(dst_upper)
        instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_lower,
                                             TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 3, i1, i2, i3);
#endif
        instrlist_concat_next_instr(ilist, 3, i1, i2, i3);
        return i1;
    } break;
    case 1: { // dst need spill
        reg_id_t spill_dst_lower = YMM_SPILL_SLOT0;
        opnd_t op_spill_dst_lower = opnd_create_reg(spill_dst_lower);

        // spill_dst_lower -> tls(spill_dst_lower)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_32);
        // vpbroadcastd src_opnd -> spill_dst_lower
        instr_t *i2 = INSTR_CREATE_vpbroadcastd(dcontext, op_spill_dst_lower, src_opnd);
        // vmovdqu spill_dst_lower -> tls(dst_lower)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_32);
        // vmovdqu spill_dst_lower -> tls(dst_upper)
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower,
                                             TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_32);
        // tls(spill_dst_lower) -> spill_dst_lower
        instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_lower,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpbroadcastd_zmm_disp2reg_gen except 0 or 1"); return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t *
vpbroadcastd_ymm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
    opnd_t dst_opnd = create_mapping_ymm_opnd(dcontext, dst_reg);
    instr_t *new_instr1 = instr_create_1dst_1src(dcontext, OP_vpbroadcastd, dst_opnd, src_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vpbroadcastd_xmm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
    opnd_t dst_opnd = create_mapping_xmm_opnd(dcontext, dst_reg);
    instr_t *new_instr1 = instr_create_1dst_1src(dcontext, OP_vpbroadcastd, dst_opnd, src_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

/**
 * @brief rewrite broadcast double to zmm register
 * @note  split one broadcast to zmm into one broadcast to ymm{i} and copy to another
 * ymm{i+1} or remapping ymm{16..31} to ymm{0..15}
 *
 * vpbroadcastd {%k[i]} disp(base, index, scale)[1,2,4,8byte] -> %zmm{j}
 */
instr_t *
rw_func_vpbroadcastd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src_opnd = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpbroadcastd", true, true, false, true);
#endif
    switch (src_opnd.kind) {
    case REG_kind: { // vpbroadcast_d{%k0} %eax -> %xyzmm0
        reg_id_t src_reg = opnd_get_reg(src_opnd);
        if (IS_32GPR_REG(src_reg) || IS_64GPR_REG(src_reg)) {
            reg_id_t dst_reg = opnd_get_reg(dst_opnd);
            if (IS_ZMM_REG(dst_reg)) { // %eax -> %zmm
                return vpbroadcastd_zmm_reg2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
            }
            if (IS_YMM_REG(dst_reg)) { // %eax -> %ymm
                return vpbroadcastd_ymm_reg2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
            }
            if (IS_XMM_REG(dst_reg)) { // %eax -> %xmm
                return vpbroadcastd_xmm_reg2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
            }
        }
    } break;
    case BASE_DISP_kind: { // disp(base, index, scale)[1,2,4,8byte] -> %zmm{i}
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_ZMM_REG(dst_reg)) {
            return vpbroadcastd_zmm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_opnd, mask_reg);
        }
        if (IS_YMM_REG(dst_reg)) {
            return vpbroadcastd_ymm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        }
        if (IS_XMM_REG(dst_reg)) {
            return vpbroadcastd_xmm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        }
    } break;
    default: REWRITE_INFO(STD_OUTF, "vpbroadcastd pattern not support");
    }
    return NULL_INSTR;
}

/* ==============================================
 *    Helper func for vpbroadcastq
 * ============================================= */

instr_t *
vpbroadcastq_zmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                             reg_id_t dst_reg, reg_id_t mask_reg)
{
    dr_ymm_pair_t dst_ymm_pair = { EMPTY, EMPTY };
    if (get_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(dst_reg), &dst_ymm_pair) == NOT_GET) {
        if (find_and_set_unused_ymm_pair(dcontext, &dst_ymm_pair) == NOT_FIND) {
#ifdef DEBUG
            REWRITE_ERROR(STD_ERRF, "find_and_set_unused_ymm_pair failed");
#endif
            return NULL_INSTR;
        }
        add_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(dst_reg), &dst_ymm_pair);
    }

    reg_id_t dst_reg_lower = TO_YMM_REG_ID_NUM(dst_ymm_pair.ymm_lower);
    reg_id_t dst_reg_upper = TO_YMM_REG_ID_NUM(dst_ymm_pair.ymm_upper);
    // can't directly broadcast a gpr to simd in avx2, should first mov gpr to a simd and then broadcast
    opnd_t ymm_down_mapping_opnd = opnd_create_reg(YMM_INDEX_TO_XMM_INDEX(dst_reg_lower));
    opnd_t lower_ymm_opnd = opnd_create_reg(dst_reg_lower);
    opnd_t upper_ymm_opnd = opnd_create_reg(dst_reg_upper);
    instr_t *new_instr1 = instr_create_1dst_1src(dcontext, OP_vmovq, ymm_down_mapping_opnd, src_opnd);
    instr_t *new_instr2 = instr_create_1dst_1src(dcontext, OP_vpbroadcastq, lower_ymm_opnd, ymm_down_mapping_opnd);
    instr_t *new_instr3 = instr_create_1dst_1src(dcontext, OP_vmovdqa, upper_ymm_opnd, lower_ymm_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 3, new_instr1, new_instr2, new_instr3);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    new_instr1->next = new_instr2;
    new_instr2->next = new_instr3;
    return new_instr1;
}

instr_t *
vpbroadcastq_ymm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                             reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    opnd_t ymm_opnd = create_mapping_ymm_opnd(dcontext, dst_reg);
    reg_id_t ymm_reg = opnd_get_reg(ymm_opnd);
    opnd_t ymm_down_mapping_opnd = opnd_create_reg(YMM_INDEX_TO_XMM_INDEX(ymm_reg));
    instr_t *new_instr1 = instr_create_1dst_1src(dcontext, OP_vmovq, ymm_down_mapping_opnd, src_opnd);
    instr_t *new_instr2 = instr_create_1dst_1src(dcontext, OP_vpbroadcastq, ymm_opnd, ymm_down_mapping_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 2, new_instr1, new_instr2);
#endif
    new_instr1->next = new_instr2;
    return new_instr1;
}

instr_t *
vpbroadcastq_xmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                             reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    opnd_t xmm_opnd = create_mapping_xmm_opnd(dcontext, dst_reg);
    instr_t *new_instr1 = instr_create_1dst_1src(dcontext, OP_vmovq, xmm_opnd, src_opnd);
    instr_t *new_instr2 = instr_create_1dst_1src(dcontext, OP_vpbroadcastq, xmm_opnd, xmm_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 2, new_instr1, new_instr2);
#endif
    new_instr1->next = new_instr2;
    return new_instr1;
}

instr_t *
vpbroadcastq_zmm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              opnd_t dst_opnd, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    reg_id_t dst_reg = opnd_get_reg(dst_opnd); // dst_reg is now DR_REG_ZMM0

    const uint dst_need_spill = NEED_SPILL_ZMM(dst_reg) ? 1 : 0;

    switch (dst_need_spill) {
    case 0: { // don't need spill
        reg_id_t dst_reg_lower = ZMM_TO_YMM(dst_reg);
        opnd_t op_dst_lower = opnd_create_reg(dst_reg_lower);
        // vpbroadcastq src_opnd -> dst_reg_lower
        instr_t *i1 = INSTR_CREATE_vpbroadcastq(dcontext, op_dst_lower, src_opnd);
        // vmovdqu64 dst_reg_lower -> tls(dst_lower)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_64);
        // vmovdqu64 dst_reg_lower -> tls(dst_upper)
        instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_lower,
                                             TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_64);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 3, i1, i2, i3);
#endif
        instrlist_concat_next_instr(ilist, 3, i1, i2, i3);
        return i1;
    } break;
    case 1: { // dst need spill
        reg_id_t spill_dst_lower = YMM_SPILL_SLOT0;
        opnd_t op_spill_dst_lower = opnd_create_reg(spill_dst_lower);

        // spill_dst_lower -> tls(spill_dst_lower)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_64);
        // vpbroadcastq src_opnd -> spill_dst_lower
        instr_t *i2 = INSTR_CREATE_vpbroadcastq(dcontext, op_spill_dst_lower, src_opnd);
        // vmovdqu64 spill_dst_lower -> tls(dst_lower)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_64);
        // vmovdqu64 spill_dst_lower -> tls(dst_upper)
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_lower,
                                             TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_64);
        // tls(spill_dst_lower) -> spill_dst_lower
        instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_lower,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_lower)), OPSZ_64);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpbroadcastq_zmm_disp2reg_gen except 0 or 1"); return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t *
vpbroadcastq_ymm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
    opnd_t dst_opnd = create_mapping_ymm_opnd(dcontext, dst_reg);
    instr_t *new_instr1 = instr_create_1dst_1src(dcontext, OP_vpbroadcastq, dst_opnd, src_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vpbroadcastq_xmm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
    opnd_t dst_opnd = create_mapping_xmm_opnd(dcontext, dst_reg);
    instr_t *new_instr1 = instr_create_1dst_1src(dcontext, OP_vpbroadcastq, dst_opnd, src_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

/**
 * @brief 467 vpbroadcastq
 * vpbroadcastq {%k0} %rdx -> %ymm0
 */
instr_t *
rw_func_vpbroadcastq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src_opnd = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpbroadcastq", true, true, false, true);
#endif
    switch (src_opnd.kind) {
    case REG_kind: { // vpbroadcast_d{%k0} %eax -> %xyzmm0
        reg_id_t src_reg = opnd_get_reg(src_opnd);
        if (IS_32GPR_REG(src_reg) || IS_64GPR_REG(src_reg)) {
            reg_id_t dst_reg = opnd_get_reg(dst_opnd);
            if (IS_ZMM_REG(dst_reg)) { // %eax -> %zmm
                return vpbroadcastq_zmm_reg2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
            }
            if (IS_YMM_REG(dst_reg)) { // %eax -> %ymm
                return vpbroadcastq_ymm_reg2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
            }
            if (IS_XMM_REG(dst_reg)) { // %eax -> %xmm
                return vpbroadcastq_xmm_reg2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
            }
        }
    } break;
    case BASE_DISP_kind: { // disp(base, index, scale)[1,2,4,8byte] -> %zmm{i}
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_ZMM_REG(dst_reg)) {
            return vpbroadcastq_zmm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_opnd, mask_reg);
        }
        if (IS_YMM_REG(dst_reg)) {
            return vpbroadcastq_ymm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        }
        if (IS_XMM_REG(dst_reg)) {
            return vpbroadcastq_xmm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        }
    } break;
    default: REWRITE_INFO(STD_OUTF, "vpbroadcastq pattern not support");
    }
    return NULL_INSTR;
}

/**
 * @brief 24 vcvtss2si
 * vcvttss2usi %xmm0[4byte] -> %rax
 */
instr_t *
rw_func_vcvtss2si(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // cvttss2si %xmm0(src1), %eax
    // mov %eax, %rax
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    opnd_t src_opnd = instr_get_src(instr, 0);
    opnd_t dst_opnd = instr_get_dst(instr, 0);

    instr_t *i1 = INSTR_CREATE_vcvtss2si(dcontext, dst_opnd, src_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
    return i1;
}

instr_t * /* 25 */
rw_func_vcvtsd2si(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    opnd_t src_opnd = instr_get_src(instr, 0);
    opnd_t dst_opnd = instr_get_dst(instr, 0);

    instr_t *i1 = INSTR_CREATE_vcvtsd2si(dcontext, dst_opnd, src_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
    return i1;
}

instr_t *
fast_rw_func_vcvttsd2usi(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t op_src, opnd_t op_dst)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    reg_id_t xmm_src_reg = opnd_get_reg(op_src);
    const uint need_spill_xmm_src = NEED_SPILL_XMM(xmm_src_reg) ? 1 : 0;

    if (!need_spill_xmm_src) {
        instr_t *i1 = INSTR_CREATE_vcvttsd2si(dcontext, op_dst, op_src);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } else {
        reg_id_t spill_src_reg = XMM_SPILL_SLOT0;
        opnd_t op_src_spill = opnd_create_reg(spill_src_reg);
        // src_spill -> tls(src_spill)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src_reg)), OPSZ_16);
        // vcvttsd2usi src_spill -> dst
        instr_t *i2 = INSTR_CREATE_vcvttsd2si(dcontext, op_dst, op_src_spill);
        // tls(src_spill) -> src_spill
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 3, i1, i2, i3);
#endif
        instrlist_concat_next_instr(ilist, 3, i1, i2, i3);
        return i1;
    }
    return NULL_INSTR;
}

/**
 * @brief 555 vcvttsd2usi
 * vcvttsd2usi %xmm0[8byte] -> %rax
 * IF 64-Bit Mode and OperandSize = 64
 *     THEN DEST[63:0] := Convert_Double_Precision_Floating_Point_To_UInteger_Truncate(SRC[63:0]);
 */
instr_t *
rw_func_vcvttsd2usi(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t src_opnd = instr_get_src(instr, 0);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "rewrite %s at %p :", "vcvttsd2usi", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src_opnd, "src:");
    dr_print_opnd(dcontext, STD_OUTF, dst_opnd, "dst:");
#endif

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    reg_id_t reg64_scrach1 = DR_REG_NULL;
    reg_id_t reg64_scrach2 = DR_REG_NULL;

    reg_id_t xmm_spill1 = DR_REG_NULL;
    reg_id_t xmm_spill2 = DR_REG_NULL;

    reg_id_t dst_reg = opnd_get_reg(dst_opnd);

    const int PRE_PUSH_BYTES = 4 * 8;

    opnd_t src_for_load64 = src_opnd;
    if (opnd_is_reg(src_opnd)) {
        reg_id_t src_xmm_reg = opnd_get_reg(src_opnd);
        DR_ASSERT(reg_is_xmm(src_xmm_reg));
        src_for_load64 = opnd_create_reg(src_xmm_reg);

        reg64_scrach1 = DR_REG_R11;
        reg64_scrach2 = DR_REG_R12;
        xmm_spill1 = find_one_available_spill_xmm(src_xmm_reg);
        xmm_spill2 = find_available_spill_xmm_avoiding(src_xmm_reg, xmm_spill1, DR_REG_NULL);

    } else if (opnd_is_memory_reference(src_opnd)) {
        if (opnd_is_base_disp(src_opnd) && opnd_get_base(src_opnd) == DR_REG_RSP) {
            src_for_load64 = opnd_create_base_disp(DR_REG_RSP, opnd_get_index(src_opnd), opnd_get_scale(src_opnd),
                                                   opnd_get_disp(src_opnd) + PRE_PUSH_BYTES, OPSZ_8);
        }
        if (src_opnd.kind == BASE_DISP_kind) {
            reg_id_t base_reg = opnd_get_base(src_opnd);
            reg_id_t index_reg = opnd_get_index(src_opnd);
            if (index_reg == DR_REG_NULL) {
                if (find_spills_avoiding_2(reg64_scrach1, reg64_scrach2, 1, base_reg, dst_reg) != 2) {
                    REWRITE_INFO(STD_OUTF, "find_spills_avoiding_3 failed");
                    return NULL_INSTR;
                }
            } else {
                if (find_spills_avoiding_2(reg64_scrach1, reg64_scrach2, 1, base_reg, index_reg, dst_reg) != 2) {
                    REWRITE_ERROR(STD_OUTF, "find_spills_avoiding_3 failed");
                    return NULL_INSTR;
                }
            }

            xmm_spill1 = XMM_SPILL_SLOT0;
            xmm_spill2 = XMM_SPILL_SLOT1;
        }
    } else {
        DR_ASSERT_MSG(false, "vcvttsd2usi: unsupported src");
    }
    opnd_t src_for_load32 = src_for_load64;

    opnd_t op64_scrach1 = opnd_create_reg(reg64_scrach1);
    opnd_t op64_scrach2 = opnd_create_reg(reg64_scrach2);
    opnd_t op32_scrach1 = opnd_create_reg(GPR64_TO_GPR32(reg64_scrach1));
    opnd_t op32_scrach2 = opnd_create_reg(GPR64_TO_GPR32(reg64_scrach2));

    opnd_t op_xmm_spill1 = opnd_create_reg(xmm_spill1);
    opnd_t op_xmm_spill2 = opnd_create_reg(xmm_spill2);

    /* labels */
    instr_t *lbl_load_direct = INSTR_CREATE_label(dcontext);
    instr_t *lbl_invalid = INSTR_CREATE_label(dcontext);
    instr_t *lbl_store = INSTR_CREATE_label(dcontext);

    if (opnd_get_size(dst_opnd) == OPSZ_8) {

        instr_t *i0 = INSTR_CREATE_pushf(dcontext);
        instr_t *i1 = INSTR_CREATE_push(dcontext, op64_scrach1);
        instr_t *i2 = INSTR_CREATE_push(dcontext, op64_scrach2);

        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_spill1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill1)), OPSZ_16);
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_spill2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill2)), OPSZ_16);

        instr_t *i6 = INSTR_CREATE_movsd(dcontext, op_xmm_spill2, src_for_load64);

        instr_t *i7 = INSTR_CREATE_pxor(dcontext, op_xmm_spill1, op_xmm_spill1);
        instr_t *i8 = INSTR_CREATE_ucomisd(dcontext, op_xmm_spill2, op_xmm_spill1);
        instr_t *i9 = INSTR_CREATE_jcc(dcontext, OP_jp, opnd_create_instr(lbl_invalid));  /* NaN */
        instr_t *i10 = INSTR_CREATE_jcc(dcontext, OP_jb, opnd_create_instr(lbl_invalid)); /* x < 0 */

        instr_t *i11 = INSTR_CREATE_mov_imm(dcontext, op64_scrach1, OPND_CREATE_INT64(0x43F0000000000000));
        instr_t *i12 = INSTR_CREATE_vmovq(dcontext, op_xmm_spill1, op64_scrach1);
        instr_t *i13 = INSTR_CREATE_ucomisd(dcontext, op_xmm_spill2, op_xmm_spill1);
        instr_t *i14 = INSTR_CREATE_jcc(dcontext, OP_jae, opnd_create_instr(lbl_invalid)); /* x >= 2^64 */

        instr_t *i15 = INSTR_CREATE_mov_imm(dcontext, op64_scrach1, OPND_CREATE_INT64(0x43E0000000000000));
        instr_t *i16 = INSTR_CREATE_vmovq(dcontext, op_xmm_spill1, op64_scrach1);
        instr_t *i17 = INSTR_CREATE_ucomisd(dcontext, op_xmm_spill2, op_xmm_spill1);
        instr_t *i18 = INSTR_CREATE_jcc(dcontext, OP_jb, opnd_create_instr(lbl_load_direct)); /* x < 2^63 */

        instr_t *i19 = INSTR_CREATE_subsd(dcontext, op_xmm_spill2, op_xmm_spill1);
        instr_t *i20 = INSTR_CREATE_cvttsd2si(dcontext, op64_scrach1, op_xmm_spill2);
        instr_t *i21 = INSTR_CREATE_mov_imm(dcontext, op64_scrach2, OPND_CREATE_INT64(0x8000000000000000));
        instr_t *i22 = INSTR_CREATE_add(dcontext, op64_scrach1, op64_scrach2);
        instr_t *i23 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(lbl_store));

        instr_t *i24 = lbl_load_direct;
        instr_t *i25 = INSTR_CREATE_cvttsd2si(dcontext, op64_scrach1, op_xmm_spill2);
        instr_t *i26 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(lbl_store));

        instr_t *i27 = lbl_invalid;
        instr_t *i28 = INSTR_CREATE_mov_imm(dcontext, op64_scrach1, OPND_CREATE_INT64(-1));

        instr_t *i29 = lbl_store;
        instr_t *i30 = INSTR_CREATE_mov_st(dcontext, dst_opnd, op64_scrach1);

        instr_t *i31 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill1)), OPSZ_16);
        instr_t *i32 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill2)), OPSZ_16);
        instr_t *i34 = INSTR_CREATE_pop(dcontext, op64_scrach2);
        instr_t *i35 = INSTR_CREATE_pop(dcontext, op64_scrach1);
        instr_t *i36 = INSTR_CREATE_popf(dcontext);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 35, i0, i1, i2, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32, i34, i35, i36);
#endif
        instrlist_concat_next_instr(ilist, 35, i0, i1, i2, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32, i34,
                                    i35, i36);
        return i0;
    } else {

        instr_t *i0 = INSTR_CREATE_pushf(dcontext);
        instr_t *i1 = INSTR_CREATE_push(dcontext, op64_scrach1);
        instr_t *i2 = INSTR_CREATE_push(dcontext, op64_scrach2);

        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_spill1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill1)), OPSZ_16);
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_spill2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill2)), OPSZ_16);

        instr_t *i6 = INSTR_CREATE_movsd(dcontext, op_xmm_spill2, src_for_load32);

        instr_t *i7 = INSTR_CREATE_pxor(dcontext, op_xmm_spill1, op_xmm_spill1);
        instr_t *i8 = INSTR_CREATE_ucomisd(dcontext, op_xmm_spill2, op_xmm_spill1);
        instr_t *i9 = INSTR_CREATE_jcc(dcontext, OP_jp, opnd_create_instr(lbl_invalid));
        instr_t *i10 = INSTR_CREATE_jcc(dcontext, OP_jb, opnd_create_instr(lbl_invalid));

        /* 2^32 */
        instr_t *i11 = INSTR_CREATE_mov_imm(dcontext, op64_scrach1, OPND_CREATE_INT64(0x41F0000000000000));
        instr_t *i12 = INSTR_CREATE_vmovq(dcontext, op_xmm_spill1, op64_scrach1);
        instr_t *i13 = INSTR_CREATE_ucomisd(dcontext, op_xmm_spill2, op_xmm_spill1);
        instr_t *i14 = INSTR_CREATE_jcc(dcontext, OP_jae, opnd_create_instr(lbl_invalid));

        /* 2^31 */
        instr_t *i15 = INSTR_CREATE_mov_imm(dcontext, op64_scrach1, OPND_CREATE_INT64(0x41E0000000000000));
        instr_t *i16 = INSTR_CREATE_vmovq(dcontext, op_xmm_spill1, op64_scrach1);
        instr_t *i17 = INSTR_CREATE_ucomisd(dcontext, op_xmm_spill2, op_xmm_spill1);
        instr_t *i18 = INSTR_CREATE_jcc(dcontext, OP_jb, opnd_create_instr(lbl_load_direct));

        instr_t *i19 = INSTR_CREATE_subsd(dcontext, op_xmm_spill2, op_xmm_spill1);
        instr_t *i20 = INSTR_CREATE_cvttsd2si(dcontext, op32_scrach1, op_xmm_spill2);
        instr_t *i21 = INSTR_CREATE_mov_imm(dcontext, op64_scrach2, OPND_CREATE_INT64(0x80000000));
        instr_t *i22 = INSTR_CREATE_add(dcontext, op32_scrach1, op32_scrach2);
        instr_t *i23 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(lbl_store));

        instr_t *i24 = lbl_load_direct;
        instr_t *i25 = INSTR_CREATE_cvttsd2si(dcontext, op32_scrach1, op_xmm_spill2);
        instr_t *i26 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(lbl_store));

        instr_t *i27 = lbl_invalid;
        instr_t *i28 = INSTR_CREATE_mov_imm(dcontext, op32_scrach1, OPND_CREATE_INT32(-1));

        instr_t *i29 = lbl_store;
        instr_t *i30 = INSTR_CREATE_mov_st(dcontext, dst_opnd, op32_scrach1);

        instr_t *i31 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill1)), OPSZ_16);
        instr_t *i32 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill1)), OPSZ_16);
        instr_t *i34 = INSTR_CREATE_pop(dcontext, op64_scrach2);
        instr_t *i35 = INSTR_CREATE_pop(dcontext, op64_scrach1);
        instr_t *i36 = INSTR_CREATE_popf(dcontext);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 35, i0, i1, i2, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32, i34, i35, i36);
#endif
        instrlist_concat_next_instr(ilist, 35, i0, i1, i2, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32, i34,
                                    i35, i36);
        return i0;
    }
}

instr_t *
fast_rw_func_vcvttss2usi(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t op_src, opnd_t op_dst)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    reg_id_t xmm_src_reg = opnd_get_reg(op_src);
    const uint need_spill_xmm_src = NEED_SPILL_XMM(xmm_src_reg) ? 1 : 0;

    if (!need_spill_xmm_src) {
        instr_t *i1 = INSTR_CREATE_vcvttss2si(dcontext, op_dst, op_src);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } else {
        reg_id_t spill_src_reg = XMM_SPILL_SLOT0;
        opnd_t op_src_spill = opnd_create_reg(spill_src_reg);
        // src_spill -> tls(src_spill)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src_reg)), OPSZ_16);
        // vcvttss2si src_spill -> dst
        instr_t *i2 = INSTR_CREATE_vcvttss2si(dcontext, op_dst, op_src_spill);
        // tls(src_spill) -> src_spill
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 3, i1, i2, i3);
#endif
        instrlist_concat_next_instr(ilist, 3, i1, i2, i3);
        return i1;
    }
    return NULL_INSTR;
}

instr_t * /* 556 */
rw_func_vcvttss2usi(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t src_opnd = instr_get_src(instr, 0);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "rewrite %s at %p :", "vcvttsd2usi", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src_opnd, "src:");
    dr_print_opnd(dcontext, STD_OUTF, dst_opnd, "dst:");
#endif

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const int PRE_PUSH_BYTES = 3 * 8;

    reg_id_t reg64_scrach1 = DR_REG_NULL;
    reg_id_t reg64_scrach2 = DR_REG_NULL;

    reg_id_t xmm_spill1 = DR_REG_NULL;
    reg_id_t xmm_spill2 = DR_REG_NULL;

    opnd_t src_for_load64 = src_opnd;
    if (opnd_is_reg(src_opnd)) {
        reg_id_t src_xmm_reg = opnd_get_reg(src_opnd);
        DR_ASSERT(reg_is_xmm(src_xmm_reg));
        src_for_load64 = opnd_create_reg(src_xmm_reg);

        reg64_scrach1 = DR_REG_R8;
        reg64_scrach2 = DR_REG_RCX;
        xmm_spill1 = find_one_available_spill_xmm(src_xmm_reg);
        xmm_spill2 = find_available_spill_xmm_avoiding(src_xmm_reg, xmm_spill1, DR_REG_NULL);

    } else if (opnd_is_memory_reference(src_opnd)) {
        if (opnd_is_base_disp(src_opnd) && opnd_get_base(src_opnd) == DR_REG_RSP) {
            src_for_load64 = opnd_create_base_disp(DR_REG_RSP, opnd_get_index(src_opnd), opnd_get_scale(src_opnd),
                                                   opnd_get_disp(src_opnd) + PRE_PUSH_BYTES, OPSZ_8);
        }
        if (src_opnd.kind == BASE_DISP_kind) {
            reg_id_t base_reg = opnd_get_base(src_opnd);
            reg_id_t index_reg = opnd_get_index(src_opnd);
            if (index_reg == DR_REG_NULL) {
                if (find_spills_avoiding_2(reg64_scrach1, reg64_scrach2, 1, base_reg) != 2) {
                    REWRITE_INFO(STD_OUTF, "find_spills_avoiding_2 failed");
                    return NULL_INSTR;
                }
            } else {
                if (find_spills_avoiding_2(reg64_scrach1, reg64_scrach2, 2, base_reg, index_reg) != 2) {
                    REWRITE_ERROR(STD_OUTF, "find_spills_avoiding_2 failed");
                    return NULL_INSTR;
                }
            }

            xmm_spill1 = XMM_SPILL_SLOT0;
            xmm_spill2 = XMM_SPILL_SLOT1;
        }
    } else {
        DR_ASSERT_MSG(false, "vcvttsd2usi: unsupported src");
    }
    opnd_t src_for_load32 = src_for_load64;

    opnd_t op64_scrach1 = opnd_create_reg(reg64_scrach1);
    opnd_t op64_scrach2 = opnd_create_reg(reg64_scrach2);
    opnd_t op32_scrach1 = opnd_create_reg(GPR64_TO_GPR32(reg64_scrach1));
    opnd_t op32_scrach2 = opnd_create_reg(GPR64_TO_GPR32(reg64_scrach2));

    opnd_t op_xmm_spill1 = opnd_create_reg(xmm_spill1);
    opnd_t op_xmm_spill2 = opnd_create_reg(xmm_spill2);

    /* labels */
    instr_t *lbl_load_direct = INSTR_CREATE_label(dcontext);
    instr_t *lbl_invalid = INSTR_CREATE_label(dcontext);
    instr_t *lbl_store = INSTR_CREATE_label(dcontext);

    if (opnd_get_size(dst_opnd) == OPSZ_8) {
        instr_t *i0 = INSTR_CREATE_pushf(dcontext);
        instr_t *i1 = INSTR_CREATE_push(dcontext, op64_scrach1);
        instr_t *i2 = INSTR_CREATE_push(dcontext, op64_scrach2);
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_spill1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill1)), OPSZ_16);
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_spill2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill2)), OPSZ_16);

        /* src -> XMM15 */
        instr_t *i6 = INSTR_CREATE_movss(dcontext, op_xmm_spill2, src_for_load32);

        instr_t *i7 = INSTR_CREATE_pxor(dcontext, op_xmm_spill1, op_xmm_spill1);
        instr_t *i8 = INSTR_CREATE_ucomiss(dcontext, op_xmm_spill2, op_xmm_spill1);
        instr_t *i9 = INSTR_CREATE_jcc(dcontext, OP_jp, opnd_create_instr(lbl_invalid));  /* NaN */
        instr_t *i10 = INSTR_CREATE_jcc(dcontext, OP_jb, opnd_create_instr(lbl_invalid)); /* x < 0 */

        instr_t *i11 = INSTR_CREATE_mov_imm(dcontext, op64_scrach1, OPND_CREATE_INT64(0x5F800000));
        instr_t *i12 = INSTR_CREATE_vmovq(dcontext, op_xmm_spill1, op64_scrach1);
        instr_t *i13 = INSTR_CREATE_ucomiss(dcontext, op_xmm_spill2, op_xmm_spill1);
        instr_t *i14 = INSTR_CREATE_jcc(dcontext, OP_jae, opnd_create_instr(lbl_invalid)); /* x >= 2^32 */

        instr_t *i15 = INSTR_CREATE_mov_imm(dcontext, op64_scrach1, OPND_CREATE_INT64(0x5F000000));
        instr_t *i16 = INSTR_CREATE_vmovq(dcontext, op_xmm_spill1, op64_scrach1);
        instr_t *i17 = INSTR_CREATE_ucomiss(dcontext, op_xmm_spill2, op_xmm_spill1);
        instr_t *i18 = INSTR_CREATE_jcc(dcontext, OP_jb, opnd_create_instr(lbl_load_direct)); /* x < 2^63 */

        instr_t *i19 = INSTR_CREATE_subss(dcontext, op_xmm_spill2, op_xmm_spill1);
        instr_t *i20 = INSTR_CREATE_cvttss2si(dcontext, op64_scrach1, op_xmm_spill2);
        instr_t *i21 = INSTR_CREATE_mov_imm(dcontext, op64_scrach2, OPND_CREATE_INT64(0x8000000000000000));
        instr_t *i22 = INSTR_CREATE_add(dcontext, op64_scrach1, op64_scrach2);
        instr_t *i23 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(lbl_store));

        instr_t *i24 = lbl_load_direct;
        instr_t *i25 = INSTR_CREATE_cvttss2si(dcontext, op64_scrach1, op_xmm_spill2);
        instr_t *i26 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(lbl_store));

        instr_t *i27 = lbl_invalid;
        instr_t *i28 = INSTR_CREATE_mov_imm(dcontext, op64_scrach1, OPND_CREATE_INT64(-1));

        instr_t *i29 = lbl_store;
        instr_t *i30 = INSTR_CREATE_mov_st(dcontext, dst_opnd, op64_scrach1);
        instr_t *i31 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill1)), OPSZ_16);
        instr_t *i32 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill2)), OPSZ_16);
        instr_t *i34 = INSTR_CREATE_pop(dcontext, op64_scrach2);
        instr_t *i35 = INSTR_CREATE_pop(dcontext, op64_scrach1);
        instr_t *i36 = INSTR_CREATE_popf(dcontext);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 35, i0, i1, i2, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32, i34, i35, i36);
#endif
        instrlist_concat_next_instr(ilist, 35, i0, i1, i2, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32, i34,
                                    i35, i36);
        return i0;

    } else {
        instr_t *i0 = INSTR_CREATE_pushf(dcontext);
        instr_t *i1 = INSTR_CREATE_push(dcontext, op64_scrach1);
        instr_t *i2 = INSTR_CREATE_push(dcontext, op64_scrach2);
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_spill1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill1)), OPSZ_16);
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_spill2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill2)), OPSZ_16);

        instr_t *i6 = INSTR_CREATE_movss(dcontext, op_xmm_spill2, src_for_load32);

        instr_t *i7 = INSTR_CREATE_pxor(dcontext, op_xmm_spill1, op_xmm_spill1);
        instr_t *i8 = INSTR_CREATE_ucomiss(dcontext, op_xmm_spill2, op_xmm_spill1);
        instr_t *i9 = INSTR_CREATE_jcc(dcontext, OP_jp, opnd_create_instr(lbl_invalid));  /* NaN */
        instr_t *i10 = INSTR_CREATE_jcc(dcontext, OP_jb, opnd_create_instr(lbl_invalid)); /* x < 0 */

        /* 2^320x4F800000 */
        instr_t *i11 = INSTR_CREATE_mov_imm(dcontext, op32_scrach1, OPND_CREATE_INT32(0x4F800000));
        instr_t *i12 = INSTR_CREATE_vmovd(dcontext, op_xmm_spill1, op32_scrach1);
        instr_t *i13 = INSTR_CREATE_ucomiss(dcontext, op_xmm_spill2, op_xmm_spill1);
        instr_t *i14 = INSTR_CREATE_jcc(dcontext, OP_jae, opnd_create_instr(lbl_invalid)); /* x >= 2^32 */

        /* 2^310x4F000000 */
        instr_t *i15 = INSTR_CREATE_mov_imm(dcontext, op32_scrach1, OPND_CREATE_INT32(0x4F000000));
        instr_t *i16 = INSTR_CREATE_vmovd(dcontext, op_xmm_spill1, op32_scrach1);
        instr_t *i17 = INSTR_CREATE_ucomiss(dcontext, op_xmm_spill2, op_xmm_spill1);
        instr_t *i18 = INSTR_CREATE_jcc(dcontext, OP_jb, opnd_create_instr(lbl_load_direct)); /* x < 2^31 */

        instr_t *i19 = INSTR_CREATE_subss(dcontext, op_xmm_spill2, op_xmm_spill1);
        instr_t *i20 = INSTR_CREATE_cvttss2si(dcontext, op32_scrach1, op_xmm_spill2);
        instr_t *i21 = INSTR_CREATE_mov_imm(dcontext, op64_scrach2, OPND_CREATE_INT64(0x80000000));
        instr_t *i22 = INSTR_CREATE_add(dcontext, op32_scrach1, op32_scrach2);
        instr_t *i23 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(lbl_store));

        instr_t *i24 = lbl_load_direct;
        instr_t *i25 = INSTR_CREATE_cvttss2si(dcontext, op32_scrach1, op_xmm_spill2);
        instr_t *i26 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(lbl_store));

        instr_t *i27 = lbl_invalid;
        instr_t *i28 = INSTR_CREATE_mov_imm(dcontext, op32_scrach1, OPND_CREATE_INT32(-1));

        instr_t *i29 = lbl_store;
        instr_t *i30 = INSTR_CREATE_mov_st(dcontext, dst_opnd, op32_scrach1);
        instr_t *i31 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill1)), OPSZ_16);
        instr_t *i32 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill2)), OPSZ_16);
        instr_t *i34 = INSTR_CREATE_pop(dcontext, op64_scrach2);
        instr_t *i35 = INSTR_CREATE_pop(dcontext, op64_scrach1);
        instr_t *i36 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 35, i0, i1, i2, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32, i34, i35, i36);
#endif
        instrlist_concat_next_instr(ilist, 35, i0, i1, i2, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32, i34,
                                    i35, i36);
        return i0;
    }
}

instr_t *
fast_rw_func_vcvtusi2sd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t op_src1, opnd_t op_src2,
                        opnd_t op_dst)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    instr_t *i1 = INSTR_CREATE_cvtsi2sd(dcontext, op_dst, op_src2);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
    return i1;
}

/**
 * @brief 561 vcvtusi2sd
 * vcvtusi2sd %xmm0[8byte] %rax -> %xmm0
 * IF 64-Bit Mode And OperandSize = 64
 *   THEN DEST[63:0] := Convert_UInteger_To_Double_Precision_Floating_Point(SRC2[63:0]);
 * DEST[127:64] := SRC1[127:64]
 * movlhps xmm0 -> xmm1 maybe work
 */
instr_t *
rw_func_vcvtusi2sd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t src_opnd1 = instr_get_src(instr, 0); // xmm reg
    opnd_t src_opnd2 = instr_get_src(instr, 1); // gpr or 32/64 bit mem loc
    opnd_t dst_opnd = instr_get_dst(instr, 0);  // xmm reg
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "rewrite %s at %p :", "vcvtusi2sd", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src_opnd1, "src1:");
    dr_print_opnd(dcontext, STD_OUTF, src_opnd2, "src2:");
    dr_print_opnd(dcontext, STD_OUTF, dst_opnd, "dst:");
#endif

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    reg_id_t src_xmm_reg1 = opnd_get_reg(src_opnd1);
    reg_id_t dst_xmm_reg = opnd_get_reg(dst_opnd);
    src_opnd1 = create_mapping_xmm_opnd(dcontext, src_xmm_reg1);
    dst_opnd = create_mapping_xmm_opnd(dcontext, dst_xmm_reg);

    reg_id_t reg64_scrach1 = DR_REG_NULL;
    reg_id_t reg64_scrach2 = DR_REG_NULL;
    reg_id_t reg64_scrach3 = DR_REG_NULL;
    int32_t RSP_disp = 0;
    bool is_RSP_disp_need_fix = false;
    reg_id_t base_reg = DR_REG_NULL;
    reg_id_t index_reg = DR_REG_NULL;
    int32_t scale = 0;

    if (src_opnd2.kind == REG_kind) {
        reg_id_t reg = opnd_get_reg(src_opnd2);
        if (find_spills_avoiding_3(reg64_scrach1, reg64_scrach2, reg64_scrach3, 1, reg) != 3) {
            REWRITE_ERROR(STD_OUTF, "find_spills_avoiding_3 failed");
            return NULL_INSTR;
        }
    } else if (src_opnd2.kind == BASE_DISP_kind) {
        base_reg = opnd_get_base(src_opnd2);
        index_reg = opnd_get_index(src_opnd2);
        scale = opnd_get_scale(src_opnd2);

        if (index_reg == DR_REG_NULL) {
            if (find_spills_avoiding_3(reg64_scrach1, reg64_scrach2, reg64_scrach3, 1, base_reg) != 3) {
                REWRITE_ERROR(STD_OUTF, "find_spills_avoiding_3 failed");
                return NULL_INSTR;
            }
        } else {
            if (find_spills_avoiding_3(reg64_scrach1, reg64_scrach2, reg64_scrach3, 2, base_reg, index_reg) != 3) {
                REWRITE_ERROR(STD_OUTF, "find_spills_avoiding_3 failed");
                return NULL_INSTR;
            }
        }
        if (base_reg == DR_REG_RSP) {
            // REWRITE_INFO(STD_OUTF, "RSP_disp_need_fix: %d", opnd_get_disp(src_opnd2));
            RSP_disp = opnd_get_disp(src_opnd2) + 0x20;
            is_RSP_disp_need_fix = true;
        }
    } else {
        reg64_scrach1 = DR_REG_RAX;
        reg64_scrach2 = DR_REG_RDX;
        reg64_scrach3 = DR_REG_RCX;
    }

    reg_id_t xmm_spill1 = find_available_spill_xmm_avoiding(src_xmm_reg1, dst_xmm_reg, DR_REG_NULL);
    reg_id_t xmm_spill2 = find_available_spill_xmm_avoiding(src_xmm_reg1, dst_xmm_reg, xmm_spill1);

    opnd_t op64_scrach1 = opnd_create_reg(reg64_scrach1);
    opnd_t op64_scrach2 = opnd_create_reg(reg64_scrach2);
    opnd_t op64_scrach3 = opnd_create_reg(reg64_scrach3);
    opnd_t op32_scrach1 = opnd_create_reg(GPR64_TO_GPR32(reg64_scrach1));
    opnd_t op32_scrach2 = opnd_create_reg(GPR64_TO_GPR32(reg64_scrach2));
    opnd_t op32_scrach3 = opnd_create_reg(GPR64_TO_GPR32(reg64_scrach3));

    opnd_t op_xmm_spill1 = opnd_create_reg(xmm_spill1);
    opnd_t op_xmm_spill2 = opnd_create_reg(xmm_spill2);

    // label we need to use
    instr_t *lbl_load_direct = INSTR_CREATE_label(dcontext);
    instr_t *lbl_store_xmm = INSTR_CREATE_label(dcontext);

    if (opnd_get_size(src_opnd2) == OPSZ_8) {
        // sse2 impl
        // spill rax, rcx, rdx to stack
        instr_t *i0 = INSTR_CREATE_pushf(dcontext);
        instr_t *i1 = INSTR_CREATE_push(dcontext, op64_scrach1);
        instr_t *i2 = INSTR_CREATE_push(dcontext, op64_scrach2);
        instr_t *i3 = INSTR_CREATE_push(dcontext, op64_scrach3);
        // spill xmm14, xmm15 to tls slot
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_spill1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill1)), OPSZ_16);
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_spill2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill2)), OPSZ_16);
        instr_t *i6 = INSTR_CREATE_movupd(dcontext, op_xmm_spill1, src_opnd1);
        // load double(2^63) bit pattern
        instr_t *i7 = INSTR_CREATE_mov_imm(dcontext, op64_scrach1, OPND_CREATE_INT64(0x43E0000000000000));
        instr_t *i8 = INSTR_CREATE_vmovq(dcontext, op_xmm_spill2, op64_scrach1);
        // load threshold 0x8000000000000000
        instr_t *i9 = INSTR_CREATE_mov_imm(dcontext, op64_scrach3, OPND_CREATE_INT64(0x8000000000000000));
        // is x < 2^63?
        instr_t *i10 = NULL;
        if (is_RSP_disp_need_fix) {
            i10 = INSTR_CREATE_mov_ld(dcontext, op64_scrach2,
                                      opnd_create_base_disp(DR_REG_RSP, index_reg, scale, RSP_disp, OPSZ_8));
        } else {
            i10 = INSTR_CREATE_mov_ld(dcontext, op64_scrach2, src_opnd2);
        }
        instr_t *i11 = INSTR_CREATE_mov_ld(dcontext, op64_scrach1, op64_scrach2);
        instr_t *i12 = INSTR_CREATE_shr(dcontext, op64_scrach2, OPND_CREATE_INT8(63));
        instr_t *i13 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(lbl_load_direct));
        // x >= 2^63
        instr_t *i14 = INSTR_CREATE_sub(dcontext, op64_scrach1, op64_scrach3);
        instr_t *i15 = INSTR_CREATE_cvtsi2sd(dcontext, op_xmm_spill1, op64_scrach1);
        instr_t *i16 = INSTR_CREATE_addsd(dcontext, op_xmm_spill1, op_xmm_spill2);
        instr_t *i17 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(lbl_store_xmm));

        // lbl load direct
        instr_t *i18 = lbl_load_direct;
        instr_t *i19 = INSTR_CREATE_cvtsi2sd(dcontext, op_xmm_spill1, op64_scrach1);

        // lbl store_xmm
        instr_t *i20 = lbl_store_xmm;
        instr_t *i21 = INSTR_CREATE_movupd(dcontext, dst_opnd, op_xmm_spill1);

        // restore regs
        instr_t *i22 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill1)), OPSZ_16);
        instr_t *i23 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill2)), OPSZ_16);
        instr_t *i24 = INSTR_CREATE_pop(dcontext, op64_scrach3);
        instr_t *i25 = INSTR_CREATE_pop(dcontext, op64_scrach2);
        instr_t *i26 = INSTR_CREATE_pop(dcontext, op64_scrach1);
        instr_t *i27 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 28, i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27);
#endif
        instrlist_concat_next_instr(ilist, 28, i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                    i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27);
        return i0;
    } else {
        // spill rax, rcx, rdx to stack
        instr_t *i0 = INSTR_CREATE_pushf(dcontext);
        instr_t *i1 = INSTR_CREATE_push(dcontext, op64_scrach1);
        instr_t *i2 = INSTR_CREATE_push(dcontext, op64_scrach2);
        instr_t *i3 = INSTR_CREATE_push(dcontext, op64_scrach3);
        // spill xmm14, xmm15 to tls slot
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_spill1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill1)), OPSZ_16);
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_spill2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill2)), OPSZ_16);
        instr_t *i6 = INSTR_CREATE_movupd(dcontext, op_xmm_spill1, src_opnd1);
        // load double(2^31) bit pattern
        instr_t *i7 = INSTR_CREATE_mov_imm(dcontext, op64_scrach1, OPND_CREATE_INT64(0x41E0000000000000));
        instr_t *i8 = instr_create_1dst_3src(dcontext, OP_vpinsrq, op_xmm_spill2, op_xmm_spill2, op64_scrach1,
                                             OPND_CREATE_INT8(0));
        // load threshold 0x80000000(2^31)
        instr_t *i9 = INSTR_CREATE_mov_imm(dcontext, op64_scrach3, OPND_CREATE_INT64(0x80000000));
        // is x < 2^31?
        instr_t *i10 = NULL;
        if (is_RSP_disp_need_fix) {
            i10 = INSTR_CREATE_mov_ld(dcontext, op32_scrach2,
                                      opnd_create_base_disp(DR_REG_RSP, index_reg, scale, RSP_disp, OPSZ_4));
        } else {
            i10 = INSTR_CREATE_mov_ld(dcontext, op32_scrach2, src_opnd2);
        }
        instr_t *i11 = INSTR_CREATE_mov_ld(dcontext, op32_scrach1, op32_scrach2);
        instr_t *i12 = INSTR_CREATE_shr(dcontext, op32_scrach2, OPND_CREATE_INT8(31));
        instr_t *i13 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(lbl_load_direct));
        // x >= 2^31
        instr_t *i14 = INSTR_CREATE_sub(dcontext, op32_scrach1, op32_scrach3);
        instr_t *i15 = INSTR_CREATE_cvtsi2sd(dcontext, op_xmm_spill1, op32_scrach1);
        instr_t *i16 = INSTR_CREATE_addsd(dcontext, op_xmm_spill1, op_xmm_spill2);
        instr_t *i17 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(lbl_store_xmm));

        // lbl load direct
        instr_t *i18 = lbl_load_direct;
        instr_t *i19 = INSTR_CREATE_cvtsi2sd(dcontext, op_xmm_spill1, op32_scrach1);

        // lbl store_xmm
        instr_t *i20 = lbl_store_xmm;
        instr_t *i21 = INSTR_CREATE_movupd(dcontext, dst_opnd, op_xmm_spill1);

        // restore regs
        instr_t *i22 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill1)), OPSZ_16);
        instr_t *i23 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill2)), OPSZ_16);
        instr_t *i24 = INSTR_CREATE_pop(dcontext, op64_scrach3);
        instr_t *i25 = INSTR_CREATE_pop(dcontext, op64_scrach2);
        instr_t *i26 = INSTR_CREATE_pop(dcontext, op64_scrach1);
        instr_t *i27 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 28, i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27);
#endif
        instrlist_concat_next_instr(ilist, 28, i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                    i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27);
        return i0;
    }
}

/**
 * @brief 562 vcvtusi2ss
 * vcvtusi2ss %xmm0[4byte] %rax -> %xmm0
 */
instr_t *
fast_rw_func_vcvtusi2ss(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t op_src1, opnd_t op_src2,
                        opnd_t op_dst)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    instr_t *i1 = INSTR_CREATE_vcvtsi2ss(dcontext, op_dst, op_src1, op_src2);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
    return i1;
}

/**
 * @brief 562 vcvtusi2ss
 * vcvtusi2ss %xmm0[4byte] %rax -> %xmm0
 */
instr_t *
rw_func_vcvtusi2ss(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    //  vcvtusi2ss %xmm0[12byte] %rdx -> %xmm0
    opnd_t src_opnd1 = instr_get_src(instr, 0); // xmm reg
    opnd_t src_opnd2 = instr_get_src(instr, 1); // gpr or 32/64 bit mem loc
    opnd_t dst_opnd = instr_get_dst(instr, 0);  // xmm reg
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vcvtusi2ss", true, true, false, true);
#endif

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    reg_id_t src_xmm_reg1 = opnd_get_reg(src_opnd1);
    reg_id_t dst_xmm_reg = opnd_get_reg(dst_opnd);
    src_opnd1 = opnd_create_reg(src_xmm_reg1);
    dst_opnd = opnd_create_reg(dst_xmm_reg);

    reg_id_t reg64_scrach1 = DR_REG_NULL;
    reg_id_t reg64_scrach2 = DR_REG_NULL;
    reg_id_t reg64_scrach3 = DR_REG_NULL;

    if (src_opnd2.kind == REG_kind) {
        reg_id_t reg = opnd_get_reg(src_opnd2);
        if (find_spills_avoiding_3(reg64_scrach1, reg64_scrach2, reg64_scrach3, 1, reg) != 3) {
            REWRITE_ERROR(STD_OUTF, "find_spills_avoiding_3 failed");
            return NULL_INSTR;
        }
    } else if (src_opnd2.kind == BASE_DISP_kind) {
        reg_id_t base_reg = opnd_get_base(src_opnd2);
        reg_id_t index_reg = opnd_get_index(src_opnd2);
        if (index_reg == DR_REG_NULL) {
            if (find_spills_avoiding_3(reg64_scrach1, reg64_scrach2, reg64_scrach3, 1, base_reg) != 3) {
                REWRITE_ERROR(STD_OUTF, "find_spills_avoiding_3 failed");
                return NULL_INSTR;
            }
        } else {
            if (find_spills_avoiding_3(reg64_scrach1, reg64_scrach2, reg64_scrach3, 2, base_reg, index_reg) != 3) {
                REWRITE_ERROR(STD_OUTF, "find_spills_avoiding_3 failed");
                return NULL_INSTR;
            }
        }
    } else {
        reg64_scrach1 = DR_REG_RAX;
        reg64_scrach2 = DR_REG_RDX;
        reg64_scrach3 = DR_REG_RCX;
    }

    opnd_t op64_scrach1 = opnd_create_reg(reg64_scrach1);
    opnd_t op64_scrach2 = opnd_create_reg(reg64_scrach2);
    opnd_t op64_scrach3 = opnd_create_reg(reg64_scrach3);
    opnd_t op32_scrach1 = opnd_create_reg(GPR64_TO_GPR32(reg64_scrach1));
    opnd_t op32_scrach2 = opnd_create_reg(GPR64_TO_GPR32(reg64_scrach2));
    opnd_t op32_scrach3 = opnd_create_reg(GPR64_TO_GPR32(reg64_scrach3));

    reg_id_t xmm_spill1 = find_available_spill_xmm_avoiding(src_xmm_reg1, dst_xmm_reg, DR_REG_NULL);
    reg_id_t xmm_spill2 = find_available_spill_xmm_avoiding(src_xmm_reg1, dst_xmm_reg, xmm_spill1);
    opnd_t op_xmm_spill2 = opnd_create_reg(xmm_spill2);

    // label we need to use
    instr_t *lbl_load_direct = INSTR_CREATE_label(dcontext);
    instr_t *lbl_store_xmm = INSTR_CREATE_label(dcontext);
    if (opnd_get_size(src_opnd2) == OPSZ_8) {
        // spill rax, rcx, rdx to stack
        instr_t *i0 = INSTR_CREATE_pushf(dcontext);
        instr_t *i1 = INSTR_CREATE_push(dcontext, op64_scrach1);
        instr_t *i2 = INSTR_CREATE_push(dcontext, op64_scrach2);
        instr_t *i3 = INSTR_CREATE_push(dcontext, op64_scrach3);
        // spill xmm14, xmm15 to tls slot
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_spill1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill1)), OPSZ_16);
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_spill2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill2)), OPSZ_16);
        // load float(2^63) bit pattern
        instr_t *i6 = INSTR_CREATE_mov_imm(dcontext, op32_scrach1, OPND_CREATE_INT32(0x5F000000));
        instr_t *i7 = instr_create_1dst_3src(dcontext, OP_vpinsrd, op_xmm_spill2, op_xmm_spill2, op32_scrach1,
                                             OPND_CREATE_INT8(0));
        // load threshold 0x8000000000000000
        instr_t *i8 = INSTR_CREATE_mov_imm(dcontext, op64_scrach3, OPND_CREATE_INT64(0x8000000000000000));
        // is x < 2^63?
        instr_t *i9 = INSTR_CREATE_mov_ld(dcontext, op64_scrach2, src_opnd2);
        instr_t *i10 = INSTR_CREATE_mov_ld(dcontext, op64_scrach1, op64_scrach2);
        instr_t *i11 = INSTR_CREATE_shr(dcontext, op64_scrach2, OPND_CREATE_INT8(63));

        instr_t *i12 = INSTR_CREATE_vpxor(dcontext, dst_opnd, dst_opnd, dst_opnd);

        instr_t *i13 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(lbl_load_direct));
        // x >= 2^63
        instr_t *i14 = INSTR_CREATE_sub(dcontext, op64_scrach1, op64_scrach3);

        instr_t *i15 = INSTR_CREATE_cvtsi2ss(dcontext, dst_opnd, op64_scrach1);
        instr_t *i16 = INSTR_CREATE_addss(dcontext, dst_opnd, op_xmm_spill2);

        instr_t *i17 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(lbl_store_xmm));

        // lbl load direct
        instr_t *i18 = lbl_load_direct;

        instr_t *i19 = INSTR_CREATE_cvtsi2ss(dcontext, dst_opnd, op64_scrach1);

        // lbl store_xmm
        instr_t *i20 = lbl_store_xmm;

        // restore regs
        instr_t *i21 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill1)), OPSZ_16);
        instr_t *i22 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill2)), OPSZ_16);
        instr_t *i23 = INSTR_CREATE_pop(dcontext, op64_scrach3);
        instr_t *i24 = INSTR_CREATE_pop(dcontext, op64_scrach2);
        instr_t *i25 = INSTR_CREATE_pop(dcontext, op64_scrach1);
        instr_t *i26 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 27, i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26);
#endif
        instrlist_concat_next_instr(ilist, 27, i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                    i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26);
        return i0;

    } else {
        // spill rax, rcx, rdx to stack
        instr_t *i0 = INSTR_CREATE_pushf(dcontext);
        instr_t *i1 = INSTR_CREATE_push(dcontext, op64_scrach1);
        instr_t *i2 = INSTR_CREATE_push(dcontext, op64_scrach2);
        instr_t *i3 = INSTR_CREATE_push(dcontext, op64_scrach3);
        // spill xmm14, xmm15 to tls slot
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_spill1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill1)), OPSZ_16);
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_spill2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill2)), OPSZ_16);
        // load float(2^31) bit pattern
        instr_t *i6 = INSTR_CREATE_mov_imm(dcontext, op64_scrach1, OPND_CREATE_INT64(0x4F000000));
        instr_t *i7 = instr_create_1dst_3src(dcontext, OP_vpinsrq, op_xmm_spill2, op_xmm_spill2, op64_scrach1,
                                             OPND_CREATE_INT8(0));
        // load threshold 0x80000000(2^31)
        instr_t *i8 = INSTR_CREATE_mov_imm(dcontext, op64_scrach3, OPND_CREATE_INT64(0x80000000));
        // is x < 2^31?
        instr_t *i9 = INSTR_CREATE_mov_ld(dcontext, op32_scrach2, src_opnd2);
        instr_t *i10 = INSTR_CREATE_mov_ld(dcontext, op32_scrach1, op32_scrach2);
        instr_t *i11 = INSTR_CREATE_shr(dcontext, op32_scrach2, OPND_CREATE_INT8(31));

        instr_t *i12 = INSTR_CREATE_vpxor(dcontext, dst_opnd, dst_opnd, dst_opnd);

        instr_t *i13 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(lbl_load_direct));
        // x >= 2^31
        instr_t *i14 = INSTR_CREATE_sub(dcontext, op32_scrach1, op32_scrach3);

        instr_t *i15 = INSTR_CREATE_cvtsi2ss(dcontext, dst_opnd, op32_scrach1);
        instr_t *i16 = INSTR_CREATE_addss(dcontext, dst_opnd, op_xmm_spill2);

        instr_t *i17 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(lbl_store_xmm));

        // lbl load direct
        instr_t *i18 = lbl_load_direct;

        instr_t *i19 = INSTR_CREATE_cvtsi2ss(dcontext, dst_opnd, op32_scrach1);

        // lbl store_xmm
        instr_t *i20 = lbl_store_xmm;

        // restore regs
        instr_t *i21 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill1)), OPSZ_16);
        instr_t *i22 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill2)), OPSZ_16);
        instr_t *i23 = INSTR_CREATE_pop(dcontext, op64_scrach3);
        instr_t *i24 = INSTR_CREATE_pop(dcontext, op64_scrach2);
        instr_t *i25 = INSTR_CREATE_pop(dcontext, op64_scrach1);
        instr_t *i26 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 27, i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26);
#endif
        instrlist_concat_next_instr(ilist, 27, i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                    i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26);
        return i0;
    }
}

instr_t * /* 563 */
rw_func_vextractf64x2(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vextractf64x2 {%k0} $0x01 %ymm1[16byte] -> %xmm1
    opnd_t imm8_opnd = instr_get_src(instr, 1);
    opnd_t src_opnd = instr_get_src(instr, 2);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vextractf64x2", true, true, true, true);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    reg_id_t src_reg = opnd_get_reg(src_opnd);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);

    // src reg is ymm, dst reg is xmm
    int src_ymm_idx = TO_YMM_REG_INDEX(src_reg);
    int dst_xmm_idx = TO_XMM_REG_INDEX(dst_reg);
    if (src_ymm_idx == dst_xmm_idx) {
        if (NEED_SPILL_YMM(src_reg)) {
            reg_id_t spill_src_reg = YMM_SPILL_SLOT0;
            reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
            opnd_t spill_src_opnd = opnd_create_reg(spill_src_reg);
            opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
            // spill_src_reg -> tls_slot(spill_src_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg)), OPSZ_32);
            // tls_slot(src_reg) -> spill_src_reg | YMM version
            instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg)), OPSZ_32);
            // vextracti128 spill_src_reg(ymm), imm8 -> spill_dst_reg(xmm)
            instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vextracti128, spill_dst_opnd, spill_src_opnd, imm8_opnd);
            // spill_dst_reg -> tls_slot(dst_reg) | XMM version
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls_slot(spill_src_reg) -> spill_src_reg
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } else {
            instr_t *i1 = instr_create_1dst_2src(dcontext, OP_vextractf128, dst_opnd, src_opnd, imm8_opnd);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
            return i1;
        }
    } else {
        instr_t *i1 = instr_create_1dst_2src(dcontext, OP_vextractf128, dst_opnd, src_opnd, imm8_opnd);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    }
    REWRITE_INFO(STD_OUTF, "vextractf64x2 pattern not support");
    return NULL_INSTR;
}

instr_t * /* 572 */
rw_func_vextracti32x4(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vextracti32x4 {%k0} $0x01 %ymm22[16byte] -> %xmm22
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t imm8_opnd = instr_get_src(instr, 1);
    opnd_t src_opnd = instr_get_src(instr, 2);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vextracti32x4", true, true, true, true);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    reg_id_t k_reg = opnd_get_reg(mask_opnd);
    reg_id_t src_reg = opnd_get_reg(src_opnd);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    const uint src_need_spill = NEED_SPILL_YMM(src_reg) ? 1 : 0;
    const uint dst_need_spill = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill = src_need_spill | dst_need_spill;

    int k_idx = TO_K_REG_INDEX(k_reg);
    if (k_idx == 0) {
        switch (need_spill) {
        case 0: { /* no spill */
            instr_t *i1 = instr_create_1dst_2src(dcontext, OP_vextracti128, dst_opnd, src_opnd, imm8_opnd);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
            instrlist_concat_next_instr(ilist, 1, i1);
            return i1;
        } break;
        case 1: { /* src need spill */
            reg_id_t src_spill_reg = find_one_available_spill_ymm(dst_reg);
            opnd_t op_src_spill = opnd_create_reg(src_spill_reg);

            // src_spill -> tls(src_spill)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src_spill_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_spill_reg)), OPSZ_32);
            // tls(src) -> src_spill
            instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg)), OPSZ_32);
            // vextracti32x4 imm8, src_spill -> dst
            instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vextracti128, dst_opnd, op_src_spill, imm8_opnd);
            // tls(src_spill) -> src_spill
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_spill_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
            instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
            return i1;
        } break;
        case 2: { /* dst need spill */
            reg_id_t dst_spill_reg = find_one_available_spill_xmm(src_reg);
            opnd_t op_dst_spill = opnd_create_reg(dst_spill_reg);

            // dst_spill -> tls(dst_spill)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_spill_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_spill_reg)), OPSZ_16);
            // vextracti32x4 imm8, src -> dst_spill
            instr_t *i2 = instr_create_1dst_2src(dcontext, OP_vextracti128, op_dst_spill, src_opnd, imm8_opnd);

            // dst_spill -> tls(dst)
            instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, XMM_TO_YMM(dst_spill_reg),
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(dst_spill) -> dst_spill
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_spill_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
            instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
            return i1;

        } break;
        case 3: { /* src and dst need spill */
            reg_id_t src_spill_reg = DR_REG_NULL;
            reg_id_t dst_spill_reg = DR_REG_NULL;
            if (TO_YMM_REG_INDEX(src_reg) == TO_XMM_REG_INDEX(dst_reg)) {
                src_spill_reg = YMM_SPILL_SLOT0;
                dst_spill_reg = YMM_TO_XMM(src_spill_reg);

                opnd_t op_src_spill = opnd_create_reg(src_spill_reg);
                opnd_t op_dst_spill = opnd_create_reg(dst_spill_reg);

                // src_spill -> tls(src_spill)
                instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src_spill_reg,
                                                     TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_spill_reg)), OPSZ_32);
                // tls(src) -> src_spill
                instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_spill_reg,
                                                          TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg)), OPSZ_32);
                // vextracti32x4 imm8, src -> dst
                instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vextracti128, op_dst_spill, op_src_spill, imm8_opnd);
                // dst_spill -> tls(dst)
                instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_spill_reg,
                                                     TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
                // tls(src_spill) -> src_spill
                instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_spill_reg,
                                                          TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_spill_reg)), OPSZ_32);
#ifdef DEBUG
                print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
                instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
                return i1;
            } else {
                src_spill_reg = YMM_SPILL_SLOT0;
                dst_spill_reg = XMM_SPILL_SLOT1;

                opnd_t op_src_spill = opnd_create_reg(src_spill_reg);
                opnd_t op_dst_spill = opnd_create_reg(dst_spill_reg);

                // src_spill -> tls(src_spill)
                instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src_spill_reg,
                                                     TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_spill_reg)), OPSZ_32);
                // dst_spill -> tls(dst_spill)
                instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_spill_reg,
                                                     TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_spill_reg)), OPSZ_16);
                // tls(src) -> src_spill
                instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_spill_reg,
                                                          TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg)), OPSZ_32);
                // vextracti32x4 imm8, src -> dst
                instr_t *i4 = instr_create_1dst_2src(dcontext, OP_vextracti128, op_dst_spill, op_src_spill, imm8_opnd);
                // dst_spill -> tls(dst)
                instr_t *i5 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_spill_reg,
                                                     TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
                // tls(src_spill) -> src_spill
                instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_spill_reg,
                                                          TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_spill_reg)), OPSZ_32);
                // tls(dst_spill) -> dst_spill
                instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_spill_reg,
                                                          TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_spill_reg)), OPSZ_16);
#ifdef DEBUG
                print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
                instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
                return i1;
            }
        } break;
        default: REWRITE_INFO(STD_OUTF, "vextracti32x4 pattern not support");
        }
        return NULL_INSTR;
    } else {
        return NULL_INSTR;
    }
}

/**
 * @brief 574 vextracti64x2
 * vextracti64x2 {%k0} $0x01 %ymm0[16byte] -> %xmm0
 */
instr_t *
rw_func_vextracti64x2(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t imm8_opnd = instr_get_src(instr, 1);
    opnd_t src_opnd = instr_get_src(instr, 2);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vextracti64x2", true, true, true, true);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    reg_id_t src_reg = opnd_get_reg(src_opnd);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);

    // src reg is ymm, dst reg is xmm
    int src_ymm_idx = TO_YMM_REG_INDEX(src_reg);
    int dst_xmm_idx = TO_XMM_REG_INDEX(dst_reg);
    if (src_ymm_idx == dst_xmm_idx) {
        if (NEED_SPILL_YMM(src_reg)) {
            reg_id_t spill_src_reg = YMM_SPILL_SLOT0;
            reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
            opnd_t spill_src_opnd = opnd_create_reg(spill_src_reg);
            opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
            // spill_src_reg -> tls_slot(spill_src_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg)), OPSZ_32);
            // tls_slot(src_reg) -> spill_src_reg | YMM version
            instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg)), OPSZ_32);
            // vextracti128 spill_src_reg(ymm), imm8 -> spill_dst_reg(xmm)
            instr_t *i3 = instr_create_1dst_2src(dcontext, OP_vextracti128, spill_dst_opnd, spill_src_opnd, imm8_opnd);
            // spill_dst_reg -> tls_slot(dst_reg) | XMM version
            instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, XMM_TO_YMM(spill_dst_reg),
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls_slot(spill_src_reg) -> spill_src_reg
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } else {
            instr_t *i1 = instr_create_1dst_2src(dcontext, OP_vextracti128, dst_opnd, src_opnd, imm8_opnd);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
            return i1;
        }
    } else {
        instr_t *i1 = instr_create_1dst_2src(dcontext, OP_vextracti128, dst_opnd, src_opnd, imm8_opnd);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    }
    REWRITE_INFO(STD_OUTF, "vextracti64x2 pattern not support");
    return NULL_INSTR;
}

/**
 * @brief 607 vinsrti64x4
 * vinserti64x4 {%k0} $0x01 %zmm0[16byte] %xmm1 -> %zmm0
 */
instr_t * /* 607 */
rw_func_vinserti64x4(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    instr_t *new_instr1 = instr_create_0dst_0src(dcontext, OP_nop);
    instr_disassemble(dcontext, new_instr1, 1);
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    return new_instr1;
}

// ==============================================
//         Helper func for vmovdqu16
// ==============================================

instr_t *
vmovdqu16_xmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{
    opnd_t src_opnd = create_mapping_xmm_opnd(dcontext, src_reg);
    opnd_t dst_opnd = create_mapping_xmm_opnd(dcontext, dst_reg);
    instr_t *new_instr1 = instr_create_1dst_1src(dcontext, OP_vmovdqu, dst_opnd, src_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vmovdqu16_ymm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{
    opnd_t src_opnd = create_mapping_ymm_opnd(dcontext, src_reg);
    opnd_t dst_opnd = create_mapping_ymm_opnd(dcontext, dst_reg);
    instr_t *new_instr1 = instr_create_1dst_1src(dcontext, OP_vmovdqu, dst_opnd, src_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vmovdqu16_zmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{
    dr_ymm_pair_t src_ymm_pair = { EMPTY, EMPTY };
    dr_ymm_pair_t dst_ymm_pair = { EMPTY, EMPTY };
    if (get_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(src_reg), &src_ymm_pair) == NOT_GET) {
        if (find_and_set_unused_ymm_pair(dcontext, &src_ymm_pair) == NOT_FIND) {
            return NULL_INSTR; // means failed find unused ymm pair, abandon instr rewrite
        }
        add_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(src_reg), &src_ymm_pair);
    }
    if (get_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(dst_reg), &dst_ymm_pair) == NOT_GET) {
        if (find_and_set_unused_ymm_pair(dcontext, &dst_ymm_pair) == NOT_FIND) {
            return NULL_INSTR; // means failed find unused ymm pair, abandon instr rewrite
        }
        add_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(dst_reg), &dst_ymm_pair);
    }
    reg_id_t src_reg_lower = TO_YMM_REG_ID_NUM(src_ymm_pair.ymm_lower);
    reg_id_t src_reg_upper = TO_YMM_REG_ID_NUM(src_ymm_pair.ymm_upper);
    reg_id_t dst_reg_lower = TO_YMM_REG_ID_NUM(dst_ymm_pair.ymm_lower);
    reg_id_t dst_reg_upper = TO_YMM_REG_ID_NUM(dst_ymm_pair.ymm_upper);

#ifdef DEBUG
    REWRITE_INFO(STD_OUTF,
                 "vmovdqu_zmm_reg2reg_gen: src_reg_lower{ymm%d}, src_reg_upper{ymm%d}, dst_reg_lower{ymm%d}, "
                 "dst_reg_upper{ymm%d}",
                 src_reg_lower - DR_REG_YMM0, src_reg_upper - DR_REG_YMM0, dst_reg_lower - DR_REG_YMM0,
                 dst_reg_upper - DR_REG_YMM0);
#endif

    instr_t *new_instr1 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, opnd_create_reg(dst_reg_lower), opnd_create_reg(src_reg_lower));
    instr_t *new_instr2 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, opnd_create_reg(dst_reg_upper), opnd_create_reg(src_reg_upper));
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 2, new_instr1, new_instr2);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    new_instr1->next = new_instr2;
    return new_instr1;
}

instr_t *
vmovdqu16_xmm_reg2disp_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, opnd_t dst_opnd,
                           reg_id_t mask_reg)
{
    opnd_t src_opnd = create_mapping_xmm_opnd(dcontext, src_reg);
    instr_t *new_instr1 = instr_create_1dst_1src(dcontext, OP_vmovdqu, dst_opnd, src_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vmovdqu16_ymm_reg2disp_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, opnd_t dst_opnd,
                           reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    int k_idx = TO_K_REG_INDEX(mask_reg);
    if (k_idx == 0) {
        opnd_t src_opnd = create_mapping_ymm_opnd(dcontext, src_reg);
        instr_t *new_instr1 = instr_create_1dst_1src(dcontext, OP_vmovdqu, dst_opnd, src_opnd);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
        return new_instr1;
    } else {
        // use k1~k7, need to rewrite the mask logic
        instr_t *SKIP_STORE = INSTR_CREATE_label(dcontext);
        instr_t *FULL_STORE = INSTR_CREATE_label(dcontext);

        reg_id_t scratch_reg_gpr64 = DR_REG_RAX;
        reg_id_t scratch_reg_gpr32 = DR_REG_EAX;
        opnd_t scratch_opnd_gpr64 = opnd_create_reg(scratch_reg_gpr64);
        opnd_t scratch_opnd_gpr32 = opnd_create_reg(scratch_reg_gpr32);

        reg_id_t ymm_src = src_reg;
        reg_id_t ymm_bit_pattern = find_one_available_spill_ymm(src_reg);
        reg_id_t ymm_mask = find_available_spill_ymm_avoiding(src_reg, ymm_bit_pattern, DR_REG_NULL);
        reg_id_t xmm_mask = ymm_mask - DR_REG_YMM0 + DR_REG_XMM0;
        reg_id_t ymm_init_dst = find_available_spill_ymm_avoiding(src_reg, ymm_bit_pattern, ymm_mask);
        reg_id_t ymm_final_dst =
            find_available_spill_ymm_avoiding_variadic(4, src_reg, ymm_bit_pattern, ymm_mask, ymm_init_dst);

        /* opnd for scratch ymms */
        opnd_t ymm_src_opnd = opnd_create_reg(ymm_src);
        opnd_t ymm_bit_pattern_opnd = opnd_create_reg(ymm_bit_pattern);
        opnd_t ymm_mask_opnd = opnd_create_reg(ymm_mask);
        opnd_t xmm_mask_opnd = opnd_create_reg(xmm_mask);
        opnd_t ymm_init_dst_opnd = opnd_create_reg(ymm_init_dst);
        opnd_t ymm_final_dst_opnd = opnd_create_reg(ymm_final_dst);

        // push rax;
        instr_t *i1 = INSTR_CREATE_push(dcontext, scratch_opnd_gpr64);
        // push eflags;
        instr_t *i2 = INSTR_CREATE_pushf(dcontext);
        // tls_slot(mask_reg) -> eax
        instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
        // test eax, eax
        instr_t *i4 = INSTR_CREATE_test(dcontext, scratch_opnd_gpr32, scratch_opnd_gpr32);
        // jz SKIP_STORE
        instr_t *i5 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_STORE));
        // cmpl 0xffff, eax
        instr_t *i6 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EAX), opnd_create_immed_int(0xffff, OPSZ_4));
        // je FULL_STORE
        instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_STORE));

        // spill ymm_bit_pattern, ymm_mask, ymm_init_dst, ymm_final_dst
        instr_t *i8 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_bit_pattern,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_bit_pattern)), OPSZ_32);
        instr_t *i9 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_mask, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);
        instr_t *i10 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_init_dst, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_init_dst)), OPSZ_32);
        instr_t *i11 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_final_dst, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_final_dst)), OPSZ_32);
        // sub rsp 32
        instr_t *i12 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM, OPSZ_4));
        // movabsq $0x0008000400020001, %rax # bits 0-3
        instr_t *i13 =
            INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64, opnd_create_immed_int(0x0008000400020001, OPSZ_8));
        // movq    %rax, (%rsp)
        instr_t *i14 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8),
                                           scratch_opnd_gpr64);
        // movabsq $0x0080004000200010, %rax # bits 4-7
        instr_t *i15 =
            INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64, opnd_create_immed_int(0x0080004000200010, OPSZ_8));
        // movq    %rax, 8(%rsp)
        instr_t *i16 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8),
                                           scratch_opnd_gpr64);
        // movabsq $0x0800040002000100, %rax # bits 8-11
        instr_t *i17 =
            INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64, opnd_create_immed_int(0x0800040002000100, OPSZ_8));
        // movq    %rax, 16(%rsp)
        instr_t *i18 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8),
                                           scratch_opnd_gpr64);
        // movabsq $0x8000400020001000, %rax # bits 12-15
        instr_t *i19 =
            INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64, opnd_create_immed_int(0x8000400020001000, OPSZ_8));
        // movq    %rax, 24(%rsp)
        instr_t *i20 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8),
                                           scratch_opnd_gpr64);
        // vmovdqu (%rsp), %ymm_bit_pattern | bit pattern get the constant value
        instr_t *i21 = INSTR_CREATE_vmovdqu(dcontext, ymm_bit_pattern_opnd,
                                            opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));
        // vmovdqu <dst_opnd>, %ymm_init_dst | init_dst used in the vpblendvb
        instr_t *i22 = INSTR_CREATE_vmovdqu(dcontext, ymm_init_dst_opnd, dst_opnd);
        // add rsp 32
        instr_t *i23 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM, OPSZ_4));

        // tls_slot(mask_reg) -> eax (scratch_reg_gpr64)
        instr_t *i24 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
        // eax * 0x10001, (mask | (mask << 16))
        instr_t *i25 = INSTR_CREATE_imul_imm(dcontext, scratch_opnd_gpr32, scratch_opnd_gpr32,
                                             opnd_create_immed_int(0x10001, OPSZ_4));
        // vmovd eax -> xmm_mask
        instr_t *i26 = INSTR_CREATE_vmovd(dcontext, xmm_mask_opnd, scratch_opnd_gpr32);
        // vpbroadcastd xmm_mask -> ymm_mask
        instr_t *i27 = INSTR_CREATE_vpbroadcastd(dcontext, ymm_mask_opnd, xmm_mask_opnd);
        // vpand ymm_bit_pattern & ymm_mask -> ymm_mask
        instr_t *i28 = INSTR_CREATE_vpand(dcontext, ymm_mask_opnd, ymm_mask_opnd, ymm_bit_pattern_opnd);
        // vpcmpeqw ymm_mask, ymm_bit_pattern -> ymm_mask
        instr_t *i29 = INSTR_CREATE_vpcmpeqw(dcontext, ymm_mask_opnd, ymm_mask_opnd, ymm_bit_pattern_opnd);
        // vpblendvb ymm_init_dst, ymm_src, ymm_mask -> ymm_final_dst
        instr_t *i30 =
            INSTR_CREATE_vpblendvb(dcontext, ymm_final_dst_opnd, ymm_init_dst_opnd, ymm_src_opnd, ymm_mask_opnd);
        // vmovdqu ymm_final_dst -> <dst_opnd>
        instr_t *i31 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, ymm_final_dst_opnd);

        // restore
        instr_t *i32 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_bit_pattern,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_bit_pattern)), OPSZ_32);
        instr_t *i33 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_mask, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);
        instr_t *i34 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_init_dst,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_init_dst)), OPSZ_32);
        instr_t *i35 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_final_dst,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_final_dst)), OPSZ_32);
        // jmp SKIP_STORE
        instr_t *i36 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_STORE));

        // FULL_STORE:
        // vmovdqu ymm_src -> <dst_opnd>
        instr_t *i37 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, ymm_src_opnd);

        // SKIP_STORE: (only a label)
        // pop eflags;
        instr_t *i38 = INSTR_CREATE_popf(dcontext);
        // pop rax;
        instr_t *i39 = INSTR_CREATE_pop(dcontext, scratch_opnd_gpr64);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 41, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32, i33, i34, i35, i36, FULL_STORE, i37, SKIP_STORE, i38, i39);
#endif
        instrlist_concat_next_instr(ilist, 41, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32, i33,
                                    i34, i35, i36, FULL_STORE, i37, SKIP_STORE, i38, i39);
        return i1;
    }
}

instr_t *
vmovdqu16_zmm_reg2disp_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, opnd_t dst_opnd,
                           reg_id_t mask_reg)
{
    dr_ymm_pair_t src_ymm_pair = { EMPTY, EMPTY };
    int disp = opnd_get_disp(dst_opnd);
    // int opsz = opnd_get_size(dst_opnd);
    reg_id_t dst_base_reg = opnd_get_base(dst_opnd);
    reg_id_t dst_index_reg = opnd_get_index(dst_opnd);
    int scale = opnd_get_scale(dst_opnd);
    if (get_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(src_reg), &src_ymm_pair) == NOT_GET) {
        if (find_and_set_unused_ymm_pair(dcontext, &src_ymm_pair) == NOT_FIND)
            return NULL_INSTR;
        add_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(src_reg), &src_ymm_pair);
    }
    reg_id_t src_reg_lower = TO_YMM_REG_ID_NUM(src_ymm_pair.ymm_lower);
    reg_id_t src_reg_upper = TO_YMM_REG_ID_NUM(src_ymm_pair.ymm_upper);

#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "vmovdqu_zmm_reg2disp_gen: src_reg_lower{ymm%d}, src_reg_upper{ymm%d}",
                 src_reg_lower - DR_REG_YMM0, src_reg_upper - DR_REG_YMM0);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vmovdqu,
                                         opnd_create_base_disp(dst_base_reg, dst_index_reg, scale, disp, OPSZ_32),
                                         opnd_create_reg(src_reg_lower));
    instr_t *i2 = instr_create_1dst_1src(
        dcontext, OP_vmovdqu, opnd_create_base_disp(dst_base_reg, dst_index_reg, scale, disp + SIZE_OF_YMM, OPSZ_32),
        opnd_create_reg(src_reg_upper));
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 2, i1, i2);
#endif
    i1->next = i2;
    return i1;
}

instr_t *
vmovdqu16_zmm_reg2reladdr_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                              opnd_t dst_opnd, reg_id_t mask_reg)
{
    // vmovdqu16 {%k0} %zmm1 -> <rel> 0x00007f4444daf5e2[64byte]
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    dr_ymm_pair_t src_ymm_pair = { EMPTY, EMPTY };
    if (get_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(src_reg), &src_ymm_pair) == NOT_GET) {
        if (find_and_set_unused_ymm_pair(dcontext, &src_ymm_pair) == NOT_FIND)
            return NULL_INSTR;
        add_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(src_reg), &src_ymm_pair);
    }
    reg_id_t src_reg_lower = TO_YMM_REG_ID_NUM(src_ymm_pair.ymm_lower);
    reg_id_t src_reg_upper = TO_YMM_REG_ID_NUM(src_ymm_pair.ymm_upper);

    opnd_t op_src_reg_lower = opnd_create_reg(src_reg_lower);
    opnd_t op_src_reg_upper = opnd_create_reg(src_reg_upper);

    // vmovdqu src_reg_lower -> dst_opnd_lower
    instr_t *i1 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, op_src_reg_lower);
    // vmovdqu src_reg_upper -> dst_opnd_upper
    instr_t *i2 = INSTR_CREATE_vmovdqu(
        dcontext, opnd_create_rel_addr((void *)((char *)opnd_get_addr(dst_opnd) + SIZE_OF_YMM), OPSZ_32),
        op_src_reg_upper);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 2, i1, i2);
#endif
    instrlist_concat_next_instr(ilist, 2, i1, i2);
    return i1;
}

instr_t *
vmovdqu16_ymm_reg2reladdr_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                              opnd_t dst_opnd, reg_id_t mask_reg)
{
    // vmovdqu16 {%k1} %ymm2 -> <rel> 0x00007f4444daf5e2[32byte]

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    int k_idx = TO_K_REG_INDEX(mask_reg);
    if (k_idx == 0) {
        // use k0 is same as using no mask, directly use vmovdqu
        instr_t *new_instr1 =
            instr_create_1dst_1src(dcontext, OP_vmovdqu, dst_opnd, create_mapping_ymm_opnd(dcontext, src_reg));
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
        return new_instr1;
    } else {
        // use k1~k7, need to rewrite the mask logic
        instr_t *SKIP_STORE = INSTR_CREATE_label(dcontext);
        instr_t *FULL_STORE = INSTR_CREATE_label(dcontext);

        reg_id_t scratch_reg_gpr64 = DR_REG_RAX;
        reg_id_t scratch_reg_gpr32 = DR_REG_EAX;
        opnd_t scratch_opnd_gpr64 = opnd_create_reg(scratch_reg_gpr64);
        opnd_t scratch_opnd_gpr32 = opnd_create_reg(scratch_reg_gpr32);

        reg_id_t ymm_src = src_reg;
        reg_id_t ymm_bit_pattern = find_one_available_spill_ymm(src_reg);
        reg_id_t ymm_mask = find_available_spill_ymm_avoiding(src_reg, ymm_bit_pattern, DR_REG_NULL);
        reg_id_t xmm_mask = ymm_mask - DR_REG_YMM0 + DR_REG_XMM0;
        reg_id_t ymm_init_dst = find_available_spill_ymm_avoiding(src_reg, ymm_bit_pattern, ymm_mask);
        reg_id_t ymm_final_dst =
            find_available_spill_ymm_avoiding_variadic(4, src_reg, ymm_bit_pattern, ymm_mask, ymm_init_dst);

        /* opnd for scratch ymms */
        opnd_t ymm_src_opnd = opnd_create_reg(ymm_src);
        opnd_t ymm_bit_pattern_opnd = opnd_create_reg(ymm_bit_pattern);
        opnd_t ymm_mask_opnd = opnd_create_reg(ymm_mask);
        opnd_t xmm_mask_opnd = opnd_create_reg(xmm_mask);
        opnd_t ymm_init_dst_opnd = opnd_create_reg(ymm_init_dst);
        opnd_t ymm_final_dst_opnd = opnd_create_reg(ymm_final_dst);

        // push rax;
        instr_t *i1 = INSTR_CREATE_push(dcontext, scratch_opnd_gpr64);
        // push eflags;
        instr_t *i2 = INSTR_CREATE_pushf(dcontext);
        // tls_slot(mask_reg) -> eax
        instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
        // test eax, eax
        instr_t *i4 = INSTR_CREATE_test(dcontext, scratch_opnd_gpr32, scratch_opnd_gpr32);
        // jz SKIP_STORE
        instr_t *i5 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_STORE));
        // cmpl 0xffff, eax
        instr_t *i6 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EAX), opnd_create_immed_int(0xffff, OPSZ_4));
        // je FULL_STORE
        instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_STORE));

        // spill ymm_bit_pattern, ymm_mask, ymm_init_dst, ymm_final_dst
        instr_t *i8 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_bit_pattern,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_bit_pattern)), OPSZ_32);
        instr_t *i9 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_mask, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);
        instr_t *i10 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_init_dst, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_init_dst)), OPSZ_32);
        instr_t *i11 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_final_dst, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_final_dst)), OPSZ_32);

        // sub rsp 32
        instr_t *i12 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM, OPSZ_4));
        // movabsq $0x0008000400020001, %rax # bits 0-3
        instr_t *i13 =
            INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64, opnd_create_immed_int(0x0008000400020001, OPSZ_8));
        // movq    %rax, (%rsp)
        instr_t *i14 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8),
                                           scratch_opnd_gpr64);
        // movabsq $0x0080004000200010, %rax # bits 4-7
        instr_t *i15 =
            INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64, opnd_create_immed_int(0x0080004000200010, OPSZ_8));
        // movq    %rax, 8(%rsp)
        instr_t *i16 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8),
                                           scratch_opnd_gpr64);
        // movabsq $0x0800040002000100, %rax # bits 8-11
        instr_t *i17 =
            INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64, opnd_create_immed_int(0x0800040002000100, OPSZ_8));
        // movq    %rax, 16(%rsp)
        instr_t *i18 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8),
                                           scratch_opnd_gpr64);
        // movabsq $0x8000400020001000, %rax # bits 12-15
        instr_t *i19 =
            INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64, opnd_create_immed_int(0x8000400020001000, OPSZ_8));
        // movq    %rax, 24(%rsp)
        instr_t *i20 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8),
                                           scratch_opnd_gpr64);
        // vmovdqu (%rsp), %ymm_bit_pattern | bit pattern get the constant value
        instr_t *i21 = INSTR_CREATE_vmovdqu(dcontext, ymm_bit_pattern_opnd,
                                            opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));
        // vmovdqu <dst_opnd>, %ymm_init_dst | init_dst used in the vpblendvb
        instr_t *i22 = INSTR_CREATE_vmovdqu(dcontext, ymm_init_dst_opnd, dst_opnd);
        // add rsp 32
        instr_t *i23 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM, OPSZ_4));

        // tls_slot(mask_reg) -> eax (scratch_reg_gpr64)
        instr_t *i24 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
        // eax * 0x10001, (mask | (mask << 16))
        instr_t *i25 = INSTR_CREATE_imul_imm(dcontext, scratch_opnd_gpr32, scratch_opnd_gpr32,
                                             opnd_create_immed_int(0x10001, OPSZ_4));
        // vmovd eax -> xmm_mask
        instr_t *i26 = INSTR_CREATE_vmovd(dcontext, xmm_mask_opnd, scratch_opnd_gpr32);
        // vpbroadcastd xmm_mask -> ymm_mask
        instr_t *i27 = INSTR_CREATE_vpbroadcastd(dcontext, ymm_mask_opnd, xmm_mask_opnd);
        // vpand ymm_bit_pattern & ymm_mask -> ymm_mask
        instr_t *i28 = INSTR_CREATE_vpand(dcontext, ymm_mask_opnd, ymm_mask_opnd, ymm_bit_pattern_opnd);
        // vpcmpeqw ymm_mask, ymm_bit_pattern -> ymm_mask
        instr_t *i29 = INSTR_CREATE_vpcmpeqw(dcontext, ymm_mask_opnd, ymm_mask_opnd, ymm_bit_pattern_opnd);
        // vpblendvb ymm_init_dst, ymm_src, ymm_mask -> ymm_final_dst
        instr_t *i30 =
            INSTR_CREATE_vpblendvb(dcontext, ymm_final_dst_opnd, ymm_init_dst_opnd, ymm_src_opnd, ymm_mask_opnd);
        // vmovdqu ymm_final_dst -> <dst_opnd>
        instr_t *i31 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, ymm_final_dst_opnd);

        // restore ymm_bit_pattern, ymm_mask, ymm_init_dst, ymm_final_dst
        instr_t *i32 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_bit_pattern,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_bit_pattern)), OPSZ_32);
        instr_t *i33 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_mask, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);
        instr_t *i34 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_init_dst,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_init_dst)), OPSZ_32);
        instr_t *i35 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_final_dst,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_final_dst)), OPSZ_32);

        // jmp SKIP_STORE
        instr_t *i36 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_STORE));

        // FULL_STORE:
        // vmovdqu ymm_src -> <dst_opnd>
        instr_t *i37 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, ymm_src_opnd);

        // SKIP_STORE: (only a label)
        // pop eflags;
        instr_t *i38 = INSTR_CREATE_popf(dcontext);
        // pop rax;
        instr_t *i39 = INSTR_CREATE_pop(dcontext, scratch_opnd_gpr64);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 41, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32, i33, i34, i35, i36, FULL_STORE, i37, SKIP_STORE, i38, i39);
#endif
        instrlist_concat_next_instr(ilist, 41, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32, i33,
                                    i34, i35, i36, FULL_STORE, i37, SKIP_STORE, i38, i39);
        return i1;
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu16_xmm_reg2reladdr_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                              opnd_t dst_opnd, reg_id_t mask_reg)
{
    instr_t *new_instr1 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, dst_opnd, create_mapping_xmm_opnd(dcontext, src_reg));
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vmovdqu16_xmm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t op_src, reg_id_t dst_reg,
                           reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint dst_need_spill = NEED_SPILL_XMM(dst_reg) ? 1 : 0;

    switch (dst_need_spill) {
    case 0: { /* no spill */
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vmovdqu, op_dst, op_src);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* dst need spill */
        reg_id_t dst_spill_reg = XMM_SPILL_SLOT0;
        opnd_t op_dst_spill = opnd_create_reg(dst_spill_reg);
        // spill_dst_reg -> tls(dst_spill_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_spill_reg)), OPSZ_16);
        // vmovdqu op_src -> spill_dst_reg
        instr_t *i2 = INSTR_CREATE_vmovdqu(dcontext, op_dst_spill, op_src);
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(dst_spill_reg) -> spill_dst_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_spill_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_spill_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    default: {
        REWRITE_INFO(STD_OUTF, "vmodqu16 xmm disp2reg pattern not support\n");
    }
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu16_ymm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t op_src, reg_id_t dst_reg,
                           reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint dst_need_spill = NEED_SPILL_YMM(dst_reg) ? 1 : 0;

    switch (dst_need_spill) {
    case 0: { /* no spill */
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vmovdqu, op_dst, op_src);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* dst need spill */
        reg_id_t dst_spill_reg = YMM_SPILL_SLOT0;
        opnd_t op_dst_spill = opnd_create_reg(dst_spill_reg);
        // spill_dst_reg -> tls(dst_spill_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_spill_reg)), OPSZ_32);
        // vmovdqu op_src -> spill_dst_reg
        instr_t *i2 = INSTR_CREATE_vmovdqu(dcontext, op_dst_spill, op_src);
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls(dst_spill_reg) -> spill_dst_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_spill_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_spill_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    default: {
        REWRITE_INFO(STD_OUTF, "vmodqu16 ymm disp2reg pattern not support\n");
    }
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu16_zmm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd, reg_id_t dst_reg,
                           reg_id_t mask_reg)
{
    // vmovdqu16 0x00000140(%rsp)[64byte] -> %zmm1
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    reg_id_t src_base_reg = opnd_get_base(src_opnd);
    reg_id_t src_index_reg = opnd_get_index(src_opnd);
    int scale = opnd_get_scale(src_opnd);
    int disp = opnd_get_disp(src_opnd);

    const uint dst_need_spill = NEED_SPILL_ZMM(dst_reg) ? 1 : 0;
    switch (dst_need_spill) {
    case 0: { /* no spill */
        reg_id_t dst_reg_lower = ZMM_TO_YMM(dst_reg);
        reg_id_t dst_reg_upper = find_one_available_spill_ymm(dst_reg_lower);

        opnd_t op_dst_reg_lower = opnd_create_reg(dst_reg_lower);
        opnd_t op_dst_reg_upper = opnd_create_reg(dst_reg_upper);

        // dst_reg_upper -> tls(dst_reg_upper)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);
        // vmovdqu16 src_low -> dst_reg_lower
        instr_t *i2 = INSTR_CREATE_vmovdqu(dcontext, op_dst_reg_lower,
                                           opnd_create_base_disp(src_base_reg, src_index_reg, scale, disp, OPSZ_32));
        // vmovdqu16 src_high -> dst_reg_upper
        instr_t *i3 = INSTR_CREATE_vmovdqu(
            dcontext, op_dst_reg_upper,
            opnd_create_base_disp(src_base_reg, src_index_reg, scale, disp + SIZE_OF_YMM, OPSZ_32));
        // dst_reg_lower -> tls(dst_lower)
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_32);
        // dst_reg_upper -> tls(dst_upper)
        instr_t *i5 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_32);
        // tls(dst_reg_upper) -> dst_reg_upper
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 6, i1, i2, i3, i4, i5, i6);
#endif
        instrlist_concat_next_instr(ilist, 6, i1, i2, i3, i4, i5, i6);
        return i1;
    } break;
    case 1: { /* dst need spill */
        reg_id_t spill_dst_reg = find_one_available_spill_ymm(DR_REG_NULL);
        reg_id_t spill_dst_reg_upper = find_one_available_spill_ymm(spill_dst_reg);

        opnd_t op_spill_dst_reg = opnd_create_reg(spill_dst_reg);
        opnd_t op_spill_dst_reg_upper = opnd_create_reg(spill_dst_reg_upper);

        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        // spill_dst_reg_upper -> tls(spill_dst_reg_upper)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg_upper)), OPSZ_32);
        // vmovdqu16 src_low -> spill_dst_reg
        instr_t *i3 = INSTR_CREATE_vmovdqu(dcontext, op_spill_dst_reg,
                                           opnd_create_base_disp(src_base_reg, src_index_reg, scale, disp, OPSZ_32));
        // vmovdqu16 src_high -> spill_dst_reg_upper
        instr_t *i4 = INSTR_CREATE_vmovdqu(
            dcontext, op_spill_dst_reg_upper,
            opnd_create_base_disp(src_base_reg, src_index_reg, scale, disp + SIZE_OF_YMM, OPSZ_32));
        // spill_dst_reg -> tls(dst_lower)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_32);
        // spill_dst_reg_upper -> tls(dst_upper)
        instr_t *i6 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_32);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        // tls(spill_dst_reg_upper) -> spill_dst_reg_upper
        instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg_upper)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
        instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
        return i1;
    } break;
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu16_xmm_reladdr2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint dst_need_spill = NEED_SPILL_XMM(dst_reg) ? 1 : 0;

    switch (dst_need_spill) {
    case 0: {
        instr_t *new_instr1 =
            instr_create_1dst_1src(dcontext, OP_vmovdqu, create_mapping_xmm_opnd(dcontext, dst_reg), src_opnd);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
        return new_instr1;
    } break;
    case 1: {
        reg_id_t spill_dst_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *new_instr1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vmovdqu src_opnd -> spill_dst_reg
        instr_t *new_instr2 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd, src_opnd);
        // spill_dst_reg -> tls(dst_reg)
        instr_t *new_instr3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *new_instr4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                          TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, new_instr1, new_instr2, new_instr3, new_instr4);
#endif
        instrlist_concat_next_instr(ilist, 4, new_instr1, new_instr2, new_instr3, new_instr4);
        return new_instr1;
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vmovdqu_xmm_reladdr2reg_gen not support");
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu16_ymm_reladdr2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
    instr_t *new_instr1 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, create_mapping_ymm_opnd(dcontext, dst_reg), src_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vmovdqu16_zmm_reladdr2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "vmovdqu_zmm_reladdr2reg_gen not support");
#endif
    return NULL_INSTR;
}

instr_t *
vmovdqu16_xmm_absaddr2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
    instr_t *new_instr1 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, create_mapping_xmm_opnd(dcontext, dst_reg), src_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vmovdqu16_ymm_absaddr2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
    instr_t *new_instr1 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, create_mapping_ymm_opnd(dcontext, dst_reg), src_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vmovdqu16_zmm_absaddr2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    reg_id_t dst_reg_lower = ZMM_TO_YMM(dst_reg);
    reg_id_t dst_reg_upper = find_one_available_spill_ymm(dst_reg_lower);

    opnd_t op_dst_reg_lower = opnd_create_reg(dst_reg_lower);
    opnd_t op_dst_reg_upper = opnd_create_reg(dst_reg_upper);

    // dst_reg_upper -> tls(dst_reg_upper)
    instr_t *i1 =
        SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);
    // vmovdqu src_opnd_lower -> dst_reg_lower
    instr_t *i2 = INSTR_CREATE_vmovdqu(dcontext, op_dst_reg_lower, src_opnd);
    // vmovdqu src_opnd_upper -> dst_reg_upper
    instr_t *i3 =
        INSTR_CREATE_vmovdqu(dcontext, op_dst_reg_upper,
                             opnd_create_abs_addr((void *)((char *)opnd_get_addr(src_opnd) + SIZE_OF_YMM), OPSZ_32));
    // dst_reg_lower -> tls(dst_reg)
    instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_32);
    // dst_reg_upper -> tls(dst_reg + SIZE_OF_YMM)
    instr_t *i5 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper,
                                         TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_32);
    // tls(dst_reg_upper) -> dst_reg_upper
    instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg_upper,
                                              TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 6, i1, i2, i3, i4, i5, i6);
#endif
    instrlist_concat_next_instr(ilist, 6, i1, i2, i3, i4, i5, i6);
    return i1;
}

/**
 * @brief 610 vmovdqu16 rewrite function
 */
instr_t *
rw_func_vmovdqu16(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t mask_opnd = instr_get_src(instr, 0);
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    opnd_t src_opnd = instr_get_src(instr, 1); // %{x,y,z}mm or disp(base, index, scale)[nbyte] or rel/abs addr
    opnd_t dst_opnd = instr_get_dst(instr, 0); // %{x,y,z}mm
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vmovdqu16", true, true, false, true);
#endif
    switch (src_opnd.kind) {
    case REG_kind: {
        reg_id_t src_reg = opnd_get_reg(src_opnd);
        switch (dst_opnd.kind) {
        case REG_kind: { // reg -> reg
            reg_id_t dst_reg = opnd_get_reg(dst_opnd);
            if (IS_ZMM_REG(dst_reg))
                return vmovdqu16_zmm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
            if (IS_YMM_REG(dst_reg))
                return vmovdqu16_ymm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
            if (IS_XMM_REG(dst_reg))
                return vmovdqu16_xmm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
        } break;
        case BASE_DISP_kind: { // reg -> disp
            if (IS_ZMM_REG(src_reg))
                return vmovdqu16_zmm_reg2disp_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
            if (IS_YMM_REG(src_reg))
                return vmovdqu16_ymm_reg2disp_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
            if (IS_XMM_REG(src_reg))
                return vmovdqu16_xmm_reg2disp_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
        } break;
        case REL_ADDR_kind: { // reg -> rel_addr
            if (IS_ZMM_REG(src_reg))
                return vmovdqu16_zmm_reg2reladdr_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
            if (IS_YMM_REG(src_reg))
                return vmovdqu16_ymm_reg2reladdr_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
            if (IS_XMM_REG(src_reg))
                return vmovdqu16_xmm_reg2reladdr_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
        } break;
        default: REWRITE_INFO(STD_OUTF, "vpmovdqa pattern not support");
        }
    } break;
    case BASE_DISP_kind: { // disp -> reg
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_ZMM_REG(dst_reg))
            return vmovdqu16_zmm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_YMM_REG(dst_reg))
            return vmovdqu16_ymm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_XMM_REG(dst_reg))
            return vmovdqu16_xmm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
    } break;
    case REL_ADDR_kind: { // rel_addr -> reg
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_ZMM_REG(dst_reg))
            return vmovdqu16_zmm_reladdr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_YMM_REG(dst_reg))
            return vmovdqu16_ymm_reladdr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_XMM_REG(dst_reg))
            return vmovdqu16_xmm_reladdr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
    } break;
    case ABS_ADDR_kind: { // abs_addr -> reg
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_ZMM_REG(dst_reg))
            return vmovdqu16_zmm_absaddr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_YMM_REG(dst_reg))
            return vmovdqu16_ymm_absaddr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_XMM_REG(dst_reg))
            return vmovdqu16_xmm_absaddr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
    } break;
    default: REWRITE_INFO(STD_OUTF, "vpmovdqu16 pattern not support");
    }
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vmovdqu32
 * ============================================= */

instr_t *
vmovdqu32_xmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src_need_spill = NEED_SPILL_XMM(src_reg) ? 1 : 0;
    const uint dst_need_spill = NEED_SPILL_XMM(dst_reg) ? 1 : 0;
    const uint need_spill = src_need_spill | dst_need_spill;

    switch (need_spill) {
    case 0: { /* no spill */
        opnd_t op_src = opnd_create_reg(src_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vmovdqu, op_dst, op_src);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src need spill */
        // tls_slot(src_reg) -> dst_reg
        instr_t *i1 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 2: { /* dst need spill */
        // src_reg -> tls_slot(dst_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, src_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        instrlist_concat_next_instr(ilist, 1, i1);
        return i1;
    } break;
    case 3: { /* src and dst need spill */
        reg_id_t spill_tmp_reg = XMM_SPILL_SLOT0;
        // spill_tmp_reg -> tls_slot(spill_tmp_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_tmp_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_tmp_reg)), OPSZ_16);
        // tls_slot(src_reg) -> spill_tmp_reg
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_tmp_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_reg)), OPSZ_16);
        // spill_tmp_reg -> tls_slot(dst_reg)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_tmp_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls_slot(spill_tmp_reg) -> spill_tmp_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_tmp_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_tmp_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    default: REWRITE_INFO(STD_OUTF, "vpmovdqu32 xmm reg2reg pattern not support");
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu32_ymm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{
    opnd_t src_opnd = create_mapping_ymm_opnd(dcontext, src_reg);
    opnd_t dst_opnd = create_mapping_ymm_opnd(dcontext, dst_reg);
    instr_t *new_instr1 = instr_create_1dst_1src(dcontext, OP_vmovdqu, dst_opnd, src_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vmovdqu32_zmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{
    dr_ymm_pair_t src_ymm_pair = { EMPTY, EMPTY };
    dr_ymm_pair_t dst_ymm_pair = { EMPTY, EMPTY };
    if (get_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(src_reg), &src_ymm_pair) == NOT_GET) {
        if (find_and_set_unused_ymm_pair(dcontext, &src_ymm_pair) == NOT_FIND) {
            return NULL_INSTR; // means failed find unused ymm pair, abandon instr rewrite
        }
        add_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(src_reg), &src_ymm_pair);
    }
    if (get_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(dst_reg), &dst_ymm_pair) == NOT_GET) {
        if (find_and_set_unused_ymm_pair(dcontext, &dst_ymm_pair) == NOT_FIND) {
            return NULL_INSTR; // means failed find unused ymm pair, abandon instr rewrite
        }
        add_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(dst_reg), &dst_ymm_pair);
    }
    reg_id_t src_reg_lower = TO_YMM_REG_ID_NUM(src_ymm_pair.ymm_lower);
    reg_id_t src_reg_upper = TO_YMM_REG_ID_NUM(src_ymm_pair.ymm_upper);
    reg_id_t dst_reg_lower = TO_YMM_REG_ID_NUM(dst_ymm_pair.ymm_lower);
    reg_id_t dst_reg_upper = TO_YMM_REG_ID_NUM(dst_ymm_pair.ymm_upper);

#ifdef DEBUG
    REWRITE_INFO(STD_OUTF,
                 "vmovdqu_zmm_reg2reg_gen: src_reg_lower{ymm%d}, src_reg_upper{ymm%d}, dst_reg_lower{ymm%d}, "
                 "dst_reg_upper{ymm%d}",
                 src_reg_lower - DR_REG_YMM0, src_reg_upper - DR_REG_YMM0, dst_reg_lower - DR_REG_YMM0,
                 dst_reg_upper - DR_REG_YMM0);
#endif

    instr_t *new_instr1 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, opnd_create_reg(dst_reg_lower), opnd_create_reg(src_reg_lower));
    instr_t *new_instr2 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, opnd_create_reg(dst_reg_upper), opnd_create_reg(src_reg_upper));
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 2, new_instr1, new_instr2);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    new_instr1->next = new_instr2;
    return new_instr1;
}

instr_t *
vmovdqu32_xmm_reg2disp_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, opnd_t op_dst,
                           reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src_need_spill = NEED_SPILL_XMM(src_reg) ? 1 : 0;
    switch (src_need_spill) {
    case 0: { /* no spill */
        opnd_t op_src = opnd_create_reg(src_reg);
        instr_t *i1 = instr_create_1dst_1src(dcontext, OP_vmovdqu, op_dst, op_src);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: {
        reg_id_t src_spill_reg = XMM_SPILL_SLOT0;
        opnd_t op_src_spill = opnd_create_reg(src_spill_reg);
        // src_spill -> tls_slot(src_spill)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, src_spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_spill_reg)), OPSZ_16);
        // tls_slot(src) -> src_spill
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_reg)), OPSZ_16);
        // src_spill -> op_dst
        instr_t *i3 = INSTR_CREATE_vmovdqu(dcontext, op_dst, op_src_spill);
        // tls_slot(src_spill) -> src_spill
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_spill_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_spill_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    default: REWRITE_INFO(STD_OUTF, "vpmovdqu32 xmm reg2disp pattern not support");
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu32_ymm_reg2disp_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, opnd_t op_dst,
                           reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src_need_spill = NEED_SPILL_YMM(src_reg) ? 1 : 0;

    switch (src_need_spill) {
    case 0: { /* no spill */
        opnd_t op_src = opnd_create_reg(src_reg);
        instr_t *i1 = INSTR_CREATE_vmovdqu(dcontext, op_dst, op_src);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src need spill */
        reg_id_t src_spill_reg = YMM_SPILL_SLOT0;
        opnd_t op_src_spill = opnd_create_reg(src_spill_reg);
        // src_spill -> tls_slot(src_spill)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, src_spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_spill_reg)), OPSZ_32);
        // tls_slot(src) -> src_spill
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg)), OPSZ_32);
        // src_spill -> op_dst
        instr_t *i3 = INSTR_CREATE_vmovdqu(dcontext, op_dst, op_src_spill);
        // tls_slot(src_spill) -> src_spill
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_spill_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_spill_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    default: REWRITE_INFO(STD_OUTF, "vpmovdqu32 ymm reg2disp pattern not support");
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu32_zmm_reg2disp_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, opnd_t dst_opnd,
                           reg_id_t mask_reg)
{
    dr_ymm_pair_t src_ymm_pair = { EMPTY, EMPTY };
    int disp = opnd_get_disp(dst_opnd);
    // int opsz = opnd_get_size(dst_opnd);
    reg_id_t dst_base_reg = opnd_get_base(dst_opnd);
    reg_id_t dst_index_reg = opnd_get_index(dst_opnd);
    int scale = opnd_get_scale(dst_opnd);
    if (get_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(src_reg), &src_ymm_pair) == NOT_GET) {
        if (find_and_set_unused_ymm_pair(dcontext, &src_ymm_pair) == NOT_FIND)
            return NULL_INSTR;
        add_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(src_reg), &src_ymm_pair);
    }
    reg_id_t src_reg_lower = TO_YMM_REG_ID_NUM(src_ymm_pair.ymm_lower);
    reg_id_t src_reg_upper = TO_YMM_REG_ID_NUM(src_ymm_pair.ymm_upper);

#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "vmovdqu_zmm_reg2disp_gen: src_reg_lower{ymm%d}, src_reg_upper{ymm%d}",
                 src_reg_lower - DR_REG_YMM0, src_reg_upper - DR_REG_YMM0);
#endif

    instr_t *new_instr1 = instr_create_1dst_1src(
        dcontext, OP_vmovdqu, opnd_create_base_disp(dst_base_reg, dst_index_reg, scale, disp, OPSZ_32),
        opnd_create_reg(src_reg_lower));
    instr_t *new_instr2 = instr_create_1dst_1src(
        dcontext, OP_vmovdqu, opnd_create_base_disp(dst_base_reg, dst_index_reg, scale, disp + SIZE_OF_YMM, OPSZ_32),
        opnd_create_reg(src_reg_upper));
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 2, new_instr1, new_instr2);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    new_instr1->next = new_instr2;
    return new_instr2;
}

instr_t *
vmovdqu32_zmm_reg2reladdr_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                              opnd_t dst_opnd, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src_need_spill = NEED_SPILL_ZMM(src_reg) ? 1 : 0;
    switch (src_need_spill) {
    case 0: { /* no spill */
        reg_id_t src_reg_lower = ZMM_TO_YMM(src_reg);
        reg_id_t src_reg_upper = find_one_available_spill_ymm(src_reg_lower);

        opnd_t op_src_reg_lower = opnd_create_reg(src_reg_lower);
        opnd_t op_src_reg_upper = opnd_create_reg(src_reg_upper);

        // src_reg_upper -> tls(src_reg_upper)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, src_reg_upper, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg_upper)), OPSZ_32);
        // tls(src_lower) -> src_reg_lower
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_reg_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src_reg)), OPSZ_32);
        // tls(src_upper) -> src_reg_upper
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src_reg)) + SIZE_OF_YMM, OPSZ_32);
        // vmovdqu src_reg_lower -> dst_low
        instr_t *i4 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, op_src_reg_lower);
        // vmovdqu src_reg_upper -> dst_high
        instr_t *i5 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_rel_addr((void *)((char *)opnd_get_addr(dst_opnd) + SIZE_OF_YMM), OPSZ_32),
            op_src_reg_upper);
        // tls(src_reg_upper) -> src_reg_upper
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg_upper)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 6, i1, i2, i3, i4, i5, i6);
#endif
        instrlist_concat_next_instr(ilist, 6, i1, i2, i3, i4, i5, i6);
        return i1;
    } break;
    case 1: { /* src need spill */
        reg_id_t spill_src_reg = find_one_available_spill_ymm(DR_REG_NULL);
        reg_id_t spill_src_reg_upper = find_one_available_spill_ymm(spill_src_reg);

        opnd_t op_spill_src_reg = opnd_create_reg(spill_src_reg);
        opnd_t op_spill_src_reg_upper = opnd_create_reg(spill_src_reg_upper);

        // spill_src_reg -> tls(spill_src_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg)), OPSZ_32);
        // spill_src_reg_upper -> tls(spill_src_reg_upper)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg_upper)), OPSZ_32);
        // tls(src_lower) -> spill_src_reg
        instr_t *i3 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src_reg)), OPSZ_32);
        // tls(src_upper) -> spill_src_reg_upper
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src_reg)) + SIZE_OF_YMM, OPSZ_32);
        // vmovdqu spill_src_reg -> dst_low
        instr_t *i5 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, op_spill_src_reg);
        // vmovdqu spill_src_reg_upper -> dst_high
        instr_t *i6 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_rel_addr((void *)((char *)opnd_get_addr(dst_opnd) + SIZE_OF_YMM), OPSZ_32),
            op_spill_src_reg_upper);
        // tls(spill_src_reg) -> spill_src_reg
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg)), OPSZ_32);
        // tls(spill_src_reg_upper) -> spill_src_reg_upper
        instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg_upper)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
        instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
        return i1;
    } break;
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu32_ymm_reg2reladdr_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, opnd_t op_dst,
                              reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src_need_spill = NEED_SPILL_YMM(src_reg) ? 1 : 0;

    switch (src_need_spill) {
    case 0: { /* no spill */
        opnd_t op_src = opnd_create_reg(src_reg);
        instr_t *i1 = INSTR_CREATE_vmovdqu(dcontext, op_dst, op_src);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src need spill */
        reg_id_t src_spill_reg = YMM_SPILL_SLOT0;
        opnd_t op_src_spill = opnd_create_reg(src_spill_reg);
        // src_spill -> tls_slot(src_spill)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, src_spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_spill_reg)), OPSZ_32);
        // tls_slot(src) -> src_spill
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg)), OPSZ_32);
        // src_spill -> op_dst
        instr_t *i3 = INSTR_CREATE_vmovdqu(dcontext, op_dst, op_src_spill);
        // tls_slot(src_spill) -> src_spill
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_spill_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_spill_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    default: REWRITE_INFO(STD_OUTF, "vpmovdqu32 ymm reg2disp pattern not support");
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu32_xmm_reg2reladdr_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                              opnd_t dst_opnd, reg_id_t mask_reg)
{
    instr_t *new_instr1 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, dst_opnd, create_mapping_xmm_opnd(dcontext, src_reg));
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vmovdqu32_xmm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd, reg_id_t dst_reg,
                           reg_id_t mask_reg)
{
    opnd_t dst_opnd = create_mapping_xmm_opnd(dcontext, dst_reg);
    instr_t *new_instr1 = instr_create_1dst_1src(dcontext, OP_vmovdqu, dst_opnd, src_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vmovdqu32_ymm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t op_src, reg_id_t dst_reg,
                           reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint dst_need_spill = NEED_SPILL_YMM(dst_reg) ? 1 : 0;

    switch (dst_need_spill) {
    case 0: { /* no spill */
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = INSTR_CREATE_vmovdqu(dcontext, op_dst, op_src);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* dst need spill */
        reg_id_t dst_spill_reg = YMM_SPILL_SLOT0;
        opnd_t op_dst_spill = opnd_create_reg(dst_spill_reg);
        // dst_spill -> tls(dst_spill)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_spill_reg)), OPSZ_32);
        // vmovdqu op_src -> dst_spill
        instr_t *i2 = INSTR_CREATE_vmovdqu(dcontext, op_dst_spill, op_src);
        // dst_spill -> tls(dst_reg)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_spill_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls(dst_spill) -> dst_spill
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_spill_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_spill_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    default: REWRITE_INFO(STD_OUTF, "vpmovdqu32 ymm disp2reg pattern not support");
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu32_zmm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd, reg_id_t dst_reg,
                           reg_id_t mask_reg)
{
    reg_id_t src_base_reg = opnd_get_base(src_opnd); // src_reg is now DR_REG_RSP
    reg_id_t src_index_reg = opnd_get_index(src_opnd);
    int scale = opnd_get_scale(src_opnd);
    int disp = opnd_get_disp(src_opnd);
    dr_ymm_pair_t dst_ymm_pair = { EMPTY, EMPTY };
    if (get_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(dst_reg), &dst_ymm_pair) == NOT_GET) {
        if (find_and_set_unused_ymm_pair(dcontext, &dst_ymm_pair) == NOT_FIND) {
            return NULL_INSTR;
        }
        add_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(dst_reg), &dst_ymm_pair);
    }

    reg_id_t dst_reg_lower = TO_YMM_REG_ID_NUM(dst_ymm_pair.ymm_lower);
    reg_id_t dst_reg_upper = TO_YMM_REG_ID_NUM(dst_ymm_pair.ymm_upper);

#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "vmovdqu_zmm_disp2reg_gen: dst_reg_lower{ymm%d}, dst_reg_upper{ymm%d}",
                 dst_reg_lower - DR_REG_YMM0, dst_reg_upper - DR_REG_YMM0);
#endif

    instr_t *new_instr1 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, opnd_create_reg(dst_reg_lower),
                               opnd_create_base_disp(src_base_reg, src_index_reg, scale, disp, OPSZ_32));
    instr_t *new_instr2 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, opnd_create_reg(dst_reg_upper),
                               opnd_create_base_disp(src_base_reg, src_index_reg, scale, disp + SIZE_OF_YMM, OPSZ_32));
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 2, new_instr1, new_instr2);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    new_instr1->next = new_instr2;
    return new_instr2;
}

instr_t *
vmovdqu32_xmm_reladdr2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint dst_need_spill = NEED_SPILL_XMM(dst_reg) ? 1 : 0;

    switch (dst_need_spill) {
    case 0: { /* no spill */
        instr_t *i1 =
            instr_create_1dst_1src(dcontext, OP_vmovdqu, create_mapping_xmm_opnd(dcontext, dst_reg), src_opnd);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: {
        reg_id_t src_reg = opnd_get_reg(src_opnd);
        reg_id_t spill_dst_reg = find_one_available_spill_xmm(src_reg);
        opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *new_instr1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vmovdqu src_opnd -> spill_dst_reg
        instr_t *new_instr2 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd, src_opnd);
        // spill_dst_reg -> tls(dst_reg)
        instr_t *new_instr3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *new_instr4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                          TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, new_instr1, new_instr2, new_instr3, new_instr4);
#endif
        instrlist_concat_next_instr(ilist, 4, new_instr1, new_instr2, new_instr3, new_instr4);
        return new_instr1;
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vmovdqu32_xmm_reladdr2reg_gen not support");
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu32_ymm_reladdr2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
    instr_t *new_instr1 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, create_mapping_ymm_opnd(dcontext, dst_reg), src_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vmovdqu32_zmm_reladdr2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "vmovdqu_zmm_reladdr2reg_gen not support");
#endif
    return NULL_INSTR;
}

instr_t *
vmovdqu32_xmm_absaddr2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
    instr_t *new_instr1 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, create_mapping_xmm_opnd(dcontext, dst_reg), src_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vmovdqu32_ymm_absaddr2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
    instr_t *new_instr1 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, create_mapping_ymm_opnd(dcontext, dst_reg), src_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vmovdqu32_zmm_absaddr2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "vmovdqu32_zmm_absaddr2reg_gen not support");
#endif
    return NULL_INSTR;
}

/**
 * @brief 611 vmovdqu32 rewrite function
 */
instr_t *
rw_func_vmovdqu32(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t mask_opnd = instr_get_src(instr, 0);
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    opnd_t src_opnd = instr_get_src(instr, 1); // %{x,y,z}mm or disp(base, index, scale)[nbyte] or rel/abs addr
    opnd_t dst_opnd = instr_get_dst(instr, 0); // %{x,y,z}mm
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vmovdqu32", true, true, false, true);
#endif
    switch (src_opnd.kind) {
    case REG_kind: {
        reg_id_t src_reg = opnd_get_reg(src_opnd);
        switch (dst_opnd.kind) {
        case REG_kind: { // reg -> reg
            reg_id_t dst_reg = opnd_get_reg(dst_opnd);
            if (IS_ZMM_REG(dst_reg))
                return vmovdqu32_zmm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
            if (IS_YMM_REG(dst_reg))
                return vmovdqu32_ymm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
            if (IS_XMM_REG(dst_reg))
                return vmovdqu32_xmm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
        } break;
        case BASE_DISP_kind: { // reg -> disp
            if (IS_ZMM_REG(src_reg))
                return vmovdqu32_zmm_reg2disp_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
            if (IS_YMM_REG(src_reg))
                return vmovdqu32_ymm_reg2disp_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
            if (IS_XMM_REG(src_reg))
                return vmovdqu32_xmm_reg2disp_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
        } break;
        case REL_ADDR_kind: { // reg -> rel_addr
            if (IS_ZMM_REG(src_reg))
                return vmovdqu32_zmm_reg2reladdr_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
            if (IS_YMM_REG(src_reg))
                return vmovdqu32_ymm_reg2reladdr_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
            if (IS_XMM_REG(src_reg))
                return vmovdqu32_xmm_reg2reladdr_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
        } break;
        default: REWRITE_WARN(STD_OUTF, "vpmovdqu32 pattern not support");
        }
    } break;
    case BASE_DISP_kind: { // disp -> reg
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_ZMM_REG(dst_reg))
            return vmovdqu32_zmm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_YMM_REG(dst_reg))
            return vmovdqu32_ymm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_XMM_REG(dst_reg))
            return vmovdqu32_xmm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
    } break;
    case REL_ADDR_kind: { // rel_addr -> reg
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_ZMM_REG(dst_reg))
            return vmovdqu32_zmm_reladdr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_YMM_REG(dst_reg))
            return vmovdqu32_ymm_reladdr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_XMM_REG(dst_reg))
            return vmovdqu32_xmm_reladdr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
    } break;
    case ABS_ADDR_kind: { // abs_addr -> reg
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_ZMM_REG(dst_reg))
            return vmovdqu32_zmm_absaddr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_YMM_REG(dst_reg))
            return vmovdqu32_ymm_absaddr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_XMM_REG(dst_reg))
            return vmovdqu32_xmm_absaddr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
    } break;
    default: REWRITE_WARN(STD_OUTF, "vpmovdqu32 pattern not support");
    }
    return NULL_INSTR;
}

/**
 * @brief 608 vmovdqa32 rewrite function
 */
instr_t *
rw_func_vmovdqa32(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t mask_opnd = instr_get_src(instr, 0);
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    opnd_t src_opnd = instr_get_src(instr, 1); // %{x,y,z}mm or disp(base, index, scale)[nbyte]
    opnd_t dst_opnd = instr_get_dst(instr, 0); // %{x,y,z}mm
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vmovdqa32", true, true, false, true);
#endif
    switch (src_opnd.kind) {
    case REG_kind: {
        reg_id_t src_reg = opnd_get_reg(src_opnd);
        switch (dst_opnd.kind) {
        case REG_kind: { // reg -> reg
            reg_id_t dst_reg = opnd_get_reg(dst_opnd);
            if (IS_XMM_REG(dst_reg))
                return vmovdqu32_xmm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
            if (IS_YMM_REG(dst_reg))
                return vmovdqu32_ymm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
            if (IS_ZMM_REG(dst_reg))
                return vmovdqu32_zmm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
        } break;
        case BASE_DISP_kind: { // reg -> disp
            if (IS_XMM_REG(src_reg))
                return vmovdqu32_xmm_reg2disp_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
            if (IS_YMM_REG(src_reg))
                return vmovdqu32_ymm_reg2disp_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
            if (IS_ZMM_REG(src_reg))
                return vmovdqu32_zmm_reg2disp_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
        } break;
        case REL_ADDR_kind: { // reg -> rel_addr
            if (IS_XMM_REG(src_reg))
                return vmovdqu32_xmm_reg2reladdr_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
            if (IS_YMM_REG(src_reg))
                return vmovdqu32_ymm_reg2reladdr_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
            if (IS_ZMM_REG(src_reg))
                return vmovdqu32_zmm_reg2reladdr_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
        }
        default: REWRITE_WARN(STD_OUTF, "vpmovdqu32 pattern not support");
        }
    } break;
    case BASE_DISP_kind: { // disp -> reg
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_XMM_REG(dst_reg))
            return vmovdqu32_xmm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_YMM_REG(dst_reg))
            return vmovdqu32_ymm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_ZMM_REG(dst_reg))
            return vmovdqu32_zmm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
    } break;
    case REL_ADDR_kind: { // rel_addr -> reg
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_XMM_REG(dst_reg))
            return vmovdqu32_xmm_reladdr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_YMM_REG(dst_reg))
            return vmovdqu32_ymm_reladdr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_ZMM_REG(dst_reg))
            return vmovdqu32_zmm_reladdr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
    } break;
    case ABS_ADDR_kind: { // abs_addr -> reg
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_XMM_REG(dst_reg))
            return vmovdqu32_xmm_absaddr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_YMM_REG(dst_reg))
            return vmovdqu32_ymm_absaddr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_ZMM_REG(dst_reg))
            return vmovdqu32_zmm_absaddr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
    } break;
    default: REWRITE_WARN(STD_OUTF, "vpmovdqa32 pattern not support");
    }
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vmovdqu64
 * ============================================= */

instr_t *
vmovdqu64_xmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{
    // vmovdqu64 {%k0} %xmm0, %xmm1
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src_need_spill = NEED_SPILL_XMM(src_reg) ? 1 : 0;
    const uint dst_need_spill = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src_need_spill | dst_need_spill;

    int k_idx = TO_K_REG_INDEX(mask_reg);

    if (k_idx == 0) { /* no mask, no spill */
        switch (need_spill_flag) {
        case 0: { /* no spill */
            opnd_t op_src = opnd_create_reg(src_reg);
            opnd_t op_dst = opnd_create_reg(dst_reg);
            instr_t *i1 = INSTR_CREATE_vmovdqu(dcontext, op_dst, op_src);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
            return i1;
        } break;
        case 1: { /* src need spill */
            // tls_slot(src_reg) -> dst_reg
            instr_t *i1 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
            return i1;
        } break;
        case 2: { /* dst need spill */
            // src_reg -> tls_slot(dst_reg)
            instr_t *i1 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, src_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
            instrlist_concat_next_instr(ilist, 1, i1);
            return i1;
        } break;
        case 3: { /* src and dst need spill */
            reg_id_t spill_tmp_reg = XMM_SPILL_SLOT0;
            // spill_tmp_reg -> tls_slot(spill_tmp_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_tmp_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_tmp_reg)), OPSZ_16);
            // tls_slot(src_reg) -> spill_tmp_reg
            instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_tmp_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_reg)), OPSZ_16);
            // spill_tmp_reg -> tls_slot(dst_reg)
            instr_t *i3 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_tmp_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls_slot(spill_tmp_reg) -> spill_tmp_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_tmp_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_tmp_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
            instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
            return i1;
        } break;
        default: {
            REWRITE_ERROR(STD_ERRF, "vmovdqu_ymm_reg2reg_gen not support pattern");
        }
            return NULL_INSTR;
        }
    } else { /* use k1~k7, need to rewrite the mask logic */
        switch (need_spill_flag) {
        case 0: { /* no spill */
            instr_t *SKIP_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *FULL_LOAD = INSTR_CREATE_label(dcontext);

            reg_id_t scratch_reg_gpr64 = DR_REG_RAX;
            reg_id_t scratch_reg_gpr32 = DR_REG_EAX;
            opnd_t scratch_opnd_gpr64 = opnd_create_reg(scratch_reg_gpr64);
            opnd_t scratch_opnd_gpr32 = opnd_create_reg(scratch_reg_gpr32);

            reg_id_t xmm_dst = dst_reg;
            reg_id_t xmm_src = src_reg;
            reg_id_t xmm_bit_pattern = find_available_spill_xmm_avoiding(xmm_src, xmm_dst, DR_REG_NULL);
            reg_id_t xmm_mask = find_available_spill_xmm_avoiding(xmm_src, xmm_dst, xmm_bit_pattern);
            reg_id_t xmm_final_dst =
                find_available_spill_xmm_avoiding_variadic(4, xmm_src, xmm_dst, xmm_bit_pattern, xmm_mask);

            /* opnd for scratch xmms */
            opnd_t xmm_dst_opnd = opnd_create_reg(xmm_dst);
            opnd_t xmm_src_opnd = opnd_create_reg(xmm_src);
            opnd_t xmm_bit_pattern_opnd = opnd_create_reg(xmm_bit_pattern);
            opnd_t xmm_mask_opnd = opnd_create_reg(xmm_mask);
            opnd_t xmm_final_dst_opnd = opnd_create_reg(xmm_final_dst);

            // push rax;
            instr_t *i1 = INSTR_CREATE_push(dcontext, scratch_opnd_gpr64);
            // push eflags;
            instr_t *i2 = INSTR_CREATE_pushf(dcontext);
            // tls_slot(mask_reg) -> eax
            instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // test eax, eax
            instr_t *i4 = INSTR_CREATE_test(dcontext, scratch_opnd_gpr32, scratch_opnd_gpr32);
            // jz SKIP_LOAD
            instr_t *i5 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_LOAD));
            // cmpl 0x3, eax (for 64-bit elements, only 2 bits matter in XMM)
            instr_t *i6 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EAX), opnd_create_immed_int(0x3, OPSZ_4));
            // je FULL_LOAD
            instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_LOAD));

            // spill xmm_bit_pattern
            instr_t *i8 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_bit_pattern,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_bit_pattern)), OPSZ_16);
            // spill xmm_mask
            instr_t *i9 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_mask, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_mask)), OPSZ_16);
            // spill xmm_final_dst
            instr_t *i10 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_final_dst,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_final_dst)), OPSZ_16);

            // sub rsp 16
            instr_t *i11 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_XMM, OPSZ_4));
            /* element-0 (bit 0) 0x0000000100000001 */
            instr_t *i12 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000100000001ULL, OPSZ_8));
            instr_t *i13 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8),
                                               scratch_opnd_gpr64);
            /* element-1 (bit 1) 0x0000000200000002 */
            instr_t *i14 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000200000002ULL, OPSZ_8));
            instr_t *i15 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8),
                                               scratch_opnd_gpr64);
            // vmovdqu (%rsp), %xmm_bit_pattern | bit pattern get the constant value
            instr_t *i16 = INSTR_CREATE_vmovdqu(dcontext, xmm_bit_pattern_opnd,
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_16));
            // add rsp 16
            instr_t *i17 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_XMM, OPSZ_4));

            // tls_slot(mask_reg) -> eax (scratch_reg_gpr64)
            instr_t *i18 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // vmovd eax -> xmm_mask
            instr_t *i19 = INSTR_CREATE_vmovd(dcontext, xmm_mask_opnd, scratch_opnd_gpr32);
            // vpbroadcastd xmm_mask -> xmm_mask (replicate mask to all 32-bit dwords)
            instr_t *i20 = INSTR_CREATE_vpbroadcastd(dcontext, xmm_mask_opnd, xmm_mask_opnd);
            // vpand xmm_bit_pattern & xmm_mask -> xmm_mask
            instr_t *i21 = INSTR_CREATE_vpand(dcontext, xmm_mask_opnd, xmm_mask_opnd, xmm_bit_pattern_opnd);
            // vpcmpeqq xmm_mask, xmm_bit_pattern -> xmm_mask (for 64-bit elements)
            instr_t *i22 = INSTR_CREATE_vpcmpeqq(dcontext, xmm_mask_opnd, xmm_mask_opnd, xmm_bit_pattern_opnd);
            // vpblendvb xmm_dst, xmm_src, xmm_mask -> xmm_final_dst
            instr_t *i23 =
                INSTR_CREATE_vpblendvb(dcontext, xmm_final_dst_opnd, xmm_dst_opnd, xmm_src_opnd, xmm_mask_opnd);
            // vmovdqu xmm_final_dst -> xmm_dst
            instr_t *i24 = INSTR_CREATE_vmovdqu(dcontext, xmm_dst_opnd, xmm_final_dst_opnd);
            // restore xmm_bit_pattern
            instr_t *i25 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_bit_pattern,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_bit_pattern)), OPSZ_16);
            // restore xmm_mask
            instr_t *i26 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_mask, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_mask)), OPSZ_16);
            // restore xmm_final_dst
            instr_t *i27 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_final_dst,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_final_dst)), OPSZ_16);

            // jmp SKIP_LOAD
            instr_t *i28 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_LOAD));

            // FULL_LOAD:
            // vmovdqu xmm_src -> xmm_dst
            instr_t *i29 = INSTR_CREATE_vmovdqu(dcontext, xmm_dst_opnd, xmm_src_opnd);

            // SKIP_LOAD: (only a label)
            // pop eflags;
            instr_t *i30 = INSTR_CREATE_popf(dcontext);
            // pop rax;
            instr_t *i31 = INSTR_CREATE_pop(dcontext, scratch_opnd_gpr64);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 33, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, FULL_LOAD,
                                         i29, SKIP_LOAD, i30, i31);
#endif
            instrlist_concat_next_instr(ilist, 33, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, FULL_LOAD, i29,
                                        SKIP_LOAD, i30, i31);
            return i1;
        } break;
        case 1: { /* src need spill */
            instr_t *SKIP_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *FULL_LOAD = INSTR_CREATE_label(dcontext);

            reg_id_t scratch_reg_gpr64 = DR_REG_RAX;
            reg_id_t scratch_reg_gpr32 = DR_REG_EAX;
            opnd_t scratch_opnd_gpr64 = opnd_create_reg(scratch_reg_gpr64);
            opnd_t scratch_opnd_gpr32 = opnd_create_reg(scratch_reg_gpr32);

            reg_id_t xmm_dst = dst_reg;
            reg_id_t spill_src_reg = find_one_available_spill_xmm(dst_reg);
            reg_id_t xmm_bit_pattern = find_available_spill_xmm_avoiding(dst_reg, spill_src_reg, DR_REG_NULL);
            reg_id_t xmm_mask = find_available_spill_xmm_avoiding(dst_reg, spill_src_reg, xmm_bit_pattern);
            reg_id_t xmm_final_dst =
                find_available_spill_xmm_avoiding_variadic(4, dst_reg, spill_src_reg, xmm_bit_pattern, xmm_mask);

            /* opnd for scratch xmms */
            opnd_t spill_src_opnd = opnd_create_reg(spill_src_reg);
            opnd_t xmm_dst_opnd = opnd_create_reg(xmm_dst);
            opnd_t xmm_bit_pattern_opnd = opnd_create_reg(xmm_bit_pattern);
            opnd_t xmm_mask_opnd = opnd_create_reg(xmm_mask);
            opnd_t xmm_final_dst_opnd = opnd_create_reg(xmm_final_dst);

            // push rax;
            instr_t *i1 = INSTR_CREATE_push(dcontext, scratch_opnd_gpr64);
            // push eflags;
            instr_t *i2 = INSTR_CREATE_pushf(dcontext);
            // spill_src_reg -> tls(spill_src_reg)
            instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src_reg)), OPSZ_16);
            // tls(src_reg) -> spill_src_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_reg)), OPSZ_16);
            // tls_slot(mask_reg) -> eax
            instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // test eax, eax
            instr_t *i6 = INSTR_CREATE_test(dcontext, scratch_opnd_gpr32, scratch_opnd_gpr32);
            // jz SKIP_LOAD
            instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_LOAD));
            // cmpl 0x3, eax (for 64-bit elements, only 2 bits matter in XMM)
            instr_t *i8 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EAX), opnd_create_immed_int(0x3, OPSZ_4));
            // je FULL_LOAD
            instr_t *i9 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_LOAD));

            // spill xmm_bit_pattern, xmm_mask, xmm_final_dst
            instr_t *i10 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_bit_pattern,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_bit_pattern)), OPSZ_16);
            instr_t *i11 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_mask, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_mask)), OPSZ_16);
            instr_t *i12 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_final_dst,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_final_dst)), OPSZ_16);

            // sub rsp 16
            instr_t *i13 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_XMM, OPSZ_4));
            /* element-0 (bit 0) 0x0000000100000001 */
            instr_t *i14 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000100000001ULL, OPSZ_8));
            instr_t *i15 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8),
                                               scratch_opnd_gpr64);
            /* element-1 (bit 1) 0x0000000200000002 */
            instr_t *i16 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000200000002ULL, OPSZ_8));
            instr_t *i17 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8),
                                               scratch_opnd_gpr64);
            // vmovdqu (%rsp), %xmm_bit_pattern | bit pattern get the constant value
            instr_t *i18 = INSTR_CREATE_vmovdqu(dcontext, xmm_bit_pattern_opnd,
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_16));
            // add rsp 16
            instr_t *i19 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_XMM, OPSZ_4));

            // tls_slot(mask_reg) -> eax (scratch_reg_gpr64)
            instr_t *i20 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // vmovd eax -> xmm_mask
            instr_t *i21 = INSTR_CREATE_vmovd(dcontext, xmm_mask_opnd, scratch_opnd_gpr32);
            // vpbroadcastd xmm_mask -> xmm_mask (replicate mask to all 32-bit dwords)
            instr_t *i22 = INSTR_CREATE_vpbroadcastd(dcontext, xmm_mask_opnd, xmm_mask_opnd);
            // vpand xmm_bit_pattern & xmm_mask -> xmm_mask
            instr_t *i23 = INSTR_CREATE_vpand(dcontext, xmm_mask_opnd, xmm_mask_opnd, xmm_bit_pattern_opnd);
            // vpcmpeqq xmm_mask, xmm_bit_pattern -> xmm_mask (for 64-bit elements)
            instr_t *i24 = INSTR_CREATE_vpcmpeqq(dcontext, xmm_mask_opnd, xmm_mask_opnd, xmm_bit_pattern_opnd);
            // vpblendvb xmm_dst, spill_src_reg, xmm_mask -> xmm_final_dst
            instr_t *i25 =
                INSTR_CREATE_vpblendvb(dcontext, xmm_final_dst_opnd, xmm_dst_opnd, spill_src_opnd, xmm_mask_opnd);
            // vmovdqu xmm_final_dst -> xmm_dst
            instr_t *i26 = INSTR_CREATE_vmovdqu(dcontext, xmm_dst_opnd, xmm_final_dst_opnd);

            /* restore xmm_bit_pattern, xmm_mask, xmm_final_dst */
            instr_t *i27 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_bit_pattern,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_bit_pattern)), OPSZ_16);
            instr_t *i28 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_mask, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_mask)), OPSZ_16);
            instr_t *i29 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_final_dst,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_final_dst)), OPSZ_16);

            // jmp SKIP_LOAD
            instr_t *i30 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_LOAD));

            // FULL_LOAD:
            // vmovdqu spill_src_reg -> xmm_dst
            instr_t *i31 = INSTR_CREATE_vmovdqu(dcontext, xmm_dst_opnd, spill_src_opnd);

            // SKIP_LOAD: (only a label)
            // tls(spill_src_reg) -> spill_src_reg
            instr_t *i32 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src_reg)), OPSZ_16);
            // pop eflags;
            instr_t *i33 = INSTR_CREATE_popf(dcontext);
            // pop rax;
            instr_t *i34 = INSTR_CREATE_pop(dcontext, scratch_opnd_gpr64);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 36, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30,
                                         FULL_LOAD, i31, SKIP_LOAD, i32, i33, i34);
#endif
            instrlist_concat_next_instr(ilist, 36, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30,
                                        FULL_LOAD, i31, SKIP_LOAD, i32, i33, i34);
            return i1;
        } break;
        case 2: { /* dst need spill */
            instr_t *SKIP_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *FULL_LOAD = INSTR_CREATE_label(dcontext);

            reg_id_t scratch_reg_gpr64 = DR_REG_RAX;
            reg_id_t scratch_reg_gpr32 = DR_REG_EAX;
            opnd_t scratch_opnd_gpr64 = opnd_create_reg(scratch_reg_gpr64);
            opnd_t scratch_opnd_gpr32 = opnd_create_reg(scratch_reg_gpr32);

            reg_id_t xmm_src = src_reg;
            reg_id_t spill_dst_reg = find_one_available_spill_xmm(xmm_src);
            reg_id_t xmm_bit_pattern = find_available_spill_xmm_avoiding(xmm_src, spill_dst_reg, DR_REG_NULL);
            reg_id_t xmm_mask = find_available_spill_xmm_avoiding(xmm_src, spill_dst_reg, xmm_bit_pattern);
            reg_id_t xmm_final_dst =
                find_available_spill_xmm_avoiding_variadic(4, xmm_src, spill_dst_reg, xmm_bit_pattern, xmm_mask);

            /* opnd for scratch xmms */
            opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
            opnd_t xmm_src_opnd = opnd_create_reg(xmm_src);
            opnd_t xmm_bit_pattern_opnd = opnd_create_reg(xmm_bit_pattern);
            opnd_t xmm_mask_opnd = opnd_create_reg(xmm_mask);
            opnd_t xmm_final_dst_opnd = opnd_create_reg(xmm_final_dst);

            // push rax;
            instr_t *i1 = INSTR_CREATE_push(dcontext, scratch_opnd_gpr64);
            // push eflags;
            instr_t *i2 = INSTR_CREATE_pushf(dcontext);
            // spill_dst_reg -> tls(spill_dst_reg)
            instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
            // tls(dst_reg) -> spill_dst_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls_slot(mask_reg) -> eax
            instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // test eax, eax
            instr_t *i6 = INSTR_CREATE_test(dcontext, scratch_opnd_gpr32, scratch_opnd_gpr32);
            // jz SKIP_LOAD
            instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_LOAD));
            // cmpl 0x3, eax (for 64-bit elements, only 2 bits matter in XMM)
            instr_t *i8 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EAX), opnd_create_immed_int(0x3, OPSZ_4));
            // je FULL_LOAD
            instr_t *i9 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_LOAD));

            // spill xmm_bit_pattern, xmm_mask, xmm_final_dst
            instr_t *i10 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_bit_pattern,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_bit_pattern)), OPSZ_16);
            instr_t *i11 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_mask, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_mask)), OPSZ_16);
            instr_t *i12 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_final_dst,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_final_dst)), OPSZ_16);

            // sub rsp 16
            instr_t *i13 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_XMM, OPSZ_4));
            /* element-0 (bit 0) 0x0000000100000001 */
            instr_t *i14 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000100000001ULL, OPSZ_8));
            instr_t *i15 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8),
                                               scratch_opnd_gpr64);
            /* element-1 (bit 1) 0x0000000200000002 */
            instr_t *i16 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000200000002ULL, OPSZ_8));
            instr_t *i17 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8),
                                               scratch_opnd_gpr64);
            // vmovdqu (%rsp), %xmm_bit_pattern | bit pattern get the constant value
            instr_t *i18 = INSTR_CREATE_vmovdqu(dcontext, xmm_bit_pattern_opnd,
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_16));
            // add rsp 16
            instr_t *i19 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_XMM, OPSZ_4));

            // tls_slot(mask_reg) -> eax (scratch_reg_gpr64)
            instr_t *i20 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // vmovd eax -> xmm_mask
            instr_t *i21 = INSTR_CREATE_vmovd(dcontext, xmm_mask_opnd, scratch_opnd_gpr32);
            // vpbroadcastd xmm_mask -> xmm_mask (replicate mask to all 32-bit dwords)
            instr_t *i22 = INSTR_CREATE_vpbroadcastd(dcontext, xmm_mask_opnd, xmm_mask_opnd);
            // vpand xmm_bit_pattern & xmm_mask -> xmm_mask
            instr_t *i23 = INSTR_CREATE_vpand(dcontext, xmm_mask_opnd, xmm_mask_opnd, xmm_bit_pattern_opnd);
            // vpcmpeqq xmm_mask, xmm_bit_pattern -> xmm_mask (for 64-bit elements)
            instr_t *i24 = INSTR_CREATE_vpcmpeqq(dcontext, xmm_mask_opnd, xmm_mask_opnd, xmm_bit_pattern_opnd);
            // vpblendvb spill_dst_reg, xmm_src, xmm_mask -> xmm_final_dst
            instr_t *i25 =
                INSTR_CREATE_vpblendvb(dcontext, xmm_final_dst_opnd, spill_dst_opnd, xmm_src_opnd, xmm_mask_opnd);
            // vmovdqu xmm_final_dst -> spill_dst_reg
            instr_t *i26 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd, xmm_final_dst_opnd);

            /* restore xmm_bit_pattern, xmm_mask, xmm_final_dst */
            instr_t *i27 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_bit_pattern,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_bit_pattern)), OPSZ_16);
            instr_t *i28 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_mask, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_mask)), OPSZ_16);
            instr_t *i29 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_final_dst,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_final_dst)), OPSZ_16);

            // jmp SKIP_LOAD
            instr_t *i30 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_LOAD));

            // FULL_LOAD:
            // vmovdqu xmm_src -> spill_dst_reg
            instr_t *i31 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd, xmm_src_opnd);

            // SKIP_LOAD: (only a label)
            // spill_dst_reg -> tls(dst_reg)
            instr_t *i32 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_dst_reg) -> spill_dst_reg
            instr_t *i33 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
            // pop eflags;
            instr_t *i34 = INSTR_CREATE_popf(dcontext);
            // pop rax;
            instr_t *i35 = INSTR_CREATE_pop(dcontext, scratch_opnd_gpr64);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 37, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30,
                                         FULL_LOAD, i31, SKIP_LOAD, i32, i33, i34, i35);
#endif
            instrlist_concat_next_instr(ilist, 37, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30,
                                        FULL_LOAD, i31, SKIP_LOAD, i32, i33, i34, i35);
            return i1;
        } break;
        case 3: { /* src and dst need spill */
            instr_t *SKIP_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *FULL_LOAD = INSTR_CREATE_label(dcontext);

            reg_id_t scratch_reg_gpr64 = DR_REG_RAX;
            reg_id_t scratch_reg_gpr32 = DR_REG_EAX;
            opnd_t scratch_opnd_gpr64 = opnd_create_reg(scratch_reg_gpr64);
            opnd_t scratch_opnd_gpr32 = opnd_create_reg(scratch_reg_gpr32);

            reg_id_t spill_tmp_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_dst_reg = XMM_SPILL_SLOT1;
            reg_id_t xmm_bit_pattern = find_available_spill_xmm_avoiding(spill_dst_reg, spill_tmp_reg, DR_REG_NULL);
            reg_id_t xmm_mask = find_available_spill_xmm_avoiding(spill_dst_reg, spill_tmp_reg, xmm_bit_pattern);
            reg_id_t xmm_final_dst =
                find_available_spill_xmm_avoiding_variadic(4, spill_dst_reg, spill_tmp_reg, xmm_bit_pattern, xmm_mask);

            /* opnd for scratch xmms */
            opnd_t spill_tmp_opnd = opnd_create_reg(spill_tmp_reg);
            opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
            opnd_t xmm_bit_pattern_opnd = opnd_create_reg(xmm_bit_pattern);
            opnd_t xmm_mask_opnd = opnd_create_reg(xmm_mask);
            opnd_t xmm_final_dst_opnd = opnd_create_reg(xmm_final_dst);

            // push rax;
            instr_t *i1 = INSTR_CREATE_push(dcontext, scratch_opnd_gpr64);
            // push eflags;
            instr_t *i2 = INSTR_CREATE_pushf(dcontext);
            // spill_tmp_reg -> tls(spill_tmp_reg)
            instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_tmp_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_tmp_reg)), OPSZ_16);
            // spill_dst_reg -> tls(spill_dst_reg)
            instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
            // tls(src_reg) -> spill_tmp_reg
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_tmp_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_reg)), OPSZ_16);
            // tls(dst_reg) -> spill_dst_reg
            instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls_slot(mask_reg) -> eax
            instr_t *i7 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // test eax, eax
            instr_t *i8 = INSTR_CREATE_test(dcontext, scratch_opnd_gpr32, scratch_opnd_gpr32);
            // jz SKIP_LOAD
            instr_t *i9 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_LOAD));
            // cmpl 0x3, eax (for 64-bit elements, only 2 bits matter in XMM)
            instr_t *i10 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EAX), opnd_create_immed_int(0x3, OPSZ_4));
            // je FULL_LOAD
            instr_t *i11 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_LOAD));

            // spill xmm_bit_pattern, xmm_mask, xmm_final_dst
            instr_t *i12 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_bit_pattern,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_bit_pattern)), OPSZ_16);
            instr_t *i13 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_mask, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_mask)), OPSZ_16);
            instr_t *i14 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_final_dst,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_final_dst)), OPSZ_16);

            // sub rsp 16
            instr_t *i15 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_XMM, OPSZ_4));
            /* element-0 (bit 0) 0x0000000100000001 */
            instr_t *i16 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000100000001ULL, OPSZ_8));
            instr_t *i17 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8),
                                               scratch_opnd_gpr64);
            /* element-1 (bit 1) 0x0000000200000002 */
            instr_t *i18 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000200000002ULL, OPSZ_8));
            instr_t *i19 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8),
                                               scratch_opnd_gpr64);
            // vmovdqu (%rsp), %xmm_bit_pattern | bit pattern get the constant value
            instr_t *i20 = INSTR_CREATE_vmovdqu(dcontext, xmm_bit_pattern_opnd,
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_16));
            // add rsp 16
            instr_t *i21 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_XMM, OPSZ_4));

            // tls_slot(mask_reg) -> eax (scratch_reg_gpr64)
            instr_t *i22 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // vmovd eax -> xmm_mask
            instr_t *i23 = INSTR_CREATE_vmovd(dcontext, xmm_mask_opnd, scratch_opnd_gpr32);
            // vpbroadcastd xmm_mask -> xmm_mask (replicate mask to all 32-bit dwords)
            instr_t *i24 = INSTR_CREATE_vpbroadcastd(dcontext, xmm_mask_opnd, xmm_mask_opnd);
            // vpand xmm_bit_pattern & xmm_mask -> xmm_mask
            instr_t *i25 = INSTR_CREATE_vpand(dcontext, xmm_mask_opnd, xmm_mask_opnd, xmm_bit_pattern_opnd);
            // vpcmpeqq xmm_mask, xmm_bit_pattern -> xmm_mask (for 64-bit elements)
            instr_t *i26 = INSTR_CREATE_vpcmpeqq(dcontext, xmm_mask_opnd, xmm_mask_opnd, xmm_bit_pattern_opnd);
            // vpblendvb spill_dst_reg, spill_tmp_reg, xmm_mask -> xmm_final_dst
            instr_t *i27 =
                INSTR_CREATE_vpblendvb(dcontext, xmm_final_dst_opnd, spill_dst_opnd, spill_tmp_opnd, xmm_mask_opnd);
            // vmovdqu xmm_final_dst -> spill_dst_reg
            instr_t *i28 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd, xmm_final_dst_opnd);

            /* restore xmm_bit_pattern, xmm_mask, xmm_final_dst */
            instr_t *i29 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_bit_pattern,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_bit_pattern)), OPSZ_16);
            instr_t *i30 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_mask, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_mask)), OPSZ_16);
            instr_t *i31 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_final_dst,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_final_dst)), OPSZ_16);

            // jmp SKIP_LOAD
            instr_t *i32 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_LOAD));

            // FULL_LOAD:
            // vmovdqu spill_tmp_reg -> spill_dst_reg
            instr_t *i33 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd, spill_tmp_opnd);

            // SKIP_LOAD: (only a label)
            // spill_dst_reg -> tls(dst_reg)
            instr_t *i34 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_tmp_reg) -> spill_tmp_reg
            instr_t *i35 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_tmp_reg,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_tmp_reg)), OPSZ_16);
            // tls(spill_dst_reg) -> spill_dst_reg
            instr_t *i36 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
            // pop eflags;
            instr_t *i37 = INSTR_CREATE_popf(dcontext);
            // pop rax;
            instr_t *i38 = INSTR_CREATE_pop(dcontext, scratch_opnd_gpr64);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 40, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                         i32, FULL_LOAD, i33, SKIP_LOAD, i34, i35, i36, i37, i38);
#endif
            instrlist_concat_next_instr(ilist, 40, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                        i32, FULL_LOAD, i33, SKIP_LOAD, i34, i35, i36, i37, i38);
            return i1;
        } break;
        default: {
            REWRITE_ERROR(STD_ERRF, "vmovdqu64_xmm_reg2reg_gen not support pattern");
        }
        }
    }

    return NULL_INSTR;
}

instr_t *
vmovdqu64_ymm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{
    // vmovdqu64 {%k0} %ymm0, %ymm1
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src_need_spill = NEED_SPILL_YMM(src_reg) ? 1 : 0;
    const uint dst_need_spill = NEED_SPILL_YMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src_need_spill | dst_need_spill;

    int k_idx = TO_K_REG_INDEX(mask_reg);
    bool is_zero_mask = is_avx512_zero_mask(instr);

    if (k_idx == 0) { // no mask, no spill
        switch (need_spill_flag) {
        case 0: { /* no spill */
            opnd_t src_opnd = opnd_create_reg(src_reg);
            opnd_t dst_opnd = opnd_create_reg(dst_reg);
            instr_t *new_instr1 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, src_opnd);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
            return new_instr1;
        } break;
        case 1: { /* src need spill */
            // tls_slot(src_reg) -> dst_reg
            instr_t *i1 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
            return i1;
        } break;
        case 2: { /* dst need spill */
            // src_reg -> tls_slot(dst_reg)
            instr_t *i1 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, src_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
            instrlist_concat_next_instr(ilist, 1, i1);
            return i1;
        } break;
        case 3: { /* src and dst need spill */
            reg_id_t spill_tmp_reg = YMM_SPILL_SLOT0;
            // spill_tmp_reg -> tls_slot(spill_tmp_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_tmp_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_tmp_reg)), OPSZ_32);
            // tls_slot(src_reg) -> spill_tmp_reg
            instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_tmp_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg)), OPSZ_32);
            // spill_tmp_reg -> tls_slot(dst_reg)
            instr_t *i3 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_tmp_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls_slot(spill_tmp_reg) -> spill_tmp_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_tmp_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_tmp_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
            instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
            return i1;
        } break;
        default: {
            REWRITE_ERROR(STD_ERRF, "vmovdqu_ymm_reg2reg_gen not support pattern");
        }
            return NULL_INSTR;
        }
    } else { // use k1~k7, need to rewrite the mask logic
        switch (need_spill_flag) {
        case 0: { /* no spill */
            if (is_zero_mask) {
                instr_t *SKIP_LOAD = INSTR_CREATE_label(dcontext);
                instr_t *FULL_LOAD = INSTR_CREATE_label(dcontext);

                reg_id_t scratch_reg_gpr64 = DR_REG_RAX;
                reg_id_t scratch_reg_gpr32 = DR_REG_EAX;
                opnd_t scratch_opnd_gpr64 = opnd_create_reg(scratch_reg_gpr64);
                opnd_t scratch_opnd_gpr32 = opnd_create_reg(scratch_reg_gpr32);

                reg_id_t ymm_dst = dst_reg;
                reg_id_t ymm_src = src_reg;
                reg_id_t ymm_bit_pattern = find_available_spill_ymm_avoiding(src_reg, dst_reg, DR_REG_NULL);
                reg_id_t ymm_mask = find_available_spill_ymm_avoiding(src_reg, dst_reg, ymm_bit_pattern);
                reg_id_t ymm_final_dst =
                    find_available_spill_ymm_avoiding_variadic(4, src_reg, dst_reg, ymm_bit_pattern, ymm_mask);

                /* opnd for scratch ymms */
                opnd_t ymm_dst_opnd = opnd_create_reg(ymm_dst);
                opnd_t ymm_src_opnd = opnd_create_reg(ymm_src);
                opnd_t ymm_bit_pattern_opnd = opnd_create_reg(ymm_bit_pattern);
                opnd_t ymm_mask_opnd = opnd_create_reg(ymm_mask);
                opnd_t xmm_mask_opnd = opnd_create_reg(ymm_mask - DR_REG_YMM0 + DR_REG_XMM0);
                opnd_t ymm_final_dst_opnd = opnd_create_reg(ymm_final_dst);

                reg_id_t ymm_else_src;
                opnd_t ymm_else_src_opnd;
                instr_t *i_spill_else_src = NULL_INSTR;
                instr_t *i_restore_else_src = NULL_INSTR;
                instr_t *i_prepare_else_src = NULL_INSTR;

                ymm_else_src = find_available_spill_ymm_avoiding_variadic(5, src_reg, dst_reg, ymm_bit_pattern,
                                                                          ymm_mask, ymm_final_dst);
                ymm_else_src_opnd = opnd_create_reg(ymm_else_src);

                i_spill_else_src = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_else_src,
                                                          TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_else_src)), OPSZ_32);
                i_prepare_else_src =
                    INSTR_CREATE_vpxor(dcontext, ymm_else_src_opnd, ymm_else_src_opnd, ymm_else_src_opnd);
                i_restore_else_src = RESTORE_SIMD_FROM_SIZED_TLS(
                    dcontext, ymm_else_src, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_else_src)), OPSZ_32);

                // push rax;
                instr_t *i1 = INSTR_CREATE_push(dcontext, scratch_opnd_gpr64);
                // push eflags;
                instr_t *i2 = INSTR_CREATE_pushf(dcontext);
                // tls_slot(mask_reg) -> eax
                instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);

                // cmpl 0xf, eax (for 64-bit elements, only 4 bits matter in YMM)
                instr_t *i4 =
                    INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EAX), opnd_create_immed_int(0xf, OPSZ_4));
                // je FULL_LOAD
                instr_t *i5 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_LOAD));

                // spill ymm_bit_pattern
                instr_t *i6 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_bit_pattern,
                                                     TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_bit_pattern)), OPSZ_32);
                // spill ymm_mask
                instr_t *i7 =
                    SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_mask, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);
                // spill ymm_final_dst
                instr_t *i8 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_final_dst,
                                                     TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_final_dst)), OPSZ_32);
                instr_t *i9 = i_spill_else_src;

                // sub rsp 32
                instr_t *i10 =
                    INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM, OPSZ_4));
                /* element-0 (bit 0) 0x0000000100000001 */
                instr_t *i11 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                    opnd_create_immed_int(0x0000000100000001ULL, OPSZ_8));
                instr_t *i12 = INSTR_CREATE_mov_st(
                    dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8), scratch_opnd_gpr64);
                /* element-1 (bit 1) 0x0000000200000002 */
                instr_t *i13 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                    opnd_create_immed_int(0x0000000200000002ULL, OPSZ_8));
                instr_t *i14 = INSTR_CREATE_mov_st(
                    dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8), scratch_opnd_gpr64);
                /* element-2 (bit 2) 0x0000000400000004 */
                instr_t *i15 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                    opnd_create_immed_int(0x0000000400000004ULL, OPSZ_8));
                instr_t *i16 = INSTR_CREATE_mov_st(
                    dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8), scratch_opnd_gpr64);
                /* element-3 (bit 3) 0x0000000800000008 */
                instr_t *i17 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                    opnd_create_immed_int(0x0000000800000008ULL, OPSZ_8));
                instr_t *i18 = INSTR_CREATE_mov_st(
                    dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8), scratch_opnd_gpr64);
                // vmovdqu (%rsp), %ymm_bit_pattern | bit pattern get the constant value
                instr_t *i19 = INSTR_CREATE_vmovdqu(dcontext, ymm_bit_pattern_opnd,
                                                    opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));
                // add rsp 32
                instr_t *i20 =
                    INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM, OPSZ_4));

                instr_t *i21 = i_prepare_else_src;

                // tls_slot(mask_reg) -> eax (scratch_reg_gpr64)
                instr_t *i22 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
                // vmovd eax -> xmm_mask
                instr_t *i23 = INSTR_CREATE_vmovd(dcontext, xmm_mask_opnd, scratch_opnd_gpr32);
                // vpbroadcastd xmm_mask -> ymm_mask (replicate mask to all 32-bit dwords)
                instr_t *i24 = INSTR_CREATE_vpbroadcastd(dcontext, ymm_mask_opnd, xmm_mask_opnd);
                // vpand ymm_bit_pattern & ymm_mask -> ymm_mask
                instr_t *i25 = INSTR_CREATE_vpand(dcontext, ymm_mask_opnd, ymm_mask_opnd, ymm_bit_pattern_opnd);
                // vpcmpeqq ymm_mask, ymm_bit_pattern -> ymm_mask (for 64-bit elements)
                instr_t *i26 = INSTR_CREATE_vpcmpeqq(dcontext, ymm_mask_opnd, ymm_mask_opnd, ymm_bit_pattern_opnd);

                instr_t *i27 = INSTR_CREATE_vpblendvb(dcontext, ymm_final_dst_opnd, ymm_else_src_opnd, ymm_src_opnd,
                                                      ymm_mask_opnd);

                // vmovdqu ymm_final_dst -> ymm_dst
                instr_t *i28 = INSTR_CREATE_vmovdqu(dcontext, ymm_dst_opnd, ymm_final_dst_opnd);
                // restore ymm_bit_pattern
                instr_t *i29 = RESTORE_SIMD_FROM_SIZED_TLS(
                    dcontext, ymm_bit_pattern, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_bit_pattern)), OPSZ_32);
                // restore ymm_mask
                instr_t *i30 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_mask,
                                                           TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);
                // restore ymm_final_dst
                instr_t *i31 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_final_dst,
                                                           TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_final_dst)), OPSZ_32);

                instr_t *i32 = i_restore_else_src;

                // jmp SKIP_LOAD
                instr_t *i33 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_LOAD));

                // FULL_LOAD:
                // vmovdqu ymm_src -> ymm_dst
                instr_t *i34 = INSTR_CREATE_vmovdqu(dcontext, ymm_dst_opnd, ymm_src_opnd);

                // SKIP_LOAD: (only a label)
                // pop eflags;
                instr_t *i35 = INSTR_CREATE_popf(dcontext);
                // pop rax;
                instr_t *i36 = INSTR_CREATE_pop(dcontext, scratch_opnd_gpr64);

#ifdef DEBUG
                print_rewrite_variadic_instr(dcontext, 38, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14,
                                             i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29,
                                             i30, i31, i32, i33, FULL_LOAD, i34, SKIP_LOAD, i35, i36);
#endif
                instrlist_concat_next_instr(ilist, 38, i1, i2, i3, i4, i5, i6, i7, i8, i9,
                                            i10, // i_spill_else_src
                                            i11, i12, i13, i14, i15, i16, i17, i18, i19, i20,
                                            i21, // i_prepare_else_src
                                            i22, i23, i24, i25, i26, i27, i28, i29,
                                            i30, // i_restore_else_src
                                            i31, i32, i33, FULL_LOAD, i34, SKIP_LOAD, i35, i36);
                return i1;
            } else {
                instr_t *SKIP_LOAD = INSTR_CREATE_label(dcontext);
                instr_t *FULL_LOAD = INSTR_CREATE_label(dcontext);

                reg_id_t scratch_reg_gpr64 = DR_REG_RAX;
                reg_id_t scratch_reg_gpr32 = DR_REG_EAX;
                opnd_t scratch_opnd_gpr64 = opnd_create_reg(scratch_reg_gpr64);
                opnd_t scratch_opnd_gpr32 = opnd_create_reg(scratch_reg_gpr32);

                reg_id_t ymm_dst = dst_reg;
                reg_id_t ymm_src = src_reg;
                reg_id_t ymm_bit_pattern = find_available_spill_ymm_avoiding(src_reg, dst_reg, DR_REG_NULL);
                reg_id_t ymm_mask = find_available_spill_ymm_avoiding(src_reg, dst_reg, ymm_bit_pattern);
                reg_id_t xmm_mask = ymm_mask - DR_REG_YMM0 + DR_REG_XMM0;
                reg_id_t ymm_final_dst =
                    find_available_spill_ymm_avoiding_variadic(4, src_reg, dst_reg, ymm_bit_pattern, ymm_mask);

                /* opnd for scratch ymms */
                opnd_t ymm_dst_opnd = opnd_create_reg(ymm_dst);
                opnd_t ymm_src_opnd = opnd_create_reg(ymm_src);
                opnd_t ymm_bit_pattern_opnd = opnd_create_reg(ymm_bit_pattern);
                opnd_t ymm_mask_opnd = opnd_create_reg(ymm_mask);
                opnd_t xmm_mask_opnd = opnd_create_reg(xmm_mask);
                opnd_t ymm_final_dst_opnd = opnd_create_reg(ymm_final_dst);

                // push rax;
                instr_t *i1 = INSTR_CREATE_push(dcontext, scratch_opnd_gpr64);
                // push eflags;
                instr_t *i2 = INSTR_CREATE_pushf(dcontext);
                // tls_slot(mask_reg) -> eax
                instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
                // test eax, eax
                instr_t *i4 = INSTR_CREATE_test(dcontext, scratch_opnd_gpr32, scratch_opnd_gpr32);
                // jz SKIP_LOAD
                instr_t *i5 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_LOAD));
                // cmpl 0xf, eax (for 64-bit elements, only 4 bits matter in YMM)
                instr_t *i6 =
                    INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EAX), opnd_create_immed_int(0xf, OPSZ_4));
                // je FULL_LOAD
                instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_LOAD));

                // spill ymm_bit_pattern
                instr_t *i8 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_bit_pattern,
                                                     TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_bit_pattern)), OPSZ_32);
                // spill ymm_mask
                instr_t *i9 =
                    SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_mask, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);
                // spill ymm_final_dst
                instr_t *i10 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_final_dst,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_final_dst)), OPSZ_32);

                // sub rsp 32
                instr_t *i11 =
                    INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM, OPSZ_4));
                /* element-0 (bit 0) 0x0000000100000001 */
                instr_t *i12 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                    opnd_create_immed_int(0x0000000100000001ULL, OPSZ_8));
                instr_t *i13 = INSTR_CREATE_mov_st(
                    dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8), scratch_opnd_gpr64);
                /* element-1 (bit 1) 0x0000000200000002 */
                instr_t *i14 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                    opnd_create_immed_int(0x0000000200000002ULL, OPSZ_8));
                instr_t *i15 = INSTR_CREATE_mov_st(
                    dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8), scratch_opnd_gpr64);
                /* element-2 (bit 2) 0x0000000400000004 */
                instr_t *i16 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                    opnd_create_immed_int(0x0000000400000004ULL, OPSZ_8));
                instr_t *i17 = INSTR_CREATE_mov_st(
                    dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8), scratch_opnd_gpr64);
                /* element-3 (bit 3) 0x0000000800000008 */
                instr_t *i18 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                    opnd_create_immed_int(0x0000000800000008ULL, OPSZ_8));
                instr_t *i19 = INSTR_CREATE_mov_st(
                    dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8), scratch_opnd_gpr64);
                // vmovdqu (%rsp), %ymm_bit_pattern | bit pattern get the constant value
                instr_t *i20 = INSTR_CREATE_vmovdqu(dcontext, ymm_bit_pattern_opnd,
                                                    opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));
                // add rsp 32
                instr_t *i21 =
                    INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM, OPSZ_4));

                // tls_slot(mask_reg) -> eax (scratch_reg_gpr64)
                instr_t *i22 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
                // vmovd eax -> xmm_mask
                instr_t *i23 = INSTR_CREATE_vmovd(dcontext, xmm_mask_opnd, scratch_opnd_gpr32);
                // vpbroadcastd xmm_mask -> ymm_mask (replicate mask to all 32-bit dwords)
                instr_t *i24 = INSTR_CREATE_vpbroadcastd(dcontext, ymm_mask_opnd, xmm_mask_opnd);
                // vpand ymm_bit_pattern & ymm_mask -> ymm_mask
                instr_t *i25 = INSTR_CREATE_vpand(dcontext, ymm_mask_opnd, ymm_mask_opnd, ymm_bit_pattern_opnd);
                // vpcmpeqq ymm_mask, ymm_bit_pattern -> ymm_mask (for 64-bit elements)
                instr_t *i26 = INSTR_CREATE_vpcmpeqq(dcontext, ymm_mask_opnd, ymm_mask_opnd, ymm_bit_pattern_opnd);
                // vpblendvb ymm_dst, ymm_src, ymm_mask -> ymm_final_dst
                instr_t *i27 =
                    INSTR_CREATE_vpblendvb(dcontext, ymm_final_dst_opnd, ymm_dst_opnd, ymm_src_opnd, ymm_mask_opnd);
                // vmovdqu ymm_final_dst -> ymm_dst
                instr_t *i28 = INSTR_CREATE_vmovdqu(dcontext, ymm_dst_opnd, ymm_final_dst_opnd);
                // restore ymm_bit_pattern
                instr_t *i29 = RESTORE_SIMD_FROM_SIZED_TLS(
                    dcontext, ymm_bit_pattern, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_bit_pattern)), OPSZ_32);
                // restore ymm_mask
                instr_t *i30 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_mask,
                                                           TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);
                // restore ymm_final_dst
                instr_t *i31 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_final_dst,
                                                           TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_final_dst)), OPSZ_32);

                // jmp SKIP_LOAD
                instr_t *i32 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_LOAD));

                // FULL_LOAD:
                // vmovdqu ymm_src -> ymm_dst
                instr_t *i33 = INSTR_CREATE_vmovdqu(dcontext, ymm_dst_opnd, ymm_src_opnd);

                // SKIP_LOAD: (only a label)
                // pop eflags;
                instr_t *i34 = INSTR_CREATE_popf(dcontext);
                // pop rax;
                instr_t *i35 = INSTR_CREATE_pop(dcontext, scratch_opnd_gpr64);

#ifdef DEBUG
                print_rewrite_variadic_instr(dcontext, 37, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14,
                                             i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29,
                                             i30, i31, i32, FULL_LOAD, i33, SKIP_LOAD, i34, i35);
#endif
                instrlist_concat_next_instr(ilist, 37, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                            i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30,
                                            i31, i32, FULL_LOAD, i33, SKIP_LOAD, i34, i35);
                return i1;
            }
        } break;
        case 1: { /* src need spill */
            instr_t *SKIP_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *FULL_LOAD = INSTR_CREATE_label(dcontext);

            reg_id_t scratch_reg_gpr64 = DR_REG_RAX;
            reg_id_t scratch_reg_gpr32 = DR_REG_EAX;
            opnd_t scratch_opnd_gpr64 = opnd_create_reg(scratch_reg_gpr64);
            opnd_t scratch_opnd_gpr32 = opnd_create_reg(scratch_reg_gpr32);

            reg_id_t ymm_dst = dst_reg;
            reg_id_t spill_src_reg = find_one_available_spill_ymm(dst_reg);
            reg_id_t ymm_bit_pattern = find_available_spill_ymm_avoiding(spill_src_reg, dst_reg, DR_REG_NULL);
            reg_id_t ymm_mask = find_available_spill_ymm_avoiding(spill_src_reg, dst_reg, ymm_bit_pattern);
            reg_id_t xmm_mask = ymm_mask - DR_REG_YMM0 + DR_REG_XMM0;
            reg_id_t ymm_final_dst =
                find_available_spill_ymm_avoiding_variadic(4, spill_src_reg, dst_reg, ymm_bit_pattern, ymm_mask);

            /* opnd for scratch ymms */
            opnd_t spill_src_opnd = opnd_create_reg(spill_src_reg);
            opnd_t ymm_dst_opnd = opnd_create_reg(ymm_dst);
            opnd_t ymm_bit_pattern_opnd = opnd_create_reg(ymm_bit_pattern);
            opnd_t ymm_mask_opnd = opnd_create_reg(ymm_mask);
            opnd_t xmm_mask_opnd = opnd_create_reg(xmm_mask);
            opnd_t ymm_final_dst_opnd = opnd_create_reg(ymm_final_dst);

            // push rax;
            instr_t *i1 = INSTR_CREATE_push(dcontext, scratch_opnd_gpr64);
            // push eflags;
            instr_t *i2 = INSTR_CREATE_pushf(dcontext);
            // spill_src_reg -> tls(spill_src_reg)
            instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg)), OPSZ_32);
            // tls(src_reg) -> spill_src_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg)), OPSZ_32);
            // tls_slot(mask_reg) -> eax
            instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // test eax, eax
            instr_t *i6 = INSTR_CREATE_test(dcontext, scratch_opnd_gpr32, scratch_opnd_gpr32);
            // jz SKIP_LOAD
            instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_LOAD));
            // cmpl 0xf, eax (for 64-bit elements, only 4 bits matter in YMM)
            instr_t *i8 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EAX), opnd_create_immed_int(0xf, OPSZ_4));
            // je FULL_LOAD
            instr_t *i9 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_LOAD));

            // spill ymm_bit_pattern, ymm_mask, ymm_final_dst
            instr_t *i10 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_bit_pattern,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_bit_pattern)), OPSZ_32);
            instr_t *i11 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_mask, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);
            instr_t *i12 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_final_dst,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_final_dst)), OPSZ_32);

            // sub rsp 32
            instr_t *i13 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM, OPSZ_4));
            /* element-0 (bit 0) 0x0000000100000001 */
            instr_t *i14 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000100000001ULL, OPSZ_8));
            instr_t *i15 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8),
                                               scratch_opnd_gpr64);
            /* element-1 (bit 1) 0x0000000200000002 */
            instr_t *i16 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000200000002ULL, OPSZ_8));
            instr_t *i17 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8),
                                               scratch_opnd_gpr64);
            /* element-2 (bit 2) 0x0000000400000004 */
            instr_t *i18 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000400000004ULL, OPSZ_8));
            instr_t *i19 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8),
                                               scratch_opnd_gpr64);
            /* element-3 (bit 3) 0x0000000800000008 */
            instr_t *i20 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000800000008ULL, OPSZ_8));
            instr_t *i21 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8),
                                               scratch_opnd_gpr64);
            // vmovdqu (%rsp), %ymm_bit_pattern | bit pattern get the constant value
            instr_t *i22 = INSTR_CREATE_vmovdqu(dcontext, ymm_bit_pattern_opnd,
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));
            // add rsp 32
            instr_t *i23 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM, OPSZ_4));

            // tls_slot(mask_reg) -> eax (scratch_reg_gpr64)
            instr_t *i24 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // vmovd eax -> xmm_mask
            instr_t *i25 = INSTR_CREATE_vmovd(dcontext, xmm_mask_opnd, scratch_opnd_gpr32);
            // vpbroadcastd xmm_mask -> ymm_mask (replicate mask to all 32-bit dwords)
            instr_t *i26 = INSTR_CREATE_vpbroadcastd(dcontext, ymm_mask_opnd, xmm_mask_opnd);
            // vpand ymm_bit_pattern & ymm_mask -> ymm_mask
            instr_t *i27 = INSTR_CREATE_vpand(dcontext, ymm_mask_opnd, ymm_mask_opnd, ymm_bit_pattern_opnd);
            // vpcmpeqq ymm_mask, ymm_bit_pattern -> ymm_mask (for 64-bit elements)
            instr_t *i28 = INSTR_CREATE_vpcmpeqq(dcontext, ymm_mask_opnd, ymm_mask_opnd, ymm_bit_pattern_opnd);
            // vpblendvb ymm_dst, spill_src_reg, ymm_mask -> ymm_final_dst
            instr_t *i29 =
                INSTR_CREATE_vpblendvb(dcontext, ymm_final_dst_opnd, ymm_dst_opnd, spill_src_opnd, ymm_mask_opnd);
            // vmovdqu ymm_final_dst -> ymm_dst
            instr_t *i30 = INSTR_CREATE_vmovdqu(dcontext, ymm_dst_opnd, ymm_final_dst_opnd);

            /* restore ymm_bit_pattern, ymm_mask, ymm_final_dst */
            instr_t *i31 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_bit_pattern,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_bit_pattern)), OPSZ_32);
            instr_t *i32 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_mask, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);
            instr_t *i33 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_final_dst,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_final_dst)), OPSZ_32);

            // jmp SKIP_LOAD
            instr_t *i34 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_LOAD));

            // FULL_LOAD:
            // vmovdqu spill_src_reg -> ymm_dst
            instr_t *i35 = INSTR_CREATE_vmovdqu(dcontext, ymm_dst_opnd, spill_src_opnd);

            // SKIP_LOAD: (only a label)
            // tls(spill_src_reg) -> spill_src_reg
            instr_t *i36 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg)), OPSZ_32);
            // pop eflags;
            instr_t *i37 = INSTR_CREATE_popf(dcontext);
            // pop rax;
            instr_t *i38 = INSTR_CREATE_pop(dcontext, scratch_opnd_gpr64);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 40, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                         i32, i33, i34, FULL_LOAD, i35, SKIP_LOAD, i36, i37, i38);
#endif
            instrlist_concat_next_instr(ilist, 40, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                        i32, i33, i34, FULL_LOAD, i35, SKIP_LOAD, i36, i37, i38);
            return i1;
        } break;
        case 2: { /* dst need spill */
            if (is_zero_mask) {
                instr_t *SKIP_LOAD = INSTR_CREATE_label(dcontext);
                instr_t *FULL_LOAD = INSTR_CREATE_label(dcontext);

                reg_id_t scratch_reg_gpr64 = DR_REG_RAX;
                reg_id_t scratch_reg_gpr32 = DR_REG_EAX;
                opnd_t scratch_opnd_gpr64 = opnd_create_reg(scratch_reg_gpr64);
                opnd_t scratch_opnd_gpr32 = opnd_create_reg(scratch_reg_gpr32);

                reg_id_t ymm_src = src_reg;
                reg_id_t spill_dst_reg = find_one_available_spill_ymm(src_reg);
                reg_id_t ymm_bit_pattern = find_available_spill_ymm_avoiding(spill_dst_reg, src_reg, DR_REG_NULL);
                reg_id_t ymm_mask = find_available_spill_ymm_avoiding(spill_dst_reg, src_reg, ymm_bit_pattern);
                reg_id_t xmm_mask = ymm_mask - DR_REG_YMM0 + DR_REG_XMM0;
                reg_id_t ymm_final_dst =
                    find_available_spill_ymm_avoiding_variadic(4, spill_dst_reg, src_reg, ymm_bit_pattern, ymm_mask);

                reg_id_t ymm_else_src = find_available_spill_ymm_avoiding_variadic(
                    5, spill_dst_reg, src_reg, ymm_bit_pattern, ymm_mask, ymm_final_dst);

                /* opnd for scratch ymms */
                opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
                opnd_t ymm_src_opnd = opnd_create_reg(ymm_src);
                opnd_t ymm_bit_pattern_opnd = opnd_create_reg(ymm_bit_pattern);
                opnd_t ymm_mask_opnd = opnd_create_reg(ymm_mask);
                opnd_t xmm_mask_opnd = opnd_create_reg(xmm_mask);
                opnd_t ymm_final_dst_opnd = opnd_create_reg(ymm_final_dst);
                opnd_t ymm_else_src_opnd = opnd_create_reg(ymm_else_src);

                instr_t *i_spill_else_src = SAVE_SIMD_TO_SIZED_TLS(
                    dcontext, ymm_else_src, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_else_src)), OPSZ_32);
                instr_t *i_prepare_else_src =
                    INSTR_CREATE_vpxor(dcontext, ymm_else_src_opnd, ymm_else_src_opnd, ymm_else_src_opnd);
                instr_t *i_restore_else_src = RESTORE_SIMD_FROM_SIZED_TLS(
                    dcontext, ymm_else_src, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_else_src)), OPSZ_32);

                // push rax;
                instr_t *i1 = INSTR_CREATE_push(dcontext, scratch_opnd_gpr64);
                // push eflags;
                instr_t *i2 = INSTR_CREATE_pushf(dcontext);
                // spill_dst_reg -> tls(spill_dst_reg)
                instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                     TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
                // tls(dst_reg) -> spill_dst_reg
                instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                          TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
                // tls_slot(mask_reg) -> eax
                instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);

                // cmpl 0xf, eax (for 64-bit elements, only 4 bits matter in YMM)
                instr_t *i6 =
                    INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EAX), opnd_create_immed_int(0xf, OPSZ_4));
                // je FULL_LOAD
                instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_LOAD));

                // spill ymm_bit_pattern, ymm_mask, ymm_final_dst
                instr_t *i8 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_bit_pattern,
                                                     TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_bit_pattern)), OPSZ_32);
                instr_t *i9 =
                    SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_mask, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);
                instr_t *i10 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_final_dst,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_final_dst)), OPSZ_32);
                instr_t *i11 = i_spill_else_src;

                // sub rsp 32
                instr_t *i12 =
                    INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM, OPSZ_4));
                /* element-0 (bit 0) 0x0000000100000001 */
                instr_t *i13 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                    opnd_create_immed_int(0x0000000100000001ULL, OPSZ_8));
                instr_t *i14 = INSTR_CREATE_mov_st(
                    dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8), scratch_opnd_gpr64);
                /* element-1 (bit 1) 0x0000000200000002 */
                instr_t *i15 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                    opnd_create_immed_int(0x0000000200000002ULL, OPSZ_8));
                instr_t *i16 = INSTR_CREATE_mov_st(
                    dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8), scratch_opnd_gpr64);
                /* element-2 (bit 2) 0x0000000400000004 */
                instr_t *i17 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                    opnd_create_immed_int(0x0000000400000004ULL, OPSZ_8));
                instr_t *i18 = INSTR_CREATE_mov_st(
                    dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8), scratch_opnd_gpr64);
                /* element-3 (bit 3) 0x0000000800000008 */
                instr_t *i19 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                    opnd_create_immed_int(0x0000000800000008ULL, OPSZ_8));
                instr_t *i20 = INSTR_CREATE_mov_st(
                    dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8), scratch_opnd_gpr64);
                // vmovdqu (%rsp), %ymm_bit_pattern | bit pattern get the constant value
                instr_t *i21 = INSTR_CREATE_vmovdqu(dcontext, ymm_bit_pattern_opnd,
                                                    opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));
                // add rsp 32
                instr_t *i22 =
                    INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM, OPSZ_4));

                instr_t *i23 = i_prepare_else_src;

                // tls_slot(mask_reg) -> eax (scratch_reg_gpr64)
                instr_t *i24 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
                // vmovd eax -> xmm_mask
                instr_t *i25 = INSTR_CREATE_vmovd(dcontext, xmm_mask_opnd, scratch_opnd_gpr32);
                // vpbroadcastd xmm_mask -> ymm_mask (replicate mask to all 32-bit dwords)
                instr_t *i26 = INSTR_CREATE_vpbroadcastd(dcontext, ymm_mask_opnd, xmm_mask_opnd);
                // vpand ymm_bit_pattern & ymm_mask -> ymm_mask
                instr_t *i27 = INSTR_CREATE_vpand(dcontext, ymm_mask_opnd, ymm_mask_opnd, ymm_bit_pattern_opnd);
                // vpcmpeqq ymm_mask, ymm_bit_pattern -> ymm_mask (for 64-bit elements)
                instr_t *i28 = INSTR_CREATE_vpcmpeqq(dcontext, ymm_mask_opnd, ymm_mask_opnd, ymm_bit_pattern_opnd);

                instr_t *i29 = INSTR_CREATE_vpblendvb(dcontext, ymm_final_dst_opnd, ymm_else_src_opnd, ymm_src_opnd,
                                                      ymm_mask_opnd);

                // vmovdqu ymm_final_dst -> spill_dst_reg
                instr_t *i30 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd, ymm_final_dst_opnd);

                /* restore ymm_bit_pattern, ymm_mask, ymm_final_dst */
                instr_t *i31 = RESTORE_SIMD_FROM_SIZED_TLS(
                    dcontext, ymm_bit_pattern, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_bit_pattern)), OPSZ_32);
                instr_t *i32 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_mask,
                                                           TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);
                instr_t *i33 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_final_dst,
                                                           TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_final_dst)), OPSZ_32);

                instr_t *i34 = i_restore_else_src;

                // jmp SKIP_LOAD
                instr_t *i35 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_LOAD));

                // FULL_LOAD:
                // vmovdqu ymm_src -> spill_dst_reg
                instr_t *i36 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd, ymm_src_opnd);

                // SKIP_LOAD: (only a label)
                // spill_dst_reg -> tls(dst_reg)
                instr_t *i37 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
                // tls(spill_dst_reg) -> spill_dst_reg
                instr_t *i38 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                           TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
                // pop eflags;
                instr_t *i39 = INSTR_CREATE_popf(dcontext);
                // pop rax;
                instr_t *i40 = INSTR_CREATE_pop(dcontext, scratch_opnd_gpr64);

#ifdef DEBUG
                print_rewrite_variadic_instr(dcontext, 42, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14,
                                             i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29,
                                             i30, i31, i32, i33, i34, i35, FULL_LOAD, i36, SKIP_LOAD, i37, i38, i39,
                                             i40);
#endif
                instrlist_concat_next_instr(ilist, 42, i1, i2, i3, i4, i5, i6, i7, i8, i9,
                                            i10, // spill ymm_final_dst
                                            i11, // i_spill_else_src
                                            i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22,
                                            i23, // i_prepare_else_src
                                            i24, i25, i26, i27, i28, i29, i30, i31, i32,
                                            i33, // restore ymm_final_dst
                                            i34, // i_restore_else_src
                                            i35, FULL_LOAD, i36, SKIP_LOAD, i37, i38, i39, i40);
                return i1;
            } else {
                instr_t *SKIP_LOAD = INSTR_CREATE_label(dcontext);
                instr_t *FULL_LOAD = INSTR_CREATE_label(dcontext);

                reg_id_t scratch_reg_gpr64 = DR_REG_RAX;
                reg_id_t scratch_reg_gpr32 = DR_REG_EAX;
                opnd_t scratch_opnd_gpr64 = opnd_create_reg(scratch_reg_gpr64);
                opnd_t scratch_opnd_gpr32 = opnd_create_reg(scratch_reg_gpr32);

                reg_id_t ymm_src = src_reg;
                reg_id_t spill_dst_reg = find_one_available_spill_ymm(src_reg);
                reg_id_t ymm_bit_pattern = find_available_spill_ymm_avoiding(spill_dst_reg, src_reg, DR_REG_NULL);
                reg_id_t ymm_mask = find_available_spill_ymm_avoiding(spill_dst_reg, src_reg, ymm_bit_pattern);
                reg_id_t xmm_mask = ymm_mask - DR_REG_YMM0 + DR_REG_XMM0;
                reg_id_t ymm_final_dst =
                    find_available_spill_ymm_avoiding_variadic(4, spill_dst_reg, src_reg, ymm_bit_pattern, ymm_mask);

                /* opnd for scratch ymms */
                opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
                opnd_t ymm_src_opnd = opnd_create_reg(ymm_src);
                opnd_t ymm_bit_pattern_opnd = opnd_create_reg(ymm_bit_pattern);
                opnd_t ymm_mask_opnd = opnd_create_reg(ymm_mask);
                opnd_t xmm_mask_opnd = opnd_create_reg(xmm_mask);
                opnd_t ymm_final_dst_opnd = opnd_create_reg(ymm_final_dst);

                // push rax;
                instr_t *i1 = INSTR_CREATE_push(dcontext, scratch_opnd_gpr64);
                // push eflags;
                instr_t *i2 = INSTR_CREATE_pushf(dcontext);
                // spill_dst_reg -> tls(spill_dst_reg)
                instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                     TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
                // tls(dst_reg) -> spill_dst_reg
                instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                          TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
                // tls_slot(mask_reg) -> eax
                instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
                // test eax, eax
                instr_t *i6 = INSTR_CREATE_test(dcontext, scratch_opnd_gpr32, scratch_opnd_gpr32);
                // jz SKIP_LOAD
                instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_LOAD));
                // cmpl 0xf, eax (for 64-bit elements, only 4 bits matter in YMM)
                instr_t *i8 =
                    INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EAX), opnd_create_immed_int(0xf, OPSZ_4));
                // je FULL_LOAD
                instr_t *i9 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_LOAD));

                // spill ymm_bit_pattern, ymm_mask, ymm_final_dst
                instr_t *i10 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_bit_pattern,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_bit_pattern)), OPSZ_32);
                instr_t *i11 =
                    SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_mask, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);
                instr_t *i12 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_final_dst,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_final_dst)), OPSZ_32);

                // sub rsp 32
                instr_t *i13 =
                    INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM, OPSZ_4));
                /* element-0 (bit 0) 0x0000000100000001 */
                instr_t *i14 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                    opnd_create_immed_int(0x0000000100000001ULL, OPSZ_8));
                instr_t *i15 = INSTR_CREATE_mov_st(
                    dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8), scratch_opnd_gpr64);
                /* element-1 (bit 1) 0x0000000200000002 */
                instr_t *i16 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                    opnd_create_immed_int(0x0000000200000002ULL, OPSZ_8));
                instr_t *i17 = INSTR_CREATE_mov_st(
                    dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8), scratch_opnd_gpr64);
                /* element-2 (bit 2) 0x0000000400000004 */
                instr_t *i18 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                    opnd_create_immed_int(0x0000000400000004ULL, OPSZ_8));
                instr_t *i19 = INSTR_CREATE_mov_st(
                    dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8), scratch_opnd_gpr64);
                /* element-3 (bit 3) 0x0000000800000008 */
                instr_t *i20 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                    opnd_create_immed_int(0x0000000800000008ULL, OPSZ_8));
                instr_t *i21 = INSTR_CREATE_mov_st(
                    dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8), scratch_opnd_gpr64);
                // vmovdqu (%rsp), %ymm_bit_pattern | bit pattern get the constant value
                instr_t *i22 = INSTR_CREATE_vmovdqu(dcontext, ymm_bit_pattern_opnd,
                                                    opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));
                // add rsp 32
                instr_t *i23 =
                    INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM, OPSZ_4));

                // tls_slot(mask_reg) -> eax (scratch_reg_gpr64)
                instr_t *i24 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
                // vmovd eax -> xmm_mask
                instr_t *i25 = INSTR_CREATE_vmovd(dcontext, xmm_mask_opnd, scratch_opnd_gpr32);
                // vpbroadcastd xmm_mask -> ymm_mask (replicate mask to all 32-bit dwords)
                instr_t *i26 = INSTR_CREATE_vpbroadcastd(dcontext, ymm_mask_opnd, xmm_mask_opnd);
                // vpand ymm_bit_pattern & ymm_mask -> ymm_mask
                instr_t *i27 = INSTR_CREATE_vpand(dcontext, ymm_mask_opnd, ymm_mask_opnd, ymm_bit_pattern_opnd);
                // vpcmpeqq ymm_mask, ymm_bit_pattern -> ymm_mask (for 64-bit elements)
                instr_t *i28 = INSTR_CREATE_vpcmpeqq(dcontext, ymm_mask_opnd, ymm_mask_opnd, ymm_bit_pattern_opnd);
                // vpblendvb spill_dst_reg, ymm_src, ymm_mask -> ymm_final_dst
                instr_t *i29 =
                    INSTR_CREATE_vpblendvb(dcontext, ymm_final_dst_opnd, spill_dst_opnd, ymm_src_opnd, ymm_mask_opnd);
                // vmovdqu ymm_final_dst -> spill_dst_reg
                instr_t *i30 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd, ymm_final_dst_opnd);

                /* restore ymm_bit_pattern, ymm_mask, ymm_final_dst */
                instr_t *i31 = RESTORE_SIMD_FROM_SIZED_TLS(
                    dcontext, ymm_bit_pattern, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_bit_pattern)), OPSZ_32);
                instr_t *i32 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_mask,
                                                           TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);
                instr_t *i33 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_final_dst,
                                                           TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_final_dst)), OPSZ_32);

                // jmp SKIP_LOAD
                instr_t *i34 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_LOAD));

                // FULL_LOAD:
                // vmovdqu ymm_src -> spill_dst_reg
                instr_t *i35 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd, ymm_src_opnd);

                // SKIP_LOAD: (only a label)
                // spill_dst_reg -> tls(dst_reg)
                instr_t *i36 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
                // tls(spill_dst_reg) -> spill_dst_reg
                instr_t *i37 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                           TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
                // pop eflags;
                instr_t *i38 = INSTR_CREATE_popf(dcontext);
                // pop rax;
                instr_t *i39 = INSTR_CREATE_pop(dcontext, scratch_opnd_gpr64);

#ifdef DEBUG
                print_rewrite_variadic_instr(dcontext, 41, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14,
                                             i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29,
                                             i30, i31, i32, i33, i34, FULL_LOAD, i35, SKIP_LOAD, i36, i37, i38, i39);
#endif
                instrlist_concat_next_instr(ilist, 41, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                            i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30,
                                            i31, i32, i33, i34, FULL_LOAD, i35, SKIP_LOAD, i36, i37, i38, i39);
                return i1;
            }
        } break;
        case 3: { /* src and dst need spill */
            instr_t *SKIP_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *FULL_LOAD = INSTR_CREATE_label(dcontext);

            reg_id_t scratch_reg_gpr64 = DR_REG_RAX;
            reg_id_t scratch_reg_gpr32 = DR_REG_EAX;
            opnd_t scratch_opnd_gpr64 = opnd_create_reg(scratch_reg_gpr64);
            opnd_t scratch_opnd_gpr32 = opnd_create_reg(scratch_reg_gpr32);

            reg_id_t spill_tmp_reg = YMM_SPILL_SLOT0;
            reg_id_t spill_dst_reg = YMM_SPILL_SLOT1;
            reg_id_t ymm_bit_pattern = find_one_available_spill_ymm(spill_tmp_reg);
            reg_id_t ymm_mask = find_available_spill_ymm_avoiding(spill_tmp_reg, ymm_bit_pattern, DR_REG_NULL);
            reg_id_t xmm_mask = ymm_mask - DR_REG_YMM0 + DR_REG_XMM0;
            reg_id_t ymm_final_dst =
                find_available_spill_ymm_avoiding_variadic(3, spill_tmp_reg, ymm_bit_pattern, ymm_mask);

            /* opnd for scratch ymms */
            opnd_t spill_tmp_opnd = opnd_create_reg(spill_tmp_reg);
            opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
            opnd_t ymm_bit_pattern_opnd = opnd_create_reg(ymm_bit_pattern);
            opnd_t ymm_mask_opnd = opnd_create_reg(ymm_mask);
            opnd_t xmm_mask_opnd = opnd_create_reg(xmm_mask);
            opnd_t ymm_final_dst_opnd = opnd_create_reg(ymm_final_dst);

            // push rax;
            instr_t *i1 = INSTR_CREATE_push(dcontext, scratch_opnd_gpr64);
            // push eflags;
            instr_t *i2 = INSTR_CREATE_pushf(dcontext);
            // spill_tmp_reg -> tls(spill_tmp_reg)
            instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_tmp_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_tmp_reg)), OPSZ_32);
            // spill_dst_reg -> tls(spill_dst_reg)
            instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
            // tls(src_reg) -> spill_tmp_reg
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_tmp_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg)), OPSZ_32);
            // tls(dst_reg) -> spill_dst_reg
            instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls_slot(mask_reg) -> eax
            instr_t *i7 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // test eax, eax
            instr_t *i8 = INSTR_CREATE_test(dcontext, scratch_opnd_gpr32, scratch_opnd_gpr32);
            // jz SKIP_LOAD
            instr_t *i9 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_LOAD));
            // cmpl 0xf, eax (for 64-bit elements, only 4 bits matter in YMM)
            instr_t *i10 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EAX), opnd_create_immed_int(0xf, OPSZ_4));
            // je FULL_LOAD
            instr_t *i11 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_LOAD));

            // spill ymm_bit_pattern, ymm_mask, ymm_final_dst
            instr_t *i12 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_bit_pattern,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_bit_pattern)), OPSZ_32);
            instr_t *i13 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_mask, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);
            instr_t *i14 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_final_dst,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_final_dst)), OPSZ_32);

            // sub rsp 32
            instr_t *i15 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM, OPSZ_4));
            /* element-0 (bit 0) 0x0000000100000001 */
            instr_t *i16 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000100000001ULL, OPSZ_8));
            instr_t *i17 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8),
                                               scratch_opnd_gpr64);
            /* element-1 (bit 1) 0x0000000200000002 */
            instr_t *i18 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000200000002ULL, OPSZ_8));
            instr_t *i19 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8),
                                               scratch_opnd_gpr64);
            /* element-2 (bit 2) 0x0000000400000004 */
            instr_t *i20 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000400000004ULL, OPSZ_8));
            instr_t *i21 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8),
                                               scratch_opnd_gpr64);
            /* element-3 (bit 3) 0x0000000800000008 */
            instr_t *i22 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000800000008ULL, OPSZ_8));
            instr_t *i23 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8),
                                               scratch_opnd_gpr64);
            // vmovdqu (%rsp), %ymm_bit_pattern | bit pattern get the constant value
            instr_t *i24 = INSTR_CREATE_vmovdqu(dcontext, ymm_bit_pattern_opnd,
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));
            // add rsp 32
            instr_t *i25 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM, OPSZ_4));

            // tls_slot(mask_reg) -> eax (scratch_reg_gpr64)
            instr_t *i26 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // vmovd eax -> xmm_mask
            instr_t *i27 = INSTR_CREATE_vmovd(dcontext, xmm_mask_opnd, scratch_opnd_gpr32);
            // vpbroadcastd xmm_mask -> ymm_mask (replicate mask to all 32-bit dwords)
            instr_t *i28 = INSTR_CREATE_vpbroadcastd(dcontext, ymm_mask_opnd, xmm_mask_opnd);
            // vpand ymm_bit_pattern & ymm_mask -> ymm_mask
            instr_t *i29 = INSTR_CREATE_vpand(dcontext, ymm_mask_opnd, ymm_mask_opnd, ymm_bit_pattern_opnd);
            // vpcmpeqq ymm_mask, ymm_bit_pattern -> ymm_mask (for 64-bit elements)
            instr_t *i30 = INSTR_CREATE_vpcmpeqq(dcontext, ymm_mask_opnd, ymm_mask_opnd, ymm_bit_pattern_opnd);
            // vpblendvb spill_dst_reg, spill_tmp_reg, ymm_mask -> ymm_final_dst
            instr_t *i31 =
                INSTR_CREATE_vpblendvb(dcontext, ymm_final_dst_opnd, spill_dst_opnd, spill_tmp_opnd, ymm_mask_opnd);
            // vmovdqu ymm_final_dst -> spill_dst_reg
            instr_t *i32 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd, ymm_final_dst_opnd);

            /* restore ymm_bit_pattern, ymm_mask, ymm_final_dst */
            instr_t *i33 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_bit_pattern,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_bit_pattern)), OPSZ_32);
            instr_t *i34 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_mask, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);
            instr_t *i35 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_final_dst,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_final_dst)), OPSZ_32);

            // jmp SKIP_LOAD
            instr_t *i36 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_LOAD));

            // FULL_LOAD:
            // vmovdqu spill_tmp_reg -> spill_dst_reg
            instr_t *i37 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd, spill_tmp_opnd);

            // SKIP_LOAD: (only a label)
            // spill_dst_reg -> tls(dst_reg)
            instr_t *i38 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill_tmp_reg) -> spill_tmp_reg
            instr_t *i39 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_tmp_reg,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_tmp_reg)), OPSZ_32);
            // tls(spill_dst_reg) -> spill_dst_reg
            instr_t *i40 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
            // pop eflags;
            instr_t *i41 = INSTR_CREATE_popf(dcontext);
            // pop rax;
            instr_t *i42 = INSTR_CREATE_pop(dcontext, scratch_opnd_gpr64);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 44, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                         i32, i33, i34, i35, i36, FULL_LOAD, i37, SKIP_LOAD, i38, i39, i40, i41, i42);
#endif
            instrlist_concat_next_instr(ilist, 44, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                        i32, i33, i34, i35, i36, FULL_LOAD, i37, SKIP_LOAD, i38, i39, i40, i41, i42);
            return i1;
        } break;
        default: {
            REWRITE_ERROR(STD_ERRF, "vmovdqu64_ymm_reg2reg_gen not support pattern");
        }
        }
    }

    return NULL_INSTR;
}

instr_t *
vmovdqu64_zmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{
    dr_ymm_pair_t src_ymm_pair = { EMPTY, EMPTY };
    dr_ymm_pair_t dst_ymm_pair = { EMPTY, EMPTY };
    if (get_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(src_reg), &src_ymm_pair) == NOT_GET) {
        if (find_and_set_unused_ymm_pair(dcontext, &src_ymm_pair) == NOT_FIND) {
            return NULL_INSTR; // means failed find unused ymm pair, abandon instr rewrite
        }
        add_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(src_reg), &src_ymm_pair);
    }
    if (get_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(dst_reg), &dst_ymm_pair) == NOT_GET) {
        if (find_and_set_unused_ymm_pair(dcontext, &dst_ymm_pair) == NOT_FIND) {
            return NULL_INSTR; // means failed find unused ymm pair, abandon instr rewrite
        }
        add_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(dst_reg), &dst_ymm_pair);
    }
    reg_id_t src_reg_lower = TO_YMM_REG_ID_NUM(src_ymm_pair.ymm_lower);
    reg_id_t src_reg_upper = TO_YMM_REG_ID_NUM(src_ymm_pair.ymm_upper);
    reg_id_t dst_reg_lower = TO_YMM_REG_ID_NUM(dst_ymm_pair.ymm_lower);
    reg_id_t dst_reg_upper = TO_YMM_REG_ID_NUM(dst_ymm_pair.ymm_upper);

#ifdef DEBUG
    REWRITE_INFO(STD_OUTF,
                 "vmovdqu_zmm_reg2reg_gen: src_reg_lower{ymm%d}, src_reg_upper{ymm%d}, dst_reg_lower{ymm%d}, "
                 "dst_reg_upper{ymm%d}",
                 src_reg_lower - DR_REG_YMM0, src_reg_upper - DR_REG_YMM0, dst_reg_lower - DR_REG_YMM0,
                 dst_reg_upper - DR_REG_YMM0);
#endif

    instr_t *new_instr1 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, opnd_create_reg(dst_reg_lower), opnd_create_reg(src_reg_lower));
    instr_t *new_instr2 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, opnd_create_reg(dst_reg_upper), opnd_create_reg(src_reg_upper));
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 2, new_instr1, new_instr2);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    new_instr1->next = new_instr2;
    return new_instr1;
}

instr_t *
vmovdqu64_xmm_reg2disp_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, opnd_t dst_opnd,
                           reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    int k_idx = TO_K_REG_INDEX(mask_reg);
    const uint src_need_spill = NEED_SPILL_XMM(src_reg) ? 1 : 0;

    if (k_idx == 0) {
        switch (src_need_spill) {
        case 0: { /* src don't need spill */
            opnd_t src_opnd = create_mapping_xmm_opnd(dcontext, src_reg);
            instr_t *new_instr1 = instr_create_1dst_1src(dcontext, OP_vmovdqu, dst_opnd, src_opnd);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
            return new_instr1;
        } break;
        case 1: { /* src need spill */
            reg_id_t spill_src_reg = XMM_SPILL_SLOT0;
            opnd_t spill_src_opnd = opnd_create_reg(spill_src_reg);
            // spill_src_reg -> tls(spill_src_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src_reg)), OPSZ_16);
            // tls(src_reg) -> spill_src_reg
            instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_reg)), OPSZ_16);
            // vmovdqu spill_src_reg -> dst_opnd
            instr_t *i3 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, spill_src_opnd);
            // tls(spill_src_reg) -> spill_src_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
            instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
            return i1;
        } break;
        default: {
            REWRITE_ERROR(STD_ERRF, "vmovdqu64_xmm_reg2disp_gen not support pattern");
        }
        }
    } else {
        // use k1~k7, need to rewrite the mask logic
        switch (src_need_spill) {
        case 0: { /* src don't need spill */
            instr_t *SKIP_STORE = INSTR_CREATE_label(dcontext);
            instr_t *FULL_STORE = INSTR_CREATE_label(dcontext);

            reg_id_t scratch_reg_gpr64 = DR_REG_RAX;
            reg_id_t scratch_reg_gpr32 = DR_REG_EAX;
            opnd_t scratch_opnd_gpr64 = opnd_create_reg(scratch_reg_gpr64);
            opnd_t scratch_opnd_gpr32 = opnd_create_reg(scratch_reg_gpr32);

            reg_id_t xmm_src = src_reg;
            reg_id_t xmm_bit_pattern = find_one_available_spill_xmm(src_reg);
            reg_id_t xmm_mask = find_available_spill_xmm_avoiding(src_reg, xmm_bit_pattern, DR_REG_NULL);
            reg_id_t xmm_init_dst = find_available_spill_xmm_avoiding(src_reg, xmm_bit_pattern, xmm_mask);
            reg_id_t xmm_final_dst =
                find_available_spill_xmm_avoiding_variadic(4, src_reg, xmm_bit_pattern, xmm_mask, xmm_init_dst);

            /* opnd for scratch xmms */
            opnd_t xmm_src_opnd = opnd_create_reg(xmm_src);
            opnd_t xmm_bit_pattern_opnd = opnd_create_reg(xmm_bit_pattern);
            opnd_t xmm_mask_opnd = opnd_create_reg(xmm_mask);
            opnd_t xmm_init_dst_opnd = opnd_create_reg(xmm_init_dst);
            opnd_t xmm_final_dst_opnd = opnd_create_reg(xmm_final_dst);

            // push rax;
            instr_t *i1 = INSTR_CREATE_push(dcontext, scratch_opnd_gpr64);
            // push eflags;
            instr_t *i2 = INSTR_CREATE_pushf(dcontext);
            // tls_slot(mask_reg) -> eax
            instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // test eax, eax
            instr_t *i4 = INSTR_CREATE_test(dcontext, scratch_opnd_gpr32, scratch_opnd_gpr32);
            // jz SKIP_STORE
            instr_t *i5 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_STORE));
            // cmpl 0x3, eax (for 64-bit elements, only 2 bits matter in XMM)
            instr_t *i6 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EAX), opnd_create_immed_int(0x3, OPSZ_4));
            // je FULL_STORE
            instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_STORE));

            // spill xmm_bit_pattern
            instr_t *i8 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_bit_pattern,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_bit_pattern)), OPSZ_16);
            // spill xmm_mask
            instr_t *i9 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_mask, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_mask)), OPSZ_16);
            // spill xmm_init_dst
            instr_t *i10 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_init_dst,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_init_dst)), OPSZ_16);
            // spill xmm_final_dst
            instr_t *i11 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_final_dst,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_final_dst)), OPSZ_16);

            // sub rsp 16
            instr_t *i12 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_XMM, OPSZ_4));
            /* element-0 (bit 0) 0x0000000100000001 */
            instr_t *i13 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000100000001ULL, OPSZ_8));
            instr_t *i14 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8),
                                               scratch_opnd_gpr64);

            /* element-1 (bit 1) 0x0000000200000002 */
            instr_t *i15 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000200000002ULL, OPSZ_8));
            instr_t *i16 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8),
                                               scratch_opnd_gpr64);

            // vmovdqu (%rsp), %xmm_bit_pattern | bit pattern get the constant value
            instr_t *i17 = INSTR_CREATE_vmovdqu(dcontext, xmm_bit_pattern_opnd,
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_16));
            // vmovdqu <dst_opnd>, %xmm_init_dst | init_dst used in the vpblendvb
            instr_t *i18 = INSTR_CREATE_vmovdqu(dcontext, xmm_init_dst_opnd, dst_opnd);
            // add rsp 16
            instr_t *i19 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_XMM, OPSZ_4));

            // tls_slot(mask_reg) -> eax (scratch_reg_gpr64)
            instr_t *i20 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // vmovd eax -> xmm_mask
            instr_t *i21 = INSTR_CREATE_vmovd(dcontext, xmm_mask_opnd, scratch_opnd_gpr32);
            // vpbroadcastd xmm_mask -> xmm_mask (replicate mask to all 32-bit dwords)
            instr_t *i22 = INSTR_CREATE_vpbroadcastd(dcontext, xmm_mask_opnd, xmm_mask_opnd);
            // vpand xmm_bit_pattern & xmm_mask -> xmm_mask
            instr_t *i23 = INSTR_CREATE_vpand(dcontext, xmm_mask_opnd, xmm_mask_opnd, xmm_bit_pattern_opnd);
            // vpcmpeqq xmm_mask, xmm_bit_pattern -> xmm_mask (for 64-bit elements)
            instr_t *i24 = INSTR_CREATE_vpcmpeqq(dcontext, xmm_mask_opnd, xmm_mask_opnd, xmm_bit_pattern_opnd);
            // vpblendvb xmm_init_dst, xmm_src, xmm_mask -> xmm_final_dst
            instr_t *i25 =
                INSTR_CREATE_vpblendvb(dcontext, xmm_final_dst_opnd, xmm_init_dst_opnd, xmm_src_opnd, xmm_mask_opnd);
            // vmovdqu xmm_final_dst -> <dst_opnd>
            instr_t *i26 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, xmm_final_dst_opnd);

            // restore xmm_bit_pattern
            instr_t *i27 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_bit_pattern,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_bit_pattern)), OPSZ_16);
            // restore xmm_mask
            instr_t *i28 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_mask, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_mask)), OPSZ_16);
            // restore xmm_init_dst
            instr_t *i29 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_init_dst,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_init_dst)), OPSZ_16);
            // restore xmm_final_dst
            instr_t *i30 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_final_dst,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_final_dst)), OPSZ_16);

            // jmp SKIP_STORE
            instr_t *i31 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_STORE));

            // FULL_STORE:
            // vmovdqu xmm_src -> <dst_opnd>
            instr_t *i32 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, xmm_src_opnd);

            // SKIP_STORE: (only a label)
            // pop eflags;
            instr_t *i33 = INSTR_CREATE_popf(dcontext);
            // pop rax;
            instr_t *i34 = INSTR_CREATE_pop(dcontext, scratch_opnd_gpr64);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 36, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                         FULL_STORE, i32, SKIP_STORE, i33, i34);
#endif
            instrlist_concat_next_instr(ilist, 36, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                        FULL_STORE, i32, SKIP_STORE, i33, i34);
            return i1;
        } break;
        case 1: { /* src need spill */
            instr_t *SKIP_STORE = INSTR_CREATE_label(dcontext);
            instr_t *FULL_STORE = INSTR_CREATE_label(dcontext);

            reg_id_t scratch_reg_gpr64 = DR_REG_RAX;
            reg_id_t scratch_reg_gpr32 = DR_REG_EAX;
            opnd_t scratch_opnd_gpr64 = opnd_create_reg(scratch_reg_gpr64);
            opnd_t scratch_opnd_gpr32 = opnd_create_reg(scratch_reg_gpr32);

            reg_id_t spill_src_reg = XMM_SPILL_SLOT0;
            reg_id_t xmm_bit_pattern = find_one_available_spill_xmm(spill_src_reg);
            reg_id_t xmm_mask = find_available_spill_xmm_avoiding(spill_src_reg, xmm_bit_pattern, DR_REG_NULL);
            reg_id_t xmm_init_dst = find_available_spill_xmm_avoiding(spill_src_reg, xmm_bit_pattern, xmm_mask);
            reg_id_t xmm_final_dst =
                find_available_spill_xmm_avoiding_variadic(4, spill_src_reg, xmm_bit_pattern, xmm_mask, xmm_init_dst);

            /* opnd for scratch xmms */
            opnd_t spill_src_opnd = opnd_create_reg(spill_src_reg);
            opnd_t xmm_bit_pattern_opnd = opnd_create_reg(xmm_bit_pattern);
            opnd_t xmm_mask_opnd = opnd_create_reg(xmm_mask);
            opnd_t xmm_init_dst_opnd = opnd_create_reg(xmm_init_dst);
            opnd_t xmm_final_dst_opnd = opnd_create_reg(xmm_final_dst);

            // push rax;
            instr_t *i1 = INSTR_CREATE_push(dcontext, scratch_opnd_gpr64);
            // push eflags;
            instr_t *i2 = INSTR_CREATE_pushf(dcontext);
            // spill_src_reg -> tls(spill_src_reg)
            instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src_reg)), OPSZ_16);
            // tls(src_reg) -> spill_src_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_reg)), OPSZ_16);
            // tls_slot(mask_reg) -> eax
            instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // test eax, eax
            instr_t *i6 = INSTR_CREATE_test(dcontext, scratch_opnd_gpr32, scratch_opnd_gpr32);
            // jz SKIP_STORE
            instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_STORE));
            // cmpl 0x3, eax (for 64-bit elements, only 2 bits matter in XMM)
            instr_t *i8 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EAX), opnd_create_immed_int(0x3, OPSZ_4));
            // je FULL_STORE
            instr_t *i9 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_STORE));

            // spill xmm_bit_pattern, xmm_mask, xmm_init_dst, xmm_final_dst
            instr_t *i10 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_bit_pattern,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_bit_pattern)), OPSZ_16);
            instr_t *i11 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_mask, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_mask)), OPSZ_16);
            instr_t *i12 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_init_dst,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_init_dst)), OPSZ_16);
            instr_t *i13 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_final_dst,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_final_dst)), OPSZ_16);

            // sub rsp 16
            instr_t *i14 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_XMM, OPSZ_4));
            /* element-0 (bit 0) 0x0000000100000001 */
            instr_t *i15 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000100000001ULL, OPSZ_8));
            instr_t *i16 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8),
                                               scratch_opnd_gpr64);
            /* element-1 (bit 1) 0x0000000200000002 */
            instr_t *i17 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000200000002ULL, OPSZ_8));
            instr_t *i18 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8),
                                               scratch_opnd_gpr64);
            // vmovdqu (%rsp), %xmm_bit_pattern | bit pattern get the constant value
            instr_t *i19 = INSTR_CREATE_vmovdqu(dcontext, xmm_bit_pattern_opnd,
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_16));
            // vmovdqu <dst_opnd>, %xmm_init_dst | init_dst used in the vpblendvb
            instr_t *i20 = INSTR_CREATE_vmovdqu(dcontext, xmm_init_dst_opnd, dst_opnd);
            // add rsp 16
            instr_t *i21 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_XMM, OPSZ_4));

            // tls_slot(mask_reg) -> eax (scratch_reg_gpr64)
            instr_t *i22 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EAX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // vmovd eax -> xmm_mask
            instr_t *i23 = INSTR_CREATE_vmovd(dcontext, xmm_mask_opnd, scratch_opnd_gpr32);
            // vpbroadcastd xmm_mask -> xmm_mask (replicate mask to all 32-bit dwords)
            instr_t *i24 = INSTR_CREATE_vpbroadcastd(dcontext, xmm_mask_opnd, xmm_mask_opnd);
            // vpand xmm_bit_pattern & xmm_mask -> xmm_mask
            instr_t *i25 = INSTR_CREATE_vpand(dcontext, xmm_mask_opnd, xmm_mask_opnd, xmm_bit_pattern_opnd);
            // vpcmpeqq xmm_mask, xmm_bit_pattern -> xmm_mask (for 64-bit elements)
            instr_t *i26 = INSTR_CREATE_vpcmpeqq(dcontext, xmm_mask_opnd, xmm_mask_opnd, xmm_bit_pattern_opnd);
            // vpblendvb xmm_init_dst, spill_src_reg, xmm_mask -> xmm_final_dst
            instr_t *i27 =
                INSTR_CREATE_vpblendvb(dcontext, xmm_final_dst_opnd, xmm_init_dst_opnd, spill_src_opnd, xmm_mask_opnd);
            // vmovdqu xmm_final_dst -> <dst_opnd>
            instr_t *i28 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, xmm_final_dst_opnd);

            /* restore xmm_bit_pattern, xmm_mask, xmm_init_dst, xmm_final_dst */
            instr_t *i29 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_bit_pattern,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_bit_pattern)), OPSZ_16);
            instr_t *i30 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_mask, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_mask)), OPSZ_16);
            instr_t *i31 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_init_dst,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_init_dst)), OPSZ_16);
            instr_t *i32 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_final_dst,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_final_dst)), OPSZ_16);

            // jmp SKIP_STORE
            instr_t *i33 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_STORE));

            // FULL_STORE:
            // vmovdqu spill_src_reg -> <dst_opnd>
            instr_t *i34 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, spill_src_opnd);

            // SKIP_STORE: (only a label)
            // tls(spill_src_reg) -> spill_src_reg
            instr_t *i35 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src_reg)), OPSZ_16);
            // pop eflags;
            instr_t *i36 = INSTR_CREATE_popf(dcontext);
            // pop rax;
            instr_t *i37 = INSTR_CREATE_pop(dcontext, scratch_opnd_gpr64);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 39, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                         i32, i33, FULL_STORE, i34, SKIP_STORE, i35, i36, i37);
#endif
            instrlist_concat_next_instr(ilist, 39, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                        i32, i33, FULL_STORE, i34, SKIP_STORE, i35, i36, i37);
            return i1;
        } break;
        default: {
            REWRITE_ERROR(STD_ERRF, "vmovdqu64_xmm_reg2disp_gen not support pattern");
        }
        }
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu64_ymm_reg2disp_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, opnd_t dst_opnd,
                           reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    int k_idx = TO_K_REG_INDEX(mask_reg);
    const uint src_need_spill = NEED_SPILL_YMM(src_reg) ? 1 : 0;

    if (k_idx == 0) {
        switch (src_need_spill) {
        case 0: { /* src don't need spill */
            opnd_t src_opnd = create_mapping_ymm_opnd(dcontext, src_reg);
            instr_t *new_instr1 = instr_create_1dst_1src(dcontext, OP_vmovdqu, dst_opnd, src_opnd);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
            return new_instr1;
        } break;
        case 1: { /* src need spill */
            reg_id_t spill_src_reg = YMM_SPILL_SLOT0;
            opnd_t spill_src_opnd = opnd_create_reg(spill_src_reg);
            // spill_src_reg -> tls(spill_src_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg)), OPSZ_32);
            // tls(src_reg) -> spill_src_reg
            instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg)), OPSZ_32);
            // vmovdqu spill_src_reg -> dst_opnd
            instr_t *i3 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, spill_src_opnd);
            // tls(spill_src_reg) -> spill_src_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
            instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
            return i1;
        } break;
        default: {
            REWRITE_ERROR(STD_ERRF, "vmovdqu64_ymm_reg2disp_gen not support pattern");
        }
        }
    } else { // use k1~k7, need to rewrite the mask logic
        // dst_opnd = disp(base, index, scale)
        // in previous implementation, if %rax is used then we will encounter SIGSEGV
        // so we need a selector to select the proper free register
        reg_id_t base_reg = opnd_get_base(dst_opnd);
        reg_id_t index_reg = opnd_get_index(dst_opnd);
        reg_id_t scratch_reg = DR_REG_NULL;
        if (index_reg == DR_REG_NULL) {
            scratch_reg = find_one_available_spill_gpr_avoiding_variadic(1, base_reg);
        } else {
            scratch_reg = find_one_available_spill_gpr_avoiding_variadic(2, base_reg, index_reg);
        }

        switch (src_need_spill) {
        case 0: { /* src don't need spill */
            instr_t *SKIP_STORE = INSTR_CREATE_label(dcontext);
            instr_t *FULL_STORE = INSTR_CREATE_label(dcontext);

            reg_id_t scratch_reg_gpr64 = scratch_reg;
            reg_id_t scratch_reg_gpr32 = GPR64_TO_GPR32(scratch_reg);
            opnd_t scratch_opnd_gpr64 = opnd_create_reg(scratch_reg_gpr64);
            opnd_t scratch_opnd_gpr32 = opnd_create_reg(scratch_reg_gpr32);

            reg_id_t ymm_src = src_reg;
            reg_id_t ymm_bit_pattern = find_one_available_spill_ymm(src_reg);
            reg_id_t ymm_mask = find_available_spill_ymm_avoiding(src_reg, ymm_bit_pattern, DR_REG_NULL);
            reg_id_t xmm_mask = ymm_mask - DR_REG_YMM0 + DR_REG_XMM0;
            reg_id_t ymm_init_dst = find_available_spill_ymm_avoiding(src_reg, ymm_bit_pattern, ymm_mask);
            reg_id_t ymm_final_dst =
                find_available_spill_ymm_avoiding_variadic(4, src_reg, ymm_bit_pattern, ymm_mask, ymm_init_dst);

            /* opnd for scratch ymms */
            opnd_t ymm_src_opnd = opnd_create_reg(ymm_src);
            opnd_t ymm_bit_pattern_opnd = opnd_create_reg(ymm_bit_pattern);
            opnd_t ymm_mask_opnd = opnd_create_reg(ymm_mask);
            opnd_t xmm_mask_opnd = opnd_create_reg(xmm_mask);
            opnd_t ymm_init_dst_opnd = opnd_create_reg(ymm_init_dst);
            opnd_t ymm_final_dst_opnd = opnd_create_reg(ymm_final_dst);

            // push rax;
            instr_t *i1 = INSTR_CREATE_push(dcontext, scratch_opnd_gpr64);
            // push eflags;
            instr_t *i2 = INSTR_CREATE_pushf(dcontext);
            // tls_slot(mask_reg) -> scratch_reg32
            instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, scratch_reg_gpr32, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // test scratch_reg32, scratch_reg32
            instr_t *i4 = INSTR_CREATE_test(dcontext, scratch_opnd_gpr32, scratch_opnd_gpr32);
            // jz SKIP_STORE
            instr_t *i5 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_STORE));
            // cmpl 0xf, scratch_reg32 (for 64-bit elements, only 4 bits matter in YMM)
            instr_t *i6 =
                INSTR_CREATE_cmp(dcontext, opnd_create_reg(scratch_reg_gpr32), opnd_create_immed_int(0xf, OPSZ_4));
            // je FULL_STORE
            instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_STORE));

            // spill ymm_bit_pattern
            instr_t *i8 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_bit_pattern,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_bit_pattern)), OPSZ_32);
            // spill ymm_mask
            instr_t *i9 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_mask, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);
            // spill ymm_init_dst
            instr_t *i10 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_init_dst,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_init_dst)), OPSZ_32);
            // spill ymm_final_dst
            instr_t *i11 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_final_dst,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_final_dst)), OPSZ_32);

            // sub rsp 32
            instr_t *i12 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM, OPSZ_4));
            /* element-0 (bit 0) 0x0000000100000001 */
            instr_t *i13 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000100000001ULL, OPSZ_8));
            instr_t *i14 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8),
                                               scratch_opnd_gpr64);

            /* element-1 (bit 1) 0x0000000200000002 */
            instr_t *i15 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000200000002ULL, OPSZ_8));
            instr_t *i16 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8),
                                               scratch_opnd_gpr64);

            /* element-2 (bit 2) 0x0000000400000004 */
            instr_t *i17 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000400000004ULL, OPSZ_8));
            instr_t *i18 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8),
                                               scratch_opnd_gpr64);

            /* element-3 (bit 3) 0x0000000800000008 */
            instr_t *i19 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000800000008ULL, OPSZ_8));
            instr_t *i20 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8),
                                               scratch_opnd_gpr64);
            // vmovdqu (%rsp), %ymm_bit_pattern | bit pattern get the constant value
            instr_t *i21 = INSTR_CREATE_vmovdqu(dcontext, ymm_bit_pattern_opnd,
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));
            // vmovdqu <dst_opnd>, %ymm_init_dst | init_dst used in the vpblendvb
            instr_t *i22 = INSTR_CREATE_vmovdqu(dcontext, ymm_init_dst_opnd, dst_opnd);
            // add rsp 32
            instr_t *i23 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM, OPSZ_4));

            // tls_slot(mask_reg) -> scratch_reg32
            instr_t *i24 = RESTORE_FROM_SIZED_TLS(dcontext, scratch_reg_gpr32, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // vmovd scratch_reg32 -> xmm_mask
            instr_t *i25 = INSTR_CREATE_vmovd(dcontext, xmm_mask_opnd, scratch_opnd_gpr32);
            // vpbroadcastd xmm_mask -> ymm_mask (replicate mask to all 32-bit dwords)
            instr_t *i26 = INSTR_CREATE_vpbroadcastd(dcontext, ymm_mask_opnd, xmm_mask_opnd);
            // vpand ymm_bit_pattern & ymm_mask -> ymm_mask
            instr_t *i27 = INSTR_CREATE_vpand(dcontext, ymm_mask_opnd, ymm_mask_opnd, ymm_bit_pattern_opnd);
            // vpcmpeqq ymm_mask, ymm_bit_pattern -> ymm_mask (for 64-bit elements)
            instr_t *i28 = INSTR_CREATE_vpcmpeqq(dcontext, ymm_mask_opnd, ymm_mask_opnd, ymm_bit_pattern_opnd);
            // vpblendvb ymm_init_dst, ymm_src, ymm_mask -> ymm_final_dst
            instr_t *i29 =
                INSTR_CREATE_vpblendvb(dcontext, ymm_final_dst_opnd, ymm_init_dst_opnd, ymm_src_opnd, ymm_mask_opnd);
            // vmovdqu ymm_final_dst -> <dst_opnd>
            instr_t *i30 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, ymm_final_dst_opnd);

            // restore ymm_bit_pattern
            instr_t *i31 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_bit_pattern,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_bit_pattern)), OPSZ_32);
            // restore ymm_mask
            instr_t *i32 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_mask, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);
            // restore ymm_init_dst
            instr_t *i33 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_init_dst,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_init_dst)), OPSZ_32);
            // restore ymm_final_dst
            instr_t *i34 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_final_dst,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_final_dst)), OPSZ_32);

            // jmp SKIP_STORE
            instr_t *i35 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_STORE));

            // FULL_STORE:
            // vmovdqu ymm_src -> <dst_opnd>
            instr_t *i36 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, ymm_src_opnd);

            // SKIP_STORE: (only a label)
            // pop eflags;
            instr_t *i37 = INSTR_CREATE_popf(dcontext);
            // pop rax;
            instr_t *i38 = INSTR_CREATE_pop(dcontext, scratch_opnd_gpr64);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 40, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                         i32, i33, i34, i35, FULL_STORE, i36, SKIP_STORE, i37, i38);
#endif
            instrlist_concat_next_instr(ilist, 40, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                        i32, i33, i34, i35, FULL_STORE, i36, SKIP_STORE, i37, i38);
            return i1;
        } break;
        case 1: { /* src need spill */
            instr_t *SKIP_STORE = INSTR_CREATE_label(dcontext);
            instr_t *FULL_STORE = INSTR_CREATE_label(dcontext);

            reg_id_t scratch_reg_gpr64 = scratch_reg;
            reg_id_t scratch_reg_gpr32 = GPR64_TO_GPR32(scratch_reg);
            opnd_t scratch_opnd_gpr64 = opnd_create_reg(scratch_reg_gpr64);
            opnd_t scratch_opnd_gpr32 = opnd_create_reg(scratch_reg_gpr32);

            reg_id_t spill_src_reg = YMM_SPILL_SLOT0;
            reg_id_t ymm_bit_pattern = find_one_available_spill_ymm(spill_src_reg);
            reg_id_t ymm_mask = find_available_spill_ymm_avoiding(spill_src_reg, ymm_bit_pattern, DR_REG_NULL);
            reg_id_t xmm_mask = ymm_mask - DR_REG_YMM0 + DR_REG_XMM0;
            reg_id_t ymm_init_dst = find_available_spill_ymm_avoiding(spill_src_reg, ymm_bit_pattern, ymm_mask);
            reg_id_t ymm_final_dst =
                find_available_spill_ymm_avoiding_variadic(4, spill_src_reg, ymm_bit_pattern, ymm_mask, ymm_init_dst);

            /* opnd for scratch ymms */
            opnd_t spill_src_opnd = opnd_create_reg(spill_src_reg);
            opnd_t ymm_bit_pattern_opnd = opnd_create_reg(ymm_bit_pattern);
            opnd_t ymm_mask_opnd = opnd_create_reg(ymm_mask);
            opnd_t xmm_mask_opnd = opnd_create_reg(xmm_mask);
            opnd_t ymm_init_dst_opnd = opnd_create_reg(ymm_init_dst);
            opnd_t ymm_final_dst_opnd = opnd_create_reg(ymm_final_dst);

            // push rax;
            instr_t *i1 = INSTR_CREATE_push(dcontext, scratch_opnd_gpr64);
            // push eflags;
            instr_t *i2 = INSTR_CREATE_pushf(dcontext);
            // spill_src_reg -> tls(spill_src_reg)
            instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg)), OPSZ_32);
            // tls(src_reg) -> spill_src_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg)), OPSZ_32);
            // tls_slot(mask_reg) -> scratch_reg32
            instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, scratch_reg_gpr32, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // test scratch_reg32, scratch_reg32
            instr_t *i6 = INSTR_CREATE_test(dcontext, scratch_opnd_gpr32, scratch_opnd_gpr32);
            // jz SKIP_STORE
            instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_STORE));
            // cmpl 0xf, scratch_reg32 (for 64-bit elements, only 4 bits matter in YMM)
            instr_t *i8 =
                INSTR_CREATE_cmp(dcontext, opnd_create_reg(scratch_reg_gpr32), opnd_create_immed_int(0xf, OPSZ_4));
            // je FULL_STORE
            instr_t *i9 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_STORE));

            // spill ymm_bit_pattern, ymm_mask, ymm_init_dst, ymm_final_dst
            instr_t *i10 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_bit_pattern,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_bit_pattern)), OPSZ_32);
            instr_t *i11 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_mask, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);
            instr_t *i12 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_init_dst,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_init_dst)), OPSZ_32);
            instr_t *i13 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_final_dst,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_final_dst)), OPSZ_32);

            // sub rsp 32
            instr_t *i14 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM, OPSZ_4));
            /* element-0 (bit 0) 0x0000000100000001 */
            instr_t *i15 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000100000001ULL, OPSZ_8));
            instr_t *i16 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8),
                                               scratch_opnd_gpr64);
            /* element-1 (bit 1) 0x0000000200000002 */
            instr_t *i17 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000200000002ULL, OPSZ_8));
            instr_t *i18 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8),
                                               scratch_opnd_gpr64);
            /* element-2 (bit 2) 0x0000000400000004 */
            instr_t *i19 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000400000004ULL, OPSZ_8));
            instr_t *i20 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8),
                                               scratch_opnd_gpr64);
            /* element-3 (bit 3) 0x0000000800000008 */
            instr_t *i21 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000800000008ULL, OPSZ_8));
            instr_t *i22 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8),
                                               scratch_opnd_gpr64);
            // vmovdqu (%rsp), %ymm_bit_pattern | bit pattern get the constant value
            instr_t *i23 = INSTR_CREATE_vmovdqu(dcontext, ymm_bit_pattern_opnd,
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));
            // vmovdqu <dst_opnd>, %ymm_init_dst | init_dst used in the vpblendvb
            instr_t *i24 = INSTR_CREATE_vmovdqu(dcontext, ymm_init_dst_opnd, dst_opnd);
            // add rsp 32
            instr_t *i25 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM, OPSZ_4));

            // tls_slot(mask_reg) -> scratch_reg32
            instr_t *i26 = RESTORE_FROM_SIZED_TLS(dcontext, scratch_reg_gpr32, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // vmovd scratch_reg32 -> xmm_mask
            instr_t *i27 = INSTR_CREATE_vmovd(dcontext, xmm_mask_opnd, scratch_opnd_gpr32);
            // vpbroadcastd xmm_mask -> ymm_mask (replicate mask to all 32-bit dwords)
            instr_t *i28 = INSTR_CREATE_vpbroadcastd(dcontext, ymm_mask_opnd, xmm_mask_opnd);
            // vpand ymm_bit_pattern & ymm_mask -> ymm_mask
            instr_t *i29 = INSTR_CREATE_vpand(dcontext, ymm_mask_opnd, ymm_mask_opnd, ymm_bit_pattern_opnd);
            // vpcmpeqq ymm_mask, ymm_bit_pattern -> ymm_mask (for 64-bit elements)
            instr_t *i30 = INSTR_CREATE_vpcmpeqq(dcontext, ymm_mask_opnd, ymm_mask_opnd, ymm_bit_pattern_opnd);
            // vpblendvb ymm_init_dst, spill_src_reg, ymm_mask -> ymm_final_dst
            instr_t *i31 =
                INSTR_CREATE_vpblendvb(dcontext, ymm_final_dst_opnd, ymm_init_dst_opnd, spill_src_opnd, ymm_mask_opnd);
            // vmovdqu ymm_final_dst -> <dst_opnd>
            instr_t *i32 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, ymm_final_dst_opnd);

            /* restore ymm_bit_pattern, ymm_mask, ymm_init_dst, ymm_final_dst */
            instr_t *i33 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_bit_pattern,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_bit_pattern)), OPSZ_32);
            instr_t *i34 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_mask, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);
            instr_t *i35 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_init_dst,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_init_dst)), OPSZ_32);
            instr_t *i36 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_final_dst,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_final_dst)), OPSZ_32);

            // jmp SKIP_STORE
            instr_t *i37 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_STORE));

            // FULL_STORE:
            // vmovdqu spill_src_reg -> <dst_opnd>
            instr_t *i38 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, spill_src_opnd);

            // SKIP_STORE: (only a label)
            // tls(spill_src_reg) -> spill_src_reg
            instr_t *i39 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg)), OPSZ_32);
            // pop eflags;
            instr_t *i40 = INSTR_CREATE_popf(dcontext);
            // pop rax;
            instr_t *i41 = INSTR_CREATE_pop(dcontext, scratch_opnd_gpr64);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 43, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                         i32, i33, i34, i35, i36, i37, FULL_STORE, i38, SKIP_STORE, i39, i40, i41);
#endif
            instrlist_concat_next_instr(ilist, 43, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                        i32, i33, i34, i35, i36, i37, FULL_STORE, i38, SKIP_STORE, i39, i40, i41);
            return i1;
        } break;
        default: {
            REWRITE_ERROR(STD_ERRF, "vmovdqu64_ymm_reg2disp_gen not support pattern");
        }
        }
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu64_zmm_reg2disp_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, opnd_t dst_opnd,
                           reg_id_t mask_reg)
{
    // vmovdqu64 %zmm0 -> 0x40(%rsp)[64byte]
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    int disp = opnd_get_disp(dst_opnd);
    reg_id_t dst_base_reg = opnd_get_base(dst_opnd);
    reg_id_t dst_index_reg = opnd_get_index(dst_opnd);
    int scale = opnd_get_scale(dst_opnd);

    const uint dst_need_spill = NEED_SPILL_ZMM(src_reg) ? 1 : 0;
    switch (dst_need_spill) {
    case 0: { /* no spill */
        reg_id_t src_reg_lower = ZMM_TO_YMM(src_reg);
        reg_id_t src_reg_upper = find_one_available_spill_ymm(src_reg_lower);

        opnd_t op_src_reg_lower = opnd_create_reg(src_reg_lower);
        opnd_t op_src_reg_upper = opnd_create_reg(src_reg_upper);

        // src_reg_upper -> tls(src_reg_upper)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, src_reg_upper, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg_upper)), OPSZ_32);
        // tls(src_upper) -> src_reg_upper
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src_reg)) + SIZE_OF_YMM, OPSZ_32);
        // tls(src_lower) -> src_reg_lower
        instr_t *i3 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_reg_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src_reg)), OPSZ_32);
        // vmovdqu src_reg_lower -> dst_opnd_lower
        instr_t *i4 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(dst_base_reg, dst_index_reg, scale, disp, OPSZ_32), op_src_reg_lower);
        // vmovdqu src_reg_upper -> dst_opnd_upper
        instr_t *i5 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(dst_base_reg, dst_index_reg, scale, disp + SIZE_OF_YMM, OPSZ_32),
            op_src_reg_upper);
        // tls(src_reg_upper) -> src_reg_upper
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg_upper)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 6, i1, i2, i3, i4, i5, i6);
#endif
        instrlist_concat_next_instr(ilist, 6, i1, i2, i3, i4, i5, i6);
        return i1;
    } break;
    case 1: { /* dst need spill */
        reg_id_t spill_src_reg = find_one_available_spill_ymm(DR_REG_NULL);
        reg_id_t spill_src_reg_upper = find_one_available_spill_ymm(spill_src_reg);

        opnd_t op_spill_src_reg = opnd_create_reg(spill_src_reg);
        opnd_t op_spill_src_reg_upper = opnd_create_reg(spill_src_reg_upper);

        // spill_src_reg -> tls(spill_src_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg)), OPSZ_32);
        // spill_src_reg_upper -> tls(spill_src_reg_upper)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg_upper)), OPSZ_32);
        // tls(src_lower) -> spill_src_reg
        instr_t *i3 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src_reg)), OPSZ_32);
        // tls(src_upper) -> spill_src_reg_upper
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src_reg)) + SIZE_OF_YMM, OPSZ_32);
        // vmovdqu spill_src_reg -> dst_opnd_lower
        instr_t *i5 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(dst_base_reg, dst_index_reg, scale, disp, OPSZ_32), op_spill_src_reg);
        // vmovdqu spill_src_reg_upper -> dst_opnd_upper
        instr_t *i6 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(dst_base_reg, dst_index_reg, scale, disp + SIZE_OF_YMM, OPSZ_32),
            op_spill_src_reg_upper);
        // tls(spill_src_reg) -> spill_src_reg
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg)), OPSZ_32);
        // tls(spill_src_reg_upper) -> spill_src_reg_upper
        instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg_upper)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
        instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
        return i1;
    } break;
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu64_zmm_reg2reladdr_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                              opnd_t dst_opnd, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src_need_spill = NEED_SPILL_ZMM(src_reg) ? 1 : 0;
    switch (src_need_spill) {
    case 0: { /* no spill */
        reg_id_t src_reg_lower = ZMM_TO_YMM(src_reg);
        reg_id_t src_reg_upper = find_one_available_spill_ymm(src_reg_lower);

        opnd_t op_src_reg_lower = opnd_create_reg(src_reg_lower);
        opnd_t op_src_reg_upper = opnd_create_reg(src_reg_upper);

        // src_reg_upper -> tls(src_reg_upper)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, src_reg_upper, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg_upper)), OPSZ_32);
        // tls(src_upper) -> src_reg_upper
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src_reg)) + SIZE_OF_YMM, OPSZ_32);
        // tls(src_lower) -> src_reg_lower
        instr_t *i3 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_reg_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src_reg)), OPSZ_32);
        // vmovdqu src_reg_lower -> dst_opnd_lower
        instr_t *i4 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_rel_addr(opnd_get_addr(dst_opnd), OPSZ_32), op_src_reg_lower);
        // vmovdqu src_reg_upper -> dst_opnd_upper
        instr_t *i5 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_rel_addr(opnd_get_addr(dst_opnd) + SIZE_OF_YMM, OPSZ_32), op_src_reg_upper);
        // tls(src_reg_upper) -> src_reg_upper
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg_upper)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 6, i1, i2, i3, i4, i5, i6);
#endif
        instrlist_concat_next_instr(ilist, 6, i1, i2, i3, i4, i5, i6);
        return i1;
    } break;
    case 1: { /* src need spill */
        reg_id_t spill_src_reg = find_one_available_spill_ymm(DR_REG_NULL);
        reg_id_t spill_src_reg_upper = find_one_available_spill_ymm(spill_src_reg);

        opnd_t op_spill_src_reg = opnd_create_reg(spill_src_reg);
        opnd_t op_spill_src_reg_upper = opnd_create_reg(spill_src_reg_upper);

        // spill_src_reg -> tls(spill_src_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg)), OPSZ_32);
        // spill_src_reg_upper -> tls(spill_src_reg_upper)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg_upper)), OPSZ_32);
        // tls(src_lower) -> spill_src_reg
        instr_t *i3 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src_reg)), OPSZ_32);
        // tls(src_upper) -> spill_src_reg_upper
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src_reg)) + SIZE_OF_YMM, OPSZ_32);
        // vmovdqu spill_src_reg -> dst_opnd_lower
        instr_t *i5 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_rel_addr(opnd_get_addr(dst_opnd), OPSZ_32), op_spill_src_reg);
        // vmovdqu spill_src_reg_upper -> dst_opnd_upper
        instr_t *i6 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_rel_addr(opnd_get_addr(dst_opnd) + SIZE_OF_YMM, OPSZ_32), op_spill_src_reg_upper);
        // tls(spill_src_reg) -> spill_src_reg
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg)), OPSZ_32);
        // tls(spill_src_reg_upper) -> spill_src_reg_upper
        instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg_upper)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
        instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
        return i1;
    } break;
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu64_ymm_reg2reladdr_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                              opnd_t dst_opnd, reg_id_t mask_reg)
{
    instr_t *new_instr1 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, dst_opnd, create_mapping_ymm_opnd(dcontext, src_reg));
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vmovdqu64_xmm_reg2reladdr_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                              opnd_t dst_opnd, reg_id_t mask_reg)
{
    instr_t *new_instr1 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, dst_opnd, create_mapping_xmm_opnd(dcontext, src_reg));
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vmovdqu64_xmm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd, reg_id_t dst_reg,
                           reg_id_t mask_reg)
{
    // vmovdqu64 {%k1} 0xffffffb8(%rdx)[16byte] -> %xmm31

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    int k_idx = TO_K_REG_INDEX(mask_reg);

    if (k_idx == 0) { // mask don't work

        const uint dst_need_spill = NEED_SPILL_XMM(dst_reg) ? 1 : 0;

        switch (dst_need_spill) {
        case 0: { /* don't need spill */
            opnd_t dst_opnd = opnd_create_reg(dst_reg);
            instr_t *i1 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, src_opnd);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
            return i1;
        } break;
        case 1: { /* dst need spill */
            reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
            opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
            // spill_dst_reg -> tls(spill_dst_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
            // VEX.128.66.0F.WIG 6F /r VMOVDQU xmm1, xmm2/m128
            instr_t *i2 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd, src_opnd);
            // spill_dst_reg -> tls(dst_reg)
            instr_t *i3 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_dst_reg) -> spill_dst_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
            instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
            return i1;
        } break;
        default: {
            REWRITE_ERROR(STD_OUTF, "vmovdqu_xmm_disp2reg_gen not support pattern");
        }
        }
    } else { // k1 ~ k7 mask work
        const uint dst_need_spill = NEED_SPILL_XMM(dst_reg) ? 1 : 0;

        reg_id_t base_reg = opnd_get_base(src_opnd);
        reg_id_t index_reg = opnd_get_index(src_opnd);
        reg_id_t scratch_reg = DR_REG_NULL;
        if (index_reg == DR_REG_NULL) {
            scratch_reg = find_one_available_spill_gpr_avoiding_variadic(1, base_reg);
        } else {
            scratch_reg = find_one_available_spill_gpr_avoiding_variadic(2, base_reg, index_reg);
        }

        switch (dst_need_spill) {
        case 0: { /* don't need spill */
            instr_t *SKIP_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *FULL_LOAD = INSTR_CREATE_label(dcontext);

            reg_id_t scratch_reg_gpr64 = scratch_reg;
            reg_id_t scratch_reg_gpr32 = GPR64_TO_GPR32(scratch_reg);
            opnd_t scratch_opnd_gpr64 = opnd_create_reg(scratch_reg_gpr64);
            opnd_t scratch_opnd_gpr32 = opnd_create_reg(scratch_reg_gpr32);

            reg_id_t xmm_dst = dst_reg;
            reg_id_t xmm_bit_pattern = find_one_available_spill_xmm(dst_reg);
            reg_id_t xmm_mask = find_available_spill_xmm_avoiding(dst_reg, xmm_bit_pattern, DR_REG_NULL);
            reg_id_t xmm_src_data = find_available_spill_xmm_avoiding(dst_reg, xmm_bit_pattern, xmm_mask);
            reg_id_t xmm_final_dst =
                find_available_spill_xmm_avoiding_variadic(4, dst_reg, xmm_bit_pattern, xmm_mask, xmm_src_data);

            /* opnd for scratch xmms */
            opnd_t xmm_dst_opnd = opnd_create_reg(xmm_dst);
            opnd_t xmm_bit_pattern_opnd = opnd_create_reg(xmm_bit_pattern);
            opnd_t xmm_mask_opnd = opnd_create_reg(xmm_mask);
            opnd_t xmm_src_data_opnd = opnd_create_reg(xmm_src_data);
            opnd_t xmm_final_dst_opnd = opnd_create_reg(xmm_final_dst);

            // push rax;
            instr_t *i1 = INSTR_CREATE_push(dcontext, scratch_opnd_gpr64);
            // push eflags;
            instr_t *i2 = INSTR_CREATE_pushf(dcontext);
            // tls_slot(mask_reg) -> scratch_reg32
            instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, scratch_reg_gpr32, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // test scratch_reg32, scratch_reg32
            instr_t *i4 = INSTR_CREATE_test(dcontext, scratch_opnd_gpr32, scratch_opnd_gpr32);
            // jz SKIP_LOAD
            instr_t *i5 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_LOAD));
            // cmpl 0x3, scratch_reg32 (for 64-bit elements, only 2 bits matter in XMM)
            instr_t *i6 =
                INSTR_CREATE_cmp(dcontext, opnd_create_reg(scratch_reg_gpr32), opnd_create_immed_int(0x3, OPSZ_4));
            // je FULL_LOAD
            instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_LOAD));

            // spill xmm_bit_pattern
            instr_t *i8 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_bit_pattern,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_bit_pattern)), OPSZ_16);
            // spill xmm_mask
            instr_t *i9 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_mask, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_mask)), OPSZ_16);
            // spill xmm_src_data
            instr_t *i10 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_src_data,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_src_data)), OPSZ_16);
            // spill xmm_final_dst
            instr_t *i11 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_final_dst,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_final_dst)), OPSZ_16);

            // sub rsp 16
            instr_t *i12 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_XMM, OPSZ_4));
            /* element-0 (bit 0) 0x0000000100000001 */
            instr_t *i13 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000100000001ULL, OPSZ_8));
            instr_t *i14 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8),
                                               scratch_opnd_gpr64);

            /* element-1 (bit 1) 0x0000000200000002 */
            instr_t *i15 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000200000002ULL, OPSZ_8));
            instr_t *i16 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8),
                                               scratch_opnd_gpr64);

            // vmovdqu (%rsp), %xmm_bit_pattern | bit pattern get the constant value
            instr_t *i17 = INSTR_CREATE_vmovdqu(dcontext, xmm_bit_pattern_opnd,
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_16));
            // vmovdqu <src_opnd>, %xmm_src_data | load source data from memory
            instr_t *i18 = INSTR_CREATE_vmovdqu(dcontext, xmm_src_data_opnd, src_opnd);
            // add rsp 16
            instr_t *i19 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_XMM, OPSZ_4));

            // tls_slot(mask_reg) -> scratch_reg32
            instr_t *i20 = RESTORE_FROM_SIZED_TLS(dcontext, scratch_reg_gpr32, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // vmovd scratch_reg32 -> xmm_mask
            instr_t *i21 = INSTR_CREATE_vmovd(dcontext, xmm_mask_opnd, scratch_opnd_gpr32);
            // vpbroadcastd xmm_mask -> xmm_mask (replicate mask to all 32-bit dwords)
            instr_t *i22 = INSTR_CREATE_vpbroadcastd(dcontext, xmm_mask_opnd, xmm_mask_opnd);
            // vpand xmm_bit_pattern & xmm_mask -> xmm_mask
            instr_t *i23 = INSTR_CREATE_vpand(dcontext, xmm_mask_opnd, xmm_mask_opnd, xmm_bit_pattern_opnd);
            // vpcmpeqq xmm_mask, xmm_bit_pattern -> xmm_mask (for 64-bit elements)
            instr_t *i24 = INSTR_CREATE_vpcmpeqq(dcontext, xmm_mask_opnd, xmm_mask_opnd, xmm_bit_pattern_opnd);
            // vpblendvb xmm_dst, xmm_src_data, xmm_mask -> xmm_final_dst
            instr_t *i25 =
                INSTR_CREATE_vpblendvb(dcontext, xmm_final_dst_opnd, xmm_dst_opnd, xmm_src_data_opnd, xmm_mask_opnd);
            // vmovdqu xmm_final_dst -> xmm_dst
            instr_t *i26 = INSTR_CREATE_vmovdqu(dcontext, xmm_dst_opnd, xmm_final_dst_opnd);
            // restore xmm_bit_pattern
            instr_t *i27 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_bit_pattern,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_bit_pattern)), OPSZ_16);
            // restore xmm_mask
            instr_t *i28 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_mask, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_mask)), OPSZ_16);
            // restore xmm_src_data
            instr_t *i29 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_src_data,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_src_data)), OPSZ_16);
            // restore xmm_final_dst
            instr_t *i30 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_final_dst,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_final_dst)), OPSZ_16);

            // jmp SKIP_LOAD
            instr_t *i31 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_LOAD));

            // FULL_LOAD:
            // vmovdqu src_opnd -> xmm_dst
            instr_t *i32 = INSTR_CREATE_vmovdqu(dcontext, xmm_dst_opnd, src_opnd);

            // SKIP_LOAD: (only a label)
            // pop eflags;
            instr_t *i33 = INSTR_CREATE_popf(dcontext);
            // pop rax;
            instr_t *i34 = INSTR_CREATE_pop(dcontext, scratch_opnd_gpr64);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 36, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                         FULL_LOAD, i32, SKIP_LOAD, i33, i34);
#endif
            instrlist_concat_next_instr(ilist, 36, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                        FULL_LOAD, i32, SKIP_LOAD, i33, i34);
            return i1;
        } break;
        case 1: { /* dst need spill */
            instr_t *SKIP_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *FULL_LOAD = INSTR_CREATE_label(dcontext);

            reg_id_t scratch_reg_gpr64 = scratch_reg;
            reg_id_t scratch_reg_gpr32 = GPR64_TO_GPR32(scratch_reg);
            opnd_t scratch_opnd_gpr64 = opnd_create_reg(scratch_reg_gpr64);
            opnd_t scratch_opnd_gpr32 = opnd_create_reg(scratch_reg_gpr32);

            reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
            reg_id_t xmm_bit_pattern = find_one_available_spill_xmm(spill_dst_reg);
            reg_id_t xmm_mask = find_available_spill_xmm_avoiding(spill_dst_reg, xmm_bit_pattern, DR_REG_NULL);
            reg_id_t xmm_src_data = find_available_spill_xmm_avoiding(spill_dst_reg, xmm_bit_pattern, xmm_mask);
            reg_id_t xmm_final_dst =
                find_available_spill_xmm_avoiding_variadic(4, spill_dst_reg, xmm_bit_pattern, xmm_mask, xmm_src_data);

            /* opnd for scratch xmms */
            opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
            opnd_t xmm_bit_pattern_opnd = opnd_create_reg(xmm_bit_pattern);
            opnd_t xmm_mask_opnd = opnd_create_reg(xmm_mask);
            opnd_t xmm_src_data_opnd = opnd_create_reg(xmm_src_data);
            opnd_t xmm_final_dst_opnd = opnd_create_reg(xmm_final_dst);

            // push rax;
            instr_t *i1 = INSTR_CREATE_push(dcontext, scratch_opnd_gpr64);
            // push eflags;
            instr_t *i2 = INSTR_CREATE_pushf(dcontext);
            // spill_dst_reg -> tls(spill_dst_reg)
            instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
            // tls(dst_reg) -> spill_dst_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls_slot(mask_reg) -> scratch_reg32
            instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, scratch_reg_gpr32, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // test scratch_reg32, scratch_reg32
            instr_t *i6 = INSTR_CREATE_test(dcontext, scratch_opnd_gpr32, scratch_opnd_gpr32);
            // jz SKIP_LOAD
            instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_LOAD));
            // cmpl 0x3, scratch_reg32 (for 64-bit elements, only 2 bits matter in XMM)
            instr_t *i8 =
                INSTR_CREATE_cmp(dcontext, opnd_create_reg(scratch_reg_gpr32), opnd_create_immed_int(0x3, OPSZ_4));
            // je FULL_LOAD
            instr_t *i9 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_LOAD));

            // spill xmm_bit_pattern, xmm_mask, xmm_src_data, xmm_final_dst
            instr_t *i10 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_bit_pattern,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_bit_pattern)), OPSZ_16);
            instr_t *i11 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_mask, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_mask)), OPSZ_16);
            instr_t *i12 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_src_data,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_src_data)), OPSZ_16);
            instr_t *i13 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_final_dst,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_final_dst)), OPSZ_16);

            // sub rsp 16
            instr_t *i14 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_XMM, OPSZ_4));
            /* element-0 (bit 0) 0x0000000100000001 */
            instr_t *i15 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000100000001ULL, OPSZ_8));
            instr_t *i16 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8),
                                               scratch_opnd_gpr64);
            /* element-1 (bit 1) 0x0000000200000002 */
            instr_t *i17 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000200000002ULL, OPSZ_8));
            instr_t *i18 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8),
                                               scratch_opnd_gpr64);
            // vmovdqu (%rsp), %xmm_bit_pattern | bit pattern get the constant value
            instr_t *i19 = INSTR_CREATE_vmovdqu(dcontext, xmm_bit_pattern_opnd,
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_16));
            // vmovdqu <src_opnd>, %xmm_src_data | load source data from memory
            instr_t *i20 = INSTR_CREATE_vmovdqu(dcontext, xmm_src_data_opnd, src_opnd);
            // add rsp 16
            instr_t *i21 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_XMM, OPSZ_4));

            // tls_slot(mask_reg) -> scratch_reg32
            instr_t *i22 = RESTORE_FROM_SIZED_TLS(dcontext, scratch_reg_gpr32, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // vmovd scratch_reg32 -> xmm_mask
            instr_t *i23 = INSTR_CREATE_vmovd(dcontext, xmm_mask_opnd, scratch_opnd_gpr32);
            // vpbroadcastd xmm_mask -> xmm_mask (replicate mask to all 32-bit dwords)
            instr_t *i24 = INSTR_CREATE_vpbroadcastd(dcontext, xmm_mask_opnd, xmm_mask_opnd);
            // vpand xmm_bit_pattern & xmm_mask -> xmm_mask
            instr_t *i25 = INSTR_CREATE_vpand(dcontext, xmm_mask_opnd, xmm_mask_opnd, xmm_bit_pattern_opnd);
            // vpcmpeqq xmm_mask, xmm_bit_pattern -> xmm_mask (for 64-bit elements)
            instr_t *i26 = INSTR_CREATE_vpcmpeqq(dcontext, xmm_mask_opnd, xmm_mask_opnd, xmm_bit_pattern_opnd);
            // vpblendvb spill_dst_reg, xmm_src_data, xmm_mask -> xmm_final_dst
            instr_t *i27 =
                INSTR_CREATE_vpblendvb(dcontext, xmm_final_dst_opnd, spill_dst_opnd, xmm_src_data_opnd, xmm_mask_opnd);
            // vmovdqu xmm_final_dst -> spill_dst_reg
            instr_t *i28 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd, xmm_final_dst_opnd);

            /* restore xmm_bit_pattern, xmm_mask, xmm_src_data, xmm_final_dst */
            instr_t *i29 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_bit_pattern,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_bit_pattern)), OPSZ_16);
            instr_t *i30 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_mask, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_mask)), OPSZ_16);
            instr_t *i31 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_src_data,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_src_data)), OPSZ_16);
            instr_t *i32 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_final_dst,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_final_dst)), OPSZ_16);

            // jmp SKIP_LOAD
            instr_t *i33 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_LOAD));

            // FULL_LOAD:
            // vmovdqu src_opnd -> spill_dst_reg
            instr_t *i34 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd, src_opnd);

            // SKIP_LOAD: (only a label)
            // spill_dst_reg -> tls(dst_reg)
            instr_t *i35 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_dst_reg) -> spill_dst_reg
            instr_t *i36 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
            // pop eflags;
            instr_t *i37 = INSTR_CREATE_popf(dcontext);
            // pop rax;
            instr_t *i38 = INSTR_CREATE_pop(dcontext, scratch_opnd_gpr64);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 40, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                         i32, i33, FULL_LOAD, i34, SKIP_LOAD, i35, i36, i37, i38);
#endif
            instrlist_concat_next_instr(ilist, 40, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                        i32, i33, FULL_LOAD, i34, SKIP_LOAD, i35, i36, i37, i38);
            return i1;
        } break;
        default: {
            REWRITE_ERROR(STD_OUTF, "vmovdqu64_xmm_disp2reg_gen not support pattern");
        }
        }
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu64_ymm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd, reg_id_t dst_reg,
                           reg_id_t mask_reg)
{
    // vmovdqu64 {%k1} 0xffffffb8(%rdx)[32byte] -> %ymm31

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    int k_idx = TO_K_REG_INDEX(mask_reg);

    if (k_idx == 0) { // mask don't work

        const uint dst_need_spill = NEED_SPILL_YMM(dst_reg) ? 1 : 0;

        switch (dst_need_spill) {
        case 0: { /* don't need spill */
            opnd_t dst_opnd = opnd_create_reg(dst_reg);
            instr_t *i1 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, src_opnd);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
            return i1;
        } break;
        case 1: { /* dst need spill */
            reg_id_t spill_dst_reg = YMM_SPILL_SLOT0;
            opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
            // spill_dst_reg -> tls(spill_dst_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
            // VEX.128.66.0F.WIG 6F /r VMOVDQU ymm1, ymm2/m256
            instr_t *i2 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd, src_opnd);
            // spill_dst_reg -> tls(dst_reg)
            instr_t *i3 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill_dst_reg) -> spill_dst_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
            instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
            return i1;
        } break;
        default: {
            REWRITE_ERROR(STD_OUTF, "vmovdqu_ymm_disp2reg_gen not support pattern");
        }
        }
    } else { // k1 ~ k7 mask work
        const uint dst_need_spill = NEED_SPILL_YMM(dst_reg) ? 1 : 0;

        reg_id_t base_reg = opnd_get_base(src_opnd);
        reg_id_t index_reg = opnd_get_index(src_opnd);
        reg_id_t scratch_reg = DR_REG_NULL;
        if (index_reg == DR_REG_NULL) {
            scratch_reg = find_one_available_spill_gpr_avoiding_variadic(1, base_reg);
        } else {
            scratch_reg = find_one_available_spill_gpr_avoiding_variadic(2, base_reg, index_reg);
        }

        switch (dst_need_spill) {
        case 0: { /* don't need spill */
            instr_t *SKIP_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *FULL_LOAD = INSTR_CREATE_label(dcontext);

            reg_id_t scratch_reg_gpr64 = scratch_reg;
            reg_id_t scratch_reg_gpr32 = GPR64_TO_GPR32(scratch_reg);
            opnd_t scratch_opnd_gpr64 = opnd_create_reg(scratch_reg_gpr64);
            opnd_t scratch_opnd_gpr32 = opnd_create_reg(scratch_reg_gpr32);

            reg_id_t ymm_dst = dst_reg;
            reg_id_t ymm_bit_pattern = find_one_available_spill_ymm(dst_reg);
            reg_id_t ymm_mask = find_available_spill_ymm_avoiding(dst_reg, ymm_bit_pattern, DR_REG_NULL);
            reg_id_t xmm_mask = ymm_mask - DR_REG_YMM0 + DR_REG_XMM0;
            reg_id_t ymm_src_data = find_available_spill_ymm_avoiding(dst_reg, ymm_bit_pattern, ymm_mask);
            reg_id_t ymm_final_dst =
                find_available_spill_ymm_avoiding_variadic(4, dst_reg, ymm_bit_pattern, ymm_mask, ymm_src_data);

            /* opnd for scratch ymms */
            opnd_t ymm_dst_opnd = opnd_create_reg(ymm_dst);
            opnd_t ymm_bit_pattern_opnd = opnd_create_reg(ymm_bit_pattern);
            opnd_t ymm_mask_opnd = opnd_create_reg(ymm_mask);
            opnd_t xmm_mask_opnd = opnd_create_reg(xmm_mask);
            opnd_t ymm_src_data_opnd = opnd_create_reg(ymm_src_data);
            opnd_t ymm_final_dst_opnd = opnd_create_reg(ymm_final_dst);

            // push rax;
            instr_t *i1 = INSTR_CREATE_push(dcontext, scratch_opnd_gpr64);
            // push eflags;
            instr_t *i2 = INSTR_CREATE_pushf(dcontext);
            // tls_slot(mask_reg) -> scratch_reg32
            instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, scratch_reg_gpr32, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // test scratch_reg32, scratch_reg32
            instr_t *i4 = INSTR_CREATE_test(dcontext, scratch_opnd_gpr32, scratch_opnd_gpr32);
            // jz SKIP_LOAD
            instr_t *i5 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_LOAD));
            // cmpl 0xf, scratch_reg32 (for 64-bit elements, only 4 bits matter in YMM)
            instr_t *i6 =
                INSTR_CREATE_cmp(dcontext, opnd_create_reg(scratch_reg_gpr32), opnd_create_immed_int(0xf, OPSZ_4));
            // je FULL_LOAD
            instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_LOAD));

            // spill ymm_bit_pattern
            instr_t *i8 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_bit_pattern,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_bit_pattern)), OPSZ_32);
            // spill ymm_mask
            instr_t *i9 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_mask, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);
            // spill ymm_src_data
            instr_t *i10 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_src_data,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_src_data)), OPSZ_32);
            // spill ymm_final_dst
            instr_t *i11 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_final_dst,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_final_dst)), OPSZ_32);

            // sub rsp 32
            instr_t *i12 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM, OPSZ_4));
            /* element-0 (bit 0) 0x0000000100000001 */
            instr_t *i13 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000100000001ULL, OPSZ_8));
            instr_t *i14 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8),
                                               scratch_opnd_gpr64);

            /* element-1 (bit 1) 0x0000000200000002 */
            instr_t *i15 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000200000002ULL, OPSZ_8));
            instr_t *i16 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8),
                                               scratch_opnd_gpr64);

            /* element-2 (bit 2) 0x0000000400000004 */
            instr_t *i17 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000400000004ULL, OPSZ_8));
            instr_t *i18 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8),
                                               scratch_opnd_gpr64);

            /* element-3 (bit 3) 0x0000000800000008 */
            instr_t *i19 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000800000008ULL, OPSZ_8));
            instr_t *i20 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8),
                                               scratch_opnd_gpr64);
            // vmovdqu (%rsp), %ymm_bit_pattern | bit pattern get the constant value
            instr_t *i21 = INSTR_CREATE_vmovdqu(dcontext, ymm_bit_pattern_opnd,
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));
            // vmovdqu <src_opnd>, %ymm_src_data | load source data from memory
            instr_t *i22 = INSTR_CREATE_vmovdqu(dcontext, ymm_src_data_opnd, src_opnd);
            // add rsp 32
            instr_t *i23 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM, OPSZ_4));

            // tls_slot(mask_reg) -> scratch_reg32
            instr_t *i24 = RESTORE_FROM_SIZED_TLS(dcontext, scratch_reg_gpr32, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // vmovd scratch_reg32 -> xmm_mask
            instr_t *i25 = INSTR_CREATE_vmovd(dcontext, xmm_mask_opnd, scratch_opnd_gpr32);
            // vpbroadcastd xmm_mask -> ymm_mask (replicate mask to all 32-bit dwords)
            instr_t *i26 = INSTR_CREATE_vpbroadcastd(dcontext, ymm_mask_opnd, xmm_mask_opnd);
            // vpand ymm_bit_pattern & ymm_mask -> ymm_mask
            instr_t *i27 = INSTR_CREATE_vpand(dcontext, ymm_mask_opnd, ymm_mask_opnd, ymm_bit_pattern_opnd);
            // vpcmpeqq ymm_mask, ymm_bit_pattern -> ymm_mask (for 64-bit elements)
            instr_t *i28 = INSTR_CREATE_vpcmpeqq(dcontext, ymm_mask_opnd, ymm_mask_opnd, ymm_bit_pattern_opnd);
            // vpblendvb ymm_dst, ymm_src_data, ymm_mask -> ymm_final_dst
            instr_t *i29 =
                INSTR_CREATE_vpblendvb(dcontext, ymm_final_dst_opnd, ymm_dst_opnd, ymm_src_data_opnd, ymm_mask_opnd);
            // vmovdqu ymm_final_dst -> ymm_dst
            instr_t *i30 = INSTR_CREATE_vmovdqu(dcontext, ymm_dst_opnd, ymm_final_dst_opnd);
            // restore ymm_bit_pattern
            instr_t *i31 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_bit_pattern,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_bit_pattern)), OPSZ_32);
            // restore ymm_mask
            instr_t *i32 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_mask, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);
            // restore ymm_src_data
            instr_t *i33 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_src_data,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_src_data)), OPSZ_32);
            // restore ymm_final_dst
            instr_t *i34 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_final_dst,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_final_dst)), OPSZ_32);

            // jmp SKIP_LOAD
            instr_t *i35 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_LOAD));

            // FULL_LOAD:
            // vmovdqu src_opnd -> ymm_dst
            instr_t *i36 = INSTR_CREATE_vmovdqu(dcontext, ymm_dst_opnd, src_opnd);

            // SKIP_LOAD: (only a label)
            // pop eflags;
            instr_t *i37 = INSTR_CREATE_popf(dcontext);
            // pop rax;
            instr_t *i38 = INSTR_CREATE_pop(dcontext, scratch_opnd_gpr64);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 40, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                         i32, i33, i34, i35, FULL_LOAD, i36, SKIP_LOAD, i37, i38);
#endif
            instrlist_concat_next_instr(ilist, 40, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                        i32, i33, i34, i35, FULL_LOAD, i36, SKIP_LOAD, i37, i38);
            return i1;
        } break;
        case 1: { /* dst need spill */
            instr_t *SKIP_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *FULL_LOAD = INSTR_CREATE_label(dcontext);

            reg_id_t scratch_reg_gpr64 = scratch_reg;
            reg_id_t scratch_reg_gpr32 = GPR64_TO_GPR32(scratch_reg);
            opnd_t scratch_opnd_gpr64 = opnd_create_reg(scratch_reg_gpr64);
            opnd_t scratch_opnd_gpr32 = opnd_create_reg(scratch_reg_gpr32);

            reg_id_t spill_dst_reg = YMM_SPILL_SLOT0;
            reg_id_t ymm_bit_pattern = find_one_available_spill_ymm(spill_dst_reg);
            reg_id_t ymm_mask = find_available_spill_ymm_avoiding(spill_dst_reg, ymm_bit_pattern, DR_REG_NULL);
            reg_id_t xmm_mask = ymm_mask - DR_REG_YMM0 + DR_REG_XMM0;
            reg_id_t ymm_src_data = find_available_spill_ymm_avoiding(spill_dst_reg, ymm_bit_pattern, ymm_mask);
            reg_id_t ymm_final_dst =
                find_available_spill_ymm_avoiding_variadic(4, spill_dst_reg, ymm_bit_pattern, ymm_mask, ymm_src_data);

            /* opnd for scratch ymms */
            opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
            opnd_t ymm_bit_pattern_opnd = opnd_create_reg(ymm_bit_pattern);
            opnd_t ymm_mask_opnd = opnd_create_reg(ymm_mask);
            opnd_t xmm_mask_opnd = opnd_create_reg(xmm_mask);
            opnd_t ymm_src_data_opnd = opnd_create_reg(ymm_src_data);
            opnd_t ymm_final_dst_opnd = opnd_create_reg(ymm_final_dst);

            // push rax;
            instr_t *i1 = INSTR_CREATE_push(dcontext, scratch_opnd_gpr64);
            // push eflags;
            instr_t *i2 = INSTR_CREATE_pushf(dcontext);
            // spill_dst_reg -> tls(spill_dst_reg)
            instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
            // tls(dst_reg) -> spill_dst_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls_slot(mask_reg) -> scratch_reg32
            instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, scratch_reg_gpr32, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // test scratch_reg32, scratch_reg32
            instr_t *i6 = INSTR_CREATE_test(dcontext, scratch_opnd_gpr32, scratch_opnd_gpr32);
            // jz SKIP_LOAD
            instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_LOAD));
            // cmpl 0xf, scratch_reg32 (for 64-bit elements, only 4 bits matter in YMM)
            instr_t *i8 =
                INSTR_CREATE_cmp(dcontext, opnd_create_reg(scratch_reg_gpr32), opnd_create_immed_int(0xf, OPSZ_4));
            // je FULL_LOAD
            instr_t *i9 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_LOAD));

            // spill ymm_bit_pattern, ymm_mask, ymm_init_dst, ymm_final_dst
            instr_t *i10 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_bit_pattern,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_bit_pattern)), OPSZ_32);
            instr_t *i11 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_mask, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);
            instr_t *i12 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_src_data,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_src_data)), OPSZ_32);
            instr_t *i13 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_final_dst,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_final_dst)), OPSZ_32);

            // sub rsp 32
            instr_t *i14 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM, OPSZ_4));
            // element-0: 0x0000000100000001
            instr_t *i15 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000100000001ULL, OPSZ_8));
            instr_t *i16 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8),
                                               scratch_opnd_gpr64);
            // element-1: 0x0000000200000002
            instr_t *i17 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000200000002ULL, OPSZ_8));
            instr_t *i18 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8),
                                               scratch_opnd_gpr64);
            // element-2: 0x0000000400000004
            instr_t *i19 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000400000004ULL, OPSZ_8));
            instr_t *i20 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8),
                                               scratch_opnd_gpr64);
            // element-3: 0x0000000800000008
            instr_t *i21 = INSTR_CREATE_mov_imm(dcontext, scratch_opnd_gpr64,
                                                opnd_create_immed_int(0x0000000800000008ULL, OPSZ_8));
            instr_t *i22 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8),
                                               scratch_opnd_gpr64);
            // vmovdqu (%rsp), %ymm_bit_pattern | bit pattern get the constant value
            instr_t *i23 = INSTR_CREATE_vmovdqu(dcontext, ymm_bit_pattern_opnd,
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));
            // vmovdqu <src_opnd>, %ymm_src_data | load source data from memory
            instr_t *i24 = INSTR_CREATE_vmovdqu(dcontext, ymm_src_data_opnd, src_opnd);
            // add rsp 32
            instr_t *i25 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM, OPSZ_4));

            // tls_slot(mask_reg) -> scratch_reg32
            instr_t *i26 = RESTORE_FROM_SIZED_TLS(dcontext, scratch_reg_gpr32, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // vmovd scratch_reg32 -> xmm_mask
            instr_t *i27 = INSTR_CREATE_vmovd(dcontext, xmm_mask_opnd, scratch_opnd_gpr32);
            // vpbroadcastd xmm_mask -> ymm_mask (replicate mask to all 32-bit dwords)
            instr_t *i28 = INSTR_CREATE_vpbroadcastd(dcontext, ymm_mask_opnd, xmm_mask_opnd);
            // vpand ymm_bit_pattern & ymm_mask -> ymm_mask
            instr_t *i29 = INSTR_CREATE_vpand(dcontext, ymm_mask_opnd, ymm_mask_opnd, ymm_bit_pattern_opnd);
            // vpcmpeqq ymm_mask, ymm_bit_pattern -> ymm_mask (for 64-bit elements)
            instr_t *i30 = INSTR_CREATE_vpcmpeqq(dcontext, ymm_mask_opnd, ymm_mask_opnd, ymm_bit_pattern_opnd);
            // vpblendvb spill_dst_reg, ymm_src_data, ymm_mask -> ymm_final_dst
            instr_t *i31 =
                INSTR_CREATE_vpblendvb(dcontext, ymm_final_dst_opnd, spill_dst_opnd, ymm_src_data_opnd, ymm_mask_opnd);
            // vmovdqu ymm_final_dst -> spill_dst_reg
            instr_t *i32 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd, ymm_final_dst_opnd);

            /* restore ymm_bit_pattern, ymm_mask, ymm_src_data, ymm_final_dst */
            instr_t *i33 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_bit_pattern,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_bit_pattern)), OPSZ_32);
            instr_t *i34 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_mask, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);
            instr_t *i35 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_src_data,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_src_data)), OPSZ_32);
            instr_t *i36 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_final_dst,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_final_dst)), OPSZ_32);

            // jmp SKIP_LOAD
            instr_t *i37 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_LOAD));

            // FULL_LOAD:
            // vmovdqu src_opnd -> spill_dst_reg
            instr_t *i38 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd, src_opnd);

            // SKIP_LOAD: (only a label)
            // spill_dst_reg -> tls(dst_reg)
            instr_t *i39 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill_dst_reg) -> spill_dst_reg
            instr_t *i40 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
            // pop eflags;
            instr_t *i41 = INSTR_CREATE_popf(dcontext);
            // pop rax;
            instr_t *i42 = INSTR_CREATE_pop(dcontext, scratch_opnd_gpr64);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 44, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                         i32, i33, i34, i35, i36, i37, FULL_LOAD, i38, SKIP_LOAD, i39, i40, i41, i42);
#endif
            instrlist_concat_next_instr(ilist, 44, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                        i32, i33, i34, i35, i36, i37, FULL_LOAD, i38, SKIP_LOAD, i39, i40, i41, i42);
            return i1;
        } break;
        default: {
            REWRITE_ERROR(STD_OUTF, "vmovdqu_ymm_disp2reg_gen not support pattern");
        }
        }
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu64_zmm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd, reg_id_t dst_reg,
                           reg_id_t mask_reg)
{
    // vmovdqa64 {%k0} 0x00000140(%rsp)[64byte] -> %zmm1
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    reg_id_t src_base_reg = opnd_get_base(src_opnd); // src_reg is now DR_REG_RSP
    reg_id_t src_index_reg = opnd_get_index(src_opnd);
    int scale = opnd_get_scale(src_opnd);
    int disp = opnd_get_disp(src_opnd);

    const uint dst_need_spill = NEED_SPILL_ZMM(dst_reg) ? 1 : 0;
    switch (dst_need_spill) {
    case 0: { /* no spill */
        reg_id_t dst_reg_lower = ZMM_TO_YMM(dst_reg);
        reg_id_t dst_reg_upper = find_one_available_spill_ymm(dst_reg_lower);

        opnd_t op_dst_reg_lower = opnd_create_reg(dst_reg_lower);
        opnd_t op_dst_reg_upper = opnd_create_reg(dst_reg_upper);

        // dst_reg_upper -> tls(dst_reg_upper)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);
        // vmodqu src_low -> dst_reg_lower
        instr_t *i2 = INSTR_CREATE_vmovdqu(dcontext, op_dst_reg_lower,
                                           opnd_create_base_disp(src_base_reg, src_index_reg, scale, disp, OPSZ_32));
        // vmodqu src_high -> dst_reg_upper
        instr_t *i3 = INSTR_CREATE_vmovdqu(
            dcontext, op_dst_reg_upper,
            opnd_create_base_disp(src_base_reg, src_index_reg, scale, disp + SIZE_OF_YMM, OPSZ_32));
        // dst_reg_lower -> tls(dst_lower)
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_32);
        // dst_reg_upper -> tls(dst_upper)
        instr_t *i5 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_32);
        // tls(dst_reg_upper) -> dst_reg_upper
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 6, i1, i2, i3, i4, i5, i6);
#endif
        instrlist_concat_next_instr(ilist, 6, i1, i2, i3, i4, i5, i6);
        return i1;
    } break;
    case 1: { /* dst need spill */
        reg_id_t spill_dst_reg = find_one_available_spill_ymm(DR_REG_NULL);
        reg_id_t spill_dst_reg_upper = find_one_available_spill_ymm(spill_dst_reg);

        opnd_t op_spill_dst_reg = opnd_create_reg(spill_dst_reg);
        opnd_t op_spill_dst_reg_upper = opnd_create_reg(spill_dst_reg_upper);

        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        // spill_dst_reg_upper -> tls(spill_dst_reg_upper)
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg_upper)), OPSZ_32);
        // vmovdqu src_low -> spill_dst_reg
        instr_t *i3 = INSTR_CREATE_vmovdqu(dcontext, op_spill_dst_reg,
                                           opnd_create_base_disp(src_base_reg, src_index_reg, scale, disp, OPSZ_32));
        // vmovdqu src_high -> spill_dst_reg_upper
        instr_t *i4 = INSTR_CREATE_vmovdqu(
            dcontext, op_spill_dst_reg_upper,
            opnd_create_base_disp(src_base_reg, src_index_reg, scale, disp + SIZE_OF_YMM, OPSZ_32));
        // spill_dst_reg -> tls(dst_lower)
        instr_t *i5 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_32);
        // spill_dst_reg_upper -> tls(dst_upper)
        instr_t *i6 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg_upper,
                                             TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_32);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        // tls(spill_dst_reg_upper) -> spill_dst_reg_upper
        instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg_upper,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg_upper)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
        instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
        return i1;
    } break;
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu64_xmm_reladdr2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint dst_need_spill = NEED_SPILL_XMM(dst_reg) ? 1 : 0;

    switch (dst_need_spill) {
    case 0: {
        instr_t *new_instr1 =
            instr_create_1dst_1src(dcontext, OP_vmovdqu, create_mapping_xmm_opnd(dcontext, dst_reg), src_opnd);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
        return new_instr1;
    } break;
    case 1: {
        reg_id_t spill_dst_reg = find_one_available_spill_xmm(dst_reg);
        opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *new_instr1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vmovdqu src_opnd -> spill_dst_reg
        instr_t *new_instr2 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd, src_opnd);
        // spill_dst_reg -> tls(dst_reg)
        instr_t *new_instr3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *new_instr4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                          TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, new_instr1, new_instr2, new_instr3, new_instr4);
#endif
        instrlist_concat_next_instr(ilist, 4, new_instr1, new_instr2, new_instr3, new_instr4);
        return new_instr1;
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vmovdqu64_xmm_reladdr2reg_gen not support");
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu64_ymm_reladdr2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
    instr_t *new_instr1 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, create_mapping_ymm_opnd(dcontext, dst_reg), src_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vmovdqu64_zmm_reladdr2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "vmovdqu_zmm_reladdr2reg_gen not support");
#endif
    return NULL_INSTR;
}

instr_t *
vmovdqu64_xmm_absaddr2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
    instr_t *new_instr1 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, create_mapping_xmm_opnd(dcontext, dst_reg), src_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vmovdqu64_ymm_absaddr2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
    instr_t *new_instr1 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, create_mapping_ymm_opnd(dcontext, dst_reg), src_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vmovdqu64_zmm_absaddr2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                              reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    reg_id_t dst_reg_lower = ZMM_TO_YMM(dst_reg);
    reg_id_t dst_reg_upper = find_one_available_spill_ymm(dst_reg_lower);

    opnd_t op_dst_reg_lower = opnd_create_reg(dst_reg_lower);
    opnd_t op_dst_reg_upper = opnd_create_reg(dst_reg_upper);

    // dst_reg_upper -> tls(dst_reg_upper)
    instr_t *i1 =
        SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);
    // vmovdqu src_opnd_lower -> dst_reg_lower
    instr_t *i2 = INSTR_CREATE_vmovdqu(dcontext, op_dst_reg_lower, src_opnd);
    // vmovdqu src_opnd_upper -> dst_reg_upper
    instr_t *i3 =
        INSTR_CREATE_vmovdqu(dcontext, op_dst_reg_upper,
                             opnd_create_abs_addr((void *)((char *)opnd_get_addr(src_opnd) + SIZE_OF_YMM), OPSZ_32));
    // dst_reg_lower -> tls(dst_reg)
    instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_lower, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)), OPSZ_32);
    // dst_reg_upper -> tls(dst_reg + SIZE_OF_YMM)
    instr_t *i5 = SAVE_SIMD_TO_SIZED_TLS(dcontext, dst_reg_upper,
                                         TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_reg)) + SIZE_OF_YMM, OPSZ_32);
    // tls(dst_reg_upper) -> dst_reg_upper
    instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg_upper,
                                              TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg_upper)), OPSZ_32);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 6, i1, i2, i3, i4, i5, i6);
#endif
    instrlist_concat_next_instr(ilist, 6, i1, i2, i3, i4, i5, i6);
    return i1;
}

/**
 * @brief 612 vmovdqu64 rewrite function
 */
instr_t *
rw_func_vmovdqu64(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t mask_opnd = instr_get_src(instr, 0);
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    opnd_t src_opnd = instr_get_src(instr, 1); // %{x,y,z}mm or disp(base, index, scale)[nbyte] or rel/abs addr
    opnd_t dst_opnd = instr_get_dst(instr, 0); // %{x,y,z}mm
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vmovdqu64", true, true, false, true);
#endif
    switch (src_opnd.kind) {
    case REG_kind: {
        reg_id_t src_reg = opnd_get_reg(src_opnd);
        switch (dst_opnd.kind) {
        case REG_kind: { // reg -> reg
            reg_id_t dst_reg = opnd_get_reg(dst_opnd);
            if (IS_ZMM_REG(dst_reg))
                return vmovdqu64_zmm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
            if (IS_YMM_REG(dst_reg))
                return vmovdqu64_ymm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
            if (IS_XMM_REG(dst_reg))
                return vmovdqu64_xmm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
        } break;
        case BASE_DISP_kind: { // reg -> disp
            if (IS_ZMM_REG(src_reg))
                return vmovdqu64_zmm_reg2disp_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
            if (IS_YMM_REG(src_reg))
                return vmovdqu64_ymm_reg2disp_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
            if (IS_XMM_REG(src_reg))
                return vmovdqu64_xmm_reg2disp_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
        } break;
        case REL_ADDR_kind: { // reg -> rel_addr
            if (IS_ZMM_REG(src_reg))
                return vmovdqu64_zmm_reg2reladdr_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
            if (IS_YMM_REG(src_reg))
                return vmovdqu64_ymm_reg2reladdr_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
            if (IS_XMM_REG(src_reg))
                return vmovdqu64_xmm_reg2reladdr_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
        } break;
        default: REWRITE_INFO(STD_OUTF, "vpmovdqu64 pattern not support");
        }
    } break;
    case BASE_DISP_kind: { // disp -> reg
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_ZMM_REG(dst_reg))
            return vmovdqu64_zmm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_YMM_REG(dst_reg))
            return vmovdqu64_ymm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_XMM_REG(dst_reg))
            return vmovdqu64_xmm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
    } break;
    case REL_ADDR_kind: { // rel_addr -> reg
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_ZMM_REG(dst_reg))
            return vmovdqu64_zmm_reladdr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_YMM_REG(dst_reg))
            return vmovdqu64_ymm_reladdr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_XMM_REG(dst_reg))
            return vmovdqu64_xmm_reladdr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
    } break;
    case ABS_ADDR_kind: { // abs_addr -> reg
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_ZMM_REG(dst_reg))
            return vmovdqu64_zmm_absaddr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_YMM_REG(dst_reg))
            return vmovdqu64_ymm_absaddr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_XMM_REG(dst_reg))
            return vmovdqu64_xmm_absaddr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
    } break;
    default: REWRITE_INFO(STD_OUTF, "vpmovdqu64 pattern not support");
    }
    return NULL_INSTR;
}

/**
 * @brief 609 vmovdqa64 rewrite function
 */
instr_t *
rw_func_vmovdqa64(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t mask_opnd = instr_get_src(instr, 0);
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    opnd_t src_opnd = instr_get_src(instr, 1); // %{x,y,z}mm or disp(base, index, scale)[nbyte]
    opnd_t dst_opnd = instr_get_dst(instr, 0); // %{x,y,z}mm
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vmovdqa64", true, true, false, true);
#endif
    switch (src_opnd.kind) {
    case REG_kind: {
        reg_id_t src_reg = opnd_get_reg(src_opnd);
        switch (dst_opnd.kind) {
        case REG_kind: { // reg -> reg
            reg_id_t dst_reg = opnd_get_reg(dst_opnd);
            if (IS_XMM_REG(dst_reg))
                return vmovdqu64_xmm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
            if (IS_YMM_REG(dst_reg))
                return vmovdqu64_ymm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
            if (IS_ZMM_REG(dst_reg))
                return vmovdqu64_zmm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
        } break;
        case BASE_DISP_kind: { // reg -> disp
            if (IS_XMM_REG(src_reg))
                return vmovdqu64_xmm_reg2disp_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
            if (IS_YMM_REG(src_reg))
                return vmovdqu64_ymm_reg2disp_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
            if (IS_ZMM_REG(src_reg))
                return vmovdqu64_zmm_reg2disp_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
        } break;
        case REL_ADDR_kind: { // reg -> rel_addr
            if (IS_XMM_REG(src_reg))
                return vmovdqu64_xmm_reg2reladdr_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
            if (IS_YMM_REG(src_reg))
                return vmovdqu64_ymm_reg2reladdr_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
            if (IS_ZMM_REG(src_reg))
                return vmovdqu64_zmm_reg2reladdr_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
        }
        default: print_file(STD_OUTF, "[WARN]: vpmovdqa64 pattern not support\n");
        }
    } break;
    case BASE_DISP_kind: { // disp -> reg
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_XMM_REG(dst_reg))
            return vmovdqu64_xmm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_YMM_REG(dst_reg))
            return vmovdqu64_ymm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_ZMM_REG(dst_reg))
            return vmovdqu64_zmm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
    } break;
    case REL_ADDR_kind: { // rel_addr -> reg
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_XMM_REG(dst_reg))
            return vmovdqu64_xmm_reladdr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_YMM_REG(dst_reg))
            return vmovdqu64_ymm_reladdr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_ZMM_REG(dst_reg))
            return vmovdqu64_zmm_reladdr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
    } break;
    case ABS_ADDR_kind: { // abs_addr -> reg
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_XMM_REG(dst_reg))
            return vmovdqu64_xmm_absaddr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_YMM_REG(dst_reg))
            return vmovdqu64_ymm_absaddr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_ZMM_REG(dst_reg))
            return vmovdqu64_zmm_absaddr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
    } break;
    default: REWRITE_INFO(STD_OUTF, "vpmovdqa64 pattern not support");
    }
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vmovdqu8
 * ============================================= */

instr_t *
vmovdqu8_xmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                         reg_id_t mask_reg)
{
    // vmovdqu8 {%k0} %xmm0, %xmm1
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src_need_spill = NEED_SPILL_XMM(src_reg) ? 1 : 0;
    const uint dst_need_spill = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src_need_spill | dst_need_spill;

    int k_idx = TO_K_REG_INDEX(mask_reg);

    if (k_idx == 0) { /* no mask, no spill */
        switch (need_spill_flag) {
        case 0: { /* no spill */
            opnd_t src_opnd = opnd_create_reg(src_reg);
            opnd_t dst_opnd = opnd_create_reg(dst_reg);
            instr_t *i1 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, src_opnd);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
            return i1;
        } break;
        case 1: { /* src need spill */
            // tls_slot(src_reg) -> dst_reg
            instr_t *i1 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
            return i1;
        } break;
        case 2: { /* dst need spill */
            // src_reg -> tls_slot(dst_reg)
            instr_t *i1 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, src_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
            instrlist_concat_next_instr(ilist, 1, i1);
            return i1;
        } break;
        case 3: { /* src and dst need spill */
            reg_id_t spill_tmp_reg = XMM_SPILL_SLOT0;
            // spill_tmp_reg -> tls_slot(spill_tmp_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_tmp_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_tmp_reg)), OPSZ_16);
            // tls_slot(src_reg) -> spill_tmp_reg
            instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_tmp_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_reg)), OPSZ_16);
            // spill_tmp_reg -> tls_slot(dst_reg)
            instr_t *i3 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_tmp_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls_slot(spill_tmp_reg) -> spill_tmp_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_tmp_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_tmp_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
            instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
            return i1;
        } break;
        default: {
            REWRITE_ERROR(STD_ERRF, "vmovdqu_xmm_reg2reg_gen not support pattern");
        }
            return NULL_INSTR;
        }
    } else { /* use k1~k7, need to rewrite the mask logic */
        switch (need_spill_flag) {
        case 0: { /* no spill */
            instr_t *SKIP_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *FULL_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *LOOP = INSTR_CREATE_label(dcontext);
            instr_t *LOOP_SKIP = INSTR_CREATE_label(dcontext);

            /* opnd for gprs */
            reg_id_t rax_reg = DR_REG_RAX;
            reg_id_t eax_reg = DR_REG_EAX;
            reg_id_t rcx_reg = DR_REG_RCX;
            reg_id_t ecx_reg = DR_REG_ECX;
            reg_id_t rdx_reg = DR_REG_RDX;
            reg_id_t edx_reg = DR_REG_EDX;
            reg_id_t dx_reg = DR_REG_DX;

            reg_id_t al_reg = DR_REG_AL;
            opnd_t rax_opnd = opnd_create_reg(rax_reg);
            opnd_t eax_opnd = opnd_create_reg(eax_reg);
            opnd_t rcx_opnd = opnd_create_reg(rcx_reg);
            opnd_t ecx_opnd = opnd_create_reg(ecx_reg);
            opnd_t rdx_opnd = opnd_create_reg(rdx_reg);
            opnd_t al_opnd = opnd_create_reg(al_reg);
            opnd_t edx_opnd = opnd_create_reg(edx_reg);
            opnd_t dx_opnd = opnd_create_reg(dx_reg);

            /* opnd for xmms */
            reg_id_t xmm_dst = dst_reg;
            reg_id_t xmm_src = src_reg;
            opnd_t xmm_dst_opnd = opnd_create_reg(xmm_dst);
            opnd_t xmm_src_opnd = opnd_create_reg(xmm_src);

            // push rax;
            instr_t *i1 = INSTR_CREATE_push(dcontext, rax_opnd);
            // push rcx;
            instr_t *i2 = INSTR_CREATE_push(dcontext, rcx_opnd);
            // push rdx;
            instr_t *i3 = INSTR_CREATE_push(dcontext, rdx_opnd);
            // push eflags;
            instr_t *i4 = INSTR_CREATE_pushf(dcontext);
            // tls_slot(mask_reg) -> dx
            instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_DX, TLS_K_idx_SLOT(k_idx), OPSZ_2);
            // test dx, dx
            instr_t *i6 = INSTR_CREATE_test(dcontext, dx_opnd, dx_opnd);
            // jz SKIP_LOAD
            instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_LOAD));
            // cmpl 0xFFFF, edx (for 8-bit elements, 16 bits matter in XMM)
            instr_t *i8 =
                INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EDX), opnd_create_immed_int(0xFFFF, OPSZ_4));
            // je FULL_LOAD
            instr_t *i9 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_LOAD));

            // sub rsp, 32
            instr_t *i10 = INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(32, OPSZ_4));
            // vmovdqu xmm_src -> 0x10(%rsp)
            instr_t *i11 = INSTR_CREATE_vmovdqu(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0x10, OPSZ_16), xmm_src_opnd);
            // vmovdqu xmm_dst -> (%rsp)
            instr_t *i12 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_16),
                                                xmm_dst_opnd);
            // xor rcx, rcx
            instr_t *i13 = INSTR_CREATE_xor(dcontext, rcx_opnd, rcx_opnd);

            /* LOOP */
            // movl %edx -> %eax
            instr_t *i14 = INSTR_CREATE_mov_st(dcontext, eax_opnd, edx_opnd);
            // bt %eax, %ecx (test bit %ecx in %eax)
            instr_t *i15 = INSTR_CREATE_bt(dcontext, eax_opnd, ecx_opnd);
            // jnc L_LOOP_SKIP
            instr_t *i16 = INSTR_CREATE_jcc(dcontext, OP_jnb_short, opnd_create_instr(LOOP_SKIP));

            // movb 0x10(%rsp, %rcx, 1) -> %al
            instr_t *i17 =
                INSTR_CREATE_mov_ld(dcontext, al_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 1, 0x10, OPSZ_1));
            // movb %al -> (%rsp, %rcx, 1)
            instr_t *i18 =
                INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 1, 0, OPSZ_1), al_opnd);

            // LOOP_SKIP
            // inc %rcx
            instr_t *i19 = INSTR_CREATE_inc(dcontext, rcx_opnd);
            // cmp %rcx, 0x10
            instr_t *i20 = INSTR_CREATE_cmp(dcontext, rcx_opnd, opnd_create_immed_int(0x10, OPSZ_4));
            // jl L_LOOP
            instr_t *i21 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP));
            // vmovdqu (%rsp),  %xmm_dst
            instr_t *i22 = INSTR_CREATE_vmovdqu(dcontext, xmm_dst_opnd,
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_16));
            // add rsp, 32
            instr_t *i23 = INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(32, OPSZ_4));

            // jmp SKIP_LOAD
            instr_t *i24 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_LOAD));

            // FULL_LOAD:
            // vmovdqu xmm_src -> xmm_dst
            instr_t *i25 = INSTR_CREATE_vmovdqu(dcontext, xmm_dst_opnd, xmm_src_opnd);

            // SKIP_LOAD: (only a label)
            // pop eflags;
            instr_t *i26 = INSTR_CREATE_popf(dcontext);
            // pop rdx;
            instr_t *i27 = INSTR_CREATE_pop(dcontext, rdx_opnd);
            // pop rcx;
            instr_t *i28 = INSTR_CREATE_pop(dcontext, rcx_opnd);
            // pop rax;
            instr_t *i29 = INSTR_CREATE_pop(dcontext, rax_opnd);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 33, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, LOOP,
                                         i14, i15, i16, i17, i18, LOOP_SKIP, i19, i20, i21, i22, i23, i24, FULL_LOAD,
                                         i25, SKIP_LOAD, i26, i27, i28, i29);
#endif
            instrlist_concat_next_instr(ilist, 33, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, LOOP, i14,
                                        i15, i16, i17, i18, LOOP_SKIP, i19, i20, i21, i22, i23, i24, FULL_LOAD, i25,
                                        SKIP_LOAD, i26, i27, i28, i29);
            return i1;
        } break;
        case 1: { /* src need spill */
            instr_t *SKIP_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *FULL_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *LOOP = INSTR_CREATE_label(dcontext);
            instr_t *LOOP_SKIP = INSTR_CREATE_label(dcontext);

            /* opnd for gprs */
            reg_id_t rax_reg = DR_REG_RAX;
            reg_id_t eax_reg = DR_REG_EAX;
            reg_id_t rcx_reg = DR_REG_RCX;
            reg_id_t ecx_reg = DR_REG_ECX;
            reg_id_t rdx_reg = DR_REG_RDX;
            reg_id_t edx_reg = DR_REG_EDX;
            reg_id_t dx_reg = DR_REG_DX;

            reg_id_t al_reg = DR_REG_AL;
            opnd_t rax_opnd = opnd_create_reg(rax_reg);
            opnd_t eax_opnd = opnd_create_reg(eax_reg);
            opnd_t rcx_opnd = opnd_create_reg(rcx_reg);
            opnd_t ecx_opnd = opnd_create_reg(ecx_reg);
            opnd_t rdx_opnd = opnd_create_reg(rdx_reg);
            opnd_t al_opnd = opnd_create_reg(al_reg);
            opnd_t edx_opnd = opnd_create_reg(edx_reg);
            opnd_t dx_opnd = opnd_create_reg(dx_reg);

            /* opnd for xmms */
            reg_id_t xmm_dst = dst_reg;
            reg_id_t xmm_src = src_reg;
            reg_id_t xmm_spill_src = find_one_available_spill_ymm(dst_reg);
            opnd_t xmm_dst_opnd = opnd_create_reg(xmm_dst);
            opnd_t xmm_spill_src_opnd = opnd_create_reg(xmm_spill_src);

            // push rax;
            instr_t *i1 = INSTR_CREATE_push(dcontext, rax_opnd);
            // push rcx;
            instr_t *i2 = INSTR_CREATE_push(dcontext, rcx_opnd);
            // push rdx;
            instr_t *i3 = INSTR_CREATE_push(dcontext, rdx_opnd);
            // push eflags;
            instr_t *i4 = INSTR_CREATE_pushf(dcontext);
            // tls_slot(mask_reg) -> dx
            instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_DX, TLS_K_idx_SLOT(k_idx), OPSZ_2);
            // test dx, dx
            instr_t *i6 = INSTR_CREATE_test(dcontext, dx_opnd, dx_opnd);
            // jz SKIP_LOAD
            instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_LOAD));
            // cmpl 0xFFFF, edx (for 8-bit elements, 16 bits matter in XMM)
            instr_t *i8 =
                INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EDX), opnd_create_immed_int(0xFFFF, OPSZ_4));
            // je FULL_LOAD
            instr_t *i9 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_LOAD));

            // sub rsp, 32
            instr_t *i10 = INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(32, OPSZ_4));
            // tls_slot(xmm_src) -> xmm_spill_src
            instr_t *i11 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill_src,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_src)), OPSZ_16);
            // vmovdqu xmm_spill_src -> 0x10(%rsp)
            instr_t *i12 = INSTR_CREATE_vmovdqu(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0x10, OPSZ_16), xmm_spill_src_opnd);
            // vmovdqu xmm_dst -> (%rsp)
            instr_t *i13 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_16),
                                                xmm_dst_opnd);
            // xor rcx, rcx
            instr_t *i14 = INSTR_CREATE_xor(dcontext, rcx_opnd, rcx_opnd);

            /* LOOP */
            // movl %edx -> %eax
            instr_t *i15 = INSTR_CREATE_mov_st(dcontext, eax_opnd, edx_opnd);
            // bt %eax, %ecx (test bit %ecx in %eax)
            instr_t *i16 = INSTR_CREATE_bt(dcontext, eax_opnd, ecx_opnd);
            // jnc L_LOOP_SKIP
            instr_t *i17 = INSTR_CREATE_jcc(dcontext, OP_jnb_short, opnd_create_instr(LOOP_SKIP));

            // movb 0x10(%rsp, %rcx, 1) -> %al
            instr_t *i18 =
                INSTR_CREATE_mov_ld(dcontext, al_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 1, 0x10, OPSZ_1));
            // movb %al -> (%rsp, %rcx, 1)
            instr_t *i19 =
                INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 1, 0, OPSZ_1), al_opnd);

            // LOOP_SKIP
            // inc %rcx
            instr_t *i20 = INSTR_CREATE_inc(dcontext, rcx_opnd);
            // cmp %rcx, 0x10
            instr_t *i21 = INSTR_CREATE_cmp(dcontext, rcx_opnd, opnd_create_immed_int(0x10, OPSZ_4));
            // jl L_LOOP
            instr_t *i22 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP));
            // vmovdqu (%rsp),  %xmm_dst
            instr_t *i23 = INSTR_CREATE_vmovdqu(dcontext, xmm_dst_opnd,
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_16));
            // add rsp, 32
            instr_t *i24 = INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(32, OPSZ_4));

            // jmp SKIP_LOAD
            instr_t *i25 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_LOAD));

            // FULL_LOAD:
            // vmovdqu xmm_src -> xmm_dst
            instr_t *i26 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_dst, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_src)), OPSZ_16);

            // SKIP_LOAD: (only a label)
            // pop eflags;
            instr_t *i27 = INSTR_CREATE_popf(dcontext);
            // pop rdx;
            instr_t *i28 = INSTR_CREATE_pop(dcontext, rdx_opnd);
            // pop rcx;
            instr_t *i29 = INSTR_CREATE_pop(dcontext, rcx_opnd);
            // pop rax;
            instr_t *i30 = INSTR_CREATE_pop(dcontext, rax_opnd);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 34, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14,
                                         LOOP, i15, i16, i17, i18, i19, LOOP_SKIP, i20, i21, i22, i23, i24, i25,
                                         FULL_LOAD, i26, SKIP_LOAD, i27, i28, i29, i30);
#endif
            instrlist_concat_next_instr(ilist, 34, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, LOOP,
                                        i15, i16, i17, i18, i19, LOOP_SKIP, i20, i21, i22, i23, i24, i25, FULL_LOAD,
                                        i26, SKIP_LOAD, i27, i28, i29, i30);
            return i1;
        } break;
        case 2: { /* dst need spill */
            instr_t *SKIP_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *FULL_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *LOOP = INSTR_CREATE_label(dcontext);
            instr_t *LOOP_SKIP = INSTR_CREATE_label(dcontext);

            /* opnd for gprs */
            reg_id_t rax_reg = DR_REG_RAX;
            reg_id_t eax_reg = DR_REG_EAX;
            reg_id_t rcx_reg = DR_REG_RCX;
            reg_id_t ecx_reg = DR_REG_ECX;
            reg_id_t rdx_reg = DR_REG_RDX;
            reg_id_t edx_reg = DR_REG_EDX;
            reg_id_t dx_reg = DR_REG_DX;

            reg_id_t al_reg = DR_REG_AL;
            opnd_t rax_opnd = opnd_create_reg(rax_reg);
            opnd_t eax_opnd = opnd_create_reg(eax_reg);
            opnd_t rcx_opnd = opnd_create_reg(rcx_reg);
            opnd_t ecx_opnd = opnd_create_reg(ecx_reg);
            opnd_t rdx_opnd = opnd_create_reg(rdx_reg);
            opnd_t al_opnd = opnd_create_reg(al_reg);
            opnd_t edx_opnd = opnd_create_reg(edx_reg);
            opnd_t dx_opnd = opnd_create_reg(dx_reg);

            /* opnd for xmms */
            reg_id_t xmm_dst = dst_reg;
            reg_id_t xmm_src = src_reg;
            reg_id_t xmm_spill_dst = find_one_available_spill_ymm(src_reg);
            opnd_t xmm_spill_dst_opnd = opnd_create_reg(xmm_spill_dst);
            opnd_t xmm_src_opnd = opnd_create_reg(xmm_src);

            // push rax;
            instr_t *i1 = INSTR_CREATE_push(dcontext, rax_opnd);
            // push rcx;
            instr_t *i2 = INSTR_CREATE_push(dcontext, rcx_opnd);
            // push rdx;
            instr_t *i3 = INSTR_CREATE_push(dcontext, rdx_opnd);
            // push eflags;
            instr_t *i4 = INSTR_CREATE_pushf(dcontext);
            // tls_slot(mask_reg) -> dx
            instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_DX, TLS_K_idx_SLOT(k_idx), OPSZ_2);
            // test dx, dx
            instr_t *i6 = INSTR_CREATE_test(dcontext, dx_opnd, dx_opnd);
            // jz SKIP_LOAD
            instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_LOAD));
            // cmpl 0xFFFF, edx (for 8-bit elements, 16 bits matter in XMM)
            instr_t *i8 =
                INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EDX), opnd_create_immed_int(0xFFFF, OPSZ_4));
            // je FULL_LOAD
            instr_t *i9 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_LOAD));

            // sub rsp, 32
            instr_t *i10 = INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(32, OPSZ_4));
            // vmovdqu xmm_src -> 0x10(%rsp)
            instr_t *i11 = INSTR_CREATE_vmovdqu(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0x10, OPSZ_16), xmm_src_opnd);
            // xmm_spill_dst -> tls_slot(xmm_spill_dst)
            instr_t *i12 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_spill_dst,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill_dst)), OPSZ_16);
            // tls_slot(xmm_dst) -> xmm_spill_dst
            instr_t *i13 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill_dst,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_dst)), OPSZ_16);
            // vmovdqu xmm_spill_dst -> (%rsp)
            instr_t *i14 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_16),
                                                xmm_spill_dst_opnd);
            // xor rcx, rcx
            instr_t *i15 = INSTR_CREATE_xor(dcontext, rcx_opnd, rcx_opnd);

            /* LOOP */
            // movl %edx -> %eax
            instr_t *i16 = INSTR_CREATE_mov_st(dcontext, eax_opnd, edx_opnd);
            // bt %eax, %ecx (test bit %ecx in %eax)
            instr_t *i17 = INSTR_CREATE_bt(dcontext, eax_opnd, ecx_opnd);
            // jnc L_LOOP_SKIP
            instr_t *i18 = INSTR_CREATE_jcc(dcontext, OP_jnb_short, opnd_create_instr(LOOP_SKIP));

            // movb 0x10(%rsp, %rcx, 1) -> %al
            instr_t *i19 =
                INSTR_CREATE_mov_ld(dcontext, al_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 1, 0x10, OPSZ_1));
            // movb %al -> (%rsp, %rcx, 1)
            instr_t *i20 =
                INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 1, 0, OPSZ_1), al_opnd);

            // LOOP_SKIP
            // inc %rcx
            instr_t *i21 = INSTR_CREATE_inc(dcontext, rcx_opnd);
            // cmp %rcx, 0x10
            instr_t *i22 = INSTR_CREATE_cmp(dcontext, rcx_opnd, opnd_create_immed_int(0x10, OPSZ_4));
            // jl L_LOOP
            instr_t *i23 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP));
            // vmovdqu (%rsp),  %xmm_spill_dst
            instr_t *i24 = INSTR_CREATE_vmovdqu(dcontext, xmm_spill_dst_opnd,
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_16));
            // %xmm_spill_dst -> xmm_dst
            instr_t *i25 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_spill_dst, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_dst)), OPSZ_16);
            // tls_slot(xmm_spill_slot) -> xmm_spill_dst
            instr_t *i26 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill_dst,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill_dst)), OPSZ_16);
            // add rsp, 32
            instr_t *i27 = INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(32, OPSZ_4));

            // jmp SKIP_LOAD
            instr_t *i28 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_LOAD));

            // FULL_LOAD:
            // vmovdqu xmm_src -> xmm_dst
            instr_t *i29 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_dst, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_src)), OPSZ_16);

            // SKIP_LOAD: (only a label)
            // pop eflags;
            instr_t *i30 = INSTR_CREATE_popf(dcontext);
            // pop rdx;
            instr_t *i31 = INSTR_CREATE_pop(dcontext, rdx_opnd);
            // pop rcx;
            instr_t *i32 = INSTR_CREATE_pop(dcontext, rcx_opnd);
            // pop rax;
            instr_t *i33 = INSTR_CREATE_pop(dcontext, rax_opnd);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 37, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         LOOP, i16, i17, i18, i19, i20, LOOP_SKIP, i21, i22, i23, i24, i25, i26, i27,
                                         i28, FULL_LOAD, i29, SKIP_LOAD, i30, i31, i32, i33);
#endif
            instrlist_concat_next_instr(ilist, 37, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        LOOP, i16, i17, i18, i19, i20, LOOP_SKIP, i21, i22, i23, i24, i25, i26, i27,
                                        i28, FULL_LOAD, i29, SKIP_LOAD, i30, i31, i32, i33);
            return i1;
        } break;
        case 3: { /* src and dst need spill */
            instr_t *SKIP_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *FULL_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *LOOP = INSTR_CREATE_label(dcontext);
            instr_t *LOOP_SKIP = INSTR_CREATE_label(dcontext);

            /* opnd for gprs */
            reg_id_t rax_reg = DR_REG_RAX;
            reg_id_t eax_reg = DR_REG_EAX;
            reg_id_t rcx_reg = DR_REG_RCX;
            reg_id_t ecx_reg = DR_REG_ECX;
            reg_id_t rdx_reg = DR_REG_RDX;
            reg_id_t edx_reg = DR_REG_EDX;
            reg_id_t dx_reg = DR_REG_DX;

            reg_id_t al_reg = DR_REG_AL;
            opnd_t rax_opnd = opnd_create_reg(rax_reg);
            opnd_t eax_opnd = opnd_create_reg(eax_reg);
            opnd_t rcx_opnd = opnd_create_reg(rcx_reg);
            opnd_t ecx_opnd = opnd_create_reg(ecx_reg);
            opnd_t rdx_opnd = opnd_create_reg(rdx_reg);
            opnd_t al_opnd = opnd_create_reg(al_reg);
            opnd_t edx_opnd = opnd_create_reg(edx_reg);
            opnd_t dx_opnd = opnd_create_reg(dx_reg);

            /* opnd for xmms */
            reg_id_t xmm_dst = dst_reg;
            reg_id_t xmm_src = src_reg;
            reg_id_t xmm_spill_dst = XMM_SPILL_SLOT0;
            reg_id_t xmm_spill_src = XMM_SPILL_SLOT1;
            opnd_t xmm_spill_dst_opnd = opnd_create_reg(xmm_spill_dst);
            opnd_t xmm_spill_src_opnd = opnd_create_reg(xmm_spill_src);

            // push rax;
            instr_t *i1 = INSTR_CREATE_push(dcontext, rax_opnd);
            // push rcx;
            instr_t *i2 = INSTR_CREATE_push(dcontext, rcx_opnd);
            // push rdx;
            instr_t *i3 = INSTR_CREATE_push(dcontext, rdx_opnd);
            // push eflags;
            instr_t *i4 = INSTR_CREATE_pushf(dcontext);
            // tls_slot(mask_reg) -> dx
            instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_DX, TLS_K_idx_SLOT(k_idx), OPSZ_2);
            // test dx, dx
            instr_t *i6 = INSTR_CREATE_test(dcontext, dx_opnd, dx_opnd);
            // jz SKIP_LOAD
            instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_LOAD));
            // cmpl 0xFFFF, edx (for 8-bit elements, 16 bits matter in XMM)
            instr_t *i8 =
                INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EDX), opnd_create_immed_int(0xFFFF, OPSZ_4));
            // je FULL_LOAD
            instr_t *i9 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_LOAD));

            // sub rsp, 32
            instr_t *i10 = INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(32, OPSZ_4));

            // xmm_spill_src -> tls_slot(xmm_spill_src)
            instr_t *i11 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_spill_src,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill_src)), SIZE_OF_XMM);
            // xmm_spill_dst -> tls_slot(xmm_spill_dst)
            instr_t *i12 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_spill_dst,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill_dst)), SIZE_OF_XMM);
            // tls_slot(xmm_src) -> xmm_spill_src
            instr_t *i13 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill_src,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_src)), SIZE_OF_XMM);
            // tls_slot(xmm_dst) -> xmm_spill_dst
            instr_t *i14 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill_dst,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_dst)), SIZE_OF_XMM);
            // vmovdqu xmm_spill_src -> 0x10(%rsp)
            instr_t *i15 = INSTR_CREATE_vmovdqu(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0x10, OPSZ_16), xmm_spill_src_opnd);
            // vmovdqu xmm_spill_dst -> (%rsp)
            instr_t *i16 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_16),
                                                xmm_spill_dst_opnd);
            // xor rcx, rcx
            instr_t *i17 = INSTR_CREATE_xor(dcontext, rcx_opnd, rcx_opnd);

            /* LOOP */
            // movl %edx -> %eax
            instr_t *i18 = INSTR_CREATE_mov_st(dcontext, eax_opnd, edx_opnd);
            // bt %eax, %ecx (test bit %ecx in %eax)
            instr_t *i19 = INSTR_CREATE_bt(dcontext, eax_opnd, ecx_opnd);
            // jnc L_LOOP_SKIP
            instr_t *i20 = INSTR_CREATE_jcc(dcontext, OP_jnb_short, opnd_create_instr(LOOP_SKIP));

            // movb 0x10(%rsp, %rcx, 1) -> %al
            instr_t *i21 =
                INSTR_CREATE_mov_ld(dcontext, al_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 1, 0x10, OPSZ_1));
            // movb %al -> (%rsp, %rcx, 1)
            instr_t *i22 =
                INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 1, 0, OPSZ_1), al_opnd);

            // LOOP_SKIP
            // inc %rcx
            instr_t *i23 = INSTR_CREATE_inc(dcontext, rcx_opnd);
            // cmp %rcx, 0x10
            instr_t *i24 = INSTR_CREATE_cmp(dcontext, rcx_opnd, opnd_create_immed_int(0x10, OPSZ_4));
            // jl L_LOOP
            instr_t *i25 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP));
            // vmovdqu (%rsp),  %xmm_spill_dst
            instr_t *i26 = INSTR_CREATE_vmovdqu(dcontext, xmm_spill_dst_opnd,
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_16));
            // xmm_spill_dst -> tls_slot(xmm_dst)
            instr_t *i27 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_spill_dst, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_dst)),
                                                  SIZE_OF_XMM);
            // tls_slot(xmm_spill_src) -> xmm_spill_src
            instr_t *i28 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill_src,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill_src)), SIZE_OF_XMM);
            // tls_slot(xmm_spill_dst) -> xmm_spill_dst
            instr_t *i29 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill_dst,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill_dst)), SIZE_OF_XMM);

            // add rsp, 32
            instr_t *i30 = INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(32, OPSZ_4));

            // jmp SKIP_LOAD
            instr_t *i31 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_LOAD));

            // FULL_LOAD:
            // spill_xmm_src -> tls_slot(xmm_spill_src)
            instr_t *i32 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_spill_src,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill_src)), SIZE_OF_XMM);
            // tls_slot(xmm_src) -> spill_xmm_src
            instr_t *i33 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill_src,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_src)), SIZE_OF_XMM);
            // spill_xmm_src -> tls_slot(xmm_dst)
            instr_t *i34 = SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_spill_src, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_dst)),
                                                  SIZE_OF_XMM);
            // tls_slot(xmm_spill_src) -> xmm_spill_src
            instr_t *i35 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill_src,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill_src)), SIZE_OF_XMM);

            // SKIP_LOAD: (only a label)
            // pop eflags;
            instr_t *i36 = INSTR_CREATE_popf(dcontext);
            // pop rdx;
            instr_t *i37 = INSTR_CREATE_pop(dcontext, rdx_opnd);
            // pop rcx;
            instr_t *i38 = INSTR_CREATE_pop(dcontext, rcx_opnd);
            // pop rax;
            instr_t *i39 = INSTR_CREATE_pop(dcontext, rax_opnd);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 43, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         i16, i17, LOOP, i18, i19, i20, i21, i22, LOOP_SKIP, i23, i24, i25, i26, i27,
                                         i28, i29, i30, i31, FULL_LOAD, i32, i33, i34, i35, SKIP_LOAD, i36, i37, i38,
                                         i39);
#endif
            instrlist_concat_next_instr(ilist, 43, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, LOOP, i18, i19, i20, i21, i22, LOOP_SKIP, i23, i24, i25, i26, i27,
                                        i28, i29, i30, i31, FULL_LOAD, i32, i33, i34, i35, SKIP_LOAD, i36, i37, i38,
                                        i39);
            return i1;
        } break;
        default: {
            REWRITE_ERROR(STD_ERRF, "vmovdqu_xmm_reg2reg_gen not support pattern");
        }
            return NULL_INSTR;
        }
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu8_ymm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                         reg_id_t mask_reg)
{
    // vmovdqu8 {%k0} %ymm0, %ymm1
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src_need_spill = NEED_SPILL_YMM(src_reg) ? 1 : 0;
    const uint dst_need_spill = NEED_SPILL_YMM(dst_reg) ? 2 : 0;
    const uint need_spill_flag = src_need_spill | dst_need_spill;

    int k_idx = TO_K_REG_INDEX(mask_reg);

    if (k_idx == 0) { // no mask, no spill
        switch (need_spill_flag) {
        case 0: { /* no spill */
            opnd_t src_opnd = opnd_create_reg(src_reg);
            opnd_t dst_opnd = opnd_create_reg(dst_reg);
            instr_t *new_instr1 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, src_opnd);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
            return new_instr1;
        } break;
        case 1: { /* src need spill */
            // tls_slot(src_reg) -> dst_reg
            instr_t *i1 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
            return i1;
        } break;
        case 2: { /* dst need spill */
            // src_reg -> tls_slot(dst_reg)
            instr_t *i1 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, src_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
            instrlist_concat_next_instr(ilist, 1, i1);
            return i1;
        } break;
        case 3: { /* src and dst need spill */
            reg_id_t spill_tmp_reg = YMM_SPILL_SLOT0;
            // spill_tmp_reg -> tls_slot(spill_tmp_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_tmp_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_tmp_reg)), OPSZ_32);
            // tls_slot(src_reg) -> spill_tmp_reg
            instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_tmp_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg)), OPSZ_32);
            // spill_tmp_reg -> tls_slot(dst_reg)
            instr_t *i3 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_tmp_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls_slot(spill_tmp_reg) -> spill_tmp_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_tmp_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_tmp_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
            instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
            return i1;
        } break;
        default: {
            REWRITE_ERROR(STD_ERRF, "vmovdqu_ymm_reg2reg_gen not support pattern");
        }
            return NULL_INSTR;
        }
    } else { // use k1~k7, need to rewrite the mask logic
        switch (need_spill_flag) {
        case 0: { /* no spill */
            instr_t *SKIP_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *FULL_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *LOOP = INSTR_CREATE_label(dcontext);
            instr_t *LOOP_SKIP = INSTR_CREATE_label(dcontext);

            /* opnd for gprs */
            reg_id_t rax_reg = DR_REG_RAX;
            reg_id_t eax_reg = DR_REG_EAX;
            reg_id_t rcx_reg = DR_REG_RCX;
            reg_id_t ecx_reg = DR_REG_ECX;
            reg_id_t rdx_reg = DR_REG_RDX;
            reg_id_t edx_reg = DR_REG_EDX;
            reg_id_t dx_reg = DR_REG_DX;

            reg_id_t al_reg = DR_REG_AL;
            opnd_t rax_opnd = opnd_create_reg(rax_reg);
            opnd_t eax_opnd = opnd_create_reg(eax_reg);
            opnd_t rcx_opnd = opnd_create_reg(rcx_reg);
            opnd_t ecx_opnd = opnd_create_reg(ecx_reg);
            opnd_t rdx_opnd = opnd_create_reg(rdx_reg);
            opnd_t al_opnd = opnd_create_reg(al_reg);
            opnd_t edx_opnd = opnd_create_reg(edx_reg);
            opnd_t dx_opnd = opnd_create_reg(dx_reg);

            /* opnd for ymms */
            reg_id_t ymm_dst = dst_reg;
            reg_id_t ymm_src = src_reg;
            opnd_t ymm_dst_opnd = opnd_create_reg(ymm_dst);
            opnd_t ymm_src_opnd = opnd_create_reg(ymm_src);

            // push rax;
            instr_t *i1 = INSTR_CREATE_push(dcontext, rax_opnd);
            // push rcx;
            instr_t *i2 = INSTR_CREATE_push(dcontext, rcx_opnd);
            // push rdx;
            instr_t *i3 = INSTR_CREATE_push(dcontext, rdx_opnd);
            // push eflags;
            instr_t *i4 = INSTR_CREATE_pushf(dcontext);
            // tls_slot(mask_reg) -> edx
            instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EDX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // test dx, dx
            instr_t *i6 = INSTR_CREATE_test(dcontext, dx_opnd, dx_opnd);
            // jz SKIP_LOAD
            instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_LOAD));
            // cmpl -1, edx (for 8-bit elements, 32 bits matter in YMM)
            instr_t *i8 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EDX), opnd_create_immed_int(-1, OPSZ_4));
            // je FULL_LOAD
            instr_t *i9 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_LOAD));

            // sub rsp, 64
            instr_t *i10 = INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(64, OPSZ_4));
            // vmovdqu ymm_src -> 0x20(%rsp)
            instr_t *i11 = INSTR_CREATE_vmovdqu(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0x20, OPSZ_32), ymm_src_opnd);
            // vmovdqu ymm_dst -> (%rsp)
            instr_t *i12 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32),
                                                ymm_dst_opnd);
            // xor rcx, rcx
            instr_t *i13 = INSTR_CREATE_xor(dcontext, rcx_opnd, rcx_opnd);

            /* LOOP */
            // movl %edx -> %eax
            instr_t *i14 = INSTR_CREATE_mov_st(dcontext, eax_opnd, edx_opnd);
            // bt %eax, %ecx (test bit %ecx in %eax)
            instr_t *i15 = INSTR_CREATE_bt(dcontext, eax_opnd, ecx_opnd);
            // jnc L_LOOP_SKIP
            instr_t *i16 = INSTR_CREATE_jcc(dcontext, OP_jnb_short, opnd_create_instr(LOOP_SKIP));

            // movb 0x20(%rsp, %rcx, 1) -> %al
            instr_t *i17 =
                INSTR_CREATE_mov_ld(dcontext, al_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 1, 0x20, OPSZ_1));
            // movb %al -> (%rsp, %rcx, 1)
            instr_t *i18 =
                INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 1, 0, OPSZ_1), al_opnd);

            // LOOP_SKIP
            // inc %rcx
            instr_t *i19 = INSTR_CREATE_inc(dcontext, rcx_opnd);
            // cmp %rcx, 0x20
            instr_t *i20 = INSTR_CREATE_cmp(dcontext, rcx_opnd, opnd_create_immed_int(0x20, OPSZ_4));
            // jl L_LOOP
            instr_t *i21 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP));
            // vmovdqu (%rsp),  %ymm_dst
            instr_t *i22 = INSTR_CREATE_vmovdqu(dcontext, ymm_dst_opnd,
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));
            // add rsp, 64
            instr_t *i23 = INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(64, OPSZ_4));

            // jmp SKIP_LOAD
            instr_t *i24 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_LOAD));

            // FULL_LOAD:
            // vmovdqu ymm_src -> ymm_dst
            instr_t *i25 = INSTR_CREATE_vmovdqu(dcontext, ymm_dst_opnd, ymm_src_opnd);

            // SKIP_LOAD: (only a label)
            // pop eflags;
            instr_t *i26 = INSTR_CREATE_popf(dcontext);
            // pop rdx;
            instr_t *i27 = INSTR_CREATE_pop(dcontext, rdx_opnd);
            // pop rcx;
            instr_t *i28 = INSTR_CREATE_pop(dcontext, rcx_opnd);
            // pop rax;
            instr_t *i29 = INSTR_CREATE_pop(dcontext, rax_opnd);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 33, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, LOOP,
                                         i14, i15, i16, i17, i18, LOOP_SKIP, i19, i20, i21, i22, i23, i24, FULL_LOAD,
                                         i25, SKIP_LOAD, i26, i27, i28, i29);
#endif
            instrlist_concat_next_instr(ilist, 33, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, LOOP, i14,
                                        i15, i16, i17, i18, LOOP_SKIP, i19, i20, i21, i22, i23, i24, FULL_LOAD, i25,
                                        SKIP_LOAD, i26, i27, i28, i29);
            return i1;
        } break;
        case 1: { /* src need spill */
            instr_t *SKIP_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *FULL_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *LOOP = INSTR_CREATE_label(dcontext);
            instr_t *LOOP_SKIP = INSTR_CREATE_label(dcontext);

            /* opnd for gprs */
            reg_id_t rax_reg = DR_REG_RAX;
            reg_id_t eax_reg = DR_REG_EAX;
            reg_id_t rcx_reg = DR_REG_RCX;
            reg_id_t ecx_reg = DR_REG_ECX;
            reg_id_t rdx_reg = DR_REG_RDX;
            reg_id_t edx_reg = DR_REG_EDX;
            reg_id_t dx_reg = DR_REG_DX;

            reg_id_t al_reg = DR_REG_AL;
            opnd_t rax_opnd = opnd_create_reg(rax_reg);
            opnd_t eax_opnd = opnd_create_reg(eax_reg);
            opnd_t rcx_opnd = opnd_create_reg(rcx_reg);
            opnd_t ecx_opnd = opnd_create_reg(ecx_reg);
            opnd_t rdx_opnd = opnd_create_reg(rdx_reg);
            opnd_t al_opnd = opnd_create_reg(al_reg);
            opnd_t edx_opnd = opnd_create_reg(edx_reg);
            opnd_t dx_opnd = opnd_create_reg(dx_reg);

            /* opnd for ymms */
            reg_id_t ymm_dst = dst_reg;
            reg_id_t ymm_src = src_reg;
            reg_id_t ymm_spill_src = find_one_available_spill_ymm(dst_reg);
            opnd_t ymm_dst_opnd = opnd_create_reg(ymm_dst);
            opnd_t ymm_spill_src_opnd = opnd_create_reg(ymm_spill_src);

            // push rax;
            instr_t *i1 = INSTR_CREATE_push(dcontext, rax_opnd);
            // push rcx;
            instr_t *i2 = INSTR_CREATE_push(dcontext, rcx_opnd);
            // push rdx;
            instr_t *i3 = INSTR_CREATE_push(dcontext, rdx_opnd);
            // push eflags;
            instr_t *i4 = INSTR_CREATE_pushf(dcontext);
            // tls_slot(mask_reg) -> edx
            instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EDX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // test edx, edx
            instr_t *i6 = INSTR_CREATE_test(dcontext, dx_opnd, dx_opnd);
            // jz SKIP_LOAD
            instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_LOAD));
            // cmpl -1, edx (for 8-bit elements, 32 bits matter in YMM)
            instr_t *i8 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EDX), opnd_create_immed_int(-1, OPSZ_4));
            // je FULL_LOAD
            instr_t *i9 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_LOAD));

            // sub rsp, 64
            instr_t *i10 = INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(64, OPSZ_4));
            // tls_slot(ymm_src) -> ymm_spill_src
            instr_t *i11 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_spill_src,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_src)), OPSZ_32);
            // vmovdqu ymm_spill_src -> 0x20(%rsp)
            instr_t *i12 = INSTR_CREATE_vmovdqu(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0x20, OPSZ_32), ymm_spill_src_opnd);
            // vmovdqu ymm_dst -> (%rsp)
            instr_t *i13 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32),
                                                ymm_dst_opnd);
            // xor rcx, rcx
            instr_t *i14 = INSTR_CREATE_xor(dcontext, rcx_opnd, rcx_opnd);

            /* LOOP */
            // movl %edx -> %eax
            instr_t *i15 = INSTR_CREATE_mov_st(dcontext, eax_opnd, edx_opnd);
            // bt %eax, %ecx (test bit %ecx in %eax)
            instr_t *i16 = INSTR_CREATE_bt(dcontext, eax_opnd, ecx_opnd);
            // jnc L_LOOP_SKIP
            instr_t *i17 = INSTR_CREATE_jcc(dcontext, OP_jnb_short, opnd_create_instr(LOOP_SKIP));

            // movb 0x20(%rsp, %rcx, 1) -> %al
            instr_t *i18 =
                INSTR_CREATE_mov_ld(dcontext, al_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 1, 0x20, OPSZ_1));
            // movb %al -> (%rsp, %rcx, 1)
            instr_t *i19 =
                INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 1, 0, OPSZ_1), al_opnd);

            // LOOP_SKIP
            // inc %rcx
            instr_t *i20 = INSTR_CREATE_inc(dcontext, rcx_opnd);
            // cmp %rcx, 0x20
            instr_t *i21 = INSTR_CREATE_cmp(dcontext, rcx_opnd, opnd_create_immed_int(0x20, OPSZ_4));
            // jl L_LOOP
            instr_t *i22 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP));
            // vmovdqu (%rsp),  %ymm_dst
            instr_t *i23 = INSTR_CREATE_vmovdqu(dcontext, ymm_dst_opnd,
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));
            // add rsp, 64
            instr_t *i24 = INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(64, OPSZ_4));

            // jmp SKIP_LOAD
            instr_t *i25 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_LOAD));

            // FULL_LOAD:
            // vmovdqu ymm_src -> ymm_dst
            instr_t *i26 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_dst, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_src)), OPSZ_32);

            // SKIP_LOAD: (only a label)
            // pop eflags;
            instr_t *i27 = INSTR_CREATE_popf(dcontext);
            // pop rdx;
            instr_t *i28 = INSTR_CREATE_pop(dcontext, rdx_opnd);
            // pop rcx;
            instr_t *i29 = INSTR_CREATE_pop(dcontext, rcx_opnd);
            // pop rax;
            instr_t *i30 = INSTR_CREATE_pop(dcontext, rax_opnd);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 34, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14,
                                         LOOP, i15, i16, i17, i18, i19, LOOP_SKIP, i20, i21, i22, i23, i24, i25,
                                         FULL_LOAD, i26, SKIP_LOAD, i27, i28, i29, i30);
#endif
            instrlist_concat_next_instr(ilist, 34, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, LOOP,
                                        i15, i16, i17, i18, i19, LOOP_SKIP, i20, i21, i22, i23, i24, i25, FULL_LOAD,
                                        i26, SKIP_LOAD, i27, i28, i29, i30);
            return i1;
        } break;
        case 2: { /* dst need spill */
            instr_t *SKIP_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *FULL_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *LOOP = INSTR_CREATE_label(dcontext);
            instr_t *LOOP_SKIP = INSTR_CREATE_label(dcontext);

            /* opnd for gprs */
            reg_id_t rax_reg = DR_REG_RAX;
            reg_id_t eax_reg = DR_REG_EAX;
            reg_id_t rcx_reg = DR_REG_RCX;
            reg_id_t ecx_reg = DR_REG_ECX;
            reg_id_t rdx_reg = DR_REG_RDX;
            reg_id_t edx_reg = DR_REG_EDX;
            reg_id_t dx_reg = DR_REG_DX;

            reg_id_t al_reg = DR_REG_AL;
            opnd_t rax_opnd = opnd_create_reg(rax_reg);
            opnd_t eax_opnd = opnd_create_reg(eax_reg);
            opnd_t rcx_opnd = opnd_create_reg(rcx_reg);
            opnd_t ecx_opnd = opnd_create_reg(ecx_reg);
            opnd_t rdx_opnd = opnd_create_reg(rdx_reg);
            opnd_t al_opnd = opnd_create_reg(al_reg);
            opnd_t edx_opnd = opnd_create_reg(edx_reg);
            opnd_t dx_opnd = opnd_create_reg(dx_reg);

            /* opnd for ymms */
            reg_id_t ymm_dst = dst_reg;
            reg_id_t ymm_src = src_reg;
            reg_id_t ymm_spill_dst = find_one_available_spill_ymm(src_reg);
            opnd_t ymm_spill_dst_opnd = opnd_create_reg(ymm_spill_dst);
            opnd_t ymm_src_opnd = opnd_create_reg(ymm_src);

            // push rax;
            instr_t *i1 = INSTR_CREATE_push(dcontext, rax_opnd);
            // push rcx;
            instr_t *i2 = INSTR_CREATE_push(dcontext, rcx_opnd);
            // push rdx;
            instr_t *i3 = INSTR_CREATE_push(dcontext, rdx_opnd);
            // push eflags;
            instr_t *i4 = INSTR_CREATE_pushf(dcontext);
            // tls_slot(mask_reg) -> edx
            instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EDX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // test edx, edx
            instr_t *i6 = INSTR_CREATE_test(dcontext, dx_opnd, dx_opnd);
            // jz SKIP_LOAD
            instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_LOAD));
            // cmpl -1, edx (for 8-bit elements, 32 bits matter in YMM)
            instr_t *i8 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EDX), opnd_create_immed_int(-1, OPSZ_4));
            // je FULL_LOAD
            instr_t *i9 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_LOAD));

            // sub rsp, 64
            instr_t *i10 = INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(64, OPSZ_4));
            // vmovdqu ymm_src -> 0x20(%rsp)
            instr_t *i11 = INSTR_CREATE_vmovdqu(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0x20, OPSZ_32), ymm_src_opnd);
            // ymm_spill_dst -> tls_slot(ymm_spill_dst)
            instr_t *i12 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_spill_dst,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill_dst)), OPSZ_32);
            // tls_slot(ymm_dst) -> ymm_spill_dst
            instr_t *i13 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_spill_dst,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_dst)), OPSZ_32);
            // vmovdqu ymm_spill_dst -> (%rsp)
            instr_t *i14 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32),
                                                ymm_spill_dst_opnd);
            // xor rcx, rcx
            instr_t *i15 = INSTR_CREATE_xor(dcontext, rcx_opnd, rcx_opnd);

            /* LOOP */
            // movl %edx -> %eax
            instr_t *i16 = INSTR_CREATE_mov_st(dcontext, eax_opnd, edx_opnd);
            // bt %eax, %ecx (test bit %ecx in %eax)
            instr_t *i17 = INSTR_CREATE_bt(dcontext, eax_opnd, ecx_opnd);
            // jnc L_LOOP_SKIP
            instr_t *i18 = INSTR_CREATE_jcc(dcontext, OP_jnb_short, opnd_create_instr(LOOP_SKIP));

            // movb 0x20(%rsp, %rcx, 1) -> %al
            instr_t *i19 =
                INSTR_CREATE_mov_ld(dcontext, al_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 1, 0x20, OPSZ_1));
            // movb %al -> (%rsp, %rcx, 1)
            instr_t *i20 =
                INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 1, 0, OPSZ_1), al_opnd);

            // LOOP_SKIP
            // inc %rcx
            instr_t *i21 = INSTR_CREATE_inc(dcontext, rcx_opnd);
            // cmp %rcx, 0x20
            instr_t *i22 = INSTR_CREATE_cmp(dcontext, rcx_opnd, opnd_create_immed_int(0x20, OPSZ_4));
            // jl L_LOOP
            instr_t *i23 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP));
            // vmovdqu (%rsp),  %ymm_spill_dst
            instr_t *i24 = INSTR_CREATE_vmovdqu(dcontext, ymm_spill_dst_opnd,
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));
            // %ymm_spill_dst -> ymm_dst
            instr_t *i25 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_spill_dst, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_dst)), OPSZ_32);
            // tls_slot(ymm_spill_slot) -> ymm_spill_dst
            instr_t *i26 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_spill_dst,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill_dst)), OPSZ_32);
            // add rsp, 64
            instr_t *i27 = INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(64, OPSZ_4));

            // jmp SKIP_LOAD
            instr_t *i28 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_LOAD));

            // FULL_LOAD:
            // vmovdqu ymm_src -> ymm_dst
            instr_t *i29 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_src, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_dst)), OPSZ_32);

            // SKIP_LOAD: (only a label)
            // pop eflags;
            instr_t *i30 = INSTR_CREATE_popf(dcontext);
            // pop rdx;
            instr_t *i31 = INSTR_CREATE_pop(dcontext, rdx_opnd);
            // pop rcx;
            instr_t *i32 = INSTR_CREATE_pop(dcontext, rcx_opnd);
            // pop rax;
            instr_t *i33 = INSTR_CREATE_pop(dcontext, rax_opnd);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 37, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         LOOP, i16, i17, i18, i19, i20, LOOP_SKIP, i21, i22, i23, i24, i25, i26, i27,
                                         i28, FULL_LOAD, i29, SKIP_LOAD, i30, i31, i32, i33);
#endif
            instrlist_concat_next_instr(ilist, 37, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        LOOP, i16, i17, i18, i19, i20, LOOP_SKIP, i21, i22, i23, i24, i25, i26, i27,
                                        i28, FULL_LOAD, i29, SKIP_LOAD, i30, i31, i32, i33);
            return i1;
        } break;
        case 3: { /* src and dst need spill */
            instr_t *SKIP_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *FULL_LOAD = INSTR_CREATE_label(dcontext);
            instr_t *LOOP = INSTR_CREATE_label(dcontext);
            instr_t *LOOP_SKIP = INSTR_CREATE_label(dcontext);

            /* opnd for gprs */
            reg_id_t rax_reg = DR_REG_RAX;
            reg_id_t eax_reg = DR_REG_EAX;
            reg_id_t rcx_reg = DR_REG_RCX;
            reg_id_t ecx_reg = DR_REG_ECX;
            reg_id_t rdx_reg = DR_REG_RDX;
            reg_id_t edx_reg = DR_REG_EDX;
            reg_id_t dx_reg = DR_REG_DX;

            reg_id_t al_reg = DR_REG_AL;
            opnd_t rax_opnd = opnd_create_reg(rax_reg);
            opnd_t eax_opnd = opnd_create_reg(eax_reg);
            opnd_t rcx_opnd = opnd_create_reg(rcx_reg);
            opnd_t ecx_opnd = opnd_create_reg(ecx_reg);
            opnd_t rdx_opnd = opnd_create_reg(rdx_reg);
            opnd_t al_opnd = opnd_create_reg(al_reg);
            opnd_t edx_opnd = opnd_create_reg(edx_reg);
            opnd_t dx_opnd = opnd_create_reg(dx_reg);

            /* opnd for ymms */
            reg_id_t ymm_dst = dst_reg;
            reg_id_t ymm_src = src_reg;
            reg_id_t ymm_spill_dst = YMM_SPILL_SLOT0;
            reg_id_t ymm_spill_src = YMM_SPILL_SLOT1;
            opnd_t ymm_spill_dst_opnd = opnd_create_reg(ymm_spill_dst);
            opnd_t ymm_spill_src_opnd = opnd_create_reg(ymm_spill_src);

            // push rax;
            instr_t *i1 = INSTR_CREATE_push(dcontext, rax_opnd);
            // push rcx;
            instr_t *i2 = INSTR_CREATE_push(dcontext, rcx_opnd);
            // push rdx;
            instr_t *i3 = INSTR_CREATE_push(dcontext, rdx_opnd);
            // push eflags;
            instr_t *i4 = INSTR_CREATE_pushf(dcontext);
            // tls_slot(mask_reg) -> edx
            instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_EDX, TLS_K_idx_SLOT(k_idx), OPSZ_4);
            // test edx, edx
            instr_t *i6 = INSTR_CREATE_test(dcontext, dx_opnd, dx_opnd);
            // jz SKIP_LOAD
            instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_LOAD));
            // cmpl -1, edx (for 8-bit elements, 32 bits matter in YMM)
            instr_t *i8 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EDX), opnd_create_immed_int(-1, OPSZ_4));
            // je FULL_LOAD
            instr_t *i9 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(FULL_LOAD));

            // sub rsp, 64
            instr_t *i10 = INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(64, OPSZ_4));

            // ymm_spill_src -> tls_slot(ymm_spill_src)
            instr_t *i11 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_spill_src,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill_src)), OPSZ_32);
            // ymm_spill_dst -> tls_slot(ymm_spill_dst)
            instr_t *i12 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_spill_dst,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill_dst)), OPSZ_32);
            // tls_slot(ymm_src) -> ymm_spill_src
            instr_t *i13 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_spill_src,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_src)), OPSZ_32);
            // tls_slot(ymm_dst) -> ymm_spill_dst
            instr_t *i14 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_spill_dst,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_dst)), OPSZ_32);
            // vmovdqu ymm_spill_src -> 0x20(%rsp)
            instr_t *i15 = INSTR_CREATE_vmovdqu(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0x20, OPSZ_32), ymm_spill_src_opnd);
            // vmovdqu ymm_spill_dst -> (%rsp)
            instr_t *i16 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32),
                                                ymm_spill_dst_opnd);
            // xor rcx, rcx
            instr_t *i17 = INSTR_CREATE_xor(dcontext, rcx_opnd, rcx_opnd);

            /* LOOP */
            // movl %edx -> %eax
            instr_t *i18 = INSTR_CREATE_mov_st(dcontext, eax_opnd, edx_opnd);
            // bt %eax, %ecx (test bit %ecx in %eax)
            instr_t *i19 = INSTR_CREATE_bt(dcontext, eax_opnd, ecx_opnd);
            // jnc L_LOOP_SKIP
            instr_t *i20 = INSTR_CREATE_jcc(dcontext, OP_jnb_short, opnd_create_instr(LOOP_SKIP));

            // movb 0x20(%rsp, %rcx, 1) -> %al
            instr_t *i21 =
                INSTR_CREATE_mov_ld(dcontext, al_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 1, 0x20, OPSZ_1));
            // movb %al -> (%rsp, %rcx, 1)
            instr_t *i22 =
                INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 1, 0, OPSZ_1), al_opnd);

            // LOOP_SKIP
            // inc %rcx
            instr_t *i23 = INSTR_CREATE_inc(dcontext, rcx_opnd);
            // cmp %rcx, 0x20
            instr_t *i24 = INSTR_CREATE_cmp(dcontext, rcx_opnd, opnd_create_immed_int(0x20, OPSZ_4));
            // jl L_LOOP
            instr_t *i25 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP));
            // vmovdqu (%rsp),  %ymm_spill_dst
            instr_t *i26 = INSTR_CREATE_vmovdqu(dcontext, ymm_spill_dst_opnd,
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));
            // ymm_spill_dst -> tls_slot(ymm_dst)
            instr_t *i27 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_spill_dst, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_dst)), OPSZ_32);
            // tls_slot(ymm_spill_src) -> ymm_spill_src
            instr_t *i28 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_spill_src,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill_src)), OPSZ_32);
            // tls_slot(ymm_spill_dst) -> ymm_spill_dst
            instr_t *i29 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_spill_dst,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill_dst)), OPSZ_32);

            // add rsp, 64
            instr_t *i30 = INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(64, OPSZ_4));

            // jmp SKIP_LOAD
            instr_t *i31 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(SKIP_LOAD));

            // FULL_LOAD:
            // spill_ymm_src -> tls_slot(ymm_spill_src)
            instr_t *i32 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_spill_src,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill_src)), OPSZ_32);
            // tls_slot(ymm_src) -> spill_ymm_src
            instr_t *i33 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_spill_src,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_src)), OPSZ_32);
            // spill_ymm_src -> tls_slot(ymm_dst)
            instr_t *i34 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_spill_src, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_dst)), OPSZ_32);
            // tls_slot(ymm_spill_src) -> ymm_spill_src
            instr_t *i35 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_spill_src,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill_src)), OPSZ_32);

            // SKIP_LOAD: (only a label)
            // pop eflags;
            instr_t *i36 = INSTR_CREATE_popf(dcontext);
            // pop rdx;
            instr_t *i37 = INSTR_CREATE_pop(dcontext, rdx_opnd);
            // pop rcx;
            instr_t *i38 = INSTR_CREATE_pop(dcontext, rcx_opnd);
            // pop rax;
            instr_t *i39 = INSTR_CREATE_pop(dcontext, rax_opnd);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 43, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         i16, i17, LOOP, i18, i19, i20, i21, i22, LOOP_SKIP, i23, i24, i25, i26, i27,
                                         i28, i29, i30, i31, FULL_LOAD, i32, i33, i34, i35, SKIP_LOAD, i36, i37, i38,
                                         i39);
#endif
            instrlist_concat_next_instr(ilist, 43, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, LOOP, i18, i19, i20, i21, i22, LOOP_SKIP, i23, i24, i25, i26, i27,
                                        i28, i29, i30, i31, FULL_LOAD, i32, i33, i34, i35, SKIP_LOAD, i36, i37, i38,
                                        i39);
            return i1;
        } break;
        default: {
            REWRITE_ERROR(STD_ERRF, "vmovdqu8_ymm_reg2reg_gen not support pattern");
        }
            return NULL_INSTR;
        }
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu8_zmm_reg2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, reg_id_t dst_reg,
                         reg_id_t mask_reg)
{
    dr_ymm_pair_t src_ymm_pair = { EMPTY, EMPTY };
    dr_ymm_pair_t dst_ymm_pair = { EMPTY, EMPTY };
    if (get_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(src_reg), &src_ymm_pair) == NOT_GET) {
        if (find_and_set_unused_ymm_pair(dcontext, &src_ymm_pair) == NOT_FIND) {
            return NULL_INSTR; // means failed find unused ymm pair, abandon instr rewrite
        }
        add_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(src_reg), &src_ymm_pair);
    }
    if (get_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(dst_reg), &dst_ymm_pair) == NOT_GET) {
        if (find_and_set_unused_ymm_pair(dcontext, &dst_ymm_pair) == NOT_FIND) {
            return NULL_INSTR; // means failed find unused ymm pair, abandon instr rewrite
        }
        add_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(dst_reg), &dst_ymm_pair);
    }
    reg_id_t src_reg_lower = TO_YMM_REG_ID_NUM(src_ymm_pair.ymm_lower);
    reg_id_t src_reg_upper = TO_YMM_REG_ID_NUM(src_ymm_pair.ymm_upper);
    reg_id_t dst_reg_lower = TO_YMM_REG_ID_NUM(dst_ymm_pair.ymm_lower);
    reg_id_t dst_reg_upper = TO_YMM_REG_ID_NUM(dst_ymm_pair.ymm_upper);

    instr_t *new_instr1 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, opnd_create_reg(dst_reg_lower), opnd_create_reg(src_reg_lower));
    instr_t *new_instr2 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, opnd_create_reg(dst_reg_upper), opnd_create_reg(src_reg_upper));
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 2, new_instr1, new_instr2);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    new_instr1->next = new_instr2;
    return new_instr1;
}

instr_t *
vmovdqu8_xmm_reg2disp_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, opnd_t dst_opnd,
                          reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    int k_idx = TO_K_REG_INDEX(mask_reg);
    const uint src_need_spill = NEED_SPILL_XMM(src_reg) ? 1 : 0;

    if (k_idx == 0) {
        switch (src_need_spill) {
        case 0: { /* src don't need spill */
            opnd_t src_opnd = opnd_create_reg(src_reg);
            instr_t *new_instr1 = instr_create_1dst_1src(dcontext, OP_vmovdqu, dst_opnd, src_opnd);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
            return new_instr1;
        } break;
        case 1: { /* src need spill */
            reg_id_t spill_src_reg = XMM_SPILL_SLOT0;
            opnd_t spill_src_opnd = opnd_create_reg(spill_src_reg);
            // spill_src_reg -> tls(spill_src_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src_reg)), OPSZ_16);
            // tls(src_reg) -> spill_src_reg
            instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src_reg)), OPSZ_16);
            // vmovdqu spill_src_reg -> dst_opnd
            instr_t *i3 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, spill_src_opnd);
            // tls(spill_src_reg) -> spill_src_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
            instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
            return i1;
        } break;
        default: {
            REWRITE_ERROR(STD_ERRF, "vmovdqu64_xmm_reg2disp_gen not support pattern");
        }
        }
    } else {
        switch (src_need_spill) {
        case 0: { /* src don't need spill */
        } break;
        case 1: { /* src need spill */
        } break;
        default: {
            REWRITE_ERROR(STD_ERRF, "vmovdqu64_xmm_reg2disp_gen not support pattern");
        }
        }
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu8_ymm_reg2disp_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, opnd_t dst_opnd,
                          reg_id_t mask_reg)
{

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    int k_idx = TO_K_REG_INDEX(mask_reg);
    const uint src_need_spill = NEED_SPILL_YMM(src_reg) ? 1 : 0;

    if (k_idx == 0) {
        switch (src_need_spill) {
        case 0: { /* src don't need spill */
            opnd_t src_opnd = opnd_create_reg(src_reg);
            instr_t *new_instr1 = instr_create_1dst_1src(dcontext, OP_vmovdqu, dst_opnd, src_opnd);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
            return new_instr1;
        } break;
        case 1: { /* src need spill */
            reg_id_t spill_src_reg = YMM_SPILL_SLOT0;
            opnd_t spill_src_opnd = opnd_create_reg(spill_src_reg);
            // spill_src_reg -> tls(spill_src_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg)), OPSZ_32);
            // tls(src_reg) -> spill_src_reg
            instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src_reg)), OPSZ_32);
            // vmovdqu spill_src_reg -> dst_opnd
            instr_t *i3 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, spill_src_opnd);
            // tls(spill_src_reg) -> spill_src_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
            instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
            return i1;
        } break;
        default: {
            REWRITE_ERROR(STD_ERRF, "vmovdqu64_ymm_reg2disp_gen not support pattern");
        }
        }
    } else {
        switch (src_need_spill) {
        case 0: { /* src don't need spill */
        } break;
        case 1: { /* src need spill */
        } break;
        default: {
            REWRITE_ERROR(STD_ERRF, "vmovdqu64_ymm_reg2disp_gen not support pattern");
        }
        }
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu8_zmm_reg2disp_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg, opnd_t dst_opnd,
                          reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vmovdqu8_zmm_reg2reladdr_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                             opnd_t dst_opnd, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vmovdqu8_ymm_reg2reladdr_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                             opnd_t dst_opnd, reg_id_t mask_reg)
{
    instr_t *new_instr1 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, dst_opnd, create_mapping_ymm_opnd(dcontext, src_reg));
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vmovdqu8_xmm_reg2reladdr_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                             opnd_t dst_opnd, reg_id_t mask_reg)
{
    instr_t *new_instr1 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, dst_opnd, create_mapping_xmm_opnd(dcontext, src_reg));
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vmovdqu8_xmm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{
    // vmovdqu64 {%k1} 0xffffffb8(%rdx)[16byte] -> %xmm31

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    int k_idx = TO_K_REG_INDEX(mask_reg);
    const uint dst_need_spill = NEED_SPILL_XMM(dst_reg) ? 1 : 0;

    if (k_idx == 0) { // mask don't work
        switch (dst_need_spill) {
        case 0: { /* don't need spill */
            opnd_t dst_opnd = opnd_create_reg(dst_reg);
            instr_t *i1 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, src_opnd);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
            return i1;
        } break;
        case 1: { /* dst need spill */
            reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
            opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
            // spill_dst_reg -> tls(spill_dst_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
            // VEX.128.66.0F.WIG 6F /r VMOVDQU xmm1, xmm2/m128
            instr_t *i2 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd, src_opnd);
            // spill_dst_reg -> tls(dst_reg)
            instr_t *i3 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_dst_reg) -> spill_dst_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
            instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
            return i1;
        } break;
        default: {
            REWRITE_ERROR(STD_OUTF, "vmovdqu_xmm_disp2reg_gen not support pattern");
        }
        }
    } else {
        switch (dst_need_spill) {
        case 0: { /* dst don't need spill */
        } break;
        case 1: { /* dst need spill */
        } break;
        default: {
            REWRITE_ERROR(STD_ERRF, "vmovdqu64_xmm_disp2reg_gen not support pattern");
        }
        }
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu8_ymm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{
    // vmovdqu64 {%k1} 0xffffffb8(%rdx)[32byte] -> %ymm31

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    int k_idx = TO_K_REG_INDEX(mask_reg);
    if (k_idx == 0) { // mask don't work
        const uint dst_need_spill = NEED_SPILL_YMM(dst_reg) ? 1 : 0;
        switch (dst_need_spill) {
        case 0: { /* don't need spill */
            opnd_t dst_opnd = opnd_create_reg(dst_reg);
            instr_t *i1 = INSTR_CREATE_vmovdqu(dcontext, dst_opnd, src_opnd);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
            return i1;
        } break;
        case 1: { /* dst need spill */
            reg_id_t spill_dst_reg = YMM_SPILL_SLOT0;
            opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
            // spill_dst_reg -> tls(spill_dst_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
            // VEX.128.66.0F.WIG 6F /r VMOVDQU ymm1, ymm2/m256
            instr_t *i2 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd, src_opnd);
            // spill_dst_reg -> tls(dst_reg)
            instr_t *i3 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill_dst_reg) -> spill_dst_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
            instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
            return i1;
        } break;
        default: {
            REWRITE_ERROR(STD_OUTF, "vmovdqu8_ymm_disp2reg_gen not support pattern");
        }
        }
    } else {
        return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu8_zmm_disp2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd, reg_id_t dst_reg,
                          reg_id_t mask_reg)
{
    reg_id_t src_base_reg = opnd_get_base(src_opnd); // src_reg is now DR_REG_RSP
    reg_id_t src_index_reg = opnd_get_index(src_opnd);
    int scale = opnd_get_scale(src_opnd);
    int disp = opnd_get_disp(src_opnd);
    dr_ymm_pair_t dst_ymm_pair = { EMPTY, EMPTY };
    if (get_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(dst_reg), &dst_ymm_pair) == NOT_GET) {
        if (find_and_set_unused_ymm_pair(dcontext, &dst_ymm_pair) == NOT_FIND) {
            return NULL_INSTR;
        }
        add_zmm_to_ymm_pair_mapping(TO_ZMM_REG_INDEX(dst_reg), &dst_ymm_pair);
    }

    reg_id_t dst_reg_lower = TO_YMM_REG_ID_NUM(dst_ymm_pair.ymm_lower);
    reg_id_t dst_reg_upper = TO_YMM_REG_ID_NUM(dst_ymm_pair.ymm_upper);

#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "vmovdqu8_zmm_disp2reg_gen: dst_reg_lower{ymm%d}, dst_reg_upper{ymm%d}",
                 dst_reg_lower - DR_REG_YMM0, dst_reg_upper - DR_REG_YMM0);
#endif

    instr_t *new_instr1 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, opnd_create_reg(dst_reg_lower),
                               opnd_create_base_disp(src_base_reg, src_index_reg, scale, disp, OPSZ_32));
    instr_t *new_instr2 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, opnd_create_reg(dst_reg_upper),
                               opnd_create_base_disp(src_base_reg, src_index_reg, scale, disp + SIZE_OF_YMM, OPSZ_32));
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 2, new_instr1, new_instr2);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    new_instr1->next = new_instr2;
    return new_instr1;
}

instr_t *
vmovdqu8_xmm_reladdr2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                             reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint dst_need_spill = NEED_SPILL_XMM(dst_reg) ? 1 : 0;

    switch (dst_need_spill) {
    case 0: { /* don't need spill */
        instr_t *i1 =
            instr_create_1dst_1src(dcontext, OP_vmovdqu, create_mapping_xmm_opnd(dcontext, dst_reg), src_opnd);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* dst need spill */
        reg_id_t spill_dst_reg = XMM_SPILL_SLOT0;
        opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vmovdqu src_opnd -> spill_dst_reg
        instr_t *i2 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd, src_opnd);
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vmovdqu64_xmm_reladdr2reg_gen not support");
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu8_ymm_reladdr2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                             reg_id_t dst_reg, reg_id_t mask_reg)
{
    int k_idx = TO_K_REG_INDEX(mask_reg);
    if (k_idx == 0) {
        instr_t *i1 =
            instr_create_1dst_1src(dcontext, OP_vmovdqu, create_mapping_ymm_opnd(dcontext, dst_reg), src_opnd);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        instrlist_remove(ilist, instr);
        instr_destroy(dcontext, instr);
        return i1;
    } else {
        REWRITE_ERROR(STD_ERRF, "vmovdqu64_ymm_reladdr2reg_gen not support mask_reg");
    }
    return NULL_INSTR;
}

instr_t *
vmovdqu8_zmm_reladdr2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                             reg_id_t dst_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vmovdqu8_xmm_absaddr2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                             reg_id_t dst_reg, reg_id_t mask_reg)
{
    instr_t *new_instr1 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, create_mapping_xmm_opnd(dcontext, dst_reg), src_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vmovdqu8_ymm_absaddr2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                             reg_id_t dst_reg, reg_id_t mask_reg)
{
    instr_t *new_instr1 =
        instr_create_1dst_1src(dcontext, OP_vmovdqu, create_mapping_ymm_opnd(dcontext, dst_reg), src_opnd);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new_instr1;
}

instr_t *
vmovdqu8_zmm_absaddr2reg_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src_opnd,
                             reg_id_t dst_reg, reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "vmovdqu_zmm_absaddr2reg_gen not support");
#endif
    return NULL_INSTR;
}

/**
 * @brief 613 vmovdqu8 rewrite function
 */
instr_t *
rw_func_vmovdqu8(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t mask_opnd = instr_get_src(instr, 0);
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    opnd_t src_opnd = instr_get_src(instr, 1); // %{x,y,z}mm or disp(base, index, scale)[nbyte]
    opnd_t dst_opnd = instr_get_dst(instr, 0); // %{x,y,z}mm
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vmovdqu8", true, true, false, true);
#endif
    switch (src_opnd.kind) {
    case REG_kind: {
        reg_id_t src_reg = opnd_get_reg(src_opnd);
        switch (dst_opnd.kind) {
        case REG_kind: { // reg -> reg
            reg_id_t dst_reg = opnd_get_reg(dst_opnd);
            if (IS_XMM_REG(dst_reg))
                return vmovdqu8_xmm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
            if (IS_YMM_REG(dst_reg))
                return vmovdqu8_ymm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
            if (IS_ZMM_REG(dst_reg))
                return vmovdqu8_zmm_reg2reg_gen(dcontext, ilist, instr, src_reg, dst_reg, mask_reg);
        } break;
        case BASE_DISP_kind: { // reg -> disp
            if (IS_XMM_REG(src_reg))
                return vmovdqu8_xmm_reg2disp_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
            if (IS_YMM_REG(src_reg))
                return vmovdqu8_ymm_reg2disp_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
            if (IS_ZMM_REG(src_reg))
                return vmovdqu8_zmm_reg2disp_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
        } break;
        case REL_ADDR_kind: { // reg -> rel_addr
            if (IS_XMM_REG(src_reg))
                return vmovdqu8_xmm_reg2reladdr_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
            if (IS_YMM_REG(src_reg))
                return vmovdqu8_ymm_reg2reladdr_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
            if (IS_ZMM_REG(src_reg))
                return vmovdqu8_zmm_reg2reladdr_gen(dcontext, ilist, instr, src_reg, dst_opnd, mask_reg);
        }
        default: print_file(STD_OUTF, "[WARN]: vpmovdqa64 pattern not support\n");
        }
    } break;
    case BASE_DISP_kind: { // disp -> reg
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_XMM_REG(dst_reg))
            return vmovdqu8_xmm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_YMM_REG(dst_reg))
            return vmovdqu8_ymm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_ZMM_REG(dst_reg))
            return vmovdqu8_zmm_disp2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
    } break;
    case REL_ADDR_kind: { // rel_addr -> reg
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_XMM_REG(dst_reg))
            return vmovdqu8_xmm_reladdr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_YMM_REG(dst_reg))
            return vmovdqu8_ymm_reladdr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_ZMM_REG(dst_reg))
            return vmovdqu8_zmm_reladdr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
    } break;
    case ABS_ADDR_kind: { // abs_addr -> reg
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_XMM_REG(dst_reg))
            return vmovdqu8_xmm_absaddr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_YMM_REG(dst_reg))
            return vmovdqu8_ymm_absaddr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
        if (IS_ZMM_REG(dst_reg))
            return vmovdqu8_zmm_absaddr2reg_gen(dcontext, ilist, instr, src_opnd, dst_reg, mask_reg);
    } break;
    default: REWRITE_INFO(STD_OUTF, "vpmovdqu8 pattern not support");
    }
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vpandd
 * ============================================= */

static inline instr_t *
emit_vpand_ymm(dcontext_t *dc, reg_id_t dst, reg_id_t a, reg_id_t b)
{
    return INSTR_CREATE_vpand(dc, opnd_create_reg(dst), opnd_create_reg(a), opnd_create_reg(b));
}

static inline instr_t *
emit_vpand_xmm(dcontext_t *dc, reg_id_t dst, reg_id_t a, reg_id_t b)
{
    return INSTR_CREATE_vpand(dc, opnd_create_reg(dst), opnd_create_reg(a), opnd_create_reg(b));
}

instr_t *
vpandd_zmm_and_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "vpandd zmm and zmm not support");
#endif
    return NULL_INSTR;
}

instr_t *
vpandd_ymm_and_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill = NEED_SPILL_YMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill = NEED_SPILL_YMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill = NEED_SPILL_YMM(dst_reg) ? 4 : 0;
    const uint need_spill = src1_need_spill | src2_need_spill | dst_need_spill;

    switch (need_spill) {
    case 0: { // no spill
        opnd_t dst_opnd = opnd_create_reg(dst_reg);
        opnd_t src_opnd1 = opnd_create_reg(src1_reg);
        opnd_t src_opnd2 = opnd_create_reg(src2_reg);
        instr_t *i1 = INSTR_CREATE_vpand(dcontext, dst_opnd, src_opnd1, src_opnd2);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { // src1 spill
        reg_id_t spill_src1_reg = find_available_spill_ymm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
        opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);
        opnd_t dst_opnd = opnd_create_reg(dst_reg);
        opnd_t src2_opnd = opnd_create_reg(src2_reg);

        // spill_src1_reg -> tls(spill_src1_reg) | spill src1
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
        // tls_slot(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
        // vpandd spill_src1_reg, src2_reg, dst_reg
        instr_t *i3 = INSTR_CREATE_vpand(dcontext, dst_opnd, spill_src1_opnd, src2_opnd);
        // tls(spill_src1_reg) -> spill_src1_reg | restore src1
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { // src2 spill
        reg_id_t s2 = find_available_spill_ymm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, s2, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(s2)), OPSZ_32);
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, s2, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
        instr_t *i3 = emit_vpand_ymm(dcontext, dst_reg, src1_reg, s2);
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, s2, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(s2)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { // src1 and src2 spill
        reg_id_t s1 = find_one_available_spill_ymm(dst_reg);
        reg_id_t s2 = find_available_spill_ymm_avoiding(dst_reg, s1, DR_REG_NULL);
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, s1, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(s1)), OPSZ_32);
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, s2, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(s2)), OPSZ_32);
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, s1, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, s2, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
        instr_t *i5 = emit_vpand_ymm(dcontext, dst_reg, s1, s2);
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, s2, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(s2)), OPSZ_32);
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, s1, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(s1)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 4: { // dst spill
        reg_id_t t = find_available_spill_ymm_avoiding(src1_reg, src2_reg, DR_REG_NULL);
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, t, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(t)), OPSZ_32);
        instr_t *i2 = emit_vpand_ymm(dcontext, t, src1_reg, src2_reg);
        instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, t, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, t, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(t)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 5: { // src1 and dst spill
        if (src1_reg == dst_reg) {
            reg_id_t spill_src1_reg = find_available_spill_ymm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
            opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);
            opnd_t spill_dst_opnd = spill_src1_opnd;
            opnd_t src2_opnd = opnd_create_reg(src2_reg);

            // spill_src1_reg -> tls(spill_src1_reg) | spill src1
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // tls_slot(src1_reg) -> spill_src1_reg | get the input src
            instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
            // vpandd spill_src1_reg, src2_reg, spill_src1_reg
            instr_t *i3 = INSTR_CREATE_vpand(dcontext, spill_dst_opnd, spill_src1_opnd, src2_opnd);
            // spill_src1_reg -> tls(dst_reg) | store the result back to dst_reg
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill_src1_reg) -> spill_src1_reg | restore src1
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } else {
        }
    } break;
    case 6: { // src2 and dst spill
        return NULL_INSTR;
    } break;
    case 7: { // src1, src2 and dst spill
        return NULL_INSTR;
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpandd ymm and ymm not support");
    }
    return NULL_INSTR;
}

instr_t *
vpandd_xmm_and_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{
    // AVX: VEX.128.66.0F.WIG DB /r VPAND xmm1, xmm2, xmm3/m128
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill = NEED_SPILL_XMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill = NEED_SPILL_XMM(dst_reg) ? 4 : 0;
    const uint need_spill = src1_need_spill | src2_need_spill | dst_need_spill;

    switch (need_spill) {
    case 0: { // no spill
        opnd_t dst_opnd = opnd_create_reg(dst_reg);
        opnd_t src_opnd1 = opnd_create_reg(src1_reg);
        opnd_t src_opnd2 = opnd_create_reg(src2_reg);
        instr_t *i1 = INSTR_CREATE_vpand(dcontext, dst_opnd, src_opnd1, src_opnd2);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { // src1 spill
        reg_id_t spill_src1_reg = find_available_spill_xmm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
        opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);
        opnd_t dst_opnd = opnd_create_reg(dst_reg);
        opnd_t src2_opnd = opnd_create_reg(src2_reg);

        // spill_src1_reg -> tls(spill_src1_reg) | spill src1
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls_slot(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vpandd spill_src1_reg, src2_reg, dst_reg
        instr_t *i3 = INSTR_CREATE_vpand(dcontext, dst_opnd, spill_src1_opnd, src2_opnd);
        // tls(spill_src1_reg) -> spill_src1_reg | restore src1
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { // src2 spill
        reg_id_t s2 = find_available_spill_xmm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, s2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(s2)), OPSZ_16);
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, s2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        instr_t *i3 = emit_vpand_xmm(dcontext, dst_reg, src1_reg, s2);
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, s2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(s2)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { // src1 and src2 spill
        reg_id_t s1 = find_one_available_spill_xmm(dst_reg);
        reg_id_t s2 = find_available_spill_xmm_avoiding(dst_reg, s1, DR_REG_NULL);
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, s1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(s1)), OPSZ_16);
        instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, s2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(s2)), OPSZ_16);
        instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, s1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, s2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        instr_t *i5 = emit_vpand_xmm(dcontext, dst_reg, s1, s2);
        instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, s2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(s2)), OPSZ_16);
        instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, s1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(s1)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 4: { // dst spill
        reg_id_t t = find_available_spill_xmm_avoiding(src1_reg, src2_reg, DR_REG_NULL);
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, t, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(t)), OPSZ_16);
        instr_t *i2 = emit_vpand_xmm(dcontext, t, src1_reg, src2_reg);
        instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, t, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, t, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(t)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 5: { // src1 and dst spill
        reg_id_t spill_src1_reg = find_available_spill_xmm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
        opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);
        opnd_t spill_dst_opnd = spill_src1_opnd;
        opnd_t src2_opnd = opnd_create_reg(src2_reg);

        // spill_src1_reg -> tls(spill_src1_reg) | spill src1
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls_slot(src1_reg) -> spill_src1_reg | get the input src
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vpandd spill_src1_reg, src2_reg, spill_src1_reg
        instr_t *i3 = INSTR_CREATE_vpand(dcontext, spill_dst_opnd, spill_src1_opnd, src2_opnd);
        // spill_src1_reg -> tls(dst_reg) | store the result back to dst_reg
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1_reg) -> spill_src1_reg | restore src1
        instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    case 6: { // src2 and dst spill
        reg_id_t spill_src2_reg = find_available_spill_xmm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
        opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);
        opnd_t spill_dst_opnd = spill_src2_opnd;
        opnd_t src1_opnd = opnd_create_reg(src1_reg);

        // spill_src2_reg -> tls(spill_src2_reg) | spill src2
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls_slot(src2_reg) -> spill_src2_reg | get the input src
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vpandd spill_src2_reg, src1_reg, spill_src2_reg
        instr_t *i3 = INSTR_CREATE_vpand(dcontext, spill_dst_opnd, src1_opnd, spill_src2_opnd);
        // spill_src2_reg -> tls(dst_reg) | store the result back to dst_reg
        instr_t *i4 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src2_reg) -> spill_src2_reg | restore src2
        instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    case 7: { // src1, src2 and dst spill
        return NULL_INSTR;
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpandd ymm and ymm not support");
    }
    return NULL_INSTR;
}

/**
 * @brief 615 vpandd rewrite function
 */
instr_t *
rw_func_vpandd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vpandd {%k0} %ymm30 %ymm1 -> %ymm2
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src_opnd1 = instr_get_src(instr, 1);
    opnd_t src_opnd2 = instr_get_src(instr, 2);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpandd", true, true, true, true);
#endif
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t src1_reg = opnd_get_reg(src_opnd1);
    reg_id_t src2_reg = opnd_get_reg(src_opnd2);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    if (IS_ZMM_REG(dst_reg)) {
        return vpandd_zmm_and_zmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
    }
    if (IS_YMM_REG(dst_reg)) {
        return vpandd_ymm_and_ymm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
    }
    if (IS_XMM_REG(dst_reg)) {
        return vpandd_xmm_and_xmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
    }
    REWRITE_ERROR(STD_ERRF, "vpandd pattern not support");
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vpandq
 * ============================================= */

instr_t *
vpandq_zmm_and_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg1, reg_id_t src_reg2,
                       reg_id_t dst_reg, reg_id_t mask_reg, opnd_t src1_opnd, opnd_t src2_opnd, opnd_t dst_opnd)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "vpandq zmm and zmm not support");
#endif
    return NULL_INSTR;
}

instr_t *
vpandq_ymm_and_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg, reg_id_t mask_reg, opnd_t src1_opnd, opnd_t src2_opnd, opnd_t dst_opnd)
{

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill = NEED_SPILL_YMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill = NEED_SPILL_YMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill = NEED_SPILL_YMM(dst_reg) ? 4 : 0;

    uint need_spill_flag = src1_need_spill | src2_need_spill | dst_need_spill;

    reg_id_t rax_reg = DR_REG_RAX;
    reg_id_t rcx_reg = DR_REG_RCX;
    reg_id_t r9_reg = DR_REG_R9;
    reg_id_t r10_reg = DR_REG_R10;
    reg_id_t rdx_reg = DR_REG_RDX;
    opnd_t rax_opnd = opnd_create_reg(rax_reg);
    opnd_t rcx_opnd = opnd_create_reg(rcx_reg);
    opnd_t r9_opnd = opnd_create_reg(r9_reg);
    opnd_t r10_opnd = opnd_create_reg(r10_reg);
    opnd_t rdx_opnd = opnd_create_reg(rdx_reg);

    switch (need_spill_flag) {
    case 0: { /* no need spill */
        // pushf
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // pushq %rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, rax_opnd);
        // pushq %rcx
        instr_t *i3 = INSTR_CREATE_push(dcontext, rcx_opnd);
        // pushq %r9
        instr_t *i4 = INSTR_CREATE_push(dcontext, r9_opnd);
        // pushq %r10
        instr_t *i5 = INSTR_CREATE_push(dcontext, r10_opnd);
        // pushq %rdx
        instr_t *i6 = INSTR_CREATE_push(dcontext, rdx_opnd);

        // sub     $96, %rsp                         # 96byte scratch
        instr_t *i7 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));
        // vmovdqu %src1,   32(%rsp)                   # spill [rsp+0] <=> src1
        instr_t *i8 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_32), src1_opnd);
        // vmovdqu %src2,  64(%rsp)                  # spill [rsp+32] <=> src2
        instr_t *i9 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_32), src2_opnd);

        // movq    32(%rsp), %rax                      # a0 = src1[0]
        instr_t *i10 =
            INSTR_CREATE_mov_ld(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_8));
        // and   64(%rsp),  %rax                   # a0 &= src2[0]
        instr_t *i11 =
            INSTR_CREATE_and(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_8));
        // movq    40(%rsp), %r9                      # a1 = src1[1]
        instr_t *i12 =
            INSTR_CREATE_mov_ld(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 40, OPSZ_8));
        // and   72(%rsp),  %r9                    # a1 &= src2[1]
        instr_t *i13 =
            INSTR_CREATE_and(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 72, OPSZ_8));
        // movq    48(%rsp), %rcx                    # a2 = src1[2]
        instr_t *i14 =
            INSTR_CREATE_mov_ld(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 48, OPSZ_8));
        // and   80(%rsp), %rcx                    # a2 &= src2[2]
        instr_t *i15 =
            INSTR_CREATE_and(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 80, OPSZ_8));
        // movq    56(%rsp), %r10                    # a3 = src1[3]
        instr_t *i16 =
            INSTR_CREATE_mov_ld(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 56, OPSZ_8));
        // and   88(%rsp), %r10                    # a3 &= src2[3]
        instr_t *i17 =
            INSTR_CREATE_and(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 88, OPSZ_8));

        // movq    %rax,  (%rsp)
        instr_t *i18 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8), rax_opnd);
        // movq    %r9,   8(%rsp)
        instr_t *i19 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8), r9_opnd);
        // movq    %rcx,  16(%rsp)
        instr_t *i20 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8), rcx_opnd);
        // movq    %r10,  24(%rsp)
        instr_t *i21 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8), r10_opnd);

        // vmovdqu (%rsp), %dst
        instr_t *i22 =
            INSTR_CREATE_vmovdqu(dcontext, dst_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));

        // add     $96, %rsp
        instr_t *i23 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));
        // popq    %rdx
        instr_t *i24 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RDX));
        // popq    %r10
        instr_t *i25 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R10));
        // popq    %r9
        instr_t *i26 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R9));
        // popq    %rcx
        instr_t *i27 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RCX));
        // popq    %rax
        instr_t *i28 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RAX));
        // popf
        instr_t *i29 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 29, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29);
#endif
        instrlist_concat_next_instr(ilist, 29, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29);
        return i1;
    } break;
    case 1: { /* only src1 need spill */
        reg_id_t spill_src1 = find_one_available_spill_ymm(src2_reg);
        opnd_t spill_src1_opnd = opnd_create_reg(spill_src1);

        // pushf
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // pushq %rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, rax_opnd);
        // pushq %rcx
        instr_t *i3 = INSTR_CREATE_push(dcontext, rcx_opnd);
        // pushq %r9
        instr_t *i4 = INSTR_CREATE_push(dcontext, r9_opnd);
        // pushq %r10
        instr_t *i5 = INSTR_CREATE_push(dcontext, r10_opnd);
        // pushq %rdx
        instr_t *i6 = INSTR_CREATE_push(dcontext, rdx_opnd);

        // sub     $96, %rsp                         # 96byte scratch
        instr_t *i7 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));

        // spill_src1 -> tls_slot(spill_src1)
        instr_t *i8 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1)), OPSZ_32);

        // tls_slot(src1) -> spill_src1
        instr_t *i9 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);

        // vmovdqu %spill_src1,   32(%rsp)           # spill [rsp+0] <=> src1
        instr_t *i10 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_32),
                                            spill_src1_opnd);
        // vmovdqu %src2,  64(%rsp)                  # spill [rsp+32] <=> src2
        instr_t *i11 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_32), src2_opnd);

        // tls_slot(spill_src1) -> spill_src1
        instr_t *i12 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1)), OPSZ_32);

        // movq    32(%rsp), %rax                     # a0 = src1[0]
        instr_t *i13 =
            INSTR_CREATE_mov_ld(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_8));
        // and   64(%rsp),  %rax                    # a0 *= src2[0]
        instr_t *i14 =
            INSTR_CREATE_and(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_8));
        // movq    40(%rsp), %r9                      # a1 = src1[1]
        instr_t *i15 =
            INSTR_CREATE_mov_ld(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 40, OPSZ_8));
        // and   72(%rsp),  %r9                    # a1 *= src2[1]
        instr_t *i16 =
            INSTR_CREATE_and(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 72, OPSZ_8));
        // movq    48(%rsp), %rcx                    # a2 = src1[2]
        instr_t *i17 =
            INSTR_CREATE_mov_ld(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 48, OPSZ_8));
        // and   80(%rsp), %rcx                    # a2 *= src2[2]
        instr_t *i18 =
            INSTR_CREATE_and(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 80, OPSZ_8));
        // movq    56(%rsp), %r10                    # a3 = src1[3]
        instr_t *i19 =
            INSTR_CREATE_mov_ld(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 56, OPSZ_8));
        // and   88(%rsp), %r10                    # a3 *= src2[3]
        instr_t *i20 =
            INSTR_CREATE_and(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 88, OPSZ_8));

        // movq    %rax,  (%rsp)
        instr_t *i21 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8), rax_opnd);
        // movq    %r9,   8(%rsp)
        instr_t *i22 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8), r9_opnd);
        // movq    %rcx,  16(%rsp)
        instr_t *i23 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8), rcx_opnd);
        // movq    %r10,  24(%rsp)
        instr_t *i24 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8), r10_opnd);

        // vmovdqu (%rsp), %dst
        instr_t *i25 =
            INSTR_CREATE_vmovdqu(dcontext, dst_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));

        // add     $96, %rsp
        instr_t *i26 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));

        // popq    %rdx
        instr_t *i27 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RDX));
        // popq    %r10
        instr_t *i28 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R10));
        // popq    %r9
        instr_t *i29 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R9));
        // popq    %rcx
        instr_t *i30 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RCX));
        // popq    %rax
        instr_t *i31 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RAX));
        // popf
        instr_t *i32 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 32, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32);
#endif
        instrlist_concat_next_instr(ilist, 32, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32);
        return i1;
    } break;
    case 2: { /* only src2 need spill */
        reg_id_t spill_src2 = find_one_available_spill_ymm(src1_reg);
        opnd_t spill_src2_opnd = opnd_create_reg(spill_src2);

        // pushf
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // pushq %rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, rax_opnd);
        // pushq %rcx
        instr_t *i3 = INSTR_CREATE_push(dcontext, rcx_opnd);
        // pushq %r9
        instr_t *i4 = INSTR_CREATE_push(dcontext, r9_opnd);
        // pushq %r10
        instr_t *i5 = INSTR_CREATE_push(dcontext, r10_opnd);
        // pushq %rdx
        instr_t *i6 = INSTR_CREATE_push(dcontext, rdx_opnd);

        // sub     $96, %rsp                         # 96byte scratch
        instr_t *i7 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));

        // spill_src2 -> tls_slot(spill_src2)
        instr_t *i8 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2)), OPSZ_32);

        // tls_slot(src2) -> spill_src2
        instr_t *i9 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);

        // vmovdqu %src1,   32(%rsp)           # spill [rsp+0] <=> src1
        instr_t *i10 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_32), src1_opnd);
        // vmovdqu spill_src2,  64(%rsp)       # spill [rsp+32] <=> src2
        instr_t *i11 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_32),
                                            spill_src2_opnd);

        // tls_slot(spill_src2) -> spill_src2
        instr_t *i12 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2)), OPSZ_32);

        // movq    32(%rsp), %rax                     # a0 = src1[0]
        instr_t *i13 =
            INSTR_CREATE_mov_ld(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_8));
        // and   64(%rsp),  %rax                    # a0 *= src2[0]
        instr_t *i14 =
            INSTR_CREATE_and(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_8));
        // movq    40(%rsp), %r9                      # a1 = src1[1]
        instr_t *i15 =
            INSTR_CREATE_mov_ld(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 40, OPSZ_8));
        // and   72(%rsp),  %r9                    # a1 *= src2[1]
        instr_t *i16 =
            INSTR_CREATE_and(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 72, OPSZ_8));
        // movq    48(%rsp), %rcx                    # a2 = src1[2]
        instr_t *i17 =
            INSTR_CREATE_mov_ld(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 48, OPSZ_8));
        // and   80(%rsp), %rcx                    # a2 *= src2[2]
        instr_t *i18 =
            INSTR_CREATE_and(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 80, OPSZ_8));
        // movq    56(%rsp), %r10                    # a3 = src1[3]
        instr_t *i19 =
            INSTR_CREATE_mov_ld(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 56, OPSZ_8));
        // and   88(%rsp), %r10                    # a3 *= src2[3]
        instr_t *i20 =
            INSTR_CREATE_and(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 88, OPSZ_8));

        // movq    %rax,  (%rsp)
        instr_t *i21 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8), rax_opnd);
        // movq    %r9,   8(%rsp)
        instr_t *i22 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8), r9_opnd);
        // movq    %rcx,  16(%rsp)
        instr_t *i23 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8), rcx_opnd);
        // movq    %r10,  24(%rsp)
        instr_t *i24 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8), r10_opnd);

        // vmovdqu (%rsp), %dst
        instr_t *i25 =
            INSTR_CREATE_vmovdqu(dcontext, dst_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));

        // add     $96, %rsp
        instr_t *i26 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));

        // popq    %rdx
        instr_t *i27 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RDX));
        // popq    %r10
        instr_t *i28 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R10));
        // popq    %r9
        instr_t *i29 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R9));
        // popq    %rcx
        instr_t *i30 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RCX));
        // popq    %rax
        instr_t *i31 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RAX));
        // popf
        instr_t *i32 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 32, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32);
#endif
        instrlist_concat_next_instr(ilist, 32, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32);
        return i1;
    } break;
    case 3: { /* src1 and src2 need spill */
        // NOTE: if src1 == src2, should handle differently
        reg_id_t spill_src1_reg = find_one_available_spill_ymm(dst_reg);
        reg_id_t spill_src2_reg = find_available_spill_ymm_avoiding(dst_reg, spill_src1_reg, DR_REG_NULL);
        opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);
        opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);
        opnd_t dst_opnd = opnd_create_reg(dst_reg);

        // pushf
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // pushq %rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, rax_opnd);
        // pushq %rcx
        instr_t *i3 = INSTR_CREATE_push(dcontext, rcx_opnd);
        // pushq %r9
        instr_t *i4 = INSTR_CREATE_push(dcontext, r9_opnd);
        // pushq %r10
        instr_t *i5 = INSTR_CREATE_push(dcontext, r10_opnd);
        // pushq %rdx
        instr_t *i6 = INSTR_CREATE_push(dcontext, rdx_opnd);

        // sub     $96, %rsp                         # 96byte scratch
        instr_t *i7 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));

        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i8 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i9 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i10 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i11 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);

        // vmovdqu spill_src1, 32(%rsp)
        instr_t *i12 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_32),
                                            spill_src1_opnd);
        // vmovdqu spill_src2, 64(%rsp)
        instr_t *i13 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_32),
                                            spill_src2_opnd);
        // movq    32(%rsp), %rax                      # a0 = src1[0]
        instr_t *i14 =
            INSTR_CREATE_mov_ld(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_8));
        // and   64(%rsp),  %rax                   # a0 *= src2[0]
        instr_t *i15 =
            INSTR_CREATE_and(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_8));
        // movq    40(%rsp), %r9                      # a1 = src1[1]
        instr_t *i16 =
            INSTR_CREATE_mov_ld(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 40, OPSZ_8));
        // and   72(%rsp),  %r9                    # a1 *= src2[1]
        instr_t *i17 =
            INSTR_CREATE_and(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 72, OPSZ_8));
        // movq    48(%rsp), %rcx                    # a2 = src1[2]
        instr_t *i18 =
            INSTR_CREATE_mov_ld(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 48, OPSZ_8));
        // and   80(%rsp), %rcx                    # a2 *= src2[2]
        instr_t *i19 =
            INSTR_CREATE_and(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 80, OPSZ_8));
        // movq    56(%rsp), %r10                    # a3 = src1[3]
        instr_t *i20 =
            INSTR_CREATE_mov_ld(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 56, OPSZ_8));
        // and   88(%rsp), %r10                    # a3 *= src2[3]
        instr_t *i21 =
            INSTR_CREATE_and(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 88, OPSZ_8));

        // movq    %rax,  (%rsp)
        instr_t *i22 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8), rax_opnd);
        // movq    %r9,   8(%rsp)
        instr_t *i23 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8), r9_opnd);
        // movq    %rcx,  16(%rsp)
        instr_t *i24 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8), rcx_opnd);
        // movq    %r10,  24(%rsp)
        instr_t *i25 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8), r10_opnd);

        // vmovdqu (%rsp), %dst
        instr_t *i26 =
            INSTR_CREATE_vmovdqu(dcontext, dst_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));

        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i27 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i28 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);

        // add     $96, %rsp
        instr_t *i29 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));

        // popq    %rdx
        instr_t *i30 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RDX));
        // popq    %r10
        instr_t *i31 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R10));
        // popq    %r9
        instr_t *i32 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R9));
        // popq    %rcx
        instr_t *i33 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RCX));
        // popq    %rax
        instr_t *i34 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RAX));
        // popf
        instr_t *i35 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 35, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32, i33, i34, i35);
#endif
        instrlist_concat_next_instr(ilist, 35, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32, i33,
                                    i34, i35);
        return i1;
    } break;
    case 4: { /* only dst need spill */
        reg_id_t spill_dst_reg = find_available_spill_ymm_avoiding(src1_reg, src2_reg, DR_REG_NULL);
        opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);

        // pushf
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // pushq %rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, rax_opnd);
        // pushq %rcx
        instr_t *i3 = INSTR_CREATE_push(dcontext, rcx_opnd);
        // pushq %r9
        instr_t *i4 = INSTR_CREATE_push(dcontext, r9_opnd);
        // pushq %r10
        instr_t *i5 = INSTR_CREATE_push(dcontext, r10_opnd);
        // pushq %rdx
        instr_t *i6 = INSTR_CREATE_push(dcontext, rdx_opnd);

        // sub     $96, %rsp                         # 96byte scratch
        instr_t *i7 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));
        // vmovdqu %src1,   32(%rsp)                   # spill [rsp+0] <=> src1
        instr_t *i8 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_32), src1_opnd);
        // vmovdqu %src2,  64(%rsp)                  # spill [rsp+32] <=> src2
        instr_t *i9 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_32), src2_opnd);

        // movq    32(%rsp), %rax                      # a0 = src1[0]
        instr_t *i10 =
            INSTR_CREATE_mov_ld(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_8));
        // and   64(%rsp),  %rax                   # a0 *= src2[0]
        instr_t *i11 =
            INSTR_CREATE_and(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_8));
        // movq    40(%rsp), %r9                      # a1 = src1[1]
        instr_t *i12 =
            INSTR_CREATE_mov_ld(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 40, OPSZ_8));
        // and   72(%rsp),  %r9                    # a1 *= src2[1]
        instr_t *i13 =
            INSTR_CREATE_and(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 72, OPSZ_8));
        // movq    48(%rsp), %rcx                    # a2 = src1[2]
        instr_t *i14 =
            INSTR_CREATE_mov_ld(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 48, OPSZ_8));
        // and   80(%rsp), %rcx                    # a2 *= src2[2]
        instr_t *i15 =
            INSTR_CREATE_and(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 80, OPSZ_8));
        // movq    56(%rsp), %r10                    # a3 = src1[3]
        instr_t *i16 =
            INSTR_CREATE_mov_ld(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 56, OPSZ_8));
        // and   88(%rsp), %r10                    # a3 *= src2[3]
        instr_t *i17 =
            INSTR_CREATE_and(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 88, OPSZ_8));

        // movq    %rax,  (%rsp)
        instr_t *i18 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8), rax_opnd);
        // movq    %r9,   8(%rsp)
        instr_t *i19 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8), r9_opnd);
        // movq    %rcx,  16(%rsp)
        instr_t *i20 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8), rcx_opnd);
        // movq    %r10,  24(%rsp)
        instr_t *i21 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8), r10_opnd);

        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *i22 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        // vmovdqu (%rsp), %spill_dst_reg
        instr_t *i23 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd,
                                            opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i24 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *i25 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);

        // add     $96, %rsp
        instr_t *i26 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));
        // popq    %rdx
        instr_t *i27 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RDX));
        // popq    %r10
        instr_t *i28 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R10));
        // popq    %r9
        instr_t *i29 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R9));
        // popq    %rcx
        instr_t *i30 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RCX));
        // popq    %rax
        instr_t *i31 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RAX));
        // popf
        instr_t *i32 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 32, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32);
#endif
        instrlist_concat_next_instr(ilist, 32, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32);
        return i1;
    } break;
    case 5: { /* src1 and dst need spill */
        reg_id_t spill_src1_reg = find_one_available_spill_ymm(src2_reg);
        reg_id_t spill_dst_reg = spill_src1_reg;
        opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);
        opnd_t spill_dst_opnd = spill_src1_opnd;

        // notice: spill src1 and spill dst can use the same spill register

        // pushf
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // pushq %rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, rax_opnd);
        // pushq %rcx
        instr_t *i3 = INSTR_CREATE_push(dcontext, rcx_opnd);
        // pushq %r9
        instr_t *i4 = INSTR_CREATE_push(dcontext, r9_opnd);
        // pushq %r10
        instr_t *i5 = INSTR_CREATE_push(dcontext, r10_opnd);
        // pushq %rdx
        instr_t *i6 = INSTR_CREATE_push(dcontext, rdx_opnd);

        // sub     $96, %rsp                         # 96byte scratch
        instr_t *i7 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));

        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i8 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i9 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
        // vmovdqu spill_src1_reg,   32(%rsp)                   # spill [rsp+0] <=> src1
        instr_t *i10 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_32),
                                            spill_src1_opnd);
        // vmovdqu %src2,  64(%rsp)                  # spill [rsp+32] <=> src2
        instr_t *i11 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_32), src2_opnd);

        // movq    32(%rsp), %rax                      # a0 = src1[0]
        instr_t *i12 =
            INSTR_CREATE_mov_ld(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_8));
        // and   64(%rsp),  %rax                   # a0 *= src2[0]
        instr_t *i13 =
            INSTR_CREATE_and(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_8));
        // movq    40(%rsp), %r9                      # a1 = src1[1]
        instr_t *i14 =
            INSTR_CREATE_mov_ld(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 40, OPSZ_8));
        // and   72(%rsp),  %r9                    # a1 *= src2[1]
        instr_t *i15 =
            INSTR_CREATE_and(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 72, OPSZ_8));
        // movq    48(%rsp), %rcx                    # a2 = src1[2]
        instr_t *i16 =
            INSTR_CREATE_mov_ld(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 48, OPSZ_8));
        // and   80(%rsp), %rcx                    # a2 *= src2[2]
        instr_t *i17 =
            INSTR_CREATE_and(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 80, OPSZ_8));
        // movq    56(%rsp), %r10                    # a3 = src1[3]
        instr_t *i18 =
            INSTR_CREATE_mov_ld(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 56, OPSZ_8));
        // and   88(%rsp), %r10                    # a3 *= src2[3]
        instr_t *i19 =
            INSTR_CREATE_and(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 88, OPSZ_8));

        // movq    %rax,  (%rsp)
        instr_t *i20 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8), rax_opnd);
        // movq    %r9,   8(%rsp)
        instr_t *i21 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8), r9_opnd);
        // movq    %rcx,  16(%rsp)
        instr_t *i22 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8), rcx_opnd);
        // movq    %r10,  24(%rsp)
        instr_t *i23 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8), r10_opnd);

        // vmovdqu (%rsp), %spill_dst_reg
        instr_t *i24 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd,
                                            opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i25 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);

        // tls(spill_dst_reg) -> spill_dst_reg | is now the same as spill_src1_reg
        instr_t *i26 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);

        // add     $96, %rsp
        instr_t *i27 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));
        // popq    %rdx
        instr_t *i28 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RDX));
        // popq    %r10
        instr_t *i29 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R10));
        // popq    %r9
        instr_t *i30 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R9));
        // popq    %rcx
        instr_t *i31 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RCX));
        // popq    %rax
        instr_t *i32 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RAX));
        // popf
        instr_t *i33 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 33, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32, i33);
#endif
        instrlist_concat_next_instr(ilist, 33, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32,
                                    i33);
        return i1;
    } break;
    case 6: { /* src2 and dst need spill */
        reg_id_t spill_src2_reg = find_one_available_spill_ymm(src1_reg);
        reg_id_t spill_dst_reg = spill_src2_reg;
        opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);
        opnd_t spill_dst_opnd = spill_src2_opnd;

        // notice: spill src2 and spill dst can use the same spill register

        // pushf
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // pushq %rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, rax_opnd);
        // pushq %rcx
        instr_t *i3 = INSTR_CREATE_push(dcontext, rcx_opnd);
        // pushq %r9
        instr_t *i4 = INSTR_CREATE_push(dcontext, r9_opnd);
        // pushq %r10
        instr_t *i5 = INSTR_CREATE_push(dcontext, r10_opnd);
        // pushq %rdx
        instr_t *i6 = INSTR_CREATE_push(dcontext, rdx_opnd);

        // sub     $96, %rsp                         # 96byte scratch
        instr_t *i7 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));

        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i8 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i9 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
        // vmovdqu src1_reg,   32(%rsp)                   # spill [rsp+0] <=> src1
        instr_t *i10 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_32), src1_opnd);
        // vmovdqu spill_src2_reg,  64(%rsp)                  # spill [rsp+32] <=> spill_src2
        instr_t *i11 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_32),
                                            spill_src2_opnd);

        // movq    32(%rsp), %rax                      # a0 = src1[0]
        instr_t *i12 =
            INSTR_CREATE_mov_ld(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_8));
        // and   64(%rsp),  %rax                   # a0 *= src2[0]
        instr_t *i13 =
            INSTR_CREATE_and(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_8));
        // movq    40(%rsp), %r9                      # a1 = src1[1]
        instr_t *i14 =
            INSTR_CREATE_mov_ld(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 40, OPSZ_8));
        // and   72(%rsp),  %r9                    # a1 *= src2[1]
        instr_t *i15 =
            INSTR_CREATE_and(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 72, OPSZ_8));
        // movq    48(%rsp), %rcx                    # a2 = src1[2]
        instr_t *i16 =
            INSTR_CREATE_mov_ld(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 48, OPSZ_8));
        // and   80(%rsp), %rcx                    # a2 *= src2[2]
        instr_t *i17 =
            INSTR_CREATE_and(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 80, OPSZ_8));
        // movq    56(%rsp), %r10                    # a3 = src1[3]
        instr_t *i18 =
            INSTR_CREATE_mov_ld(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 56, OPSZ_8));
        // and   88(%rsp), %r10                    # a3 *= src2[3]
        instr_t *i19 =
            INSTR_CREATE_and(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 88, OPSZ_8));

        // movq    %rax,  (%rsp)
        instr_t *i20 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8), rax_opnd);
        // movq    %r9,   8(%rsp)
        instr_t *i21 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8), r9_opnd);
        // movq    %rcx,  16(%rsp)
        instr_t *i22 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8), rcx_opnd);
        // movq    %r10,  24(%rsp)
        instr_t *i23 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8), r10_opnd);

        // vmovdqu (%rsp), %spill_dst_reg
        instr_t *i24 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd,
                                            opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i25 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);

        // tls(spill_dst_reg) -> spill_dst_reg | is now the same as spill_src1_reg
        instr_t *i26 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);

        // add     $96, %rsp
        instr_t *i27 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));
        // popq    %rdx
        instr_t *i28 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RDX));
        // popq    %r10
        instr_t *i29 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R10));
        // popq    %r9
        instr_t *i30 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R9));
        // popq    %rcx
        instr_t *i31 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RCX));
        // popq    %rax
        instr_t *i32 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RAX));
        // popf
        instr_t *i33 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 33, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32, i33);
#endif
        instrlist_concat_next_instr(ilist, 33, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32,
                                    i33);
        return i1;
    } break;
    case 7: { /* src1, src2 and dst need spill */
        reg_id_t spill_src1_reg = YMM_SPILL_SLOT0;
        reg_id_t spill_src2_reg = YMM_SPILL_SLOT1;
        reg_id_t spill_dst_reg = spill_src1_reg;

        opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);
        opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);
        opnd_t spill_dst_opnd = spill_src1_opnd;

        // pushf
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // pushq %rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, rax_opnd);
        // pushq %rcx
        instr_t *i3 = INSTR_CREATE_push(dcontext, rcx_opnd);
        // pushq %r9
        instr_t *i4 = INSTR_CREATE_push(dcontext, r9_opnd);
        // pushq %r10
        instr_t *i5 = INSTR_CREATE_push(dcontext, r10_opnd);
        // pushq %rdx
        instr_t *i6 = INSTR_CREATE_push(dcontext, rdx_opnd);
        // sub     $96, %rsp                       # 96byte scratch
        instr_t *i7 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i8 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);

        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i9 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);

        // tls(src1_reg) -> spill_src1_reg
        instr_t *i10 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i11 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);

        // vmovdqu spill_src1_reg,   32(%rsp)                 # spill [rsp+0] <=> spill_src1
        instr_t *i12 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_32),
                                            spill_src1_opnd);
        // vmovdqu spill_src2_reg,  64(%rsp)                  # spill [rsp+32] <=> spill_src2
        instr_t *i13 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_32),
                                            spill_src2_opnd);

        // movq    32(%rsp), %rax                     # a0 = src1[0]
        instr_t *i14 =
            INSTR_CREATE_mov_ld(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_8));
        // and   64(%rsp),  %rax                    # a0 *= src2[0]
        instr_t *i15 =
            INSTR_CREATE_and(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_8));
        // movq    40(%rsp), %r9                      # a1 = src1[1]
        instr_t *i16 =
            INSTR_CREATE_mov_ld(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 40, OPSZ_8));
        // and   72(%rsp),  %r9                     # a1 *= src2[1]
        instr_t *i17 =
            INSTR_CREATE_and(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 72, OPSZ_8));
        // movq    48(%rsp), %rcx                     # a2 = src1[2]
        instr_t *i18 =
            INSTR_CREATE_mov_ld(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 48, OPSZ_8));
        // and   80(%rsp), %rcx                     # a2 *= src2[2]
        instr_t *i19 =
            INSTR_CREATE_and(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 80, OPSZ_8));
        // movq    56(%rsp), %r10                     # a3 = src1[3]
        instr_t *i20 =
            INSTR_CREATE_mov_ld(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 56, OPSZ_8));
        // and   88(%rsp), %r10                     # a3 *= src2[3]
        instr_t *i21 =
            INSTR_CREATE_and(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 88, OPSZ_8));

        // movq    %rax,  (%rsp)
        instr_t *i22 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8), rax_opnd);
        // movq    %r9,   8(%rsp)
        instr_t *i23 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8), r9_opnd);
        // movq    %rcx,  16(%rsp)
        instr_t *i24 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8), rcx_opnd);
        // movq    %r10,  24(%rsp)
        instr_t *i25 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8), r10_opnd);

        // vmovdqu (%rsp), %spill_dst_reg
        instr_t *i26 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd,
                                            opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i27 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);

        // tls(spill_dst_reg) -> spill_dst_reg | is now the same as spill_src1_reg
        instr_t *i28 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);

        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i29 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);

        // add     $96, %rsp
        instr_t *i30 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));
        // popq    %rdx
        instr_t *i31 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RDX));
        // popq    %r10
        instr_t *i32 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R10));
        // popq    %r9
        instr_t *i33 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R9));
        // popq    %rcx
        instr_t *i34 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RCX));
        // popq    %rax
        instr_t *i35 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RAX));
        // popf
        instr_t *i36 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 36, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32, i33, i34, i35, i36);
#endif
        instrlist_concat_next_instr(ilist, 36, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32, i33,
                                    i34, i35, i36);
        return i1;
    } break;
    default: {
        REWRITE_ERROR(STD_ERRF, "vpandq ymm and ymm not support");
        return NULL_INSTR;
    }
    }
}

instr_t *
vpandq_xmm_and_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg, reg_id_t mask_reg, opnd_t src1_opnd, opnd_t src2_opnd, opnd_t dst_opnd)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill_flag = NEED_SPILL_XMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 4 : 0;
    const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

    switch (need_spill_flag) {
    case 0: { /* no spill */
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        instr_t *i1 = INSTR_CREATE_vpand(dcontext, op_dst, op_src1, op_src2);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    } break;
    case 1: { /* src1 need spill */
        // vpand {%k0} %xmm23 %xmm13 -> %xmm13
        reg_id_t spill_src1_reg = DR_REG_NULL;
        if (src2_reg == dst_reg) {
            spill_src1_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src1_reg = find_available_spill_xmm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vpand spill_src1_reg src2_reg -> dst_reg
        instr_t *i3 = INSTR_CREATE_vpand(dcontext, op_dst, op_spill_src1, op_src2);
        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 2: { /* src2 need spill */
        // vpand {%k0} %xmm11 %xmm23 -> %xmm11
        reg_id_t spill_src2_reg = DR_REG_NULL;
        if (src1_reg == dst_reg) {
            spill_src2_reg = find_one_available_spill_xmm(src2_reg);
        } else {
            spill_src2_reg = find_available_spill_xmm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
        }
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_dst = opnd_create_reg(dst_reg);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vpand src1_reg spill_src2_reg -> dst_reg
        instr_t *i3 = INSTR_CREATE_vpand(dcontext, op_dst, op_src1, op_spill_src2);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 3: { /* both src need spill */
        reg_id_t spill_src1 = find_one_available_spill_xmm(dst_reg);
        reg_id_t spill_src2 = find_available_spill_xmm_avoiding(spill_src1, dst_reg, DR_REG_NULL);

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1);
        opnd_t op_spill_src2 = opnd_create_reg(spill_src2);
        opnd_t op_dst = opnd_create_reg(dst_reg);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1)), OPSZ_16);
        // spill_src2 -> tls(spill_src2)
        instr_t *i2 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i3 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // tls(src2) -> spill_srrc2
        instr_t *i4 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vpand spill_src1 spill_src2 -> dst
        instr_t *i5 = INSTR_CREATE_vpand(dcontext, op_dst, op_spill_src1, op_spill_src2);
        // tls(spill_src1) -> spill_src1
        instr_t *i6 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1)), OPSZ_16);
        // tls(spill_src2) -> spill_src2
        instr_t *i7 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } break;
    case 4: { /* dst need spill */
        // vpand {%k0} %xmm5 %xmm0 -> %xmm22
        reg_id_t spill_dst_reg = find_available_spill_xmm_avoiding(src1_reg, src2_reg, DR_REG_NULL);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_src2 = opnd_create_reg(src2_reg);

        // spill_dst -> tls(spill_dst)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
        // vpand src1 src2 -> spill_dst
        instr_t *i2 = INSTR_CREATE_vpand(dcontext, op_spill_dst, op_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i3 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_dst) -> spill_dst
        instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } break;
    case 5: { /* src1 and dst need spill */
        // vpand {%k0} %xmm22 %xmm1 -> %xmm22
        reg_id_t spill_src1 = find_one_available_spill_xmm(src2_reg);
        reg_id_t spill_dst = spill_src1;

        opnd_t op_spill_src1 = opnd_create_reg(spill_src1);
        opnd_t op_src2 = opnd_create_reg(src2_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
        // vpand spill_src1 src2 -> spill_src1
        instr_t *i3 = INSTR_CREATE_vpand(dcontext, op_spill_dst, op_spill_src1, op_src2);
        // spill_dst -> tls(dst)
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i5 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    case 6: { /* src2 and dst need spill */
        // vpand {%k0} %xmm1 %xmm22 -> %xmm22
        reg_id_t spill_src2 = find_one_available_spill_xmm(src1_reg);
        reg_id_t spill_dst = spill_src2;

        opnd_t op_spill_src2 = opnd_create_reg(spill_src2);
        opnd_t op_src1 = opnd_create_reg(src1_reg);
        opnd_t op_spill_dst = opnd_create_reg(spill_dst);

        // spill_src1 -> tls(spill_src1)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2)), OPSZ_16);
        // tls(src1) -> spill_src1
        instr_t *i2 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
        // vpand spill_src1 src2 -> spill_src1
        instr_t *i3 = INSTR_CREATE_vpand(dcontext, op_spill_dst, op_src1, op_spill_src2);
        // spill_dst -> tls(dst)
        instr_t *i4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
        // tls(spill_src1) -> spill_src1
        instr_t *i5 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, src1_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
        return i1;
    } break;
    case 7: { /* all need spill */
        if (src1_reg == dst_reg && src2_reg == dst_reg) {
            reg_id_t spill_reg = XMM_SPILL_SLOT0;
            opnd_t op_spill = opnd_create_reg(spill_reg);
            // spill -> tls_slot(spill)
            instr_t *i1 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
            // tls(src1) -> spill
            instr_t *i2 =
                RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // vpand spill spill -> spill
            instr_t *i3 = INSTR_CREATE_vpand(dcontext, op_spill, op_spill, op_spill);
            // spill -> tls(dst)
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill) -> spill
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } else if (src1_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vpand spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpand(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else if (src2_reg == dst_reg) {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src2_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vpand spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpand(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } else {
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = spill_src1_reg;

            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // spill_src1 -> tls(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2 -> tls(spill_src2)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls(src1) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls(src2) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vpand spill_src1 spill_src2 -> spill_dst
            instr_t *i5 = INSTR_CREATE_vpand(dcontext, op_spill_dst, op_spill_src1, op_spill_src2);
            // spill_dst -> tls(dst)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls(spill_src1) -> spill_src1
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls(spill_src2) -> spill_src2
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        }
    } break;
    default: {
        REWRITE_INFO(STD_OUTF, "vpand xmm and xmm pattern not support\n");
    } break;
    }
    return NULL_INSTR;
}

/**
 * @brief 618 vpandq rewrite function
 */
instr_t *
rw_func_vpandq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vpandq {%k0} %ymm4 %ymm5 -> %ymm23
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src_opnd1 = instr_get_src(instr, 1);
    opnd_t src_opnd2 = instr_get_src(instr, 2);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpandq", true, true, true, true);
#endif
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t src1_reg = opnd_get_reg(src_opnd1);
    reg_id_t src2_reg = opnd_get_reg(src_opnd2);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    if (IS_ZMM_REG(dst_reg)) {
        return vpandq_zmm_and_zmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg, src_opnd1,
                                      src_opnd2, dst_opnd);
    }
    if (IS_YMM_REG(dst_reg)) {
        return vpandq_ymm_and_ymm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg, src_opnd1,
                                      src_opnd2, dst_opnd);
    }
    if (IS_XMM_REG(dst_reg)) {
        return vpandq_xmm_and_xmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg, src_opnd1,
                                      src_opnd2, dst_opnd);
    }
    REWRITE_ERROR(STD_ERRF, "vpandq pattern not support");
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vpcmpd
 * ============================================= */

instr_t * /* 0x00 */
rw_func_vpcmpd_EQ_ymm_ymm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg, opnd_t src1_opnd,
                          opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    // NOTE: this has a scalar implementation counterpart, but I don't want to write it here
    // vpcmpd {%k2} $0x00 %ymm0 %ymm2 -> %k5
    //     [REWRITE INFO]:   ymm_bitmap: 0
    //     mask: %k2
    //     src1: %ymm0
    //     src2: %ymm2
    //     dst: %k5

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    int input_mask_idx = TO_K_REG_INDEX(mask_reg);
    int output_mask_idx = TO_K_REG_INDEX(dst_mask_reg);

    const uint src1_need_spill = NEED_SPILL_YMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill = NEED_SPILL_YMM(src2_reg) ? 2 : 0;
    const uint need_spill = src1_need_spill | src2_need_spill;

    switch (need_spill) {
    case 0: { // no spill
        if (input_mask_idx == 0) {
            // vpcmpd {%k0} $0x00 %ymm0 %ymm2 -> %k5
            instr_t *LOOP_EQ_K0 = INSTR_CREATE_label(dcontext);
            instr_t *MATCH_EQ_K0 = INSTR_CREATE_label(dcontext);
            instr_t *DONE_EQ_K0 = INSTR_CREATE_label(dcontext);

            opnd_t opnd_rbx = opnd_create_reg(DR_REG_RBX);
            opnd_t opnd_rcx = opnd_create_reg(DR_REG_RCX);
            opnd_t opnd_r9 = opnd_create_reg(DR_REG_R9);
            opnd_t opnd_r10 = opnd_create_reg(DR_REG_R10);
            opnd_t opnd_r11 = opnd_create_reg(DR_REG_R11);
            opnd_t opnd_r12 = opnd_create_reg(DR_REG_R12);
            opnd_t opnd_r13 = opnd_create_reg(DR_REG_R13);
            opnd_t opnd_r14 = opnd_create_reg(DR_REG_R14);

            // save rax, rbx, rcx, r9, r10, r11, r12, r13, r14
            instr_t *i1 = INSTR_CREATE_push(dcontext, opnd_rbx);
            instr_t *i2 = INSTR_CREATE_push(dcontext, opnd_rcx);
            instr_t *i3 = INSTR_CREATE_push(dcontext, opnd_r9);
            instr_t *i4 = INSTR_CREATE_push(dcontext, opnd_r10);
            instr_t *i5 = INSTR_CREATE_push(dcontext, opnd_r11);
            instr_t *i6 = INSTR_CREATE_push(dcontext, opnd_r12);
            instr_t *i7 = INSTR_CREATE_push(dcontext, opnd_r13);
            instr_t *i8 = INSTR_CREATE_push(dcontext, opnd_r14);

            // pushf
            instr_t *i9 = INSTR_CREATE_pushf(dcontext);

            //  sub $64, %rsp
            instr_t *i10 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            //  vmovdqu %ymm0, (%rsp)
            instr_t *i11 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32),
                                                src1_opnd);

            //  vmovdqu %ymm2, 32(%rsp)
            instr_t *i12 = INSTR_CREATE_vmovdqu(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, SIZE_OF_YMM, OPSZ_32), src2_opnd);

            //  r9d = tls(output_mask) | accmulate mask result
            instr_t *i13 = RESTORE_FROM_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

            //  xor %ebx, %ebx  | j = 0
            instr_t *i14 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_reg(DR_REG_EBX));

            // NOTE: /* .LoopEq_k0 */

            // mov (%rsp, %rbx, 4), %r13d
            instr_t *i15 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R13D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, 0, OPSZ_4));

            // mov 32(%rsp, %rbx, 4), %r14d
            instr_t *i16 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R14D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, SIZE_OF_YMM, OPSZ_4));

            // cmp %r14d, %r13d
            instr_t *i17 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_R13D), opnd_create_reg(DR_REG_R14D));

            // je .MatchEq_k0
            instr_t *i18 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(MATCH_EQ_K0));

            // btr %r9d, %ebx
            instr_t *i19 = INSTR_CREATE_btr(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // NOTE: /* .NextIter_k0 */
            // inc %ebx
            instr_t *i20 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // cmp $8, %ebx
            instr_t *i21 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // jl .LoopEq_k0
            instr_t *i22 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_EQ_K0));

            // jmp .DoneEq_k0
            instr_t *i23 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(DONE_EQ_K0));

            // NOTE: /* MatchEq_k0 */
            // bts %r9d, %ebx
            instr_t *i24 = INSTR_CREATE_bts(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // inc %ebx
            instr_t *i25 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // cmp $8, %ebx
            instr_t *i26 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // jl .LoopEq_k0
            instr_t *i27 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_EQ_K0));

            // NOTE: /* .DoneEq_k0 */
            // and $0x00FF, %r9d
            instr_t *i28 =
                INSTR_CREATE_and(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_immed_int(0x00FF, OPSZ_4));
            // mov %r9, tls(output_mask)
            instr_t *i29 = SAVE_TO_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

            // add $64, %rsp
            instr_t *i30 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            // popf
            instr_t *i31 = INSTR_CREATE_popf(dcontext);

            // restore rax, rbx, rcx, r9, r10, r11, r12...
            instr_t *i32 = INSTR_CREATE_pop(dcontext, opnd_r14);
            instr_t *i33 = INSTR_CREATE_pop(dcontext, opnd_r13);
            instr_t *i34 = INSTR_CREATE_pop(dcontext, opnd_r12);
            instr_t *i35 = INSTR_CREATE_pop(dcontext, opnd_r11);
            instr_t *i36 = INSTR_CREATE_pop(dcontext, opnd_r10);
            instr_t *i37 = INSTR_CREATE_pop(dcontext, opnd_r9);
            instr_t *i38 = INSTR_CREATE_pop(dcontext, opnd_rcx);
            instr_t *i39 = INSTR_CREATE_pop(dcontext, opnd_rbx);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 42, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14,
                                         LOOP_EQ_K0, i15, i16, i17, i18, i19, /* NEXT_ITER_K0 (i20) */ i20, i21, i22,
                                         i23, MATCH_EQ_K0, i24, i25, i26, i27, DONE_EQ_K0, i28, i29, i30, i31, i32, i33,
                                         i34, i35, i36, i37, i38, i39);
#endif
            instrlist_concat_next_instr(ilist, 42, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14,
                                        LOOP_EQ_K0, i15, i16, i17, i18, i19, /* NEXT_ITER_K0 (i20) */ i20, i21, i22,
                                        i23, MATCH_EQ_K0, i24, i25, i26, i27, DONE_EQ_K0, i28, i29, i30, i31, i32, i33,
                                        i34, i35, i36, i37, i38, i39);
            return i1;
        } else {

            // all we need to save/restore gprs are:
            // rax, rbx, rcx, r9, r10, r11, r12, r13, r14
            instr_t *LOOP_EQ = INSTR_CREATE_label(dcontext);
            instr_t *SKIP_EQ = INSTR_CREATE_label(dcontext);
            instr_t *MATCH_EQ = INSTR_CREATE_label(dcontext);
            instr_t *DONE_EQ = INSTR_CREATE_label(dcontext);

            opnd_t opnd_rbx = opnd_create_reg(DR_REG_RBX);
            opnd_t opnd_rcx = opnd_create_reg(DR_REG_RCX);
            opnd_t opnd_r9 = opnd_create_reg(DR_REG_R9);
            opnd_t opnd_r10 = opnd_create_reg(DR_REG_R10);
            opnd_t opnd_r11 = opnd_create_reg(DR_REG_R11);
            opnd_t opnd_r12 = opnd_create_reg(DR_REG_R12);
            opnd_t opnd_r13 = opnd_create_reg(DR_REG_R13);
            opnd_t opnd_r14 = opnd_create_reg(DR_REG_R14);

            // save rax, rbx, rcx, r9, r10, r11, r12, r13, r14
            instr_t *i1 = INSTR_CREATE_push(dcontext, opnd_rbx);
            instr_t *i2 = INSTR_CREATE_push(dcontext, opnd_rcx);
            instr_t *i3 = INSTR_CREATE_push(dcontext, opnd_r9);
            instr_t *i4 = INSTR_CREATE_push(dcontext, opnd_r10);
            instr_t *i5 = INSTR_CREATE_push(dcontext, opnd_r11);
            instr_t *i6 = INSTR_CREATE_push(dcontext, opnd_r12);
            instr_t *i7 = INSTR_CREATE_push(dcontext, opnd_r13);
            instr_t *i8 = INSTR_CREATE_push(dcontext, opnd_r14);

            // pushf
            instr_t *i9 = INSTR_CREATE_pushf(dcontext);

            //  sub $64, %rsp                   | reserve 64bytes(512 bits = 2 ymm registers slot) for the spill
            instr_t *i10 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            //  vmovdqu %ymm0, (%rsp)           | save ymm0 to stack
            instr_t *i11 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32),
                                                src1_opnd);

            //  vmovdqu %ymm2, 32(%rsp)         | save ymm2 to stack
            instr_t *i12 = INSTR_CREATE_vmovdqu(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, SIZE_OF_YMM, OPSZ_32), src2_opnd);

            //  xor %r9d, %r9d                  | accmulate mask result, r9d is the output mask, r9d is tls spill
            //  register
            instr_t *i13 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_R9D));

            //  xor %ebx, %ebx                  | j = 0
            instr_t *i14 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_reg(DR_REG_EBX));

            // tls(%k2, input_mask) -> %r10 | get the input mask into r10
            // scratch register is %r10
            instr_t *i15 = RESTORE_FROM_TLS(dcontext, DR_REG_R10, TLS_K_idx_SLOT(input_mask_idx));

            // NOTE: /* .LoopEq */
            // mov %r10d, %r11d                 | get the input mask into r11
            instr_t *i16 = INSTR_CREATE_mov_ld(dcontext, opnd_r11, opnd_r10);

            // mov $1, %r12d                    | prepare bit mask 1 << j
            instr_t *i17 =
                INSTR_CREATE_mov_imm(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_immed_int(1, OPSZ_4));

            // mov %bl, %cl                     | j -> cl, move j to cl for shift count
            instr_t *i18 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_CL), opnd_create_reg(DR_REG_BL));

            // shl %cl, %r12d                   | shift left by j
            instr_t *i19 = INSTR_CREATE_shl(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_CL));

            // test %r11d, %r12d                | test if jth element is enabled
            instr_t *i20 = INSTR_CREATE_test(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_R11D));

            // jz .SkipEQ                       | if not enabled, skip
            instr_t *i21 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_EQ));

            // mov (%rsp, %rbx, 4), %r13d       | r13d = src_reg1[j], ymm0[j] -> r13d, load the j-th dword of ymm0
            instr_t *i22 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R13D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, 0, OPSZ_4));

            // mov 32(%rsp, %rbx, 4), %r14d     | r14d = src_reg2[j], ymm2[j] -> r14d, load the j-th dword of ymm2
            instr_t *i23 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R14D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, SIZE_OF_YMM, OPSZ_4));

        // cmp %r14d, %r13d                 | compare src_reg1[j] with src_reg2[j]
        instr_t *i24 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_R13D),
                                        opnd_create_reg(DR_REG_R14D));

            // je .MatchEq                      | if equal, set bit j in output mask
            instr_t *i25 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(MATCH_EQ));

            instr_t *i25a = INSTR_CREATE_btr(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // NOTE: /* .SkipEq */
            // inc %ebx                         | j++
            instr_t *i26 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // cmp $8, %ebx                     | compare j with 8, for 256-bits ymm, one can only hold 8 dwords
            // elements
            instr_t *i27 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // jl .LoopEq                       | loop if j < 8
            instr_t *i28 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_EQ));

            // jmp .DoneEq
            instr_t *i29 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(DONE_EQ));

            // NOTE: /* MatchEq */
            instr_t *i30 = INSTR_CREATE_bts(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // inc %ebx                         | j++
            instr_t *i31 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // cmp $8, %ebx                     | compare j with 8 check if < 8
            instr_t *i32 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // jl .LoopEq                       | loop if j < 8
            instr_t *i33 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_EQ));

            // NOTE: /* .DoneEq */
            // and output_mask & 0x00FF
            // movzx %r9b, tls(%k5, output_mask) | move the output mask to rax, r10 is the tls spill register
            // but since %r9 is 0 initialized and we only need to set the bit, so we can just use %r9 as the tls spill
            // register, and directly save it to tls
            instr_t *i34a =
                INSTR_CREATE_and(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_immed_int(0x00FF, OPSZ_4));
            instr_t *i34 = SAVE_TO_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

            // add $64, %rsp
            instr_t *i35 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            // popf
            instr_t *i36 = INSTR_CREATE_popf(dcontext);

            // restore rax, rbx, rcx, r9, r10, r11, r12
            instr_t *i37 = INSTR_CREATE_pop(dcontext, opnd_r14);
            instr_t *i38 = INSTR_CREATE_pop(dcontext, opnd_r13);
            instr_t *i39 = INSTR_CREATE_pop(dcontext, opnd_r12);
            instr_t *i40 = INSTR_CREATE_pop(dcontext, opnd_r11);
            instr_t *i41 = INSTR_CREATE_pop(dcontext, opnd_r10);
            instr_t *i42 = INSTR_CREATE_pop(dcontext, opnd_r9);
            instr_t *i43 = INSTR_CREATE_pop(dcontext, opnd_rcx);
            instr_t *i44 = INSTR_CREATE_pop(dcontext, opnd_rbx);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 50, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         LOOP_EQ, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i25a, SKIP_EQ, i26,
                                         i27, i28, i29, MATCH_EQ, i30, i31, i32, i33, DONE_EQ, i34a, i34, i35, i36, i37,
                                         i38, i39, i40, i41, i42, i43, i44);
#endif
            instrlist_concat_next_instr(ilist, 50, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        LOOP_EQ, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i25a, SKIP_EQ, i26,
                                        i27, i28, i29, MATCH_EQ, i30, i31, i32, i33, DONE_EQ, i34a, i34, i35, i36, i37,
                                        i38, i39, i40, i41, i42, i43, i44);
            return i1;
        }
    } break;
    case 1: { // only src1 need spill
        if (input_mask_idx == 0) {
            // vpcmpd {%k0} $0x00 %ymm30 %ymm4 -> %k6
            instr_t *LOOP_EQ_K0 = INSTR_CREATE_label(dcontext);
            instr_t *MATCH_EQ_K0 = INSTR_CREATE_label(dcontext);
            instr_t *DONE_EQ_K0 = INSTR_CREATE_label(dcontext);

            reg_id_t spill_src1_reg = find_one_available_spill_ymm(src2_reg);
            opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);

            opnd_t opnd_rbx = opnd_create_reg(DR_REG_RBX);
            opnd_t opnd_rcx = opnd_create_reg(DR_REG_RCX);
            opnd_t opnd_r9 = opnd_create_reg(DR_REG_R9);
            opnd_t opnd_r10 = opnd_create_reg(DR_REG_R10);
            opnd_t opnd_r11 = opnd_create_reg(DR_REG_R11);
            opnd_t opnd_r12 = opnd_create_reg(DR_REG_R12);
            opnd_t opnd_r13 = opnd_create_reg(DR_REG_R13);
            opnd_t opnd_r14 = opnd_create_reg(DR_REG_R14);

            // save rax, rbx, rcx, r9, r10, r11, r12, r13, r14
            instr_t *i1 = INSTR_CREATE_push(dcontext, opnd_rbx);
            instr_t *i2 = INSTR_CREATE_push(dcontext, opnd_rcx);
            instr_t *i3 = INSTR_CREATE_push(dcontext, opnd_r9);
            instr_t *i4 = INSTR_CREATE_push(dcontext, opnd_r10);
            instr_t *i5 = INSTR_CREATE_push(dcontext, opnd_r11);
            instr_t *i6 = INSTR_CREATE_push(dcontext, opnd_r12);
            instr_t *i7 = INSTR_CREATE_push(dcontext, opnd_r13);
            instr_t *i8 = INSTR_CREATE_push(dcontext, opnd_r14);

            // pushf
            instr_t *i9 = INSTR_CREATE_pushf(dcontext);

            //  sub $64, %rsp
            instr_t *i10 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            // spill_src1_reg -> tls_slot(spill_src1_reg)
            instr_t *i11 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);

            // tls_slot(src1_reg) -> spill_src1_reg
            instr_t *i12 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);

            //  vmovdqu %spill_src1_reg, (%rsp)
            instr_t *i13 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32),
                                                spill_src1_opnd);

            // tls_slot(spill_src1_reg) -> spill_src1_reg
            instr_t *i14 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);

            //  vmovdqu %src2, 32(%rsp)
            instr_t *i15 = INSTR_CREATE_vmovdqu(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, SIZE_OF_YMM, OPSZ_32), src2_opnd);

            //  r9d = xor %r9d, %r9d
            instr_t *i16 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_R9D));

            //  xor %ebx, %ebx  | j = 0
            instr_t *i17 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_reg(DR_REG_EBX));

            // NOTE: /* .LoopEq_k0 */

            // mov (%rsp, %rbx, 4), %r13d
            instr_t *i18 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R13D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, 0, OPSZ_4));

            // mov 32(%rsp, %rbx, 4), %r14d
            instr_t *i19 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R14D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, SIZE_OF_YMM, OPSZ_4));

            // cmp %r14d, %r13d
            instr_t *i20 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_R13D), opnd_create_reg(DR_REG_R14D));

            // je .MatchEq_k0
            instr_t *i21 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(MATCH_EQ_K0));

            // btr %r9d, %ebx
            instr_t *i22 = INSTR_CREATE_btr(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // NOTE: /* .NextIter_k0 */
            // inc %ebx
            instr_t *i23 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // cmp $8, %ebx
            instr_t *i24 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // jl .LoopEq_k0
            instr_t *i25 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_EQ_K0));

            // jmp .DoneEq_k0
            instr_t *i26 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(DONE_EQ_K0));

            // NOTE: /* MatchEq_k0 */
            // bts %r9d, %ebx
            instr_t *i27 = INSTR_CREATE_bts(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // inc %ebx
            instr_t *i28 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // cmp $8, %ebx
            instr_t *i29 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // jl .LoopEq_k0
            instr_t *i30 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_EQ_K0));

            // NOTE: /* .DoneEq_k0 */
            // and $0x00FF, %r9d
            instr_t *i31 =
                INSTR_CREATE_and(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_immed_int(0x00FF, OPSZ_4));
            // mov %r9, tls(output_mask)
            instr_t *i32 = SAVE_TO_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

            // add $64, %rsp
            instr_t *i33 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            // popf
            instr_t *i34 = INSTR_CREATE_popf(dcontext);

            // restore rax, rbx, rcx, r9, r10, r11, r12...
            instr_t *i35 = INSTR_CREATE_pop(dcontext, opnd_r14);
            instr_t *i36 = INSTR_CREATE_pop(dcontext, opnd_r13);
            instr_t *i37 = INSTR_CREATE_pop(dcontext, opnd_r12);
            instr_t *i38 = INSTR_CREATE_pop(dcontext, opnd_r11);
            instr_t *i39 = INSTR_CREATE_pop(dcontext, opnd_r10);
            instr_t *i40 = INSTR_CREATE_pop(dcontext, opnd_r9);
            instr_t *i41 = INSTR_CREATE_pop(dcontext, opnd_rcx);
            instr_t *i42 = INSTR_CREATE_pop(dcontext, opnd_rbx);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 45, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14,
                                         LOOP_EQ_K0, i15, i16, i17, i18, i19, i20, i21, i22, i23, MATCH_EQ_K0, i24, i25,
                                         i26, i27, DONE_EQ_K0, i28, i29, i30, i31, i32, i33, i34, i35, i36, i37, i38,
                                         i39, i40, i41, i42);
#endif
            instrlist_concat_next_instr(ilist, 45, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, LOOP_EQ_K0, i18, i19, i20, i21, i22, i23, i24, i25, i26, MATCH_EQ_K0,
                                        i27, i28, i29, i30, DONE_EQ_K0, i31, i32, i33, i34, i35, i36, i37, i38, i39,
                                        i40, i41, i42);
            return i1;
        } else {
            // all we need to save/restore gprs are:
            // rax, rbx, rcx, r9, r10, r11, r12, r13, r14
            instr_t *LOOP_EQ = INSTR_CREATE_label(dcontext);
            instr_t *SKIP_EQ = INSTR_CREATE_label(dcontext);
            instr_t *MATCH_EQ = INSTR_CREATE_label(dcontext);
            instr_t *DONE_EQ = INSTR_CREATE_label(dcontext);

            opnd_t opnd_rbx = opnd_create_reg(DR_REG_RBX);
            opnd_t opnd_rcx = opnd_create_reg(DR_REG_RCX);
            opnd_t opnd_r9 = opnd_create_reg(DR_REG_R9);
            opnd_t opnd_r10 = opnd_create_reg(DR_REG_R10);
            opnd_t opnd_r11 = opnd_create_reg(DR_REG_R11);
            opnd_t opnd_r12 = opnd_create_reg(DR_REG_R12);
            opnd_t opnd_r13 = opnd_create_reg(DR_REG_R13);
            opnd_t opnd_r14 = opnd_create_reg(DR_REG_R14);

            // save rax, rbx, rcx, r9, r10, r11, r12, r13, r14
            instr_t *i1 = INSTR_CREATE_push(dcontext, opnd_rbx);
            instr_t *i2 = INSTR_CREATE_push(dcontext, opnd_rcx);
            instr_t *i3 = INSTR_CREATE_push(dcontext, opnd_r9);
            instr_t *i4 = INSTR_CREATE_push(dcontext, opnd_r10);
            instr_t *i5 = INSTR_CREATE_push(dcontext, opnd_r11);
            instr_t *i6 = INSTR_CREATE_push(dcontext, opnd_r12);
            instr_t *i7 = INSTR_CREATE_push(dcontext, opnd_r13);
            instr_t *i8 = INSTR_CREATE_push(dcontext, opnd_r14);

            // spill_src1_reg use YMM_SPILL_SLOT0
            reg_id_t spill_src1_reg = find_one_available_spill_ymm(src2_reg);
            opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);

            // pushf
            instr_t *i9 = INSTR_CREATE_pushf(dcontext);

            //  sub $64, %rsp                   | reserve 64bytes(512 bits = 2 ymm registers slot) for the spill
            instr_t *i10 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            // spill_src1_reg -> tls_slot(spill_src1_reg)
            instr_t *i11 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);

            // tls_slot(src1_reg) -> spill_src1_reg
            instr_t *i12 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);

            //  vmovdqu spill_src1_reg, (%rsp)           | save ymm0 to stack
            instr_t *i13 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32),
                                                spill_src1_opnd);

            //  vmovdqu %ymm2, 32(%rsp)         | save ymm2 to stack
            instr_t *i14 = INSTR_CREATE_vmovdqu(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, SIZE_OF_YMM, OPSZ_32), src2_opnd);

            // tls_slot(spill_src1_reg) -> spill_src1_reg
            instr_t *i15 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);

            //  xor %r9d, %r9d                  | accmulate mask result, r9d is the output mask, r9d is tls spill
            //  register
            instr_t *i16 = RESTORE_FROM_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));
            ;

            //  xor %ebx, %ebx                  | j = 0
            instr_t *i17 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_reg(DR_REG_EBX));

            // tls(%k2, input_mask) -> %r10 | get the input mask into r10
            // scratch register is %r10
            instr_t *i18 = RESTORE_FROM_TLS(dcontext, DR_REG_R10, TLS_K_idx_SLOT(input_mask_idx));

            // NOTE: /* .LoopEq */
            // mov %r10d, %r11d                 | get the input mask into r11
            instr_t *i19 = INSTR_CREATE_mov_ld(dcontext, opnd_r11, opnd_r10);

            // mov $1, %r12d                    | prepare bit mask 1 << j
            instr_t *i20 =
                INSTR_CREATE_mov_imm(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_immed_int(1, OPSZ_4));

            // mov %bl, %cl                     | j -> cl, move j to cl for shift count
            instr_t *i21 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_CL), opnd_create_reg(DR_REG_BL));

            // shl %cl, %r12d                   | shift left by j
            instr_t *i22 = INSTR_CREATE_shl(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_CL));

            // test %r11d, %r12d                | test if jth element is enabled
            instr_t *i23 = INSTR_CREATE_test(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_R11D));

            // jz .SkipEQ                       | if not enabled, skip
            instr_t *i24 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_EQ));

            // mov (%rsp, %rbx, 4), %r13d       | r13d = src_reg1[j], ymm0[j] -> r13d, load the j-th dword of ymm0
            instr_t *i25 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R13D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, 0, OPSZ_4));

            // mov 32(%rsp, %rbx, 4), %r14d     | r14d = src_reg2[j], ymm2[j] -> r14d, load the j-th dword of ymm2
            instr_t *i26 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R14D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, SIZE_OF_YMM, OPSZ_4));

            // cmp %r14d, %r13d                 | compare src_reg1[j] with src_reg2[j]
            instr_t *i27 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_R13D), opnd_create_reg(DR_REG_R14D));

            // je .MatchEq                      | if equal, set bit j in output mask
            instr_t *i28 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(MATCH_EQ));

            instr_t *i28a = INSTR_CREATE_btr(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // NOTE: /* .SkipEq */
            // inc %ebx                         | j++
            instr_t *i29 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // cmp $8, %ebx                     | compare j with 8, for 256-bits ymm, one can only hold 8 dwords
            // elements
            instr_t *i30 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // jl .LoopEq                       | loop if j < 8
            instr_t *i31 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_EQ));

            // jmp .DoneEq
            instr_t *i32 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(DONE_EQ));

            // NOTE: /* MatchEq */
            // bts %r12d, %r9d                   | set bit j in output mask
            instr_t *i33 = INSTR_CREATE_bts(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // inc %ebx                         | j++
            instr_t *i34 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // cmp $8, %ebx                     | compare j with 8 check if < 8
            instr_t *i35 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // jl .LoopEq                       | loop if j < 8
            instr_t *i36 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_EQ));

            // NOTE: /* .DoneEq */
            // movzx %r9b, tls(%k5, output_mask) | move the output mask to rax, r10 is the tls spill register
            // but since %r9 is 0 initialized and we only need to set the bit, so we can just use %r9 as the tls spill
            // register, and directly save it to tls
            instr_t *i37a =
                INSTR_CREATE_and(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_immed_int(0x00FF, OPSZ_4));
            instr_t *i37 = SAVE_TO_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

            // add $64, %rsp
            instr_t *i38 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            // popf
            instr_t *i39 = INSTR_CREATE_popf(dcontext);

            // restore rax, rbx, rcx, r9, r10, r11, r12
            instr_t *i40 = INSTR_CREATE_pop(dcontext, opnd_r14);
            instr_t *i41 = INSTR_CREATE_pop(dcontext, opnd_r13);
            instr_t *i42 = INSTR_CREATE_pop(dcontext, opnd_r12);
            instr_t *i43 = INSTR_CREATE_pop(dcontext, opnd_r11);
            instr_t *i44 = INSTR_CREATE_pop(dcontext, opnd_r10);
            instr_t *i45 = INSTR_CREATE_pop(dcontext, opnd_r9);
            instr_t *i46 = INSTR_CREATE_pop(dcontext, opnd_rcx);
            instr_t *i47 = INSTR_CREATE_pop(dcontext, opnd_rbx);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 53, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         i16, i17, i18, LOOP_EQ, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i28a,
                                         SKIP_EQ, i29, i30, i31, i32, MATCH_EQ, i33, i34, i35, i36, DONE_EQ, i37a, i37,
                                         i38, i39, i40, i41, i42, i43, i44, i45, i46, i47);
#endif
            instrlist_concat_next_instr(ilist, 53, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, i18, LOOP_EQ, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i28a,
                                        SKIP_EQ, i29, i30, i31, i32, MATCH_EQ, i33, i34, i35, i36, DONE_EQ, i37a, i37,
                                        i38, i39, i40, i41, i42, i43, i44, i45, i46, i47);
            return i1;
        }
    } break;
    case 2: { // only src2 need spill
              // all we need to save/restore gprs are:
        // rax, rbx, rcx, r9, r10, r11, r12, r13, r14
        instr_t *LOOP_EQ = INSTR_CREATE_label(dcontext);
        instr_t *SKIP_EQ = INSTR_CREATE_label(dcontext);
        instr_t *MATCH_EQ = INSTR_CREATE_label(dcontext);
        instr_t *DONE_EQ = INSTR_CREATE_label(dcontext);

        opnd_t opnd_rbx = opnd_create_reg(DR_REG_RBX);
        opnd_t opnd_rcx = opnd_create_reg(DR_REG_RCX);
        opnd_t opnd_r9 = opnd_create_reg(DR_REG_R9);
        opnd_t opnd_r10 = opnd_create_reg(DR_REG_R10);
        opnd_t opnd_r11 = opnd_create_reg(DR_REG_R11);
        opnd_t opnd_r12 = opnd_create_reg(DR_REG_R12);
        opnd_t opnd_r13 = opnd_create_reg(DR_REG_R13);
        opnd_t opnd_r14 = opnd_create_reg(DR_REG_R14);

        // save rax, rbx, rcx, r9, r10, r11, r12, r13, r14
        instr_t *i1 = INSTR_CREATE_push(dcontext, opnd_rbx);
        instr_t *i2 = INSTR_CREATE_push(dcontext, opnd_rcx);
        instr_t *i3 = INSTR_CREATE_push(dcontext, opnd_r9);
        instr_t *i4 = INSTR_CREATE_push(dcontext, opnd_r10);
        instr_t *i5 = INSTR_CREATE_push(dcontext, opnd_r11);
        instr_t *i6 = INSTR_CREATE_push(dcontext, opnd_r12);
        instr_t *i7 = INSTR_CREATE_push(dcontext, opnd_r13);
        instr_t *i8 = INSTR_CREATE_push(dcontext, opnd_r14);

        // spill_src1_reg use YMM_SPILL_SLOT0
        reg_id_t spill_src2_reg = find_one_available_spill_ymm(src1_reg);
        opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);

        // pushf
        instr_t *i9 = INSTR_CREATE_pushf(dcontext);

        //  sub $64, %rsp                   | reserve 64bytes(512 bits = 2 ymm registers slot) for the spill
        instr_t *i10 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

        // spill_src2_reg -> tls_slot(spill_src2_reg)
        instr_t *i11 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                              TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);

        // tls_slot(src2_reg) -> spill_src2_reg
        instr_t *i12 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);

        //  vmovdqu %ymm0, (%rsp)           | save ymm0 to stack
        instr_t *i13 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32), src1_opnd);

        //  vmovdqu %ymm2, 32(%rsp)         | save ymm2 to stack
        instr_t *i14 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, SIZE_OF_YMM, OPSZ_32), spill_src2_opnd);

        // tls_slot(spill_src2_reg) -> spill_src2_reg
        instr_t *i15 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);

        //  xor %r9d, %r9d                  | accmulate mask result, r9d is the output mask, r9d is tls spill register
        instr_t *i16 = RESTORE_FROM_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

        //  xor %ebx, %ebx                  | j = 0
        instr_t *i17 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_reg(DR_REG_EBX));

        // tls(%k2, input_mask) -> %r10 | get the input mask into r10
        // scratch register is %r10
        instr_t *i18 = RESTORE_FROM_TLS(dcontext, DR_REG_R10, TLS_K_idx_SLOT(input_mask_idx));

        // NOTE: /* .LoopEq */
        // mov %r10d, %r11d                 | get the input mask into r11
        instr_t *i19 = INSTR_CREATE_mov_ld(dcontext, opnd_r11, opnd_r10);

        // mov $1, %r12d                    | prepare bit mask 1 << j
        instr_t *i20 = INSTR_CREATE_mov_imm(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_immed_int(1, OPSZ_4));

        // mov %bl, %cl                     | j -> cl, move j to cl for shift count
        instr_t *i21 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_CL), opnd_create_reg(DR_REG_BL));

        // shl %cl, %r12d                   | shift left by j
        instr_t *i22 = INSTR_CREATE_shl(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_CL));

        // test %r11d, %r12d                | test if jth element is enabled
        instr_t *i23 = INSTR_CREATE_test(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_R11D));

        // jz .SkipEQ                       | if not enabled, skip
        instr_t *i24 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_EQ));

        // mov (%rsp, %rbx, 4), %r13d       | r13d = src_reg1[j], ymm0[j] -> r13d, load the j-th dword of ymm0
        instr_t *i25 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R13D),
                                           opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, 0, OPSZ_4));

        // mov 32(%rsp, %rbx, 4), %r14d     | r14d = src_reg2[j], ymm2[j] -> r14d, load the j-th dword of ymm2
        instr_t *i26 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R14D),
                                           opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, SIZE_OF_YMM, OPSZ_4));

        // cmp %r14d, %r13d                 | compare src_reg1[j] with src_reg2[j]
        instr_t *i27 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_R13D), opnd_create_reg(DR_REG_R14D));

        // je .MatchEq                      | if equal, set bit j in output mask
        instr_t *i28 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(MATCH_EQ));

        instr_t *i28a = INSTR_CREATE_btr(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

        // NOTE: /* .SkipEq */
        // inc %ebx                         | j++
        instr_t *i29 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

        // cmp $8, %ebx                     | compare j with 8, for 256-bits ymm, one can only hold 8 dwords elements
        instr_t *i30 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

        // jl .LoopEq                       | loop if j < 8
        instr_t *i31 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_EQ));

        // jmp .DoneEq
        instr_t *i32 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(DONE_EQ));

        // NOTE: /* MatchEq */
        // bts %r12d, %r9d                   | set bit j in output mask
        instr_t *i33 = INSTR_CREATE_bts(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

        // inc %ebx                         | j++
        instr_t *i34 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

        // cmp $8, %ebx                     | compare j with 8 check if < 8
        instr_t *i35 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

        // jl .LoopEq                       | loop if j < 8
        instr_t *i36 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_EQ));

        // NOTE: /* .DoneEq */
        // movzx %r9b, tls(%k5, output_mask) | move the output mask to rax, r10 is the tls spill register
        // but since %r9 is 0 initialized and we only need to set the bit, so we can just use %r9 as the tls spill
        // register, and directly save it to tls
        instr_t *i37a = INSTR_CREATE_and(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_immed_int(0x00FF, OPSZ_4));
        instr_t *i37 = SAVE_TO_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

        // add $64, %rsp
        instr_t *i38 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

        // popf
        instr_t *i39 = INSTR_CREATE_popf(dcontext);

        // restore rax, rbx, rcx, r9, r10, r11, r12
        instr_t *i40 = INSTR_CREATE_pop(dcontext, opnd_r14);
        instr_t *i41 = INSTR_CREATE_pop(dcontext, opnd_r13);
        instr_t *i42 = INSTR_CREATE_pop(dcontext, opnd_r12);
        instr_t *i43 = INSTR_CREATE_pop(dcontext, opnd_r11);
        instr_t *i44 = INSTR_CREATE_pop(dcontext, opnd_r10);
        instr_t *i45 = INSTR_CREATE_pop(dcontext, opnd_r9);
        instr_t *i46 = INSTR_CREATE_pop(dcontext, opnd_rcx);
        instr_t *i47 = INSTR_CREATE_pop(dcontext, opnd_rbx);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 53, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, LOOP_EQ, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i28a,
                                     SKIP_EQ, i29, i30, i31, i32, MATCH_EQ, i33, i34, i35, i36, DONE_EQ, i37a, i37, i38,
                                     i39, i40, i41, i42, i43, i44, i45, i46, i47);
#endif
        instrlist_concat_next_instr(ilist, 53, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, LOOP_EQ, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i28a, SKIP_EQ,
                                    i29, i30, i31, i32, MATCH_EQ, i33, i34, i35, i36, DONE_EQ, i37a, i37, i38, i39, i40,
                                    i41, i42, i43, i44, i45, i46, i47);
        return i1;
    } break;
    case 3: { // both src1 and src2 need spill
        // rax, rbx, rcx, r9, r10, r11, r12, r13, r14
        instr_t *LOOP_EQ = INSTR_CREATE_label(dcontext);
        instr_t *SKIP_EQ = INSTR_CREATE_label(dcontext);
        instr_t *MATCH_EQ = INSTR_CREATE_label(dcontext);
        instr_t *DONE_EQ = INSTR_CREATE_label(dcontext);

        opnd_t opnd_rbx = opnd_create_reg(DR_REG_RBX);
        opnd_t opnd_rcx = opnd_create_reg(DR_REG_RCX);
        opnd_t opnd_r9 = opnd_create_reg(DR_REG_R9);
        opnd_t opnd_r10 = opnd_create_reg(DR_REG_R10);
        opnd_t opnd_r11 = opnd_create_reg(DR_REG_R11);
        opnd_t opnd_r12 = opnd_create_reg(DR_REG_R12);
        opnd_t opnd_r13 = opnd_create_reg(DR_REG_R13);
        opnd_t opnd_r14 = opnd_create_reg(DR_REG_R14);

        // save rax, rbx, rcx, r9, r10, r11, r12, r13, r14
        instr_t *i1 = INSTR_CREATE_push(dcontext, opnd_rbx);
        instr_t *i2 = INSTR_CREATE_push(dcontext, opnd_rcx);
        instr_t *i3 = INSTR_CREATE_push(dcontext, opnd_r9);
        instr_t *i4 = INSTR_CREATE_push(dcontext, opnd_r10);
        instr_t *i5 = INSTR_CREATE_push(dcontext, opnd_r11);
        instr_t *i6 = INSTR_CREATE_push(dcontext, opnd_r12);
        instr_t *i7 = INSTR_CREATE_push(dcontext, opnd_r13);
        instr_t *i8 = INSTR_CREATE_push(dcontext, opnd_r14);

        // spill_src1_reg use YMM_SPILL_SLOT0
        reg_id_t spill_src1_reg = YMM_SPILL_SLOT0;
        reg_id_t spill_src2_reg = YMM_SPILL_SLOT1;
        opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);
        opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);

        // pushf
        instr_t *i9 = INSTR_CREATE_pushf(dcontext);

        //  sub $64, %rsp                   | reserve 64bytes(512 bits = 2 ymm registers slot) for the spill
        instr_t *i10 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

        // spill_src1_reg -> tls_slot(spill_src1_reg)
        instr_t *i11 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                              TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);

        // tls_slot(src1_reg) -> spill_src1_reg
        instr_t *i12 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);

        // spill_src2_reg -> tls_slot(spill_src2_reg)
        instr_t *i13 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                              TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);

        // tls_slot(src2_reg) -> spill_src2_reg
        instr_t *i14 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);

        //  vmovdqu %ymm0, (%rsp)           | save ymm0 to stack
        instr_t *i15 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32),
                                            spill_src1_opnd);

        //  vmovdqu %ymm2, 32(%rsp)         | save ymm2 to stack
        instr_t *i16 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, SIZE_OF_YMM, OPSZ_32), spill_src2_opnd);

        // tls_slot(spill_src1_reg) -> spill_src1_reg
        instr_t *i17 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);

        // tls_slot(spill_src2_reg) -> spill_src2_reg
        instr_t *i18 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);

        //  xor %r9d, %r9d                  | accmulate mask result, r9d is the output mask, r9d is tls spill register
        instr_t *i19 = RESTORE_FROM_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

        //  xor %ebx, %ebx                  | j = 0
        instr_t *i20 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_reg(DR_REG_EBX));

        // tls(%k2, input_mask) -> %r10 | get the input mask into r10
        // scratch register is %r10
        instr_t *i21 = RESTORE_FROM_TLS(dcontext, DR_REG_R10, TLS_K_idx_SLOT(input_mask_idx));

        // NOTE: /* .LoopEq */
        // mov %r10d, %r11d                 | get the input mask into r11
        instr_t *i22 = INSTR_CREATE_mov_ld(dcontext, opnd_r11, opnd_r10);

        // mov $1, %r12d                    | prepare bit mask 1 << j
        instr_t *i23 = INSTR_CREATE_mov_imm(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_immed_int(1, OPSZ_4));

        // mov %bl, %cl                     | j -> cl, move j to cl for shift count
        instr_t *i24 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_CL), opnd_create_reg(DR_REG_BL));

        // shl %cl, %r12d                   | shift left by j
        instr_t *i25 = INSTR_CREATE_shl(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_CL));

        // test %r11d, %r12d                | test if jth element is enabled
        instr_t *i26 = INSTR_CREATE_test(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_R11D));

        // jz .SkipEQ                       | if not enabled, skip
        instr_t *i27 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_EQ));

        // mov (%rsp, %rbx, 4), %r13d       | r13d = src_reg1[j], ymm0[j] -> r13d, load the j-th dword of ymm0
        instr_t *i28 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R13D),
                                           opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, 0, OPSZ_4));

        // mov 32(%rsp, %rbx, 4), %r14d     | r14d = src_reg2[j], ymm2[j] -> r14d, load the j-th dword of ymm2
        instr_t *i29 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R14D),
                                           opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, SIZE_OF_YMM, OPSZ_4));

        // cmp %r14d, %r13d                 | compare src_reg1[j] with src_reg2[j]
        instr_t *i30 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_R13D), opnd_create_reg(DR_REG_R14D));

        // je .MatchEq                      | if equal, set bit j in output mask
        instr_t *i31 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(MATCH_EQ));

        instr_t *i31a = INSTR_CREATE_btr(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

        // NOTE: /* .SkipEq */
        // inc %ebx                         | j++
        instr_t *i32 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

        // cmp $8, %ebx                     | compare j with 8, for 256-bits ymm, one can only hold 8 dwords elements
        instr_t *i33 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

        // jl .LoopEq                       | loop if j < 8
        instr_t *i34 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_EQ));

        // jmp .DoneEq
        instr_t *i35 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(DONE_EQ));

        // NOTE: /* MatchEq */
        // or %r12d, %r9d                   | set bit j in output mask
        instr_t *i36 = INSTR_CREATE_bts(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

        // inc %ebx                         | j++
        instr_t *i37 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

        // cmp $8, %ebx                     | compare j with 8 check if < 8
        instr_t *i38 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

        // jl .LoopEq                       | loop if j < 8
        instr_t *i39 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_EQ));

        // NOTE: /* .DoneEq */
        // movzx %r9b, tls(%k5, output_mask) | move the output mask to rax, r10 is the tls spill register
        // but since %r9 is 0 initialized and we only need to set the bit, so we can just use %r9 as the tls spill
        // register, and directly save it to tls
        instr_t *i40a = INSTR_CREATE_and(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_immed_int(0x00FF, OPSZ_4));
        instr_t *i40 = SAVE_TO_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

        // add $64, %rsp
        instr_t *i41 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

        // popf
        instr_t *i42 = INSTR_CREATE_popf(dcontext);

        // restore rax, rbx, rcx, r9, r10, r11, r12
        instr_t *i43 = INSTR_CREATE_pop(dcontext, opnd_r14);
        instr_t *i44 = INSTR_CREATE_pop(dcontext, opnd_r13);
        instr_t *i45 = INSTR_CREATE_pop(dcontext, opnd_r12);
        instr_t *i46 = INSTR_CREATE_pop(dcontext, opnd_r11);
        instr_t *i47 = INSTR_CREATE_pop(dcontext, opnd_r10);
        instr_t *i48 = INSTR_CREATE_pop(dcontext, opnd_r9);
        instr_t *i49 = INSTR_CREATE_pop(dcontext, opnd_rcx);
        instr_t *i50 = INSTR_CREATE_pop(dcontext, opnd_rbx);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 56, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, LOOP_EQ, i22, i23, i24, i25, i26, i27, i28, i29, i30,
                                     i31, i31a, SKIP_EQ, i32, i33, i34, i35, MATCH_EQ, i36, i37, i38, i39, DONE_EQ,
                                     i40a, i40, i41, i42, i43, i44, i45, i46, i47, i48, i49, i50);
#endif
        instrlist_concat_next_instr(ilist, 56, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, LOOP_EQ, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                    i31a, SKIP_EQ, i32, i33, i34, i35, MATCH_EQ, i36, i37, i38, i39, DONE_EQ, i40a, i40,
                                    i41, i42, i43, i44, i45, i46, i47, i48, i49, i50);
        return i1;
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpcmpd EQ ymm and ymm pattern not support"); return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t * /* 0x00 */
rw_func_vpcmpd_EQ_ymm_m256(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src1_opnd, opnd_t src2_opnd,
                           reg_id_t src1_reg, reg_id_t mask_reg, reg_id_t dst_mask_reg)
{
    // NOTE: this has a scalar implementation counterpart, but I don't want to write it here
    // vpcmpd {%k0} $0x00 %ymm0 <rel> 0x00007f97ac4c8360[32byte] -> %k7
    //      input mask:  %k0
    //      input imm8:  $0x00
    //      input src1:  %ymm0
    //      input src2:  <rel> 0x00007f97ac4c8360
    //      output mask:  %k7

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    int input_mask_idx = TO_K_REG_INDEX(mask_reg);
    int output_mask_idx = TO_K_REG_INDEX(dst_mask_reg);

    const uint src1_need_spill = NEED_SPILL_YMM(src1_reg) ? 1 : 0;

    switch (src1_need_spill) {
    case 0: { // no spill
        if (input_mask_idx == 0) {
            // vpcmpd {%k0} $0x00 %ymm0 <rel>m256 -> %k5
            instr_t *LOOP_EQ_K0 = INSTR_CREATE_label(dcontext);
            instr_t *MATCH_EQ_K0 = INSTR_CREATE_label(dcontext);
            instr_t *DONE_EQ_K0 = INSTR_CREATE_label(dcontext);

            opnd_t opnd_rbx = opnd_create_reg(DR_REG_RBX);
            opnd_t opnd_rcx = opnd_create_reg(DR_REG_RCX);
            opnd_t opnd_r9 = opnd_create_reg(DR_REG_R9);
            opnd_t opnd_r10 = opnd_create_reg(DR_REG_R10);
            opnd_t opnd_r11 = opnd_create_reg(DR_REG_R11);
            opnd_t opnd_r12 = opnd_create_reg(DR_REG_R12);
            opnd_t opnd_r13 = opnd_create_reg(DR_REG_R13);
            opnd_t opnd_r14 = opnd_create_reg(DR_REG_R14);

            // save rax, rbx, rcx, r9, r10, r11, r12, r13, r14
            instr_t *i1 = INSTR_CREATE_push(dcontext, opnd_rbx);
            instr_t *i2 = INSTR_CREATE_push(dcontext, opnd_rcx);
            instr_t *i3 = INSTR_CREATE_push(dcontext, opnd_r9);
            instr_t *i4 = INSTR_CREATE_push(dcontext, opnd_r10);
            instr_t *i5 = INSTR_CREATE_push(dcontext, opnd_r11);
            instr_t *i6 = INSTR_CREATE_push(dcontext, opnd_r12);
            instr_t *i7 = INSTR_CREATE_push(dcontext, opnd_r13);
            instr_t *i8 = INSTR_CREATE_push(dcontext, opnd_r14);

            reg_id_t spill_ymm_reg = find_one_available_spill_ymm(src1_reg);
            opnd_t spill_ymm_opnd = opnd_create_reg(spill_ymm_reg);

            // pushf
            instr_t *i9 = INSTR_CREATE_pushf(dcontext);

            //  sub $64, %rsp
            instr_t *i10 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            //  vmovdqu %ymm0, (%rsp)
            instr_t *i11 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32),
                                                src1_opnd);

            // spill_ymm_reg -> tls_slot(spill_ymm_reg)
            instr_t *i12 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_ymm_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_ymm_reg)), OPSZ_32);
            // vmovdqu <rel>, spill_ymm_reg
            instr_t *i13 = INSTR_CREATE_vmovdqu(dcontext, spill_ymm_opnd, src2_opnd);

            // vmovdqu spill_ymm_reg, 32(%rsp)
            instr_t *i14 = INSTR_CREATE_vmovdqu(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, SIZE_OF_YMM, OPSZ_32), spill_ymm_opnd);

            // tls_slot(spill_ymm_reg) -> spill_ymm_reg
            instr_t *i15 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_ymm_reg,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_ymm_reg)), OPSZ_32);

            //  r9d = tls(output_mask) | accmulate mask result
            instr_t *i16 = RESTORE_FROM_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

            //  xor %ebx, %ebx  | j = 0
            instr_t *i17 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_reg(DR_REG_EBX));

            // NOTE: /* .LoopEq_k0 */

            // mov (%rsp, %rbx, 4), %r13d
            instr_t *i18 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R13D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, 0, OPSZ_4));

            // mov 32(%rsp, %rbx, 4), %r14d
            instr_t *i19 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R14D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, SIZE_OF_YMM, OPSZ_4));

            // cmp %r14d, %r13d
            instr_t *i20 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_R13D), opnd_create_reg(DR_REG_R14D));

            // je .MatchEq_k0
            instr_t *i21 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(MATCH_EQ_K0));

            // btr %r9d, %ebx
            instr_t *i22 = INSTR_CREATE_btr(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // NOTE: /* .NextIter_k0 */
            // inc %ebx
            instr_t *i23 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // cmp $8, %ebx
            instr_t *i24 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // jl .LoopEq_k0
            instr_t *i25 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_EQ_K0));

            // jmp .DoneEq_k0
            instr_t *i26 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(DONE_EQ_K0));

            // NOTE: /* MatchEq_k0 */
            // bts %r9d, %ebx
            instr_t *i27 = INSTR_CREATE_bts(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // inc %ebx
            instr_t *i28 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // cmp $8, %ebx
            instr_t *i29 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // jl .LoopEq_k0
            instr_t *i30 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_EQ_K0));

            // NOTE: /* .DoneEq_k0 */
            // and $0x00FF, %r9d
            instr_t *i31 =
                INSTR_CREATE_and(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_immed_int(0x00FF, OPSZ_4));
            // mov %r9, tls(output_mask)
            instr_t *i32 = SAVE_TO_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

            // add $64, %rsp
            instr_t *i33 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            // popf
            instr_t *i34 = INSTR_CREATE_popf(dcontext);

            // restore rax, rbx, rcx, r9, r10, r11, r12...
            instr_t *i35 = INSTR_CREATE_pop(dcontext, opnd_r14);
            instr_t *i36 = INSTR_CREATE_pop(dcontext, opnd_r13);
            instr_t *i37 = INSTR_CREATE_pop(dcontext, opnd_r12);
            instr_t *i38 = INSTR_CREATE_pop(dcontext, opnd_r11);
            instr_t *i39 = INSTR_CREATE_pop(dcontext, opnd_r10);
            instr_t *i40 = INSTR_CREATE_pop(dcontext, opnd_r9);
            instr_t *i41 = INSTR_CREATE_pop(dcontext, opnd_rcx);
            instr_t *i42 = INSTR_CREATE_pop(dcontext, opnd_rbx);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 45, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         i16, i17, LOOP_EQ_K0, i18, i19, i20, i21, i22, i23, i24, i25, i26, MATCH_EQ_K0,
                                         i27, i28, i29, i30, DONE_EQ_K0, i31, i32, i33, i34, i35, i36, i37, i38, i39,
                                         i40, i41, i42);
#endif
            instrlist_concat_next_instr(ilist, 45, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, LOOP_EQ_K0, i18, i19, i20, i21, i22, i23, i24, i25, i26, MATCH_EQ_K0,
                                        i27, i28, i29, i30, DONE_EQ_K0, i31, i32, i33, i34, i35, i36, i37, i38, i39,
                                        i40, i41, i42);
            return i1;
        } else {
            // all we need to save/restore gprs are:
            // rax, rbx, rcx, r9, r10, r11, r12, r13, r14
            instr_t *LOOP_EQ = INSTR_CREATE_label(dcontext);
            instr_t *SKIP_EQ = INSTR_CREATE_label(dcontext);
            instr_t *MATCH_EQ = INSTR_CREATE_label(dcontext);
            instr_t *DONE_EQ = INSTR_CREATE_label(dcontext);

            opnd_t opnd_rbx = opnd_create_reg(DR_REG_RBX);
            opnd_t opnd_rcx = opnd_create_reg(DR_REG_RCX);
            opnd_t opnd_r9 = opnd_create_reg(DR_REG_R9);
            opnd_t opnd_r10 = opnd_create_reg(DR_REG_R10);
            opnd_t opnd_r11 = opnd_create_reg(DR_REG_R11);
            opnd_t opnd_r12 = opnd_create_reg(DR_REG_R12);
            opnd_t opnd_r13 = opnd_create_reg(DR_REG_R13);
            opnd_t opnd_r14 = opnd_create_reg(DR_REG_R14);

            // save rax, rbx, rcx, r9, r10, r11, r12, r13, r14
            instr_t *i1 = INSTR_CREATE_push(dcontext, opnd_rbx);
            instr_t *i2 = INSTR_CREATE_push(dcontext, opnd_rcx);
            instr_t *i3 = INSTR_CREATE_push(dcontext, opnd_r9);
            instr_t *i4 = INSTR_CREATE_push(dcontext, opnd_r10);
            instr_t *i5 = INSTR_CREATE_push(dcontext, opnd_r11);
            instr_t *i6 = INSTR_CREATE_push(dcontext, opnd_r12);
            instr_t *i7 = INSTR_CREATE_push(dcontext, opnd_r13);
            instr_t *i8 = INSTR_CREATE_push(dcontext, opnd_r14);

            // tmp reg
            reg_id_t spill_ymm_reg = find_one_available_spill_ymm(src1_reg);
            opnd_t spill_ymm_opnd = opnd_create_reg(spill_ymm_reg);

            // pushf
            instr_t *i9 = INSTR_CREATE_pushf(dcontext);

            //  sub $64, %rsp                   | reserve 64bytes(512 bits = 2 ymm registers slot) for the spill
            instr_t *i10 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            //  vmovdqu %ymm0, (%rsp)           | save ymm0 to stack
            instr_t *i11 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32),
                                                src1_opnd);

            // spill_ymm_reg -> tls_slot(spill_ymm_reg)
            instr_t *i12 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_ymm_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_ymm_reg)), OPSZ_32);

            // vmovdqu <rel>, spill_ymm_reg
            instr_t *i13 = INSTR_CREATE_vmovdqu(dcontext, spill_ymm_opnd, src2_opnd);

            //  vmovdqu spill_ymm_reg, 32(%rsp)         | save ymm2 to stack
            instr_t *i14 = INSTR_CREATE_vmovdqu(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, SIZE_OF_YMM, OPSZ_32), spill_ymm_opnd);

            // tls_slot(spill_ymm_reg) = spill_ymm_reg
            instr_t *i15 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_ymm_reg,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_ymm_reg)), OPSZ_32);

            // tls_slot(output_mask) -> r9d     | accmulate mask result, r9d is the output mask, r9d is tls spill
            // register
            instr_t *i16 = RESTORE_FROM_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

            //  xor %ebx, %ebx                  | j = 0
            instr_t *i17 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_reg(DR_REG_EBX));

            // tls(%k2, input_mask) -> %r10 | get the input mask into r10
            // scratch register is %r10
            instr_t *i18 = RESTORE_FROM_TLS(dcontext, DR_REG_R10, TLS_K_idx_SLOT(input_mask_idx));

            // NOTE: /* .LoopEq */
            // mov %r10d, %r11d                 | get the input mask into r11
            instr_t *i19 = INSTR_CREATE_mov_ld(dcontext, opnd_r11, opnd_r10);

            // mov $1, %r12d                    | prepare bit mask 1 << j
            instr_t *i20 =
                INSTR_CREATE_mov_imm(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_immed_int(1, OPSZ_4));

            // mov %bl, %cl                     | j -> cl, move j to cl for shift count
            instr_t *i21 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_CL), opnd_create_reg(DR_REG_BL));

            // shl %cl, %r12d                   | shift left by j
            instr_t *i22 = INSTR_CREATE_shl(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_CL));

            // test %r11d, %r12d                | test if jth element is enabled
            instr_t *i23 = INSTR_CREATE_test(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_R11D));

            // jz .SkipEQ                       | if not enabled, skip
            instr_t *i24 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_EQ));

            // mov (%rsp, %rbx, 4), %r13d       | r13d = src_reg1[j], ymm0[j] -> r13d, load the j-th dword of ymm0
            instr_t *i25 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R13D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, 0, OPSZ_4));

            // mov 32(%rsp, %rbx, 4), %r14d     | r14d = src_reg2[j], ymm2[j] -> r14d, load the j-th dword of ymm2
            instr_t *i26 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R14D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, SIZE_OF_YMM, OPSZ_4));

            // cmp %r14d, %r13d                 | compare src_reg1[j] with src_reg2[j]
            instr_t *i27 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_R13D), opnd_create_reg(DR_REG_R14D));

            // je .MatchEq                      | if equal, set bit j in output mask
            instr_t *i28 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(MATCH_EQ));

            instr_t *i28a = INSTR_CREATE_btr(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // NOTE: /* .SkipEq */
            // inc %ebx                         | j++
            instr_t *i29 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // cmp $8, %ebx                     | compare j with 8, for 256-bits ymm, one can only hold 8 dwords
            // elements
            instr_t *i30 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // jl .LoopEq                       | loop if j < 8
            instr_t *i31 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_EQ));

            // jmp .DoneEq
            instr_t *i32 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(DONE_EQ));

            // NOTE: /* MatchEq */
            // or %r12d, %r9d                   | set bit j in output mask
            instr_t *i33 = INSTR_CREATE_bts(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // inc %ebx                         | j++
            instr_t *i34 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // cmp $8, %ebx                     | compare j with 8 check if < 8
            instr_t *i35 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // jl .LoopEq                       | loop if j < 8
            instr_t *i36 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_EQ));

            // NOTE: /* .DoneEq */
            // movzx %r9b, tls(%k5, output_mask) | move the output mask to rax, r10 is the tls spill register
            // but since %r9 is 0 initialized and we only need to set the bit, so we can just use %r9 as the tls spill
            // register, and directly save it to tls
            instr_t *i37a =
                INSTR_CREATE_and(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_immed_int(0x00FF, OPSZ_4));
            instr_t *i37 = SAVE_TO_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

            // add $64, %rsp
            instr_t *i38 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            // popf
            instr_t *i39 = INSTR_CREATE_popf(dcontext);

            // restore rax, rbx, rcx, r9, r10, r11, r12
            instr_t *i40 = INSTR_CREATE_pop(dcontext, opnd_r14);
            instr_t *i41 = INSTR_CREATE_pop(dcontext, opnd_r13);
            instr_t *i42 = INSTR_CREATE_pop(dcontext, opnd_r12);
            instr_t *i43 = INSTR_CREATE_pop(dcontext, opnd_r11);
            instr_t *i44 = INSTR_CREATE_pop(dcontext, opnd_r10);
            instr_t *i45 = INSTR_CREATE_pop(dcontext, opnd_r9);
            instr_t *i46 = INSTR_CREATE_pop(dcontext, opnd_rcx);
            instr_t *i47 = INSTR_CREATE_pop(dcontext, opnd_rbx);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 53, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         i16, i17, i18, LOOP_EQ, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i28a,
                                         SKIP_EQ, i29, i30, i31, i32, MATCH_EQ, i33, i34, i35, i36, DONE_EQ, i37a, i37,
                                         i38, i39, i40, i41, i42, i43, i44, i45, i46, i47);
#endif
            instrlist_concat_next_instr(ilist, 53, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, i18, LOOP_EQ, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i28a,
                                        SKIP_EQ, i29, i30, i31, i32, MATCH_EQ, i33, i34, i35, i36, DONE_EQ, i37a, i37,
                                        i38, i39, i40, i41, i42, i43, i44, i45, i46, i47);
            return i1;
        }
    } break;
    case 1: { // only src1 need spill
        // all we need to save/restore gprs are:
        // rax, rbx, rcx, r9, r10, r11, r12, r13, r14
        instr_t *LOOP_EQ = INSTR_CREATE_label(dcontext);
        instr_t *SKIP_EQ = INSTR_CREATE_label(dcontext);
        instr_t *MATCH_EQ = INSTR_CREATE_label(dcontext);
        instr_t *DONE_EQ = INSTR_CREATE_label(dcontext);

        opnd_t opnd_rbx = opnd_create_reg(DR_REG_RBX);
        opnd_t opnd_rcx = opnd_create_reg(DR_REG_RCX);
        opnd_t opnd_r9 = opnd_create_reg(DR_REG_R9);
        opnd_t opnd_r10 = opnd_create_reg(DR_REG_R10);
        opnd_t opnd_r11 = opnd_create_reg(DR_REG_R11);
        opnd_t opnd_r12 = opnd_create_reg(DR_REG_R12);
        opnd_t opnd_r13 = opnd_create_reg(DR_REG_R13);
        opnd_t opnd_r14 = opnd_create_reg(DR_REG_R14);

        // save rax, rbx, rcx, r9, r10, r11, r12, r13, r14
        instr_t *i1 = INSTR_CREATE_push(dcontext, opnd_rbx);
        instr_t *i2 = INSTR_CREATE_push(dcontext, opnd_rcx);
        instr_t *i3 = INSTR_CREATE_push(dcontext, opnd_r9);
        instr_t *i4 = INSTR_CREATE_push(dcontext, opnd_r10);
        instr_t *i5 = INSTR_CREATE_push(dcontext, opnd_r11);
        instr_t *i6 = INSTR_CREATE_push(dcontext, opnd_r12);
        instr_t *i7 = INSTR_CREATE_push(dcontext, opnd_r13);
        instr_t *i8 = INSTR_CREATE_push(dcontext, opnd_r14);

        // spill_src1_reg use YMM_SPILL_SLOT0
        reg_id_t spill_src1_reg = YMM_SPILL_SLOT0;
        reg_id_t spill_src2_rel_reg = YMM_SPILL_SLOT1;
        opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);
        opnd_t spill_src2_rel_opnd = opnd_create_reg(spill_src2_rel_reg);

        // pushf
        instr_t *i9 = INSTR_CREATE_pushf(dcontext);

        //  sub $64, %rsp                   | reserve 64bytes(512 bits = 2 ymm registers slot) for the spill
        instr_t *i10 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

        // spill_src1_reg -> tls_slot(spill_src1_reg)
        instr_t *i11 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                              TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);

        // spill_src2_tmp_reg -> tls_slot(spill_src2_tmp_reg)
        instr_t *i12 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_rel_reg,
                                              TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_rel_reg)), OPSZ_32);

        // tls_slot(src1_reg) -> spill_src1_reg
        instr_t *i13 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);

        // vmovdqu spill_src1_reg, (%rsp)           | save ymm0 to stack
        instr_t *i14 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32),
                                            spill_src1_opnd);

        // vmovdqu <rel>, spill_src2_rel_reg
        instr_t *i15 = INSTR_CREATE_vmovdqu(dcontext, spill_src2_rel_opnd, src2_opnd);

        // vmovdqu spill_src2_rel_reg, 32(%rsp)         | save ymm2 to stack
        instr_t *i16 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, SIZE_OF_YMM, OPSZ_32), spill_src2_rel_opnd);

        // tls_slot(spill_src1_reg) -> spill_src1_reg
        instr_t *i17 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);

        // tls_slot(spill_src2_rel_reg) -> spill_src2_rel_reg
        instr_t *i18 = RESTORE_FROM_SIZED_TLS(dcontext, spill_src2_rel_reg,
                                              TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_rel_reg)), OPSZ_32);

        //  xor %r9d, %r9d                  | accmulate mask result, r9d is the output mask, r9d is tls spill register
        instr_t *i19 = RESTORE_FROM_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

        //  xor %ebx, %ebx                  | j = 0
        instr_t *i20 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_reg(DR_REG_EBX));

        // tls(%k2, input_mask) -> %r10 | get the input mask into r10
        // scratch register is %r10
        instr_t *i21 = RESTORE_FROM_TLS(dcontext, DR_REG_R10, TLS_K_idx_SLOT(input_mask_idx));

        // NOTE: /* .LoopEq */
        // mov %r10d, %r11d                 | get the input mask into r11
        instr_t *i22 = INSTR_CREATE_mov_ld(dcontext, opnd_r11, opnd_r10);

        // mov $1, %r12d                    | prepare bit mask 1 << j
        instr_t *i23 = INSTR_CREATE_mov_imm(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_immed_int(1, OPSZ_4));

        // mov %bl, %cl                     | j -> cl, move j to cl for shift count
        instr_t *i24 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_CL), opnd_create_reg(DR_REG_BL));

        // shl %cl, %r12d                   | shift left by j
        instr_t *i25 = INSTR_CREATE_shl(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_CL));

        // test %r11d, %r12d                | test if jth element is enabled
        instr_t *i26 = INSTR_CREATE_test(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_R11D));

        // jz .SkipEQ                       | if not enabled, skip
        instr_t *i27 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_EQ));

        // mov (%rsp, %rbx, 4), %r13d       | r13d = src_reg1[j], ymm0[j] -> r13d, load the j-th dword of ymm0
        instr_t *i28 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R13D),
                                           opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, 0, OPSZ_4));

        // mov 32(%rsp, %rbx, 4), %r14d     | r14d = src_reg2[j], ymm2[j] -> r14d, load the j-th dword of ymm2
        instr_t *i29 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R14D),
                                           opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, SIZE_OF_YMM, OPSZ_4));

        // cmp %r14d, %r13d                 | compare src_reg1[j] with src_reg2[j]
        instr_t *i30 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_R13D), opnd_create_reg(DR_REG_R14D));

        // je .MatchEq                      | if equal, set bit j in output mask
        instr_t *i31 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(MATCH_EQ));

        instr_t *i31a = INSTR_CREATE_btr(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

        // NOTE: /* .SkipEq */
        // inc %ebx                         | j++
        instr_t *i32 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

        // cmp $8, %ebx                     | compare j with 8, for 256-bits ymm, one can only hold 8 dwords elements
        instr_t *i33 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

        // jl .LoopEq                       | loop if j < 8
        instr_t *i34 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_EQ));

        // jmp .DoneEq
        instr_t *i35 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(DONE_EQ));

        // NOTE: /* MatchEq */
        // bts %r12d, %r9d                  | set bit j in output mask
        instr_t *i36 = INSTR_CREATE_bts(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

        // inc %ebx                         | j++
        instr_t *i37 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

        // cmp $8, %ebx                     | compare j with 8 check if < 8
        instr_t *i38 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

        // jl .LoopEq                       | loop if j < 8
        instr_t *i39 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_EQ));

        // NOTE: /* .DoneEq */
        // movzx %r9b, tls(%k5, output_mask) | move the output mask to rax, r10 is the tls spill register
        // but since %r9 is 0 initialized and we only need to set the bit, so we can just use %r9 as the tls spill
        // register, and directly save it to tls
        instr_t *i40a = INSTR_CREATE_and(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_immed_int(0x00FF, OPSZ_4));
        instr_t *i40 = SAVE_TO_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

        // add $64, %rsp
        instr_t *i41 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

        // popf
        instr_t *i42 = INSTR_CREATE_popf(dcontext);

        // restore rax, rbx, rcx, r9, r10, r11, r12
        instr_t *i43 = INSTR_CREATE_pop(dcontext, opnd_r14);
        instr_t *i44 = INSTR_CREATE_pop(dcontext, opnd_r13);
        instr_t *i45 = INSTR_CREATE_pop(dcontext, opnd_r12);
        instr_t *i46 = INSTR_CREATE_pop(dcontext, opnd_r11);
        instr_t *i47 = INSTR_CREATE_pop(dcontext, opnd_r10);
        instr_t *i48 = INSTR_CREATE_pop(dcontext, opnd_r9);
        instr_t *i49 = INSTR_CREATE_pop(dcontext, opnd_rcx);
        instr_t *i50 = INSTR_CREATE_pop(dcontext, opnd_rbx);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 56, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, LOOP_EQ, i22, i23, i24, i25, i26, i27, i28, i29, i30,
                                     i31, i31a, SKIP_EQ, i32, i33, i34, i35, MATCH_EQ, i36, i37, i38, i39, DONE_EQ,
                                     i40a, i40, i41, i42, i43, i44, i45, i46, i47, i48, i49, i50);
#endif
        instrlist_concat_next_instr(ilist, 56, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, LOOP_EQ, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                    i31a, SKIP_EQ, i32, i33, i34, i35, MATCH_EQ, i36, i37, i38, i39, DONE_EQ, i40a, i40,
                                    i41, i42, i43, i44, i45, i46, i47, i48, i49, i50);
        return i1;
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpcmpd EQ ymm and ymm pattern not support"); return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t * /* 0x00 */
rw_func_vpcmpd_EQ_xmm_xmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                          reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x00 */
rw_func_vpcmpd_EQ_xmm_m128(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src2_opnd,
                           reg_id_t src1_reg, reg_id_t mask_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x00 */
rw_func_vpcmpd_EQ_zmm_zmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                          reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x00 */
rw_func_vpcmpd_EQ_zmm_m512(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src2_opnd,
                           reg_id_t src1_reg, reg_id_t mask_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x01 */
rw_func_vpcmpd_LT_ymm_ymm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                          reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x01 */
rw_func_vpcmpd_LT_ymm_m256(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src2_opnd,
                           reg_id_t src1_reg, reg_id_t mask_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x01 */
rw_func_vpcmpd_LT_xmm_xmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                          reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x01 */
rw_func_vpcmpd_LT_xmm_m128(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src2_opnd,
                           reg_id_t src1_reg, reg_id_t mask_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x01 */
rw_func_vpcmpd_LT_zmm_zmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                          reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x01 */
rw_func_vpcmpd_LT_zmm_m512(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src2_opnd,
                           reg_id_t src1_reg, reg_id_t mask_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x02 */
rw_func_vpcmpd_LE_ymm_ymm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg, opnd_t src1_opnd,
                          opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    // vpcmpd {%k3} $0x02 %ymm1 %ymm2 -> %k4
    //      input mask:  %k3
    //      input imm8:  $0x02
    //      input src1:  %ymm1
    //      input src2:  %ymm2
    //      output mask:  %k4

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    int input_mask_idx = TO_K_REG_INDEX(mask_reg);
    int output_mask_idx = TO_K_REG_INDEX(dst_mask_reg);

    const uint src1_need_spill = NEED_SPILL_YMM(src1_reg) ? 1 : 0;

    switch (src1_need_spill) {
    case 0: { // no spill
        // all we need to save/restore gprs are:
        // rax, rbx, rcx, r9, r10, r11, r12, r13, r14
        instr_t *LOOP_LE = INSTR_CREATE_label(dcontext);
        instr_t *SKIP_LE = INSTR_CREATE_label(dcontext);
        instr_t *MATCH_LE = INSTR_CREATE_label(dcontext);
        instr_t *DONE_LE = INSTR_CREATE_label(dcontext);

        opnd_t opnd_rbx = opnd_create_reg(DR_REG_RBX);
        opnd_t opnd_rcx = opnd_create_reg(DR_REG_RCX);
        opnd_t opnd_r9 = opnd_create_reg(DR_REG_R9);
        opnd_t opnd_r10 = opnd_create_reg(DR_REG_R10);
        opnd_t opnd_r11 = opnd_create_reg(DR_REG_R11);
        opnd_t opnd_r12 = opnd_create_reg(DR_REG_R12);
        opnd_t opnd_r13 = opnd_create_reg(DR_REG_R13);
        opnd_t opnd_r14 = opnd_create_reg(DR_REG_R14);

        // save rax, rbx, rcx, r9, r10, r11, r12, r13, r14
        instr_t *i1 = INSTR_CREATE_push(dcontext, opnd_rbx);
        instr_t *i2 = INSTR_CREATE_push(dcontext, opnd_rcx);
        instr_t *i3 = INSTR_CREATE_push(dcontext, opnd_r9);
        instr_t *i4 = INSTR_CREATE_push(dcontext, opnd_r10);
        instr_t *i5 = INSTR_CREATE_push(dcontext, opnd_r11);
        instr_t *i6 = INSTR_CREATE_push(dcontext, opnd_r12);
        instr_t *i7 = INSTR_CREATE_push(dcontext, opnd_r13);
        instr_t *i8 = INSTR_CREATE_push(dcontext, opnd_r14);

        // pushf
        instr_t *i9 = INSTR_CREATE_pushf(dcontext);

        //  sub $64, %rsp                   | reserve 64bytes(512 bits = 2 ymm registers slot) for the spill
        instr_t *i10 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

        //  vmovdqu %ymm0, (%rsp)           | save ymm0 to stack
        instr_t *i11 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32), src1_opnd);

        //  vmovdqu %ymm2, 32(%rsp)         | save ymm2 to stack
        instr_t *i12 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, SIZE_OF_YMM, OPSZ_32), src2_opnd);

        // tls_slot(output_mask) -> r9      | accmulate mask result, r9d is the output mask, r9d is tls spill
        // register
        instr_t *i13 = RESTORE_FROM_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

        //  xor %ebx, %ebx                  | j = 0
        instr_t *i14 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_reg(DR_REG_EBX));

        // tls(%k2, input_mask) -> %r10 | get the input mask into r10
        // scratch register is %r10
        instr_t *i15 = RESTORE_FROM_TLS(dcontext, DR_REG_R10, TLS_K_idx_SLOT(input_mask_idx));

        // NOTE: /* .LoopLE */
        // mov %r10d, %r11d                 | get the input mask into r11
        instr_t *i16 = INSTR_CREATE_mov_ld(dcontext, opnd_r11, opnd_r10);

        // mov $1, %r12d                    | prepare bit mask 1 << j
        instr_t *i17 = INSTR_CREATE_mov_imm(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_immed_int(1, OPSZ_4));

        // mov %bl, %cl                     | j -> cl, move j to cl for shift count
        instr_t *i18 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_CL), opnd_create_reg(DR_REG_BL));

        // shl %cl, %r12d                   | shift left by j
        instr_t *i19 = INSTR_CREATE_shl(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_CL));

        // test %r11d, %r12d                | test if jth element is enabled
        instr_t *i20 = INSTR_CREATE_test(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_R11D));

        // jz .SkipLE                       | if not enabled, skip
        instr_t *i21 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_LE));

        // mov (%rsp, %rbx, 4), %r13d       | r13d = src_reg1[j], ymm0[j] -> r13d, load the j-th dword of ymm0
        instr_t *i22 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R13D),
                                           opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, 0, OPSZ_4));

        // mov 32(%rsp, %rbx, 4), %r14d     | r14d = src_reg2[j], ymm2[j] -> r14d, load the j-th dword of ymm2
        instr_t *i23 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R14D),
                                           opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, SIZE_OF_YMM, OPSZ_4));

        // cmp %r14d, %r13d                 | compare src_reg1[j] with src_reg2[j]
        instr_t *i24 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_R13D), opnd_create_reg(DR_REG_R14D));

        // jle .MatchLE                     | if less than or equal, set bit j in output mask
        instr_t *i25 = INSTR_CREATE_jcc(dcontext, OP_jle, opnd_create_instr(MATCH_LE));

        instr_t *i25a = INSTR_CREATE_btr(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

        // NOTE: /* .SkipLE */
        // inc %ebx                         | j++
        instr_t *i26 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

        // cmp $8, %ebx                     | compare j with 8, for 256-bits ymm, one can only hold 8 dwords
        // elements
        instr_t *i27 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

        // jl .LoopLE                       | loop if j < 8
        instr_t *i28 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_LE));

        // jmp .DoneLE
        instr_t *i29 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(DONE_LE));

        // NOTE: /* MatchLE */
        // bts %r12d, %r9d                   | set bit j in output mask
        instr_t *i30 = INSTR_CREATE_bts(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

        // inc %ebx                         | j++
        instr_t *i31 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

        // cmp $8, %ebx                     | compare j with 8 check if < 8
        instr_t *i32 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

        // jl .LoopLE                       | loop if j < 8
        instr_t *i33 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_LE));

        // NOTE: /* .DoneLE */
        // movzx %r9b, tls(%k5, output_mask) | move the output mask to rax, r10 is the tls spill register
        // but since %r9 is 0 initialized and we only need to set the bit, so we can just use %r9 as the tls spill
        // register, and directly save it to tls
        instr_t *i34a = INSTR_CREATE_and(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_immed_int(0x00FF, OPSZ_4));
        instr_t *i34 = SAVE_TO_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

        // add $64, %rsp
        instr_t *i35 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

        // popf
        instr_t *i36 = INSTR_CREATE_popf(dcontext);

        // restore rax, rbx, rcx, r9, r10, r11, r12
        instr_t *i37 = INSTR_CREATE_pop(dcontext, opnd_r14);
        instr_t *i38 = INSTR_CREATE_pop(dcontext, opnd_r13);
        instr_t *i39 = INSTR_CREATE_pop(dcontext, opnd_r12);
        instr_t *i40 = INSTR_CREATE_pop(dcontext, opnd_r11);
        instr_t *i41 = INSTR_CREATE_pop(dcontext, opnd_r10);
        instr_t *i42 = INSTR_CREATE_pop(dcontext, opnd_r9);
        instr_t *i43 = INSTR_CREATE_pop(dcontext, opnd_rcx);
        instr_t *i44 = INSTR_CREATE_pop(dcontext, opnd_rbx);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 50, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     LOOP_LE, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i25a, SKIP_LE, i26, i27,
                                     i28, i29, MATCH_LE, i30, i31, i32, i33, DONE_LE, i34a, i34, i35, i36, i37, i38,
                                     i39, i40, i41, i42, i43, i44);
#endif
        instrlist_concat_next_instr(ilist, 50, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                    LOOP_LE, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i25a, SKIP_LE, i26, i27,
                                    i28, i29, MATCH_LE, i30, i31, i32, i33, DONE_LE, i34a, i34, i35, i36, i37, i38, i39,
                                    i40, i41, i42, i43, i44);
        return i1;
    } break;
    case 1: { // only src1 need spill
    } break;
    default: return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t * /* 0x02 */
rw_func_vpcmpd_LE_ymm_m256(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src1_opnd, opnd_t src2_opnd,
                           reg_id_t src1_reg, reg_id_t mask_reg, reg_id_t dst_mask_reg)
{
    // vpcmpd {%k0} $0x02 %ymm2 <rel> 0x00007fd8b00a6380[32byte] -> %k3
    //      input mask:  %k0
    //      input imm8:  $0x02
    //      input src1:  %ymm2
    //      input src2:  <rel> 0x00007fd8b00a6380
    //      output mask:  %k3

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    int input_mask_idx = TO_K_REG_INDEX(mask_reg);
    int output_mask_idx = TO_K_REG_INDEX(dst_mask_reg);

    const uint src1_need_spill = NEED_SPILL_YMM(src1_reg) ? 1 : 0;

    switch (src1_need_spill) {
    case 0: { // no spill
        if (input_mask_idx == 0) {
            instr_t *LOOP_LE_K0 = INSTR_CREATE_label(dcontext);
            instr_t *MATCH_LE_K0 = INSTR_CREATE_label(dcontext);
            instr_t *DONE_LE_K0 = INSTR_CREATE_label(dcontext);

            opnd_t opnd_rbx = opnd_create_reg(DR_REG_RBX);
            opnd_t opnd_rcx = opnd_create_reg(DR_REG_RCX);
            opnd_t opnd_r9 = opnd_create_reg(DR_REG_R9);
            opnd_t opnd_r10 = opnd_create_reg(DR_REG_R10);
            opnd_t opnd_r11 = opnd_create_reg(DR_REG_R11);
            opnd_t opnd_r12 = opnd_create_reg(DR_REG_R12);
            opnd_t opnd_r13 = opnd_create_reg(DR_REG_R13);
            opnd_t opnd_r14 = opnd_create_reg(DR_REG_R14);

            // (i1-i8) save gprs
            instr_t *i1 = INSTR_CREATE_push(dcontext, opnd_rbx);
            instr_t *i2 = INSTR_CREATE_push(dcontext, opnd_rcx);
            instr_t *i3 = INSTR_CREATE_push(dcontext, opnd_r9);
            instr_t *i4 = INSTR_CREATE_push(dcontext, opnd_r10);
            instr_t *i5 = INSTR_CREATE_push(dcontext, opnd_r11);
            instr_t *i6 = INSTR_CREATE_push(dcontext, opnd_r12);
            instr_t *i7 = INSTR_CREATE_push(dcontext, opnd_r13);
            instr_t *i8 = INSTR_CREATE_push(dcontext, opnd_r14);

            reg_id_t spill_ymm_reg = find_one_available_spill_ymm(src1_reg);
            opnd_t spill_ymm_opnd = opnd_create_reg(spill_ymm_reg);

            // (i9) pushf
            instr_t *i9 = INSTR_CREATE_pushf(dcontext);

            // (i10) sub $64, %rsp
            instr_t *i10 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            // (i11) vmovdqu %ymm0, (%rsp)
            instr_t *i11 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32),
                                                src1_opnd);

            // (i12) spill_ymm_reg -> tls_slot(spill_ymm_reg)
            instr_t *i12 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_ymm_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_ymm_reg)), OPSZ_32);
            // (i13) vmovdqu <rel>, spill_ymm_reg
            instr_t *i13 = INSTR_CREATE_vmovdqu(dcontext, spill_ymm_opnd, src2_opnd);

            // (i14) vmovdqu spill_ymm_reg, 32(%rsp)
            instr_t *i14 = INSTR_CREATE_vmovdqu(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, SIZE_OF_YMM, OPSZ_32), spill_ymm_opnd);

            // (i15) tls_slot(spill_ymm_reg) -> spill_ymm_reg
            instr_t *i15 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_ymm_reg,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_ymm_reg)), OPSZ_32);

            // (i16) r9d = tls(output_mask)
            instr_t *i16 = RESTORE_FROM_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

            // (i17) xor %ebx, %ebx  | j = 0
            instr_t *i17 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_reg(DR_REG_EBX));

            // NOTE: /* .LoopLe_k0 */

            // (i18) mov (%rsp, %rbx, 4), %r13d
            instr_t *i18 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R13D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, 0, OPSZ_4));

            // (i19) mov 32(%rsp, %rbx, 4), %r14d
            instr_t *i19 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R14D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, SIZE_OF_YMM, OPSZ_4));

            // (i20) cmp %r14d, %r13d ( src1[j]  src2[j])
            instr_t *i20 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_R13D), opnd_create_reg(DR_REG_R14D));

            // (i21) jle .MatchLe_k0 (Jump if Less or Equal)
            instr_t *i21 = INSTR_CREATE_jcc(dcontext, OP_jle, opnd_create_instr(MATCH_LE_K0));

            // (i22) btr %r9d, %ebx (Not LE, so clear bit)
            instr_t *i22 = INSTR_CREATE_btr(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // (i23) inc %ebx
            instr_t *i23 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // (i24) cmp $8, %ebx
            instr_t *i24 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // (i25) jl .LoopLe_k0
            instr_t *i25 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_LE_K0));

            // (i26) jmp .DoneLe_k0
            instr_t *i26 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(DONE_LE_K0));

            // NOTE: /* MatchLe_k0 */
            // (i27) bts %r9d, %ebx (Is LE, so set bit)
            instr_t *i27 = INSTR_CREATE_bts(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // (i28) inc %ebx
            instr_t *i28 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // (i29) cmp $8, %ebx
            instr_t *i29 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // (i30) jl .LoopLe_k0
            instr_t *i30 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_LE_K0));

            // NOTE: /* .DoneLe_k0 */
            // (i31) and $0x00FF, %r9d
            instr_t *i31 =
                INSTR_CREATE_and(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_immed_int(0x00FF, OPSZ_4));
            // (i32) mov %r9, tls(output_mask)
            instr_t *i32 = SAVE_TO_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

            // (i33) add $64, %rsp
            instr_t *i33 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            // (i34) popf
            instr_t *i34 = INSTR_CREATE_popf(dcontext);

            // (i35-i42) restore gprs
            instr_t *i35 = INSTR_CREATE_pop(dcontext, opnd_r14);
            instr_t *i36 = INSTR_CREATE_pop(dcontext, opnd_r13);
            instr_t *i37 = INSTR_CREATE_pop(dcontext, opnd_r12);
            instr_t *i38 = INSTR_CREATE_pop(dcontext, opnd_r11);
            instr_t *i39 = INSTR_CREATE_pop(dcontext, opnd_r10);
            instr_t *i40 = INSTR_CREATE_pop(dcontext, opnd_r9);
            instr_t *i41 = INSTR_CREATE_pop(dcontext, opnd_rcx);
            instr_t *i42 = INSTR_CREATE_pop(dcontext, opnd_rbx);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 45, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         i16, i17, LOOP_LE_K0, i18, i19, i20, i21, i22, i23, i24, i25, i26, MATCH_LE_K0,
                                         i27, i28, i29, i30, DONE_LE_K0, i31, i32, i33, i34, i35, i36, i37, i38, i39,
                                         i40, i41, i42);
#endif
            instrlist_concat_next_instr(ilist, 45, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, LOOP_LE_K0, i18, i19, i20, i21, i22, i23, i24, i25, i26, MATCH_LE_K0,
                                        i27, i28, i29, i30, DONE_LE_K0, i31, i32, i33, i34, i35, i36, i37, i38, i39,
                                        i40, i41, i42);
            return i1;
        } else {
            // all we need to save/restore gprs are:
            // rax, rbx, rcx, r9, r10, r11, r12, r13, r14
            instr_t *LOOP_LE = INSTR_CREATE_label(dcontext);
            instr_t *SKIP_LE = INSTR_CREATE_label(dcontext);
            instr_t *MATCH_LE = INSTR_CREATE_label(dcontext);
            instr_t *DONE_LE = INSTR_CREATE_label(dcontext);

            opnd_t opnd_rbx = opnd_create_reg(DR_REG_RBX);
            opnd_t opnd_rcx = opnd_create_reg(DR_REG_RCX);
            opnd_t opnd_r9 = opnd_create_reg(DR_REG_R9);
            opnd_t opnd_r10 = opnd_create_reg(DR_REG_R10);
            opnd_t opnd_r11 = opnd_create_reg(DR_REG_R11);
            opnd_t opnd_r12 = opnd_create_reg(DR_REG_R12);
            opnd_t opnd_r13 = opnd_create_reg(DR_REG_R13);
            opnd_t opnd_r14 = opnd_create_reg(DR_REG_R14);

            // save rax, rbx, rcx, r9, r10, r11, r12, r13, r14
            instr_t *i1 = INSTR_CREATE_push(dcontext, opnd_rbx);
            instr_t *i2 = INSTR_CREATE_push(dcontext, opnd_rcx);
            instr_t *i3 = INSTR_CREATE_push(dcontext, opnd_r9);
            instr_t *i4 = INSTR_CREATE_push(dcontext, opnd_r10);
            instr_t *i5 = INSTR_CREATE_push(dcontext, opnd_r11);
            instr_t *i6 = INSTR_CREATE_push(dcontext, opnd_r12);
            instr_t *i7 = INSTR_CREATE_push(dcontext, opnd_r13);
            instr_t *i8 = INSTR_CREATE_push(dcontext, opnd_r14);

            // tmp reg
            reg_id_t spill_ymm_reg = YMM_SPILL_SLOT0;
            opnd_t spill_ymm_opnd = opnd_create_reg(spill_ymm_reg);

            // pushf
            instr_t *i9 = INSTR_CREATE_pushf(dcontext);

            //  sub $64, %rsp                   | reserve 64bytes(512 bits = 2 ymm registers slot) for the spill
            instr_t *i10 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            //  vmovdqu %ymm0, (%rsp)           | save ymm0 to stack
            instr_t *i11 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32),
                                                src1_opnd);

            // spill_ymm_reg -> tls_slot(spill_ymm_reg)
            instr_t *i12 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_ymm_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_ymm_reg)), OPSZ_32);

            // vmovdqu <rel>, spill_ymm_reg
            instr_t *i13 = INSTR_CREATE_vmovdqu(dcontext, spill_ymm_opnd, src2_opnd);

            //  vmovdqu spill_ymm_reg, 32(%rsp)         | save ymm2 to stack
            instr_t *i14 = INSTR_CREATE_vmovdqu(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, SIZE_OF_YMM, OPSZ_32), spill_ymm_opnd);

            // tls_slot(spill_ymm_reg) -> spill_ymm_reg
            instr_t *i15 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_ymm_reg,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_ymm_reg)), OPSZ_32);

            // tls_slot(output_mask) -> r9      | accmulate mask result, r9d is the output mask, r9d is tls spill
            // register
            instr_t *i16 = RESTORE_FROM_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

            //  xor %ebx, %ebx                  | j = 0
            instr_t *i17 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_reg(DR_REG_EBX));

            // tls(%k2, input_mask) -> %r10 | get the input mask into r10
            // scratch register is %r10
            instr_t *i18 = RESTORE_FROM_TLS(dcontext, DR_REG_R10, TLS_K_idx_SLOT(input_mask_idx));

            // NOTE: /* .LoopLE */
            // mov %r10d, %r11d                 | get the input mask into r11
            instr_t *i19 = INSTR_CREATE_mov_ld(dcontext, opnd_r11, opnd_r10);

            // mov $1, %r12d                    | prepare bit mask 1 << j
            instr_t *i20 =
                INSTR_CREATE_mov_imm(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_immed_int(1, OPSZ_4));

            // mov %bl, %cl                     | j -> cl, move j to cl for shift count
            instr_t *i21 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_CL), opnd_create_reg(DR_REG_BL));

            // shl %cl, %r12d                   | shift left by j
            instr_t *i22 = INSTR_CREATE_shl(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_CL));

            // test %r11d, %r12d                | test if jth element is enabled
            instr_t *i23 = INSTR_CREATE_test(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_R11D));

            // jz .SkipLE                       | if not enabled, skip
            instr_t *i24 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_LE));

            // mov (%rsp, %rbx, 4), %r13d       | r13d = src_reg1[j], ymm0[j] -> r13d, load the j-th dword of ymm0
            instr_t *i25 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R13D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, 0, OPSZ_4));

            // mov 32(%rsp, %rbx, 4), %r14d     | r14d = src_reg2[j], ymm2[j] -> r14d, load the j-th dword of ymm2
            instr_t *i26 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R14D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, SIZE_OF_YMM, OPSZ_4));

            // cmp %r14d, %r13d                 | compare src_reg1[j] with src_reg2[j]
            instr_t *i27 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_R13D), opnd_create_reg(DR_REG_R14D));

            // jle .MatchLE                     | if less than or equal, set bit j in output mask
            instr_t *i28 = INSTR_CREATE_jcc(dcontext, OP_jle, opnd_create_instr(MATCH_LE));

            instr_t *i28a = INSTR_CREATE_btr(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // NOTE: /* .SkipLE */
            // inc %ebx                         | j++
            instr_t *i29 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // cmp $8, %ebx                     | compare j with 8, for 256-bits ymm, one can only hold 8 dwords
            // elements
            instr_t *i30 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // jl .LoopLE                       | loop if j < 8
            instr_t *i31 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_LE));

            // jmp .DoneLE
            instr_t *i32 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(DONE_LE));

            // NOTE: /* MatchLE */
            // bts %r12d, %r9d                   | set bit j in output mask
            instr_t *i33 = INSTR_CREATE_bts(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // inc %ebx                         | j++
            instr_t *i34 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // cmp $8, %ebx                     | compare j with 8 check if < 8
            instr_t *i35 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // jl .LoopLE                       | loop if j < 8
            instr_t *i36 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_LE));

            // NOTE: /* .DoneLE */
            // movzx %r9b, tls(%k5, output_mask) | move the output mask to rax, r10 is the tls spill register
            // but since %r9 is 0 initialized and we only need to set the bit, so we can just use %r9 as the tls spill
            // register, and directly save it to tls
            instr_t *i37a =
                INSTR_CREATE_and(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_immed_int(0x00FF, OPSZ_4));
            instr_t *i37 = SAVE_TO_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

            // add $64, %rsp
            instr_t *i38 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            // popf
            instr_t *i39 = INSTR_CREATE_popf(dcontext);

            // restore rax, rbx, rcx, r9, r10, r11, r12
            instr_t *i40 = INSTR_CREATE_pop(dcontext, opnd_r14);
            instr_t *i41 = INSTR_CREATE_pop(dcontext, opnd_r13);
            instr_t *i42 = INSTR_CREATE_pop(dcontext, opnd_r12);
            instr_t *i43 = INSTR_CREATE_pop(dcontext, opnd_r11);
            instr_t *i44 = INSTR_CREATE_pop(dcontext, opnd_r10);
            instr_t *i45 = INSTR_CREATE_pop(dcontext, opnd_r9);
            instr_t *i46 = INSTR_CREATE_pop(dcontext, opnd_rcx);
            instr_t *i47 = INSTR_CREATE_pop(dcontext, opnd_rbx);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 53, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         i16, i17, i18, LOOP_LE, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i28a,
                                         SKIP_LE, i29, i30, i31, i32, MATCH_LE, i33, i34, i35, i36, DONE_LE, i37a, i37,
                                         i38, i39, i40, i41, i42, i43, i44, i45, i46, i47);
#endif
            instrlist_concat_next_instr(ilist, 53, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, i18, LOOP_LE, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i28a,
                                        SKIP_LE, i29, i30, i31, i32, MATCH_LE, i33, i34, i35, i36, DONE_LE, i37a, i37,
                                        i38, i39, i40, i41, i42, i43, i44, i45, i46, i47);
            return i1;
        }
    } break;
    case 1: { // only src1 need spill
    } break;
    default: return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t * /* 0x02 */
rw_func_vpcmpd_LE_xmm_xmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                          reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x02 */
rw_func_vpcmpd_LE_xmm_m128(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src2_opnd,
                           reg_id_t src1_reg, reg_id_t mask_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x02 */
rw_func_vpcmpd_LE_zmm_zmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                          reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x02 */
rw_func_vpcmpd_LE_zmm_m512(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src2_opnd,
                           reg_id_t src1_reg, reg_id_t mask_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x03 */
rw_func_vpcmpd_FALSE_ymm_ymm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                             reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x03 */
rw_func_vpcmpd_FALSE_ymm_m256(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src2_opnd,
                              reg_id_t src1_reg, reg_id_t mask_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x03 */
rw_func_vpcmpd_FALSE_xmm_xmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                             reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x03 */
rw_func_vpcmpd_FALSE_xmm_m128(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src2_opnd,
                              reg_id_t src1_reg, reg_id_t mask_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x03 */
rw_func_vpcmpd_FALSE_zmm_zmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                             reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x03 */
rw_func_vpcmpd_FALSE_zmm_m512(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src2_opnd,
                              reg_id_t src1_reg, reg_id_t mask_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x04 */
rw_func_vpcmpd_NEQ_ymm_ymm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t src2_reg,
                           reg_id_t dst_mask_reg)
{
    // vpcmpd {%k0} $0x04 %ymm1 %ymm2 -> %k1
    //     [REWRITE INFO]:   ymm_bitmap: 0
    //     mask: %k0
    //     src1: %ymm1
    //     src2: %ymm2
    //     dst: %k1

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    int input_mask_idx = TO_K_REG_INDEX(mask_reg);
    int output_mask_idx = TO_K_REG_INDEX(dst_mask_reg);

    const uint src1_need_spill = NEED_SPILL_YMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill = NEED_SPILL_YMM(src2_reg) ? 2 : 0;
    const uint need_spill = src1_need_spill | src2_need_spill;

    switch (need_spill) {
    case 0: { // no spill
        if (input_mask_idx == 0) {
            // vpcmpd {%k0} $0x04 %ymm1 %ymm2 -> %k1
            // k0 is treated as all 1s (all lanes active)
            instr_t *LOOP_NE_K0 = INSTR_CREATE_label(dcontext);
            instr_t *MATCH_NE_K0 = INSTR_CREATE_label(dcontext);
            instr_t *DONE_NE_K0 = INSTR_CREATE_label(dcontext);

            opnd_t opnd_rbx = opnd_create_reg(DR_REG_RBX);
            opnd_t opnd_rcx = opnd_create_reg(DR_REG_RCX);
            opnd_t opnd_r9 = opnd_create_reg(DR_REG_R9);
            opnd_t opnd_r10 = opnd_create_reg(DR_REG_R10);
            opnd_t opnd_r11 = opnd_create_reg(DR_REG_R11);
            opnd_t opnd_r12 = opnd_create_reg(DR_REG_R12);
            opnd_t opnd_r13 = opnd_create_reg(DR_REG_R13);
            opnd_t opnd_r14 = opnd_create_reg(DR_REG_R14);

            // save rax, rbx, rcx, r9, r10, r11, r12, r13, r14
            instr_t *i1 = INSTR_CREATE_push(dcontext, opnd_rbx);
            instr_t *i2 = INSTR_CREATE_push(dcontext, opnd_rcx);
            instr_t *i3 = INSTR_CREATE_push(dcontext, opnd_r9);
            instr_t *i4 = INSTR_CREATE_push(dcontext, opnd_r10);
            instr_t *i5 = INSTR_CREATE_push(dcontext, opnd_r11);
            instr_t *i6 = INSTR_CREATE_push(dcontext, opnd_r12);
            instr_t *i7 = INSTR_CREATE_push(dcontext, opnd_r13);
            instr_t *i8 = INSTR_CREATE_push(dcontext, opnd_r14);

            // pushf
            instr_t *i9 = INSTR_CREATE_pushf(dcontext);

            //  sub $64, %rsp
            instr_t *i10 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            //  vmovdqu %ymm0 (src1), (%rsp)
            instr_t *i11 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32),
                                                src1_opnd);

            //  vmovdqu %ymm2 (src2), 32(%rsp)
            instr_t *i12 = INSTR_CREATE_vmovdqu(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, SIZE_OF_YMM, OPSZ_32), src2_opnd);

            //  r9d = tls(output_mask) | accmulate mask result
            instr_t *i13 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_R9D));

            //  xor %ebx, %ebx  | j = 0
            instr_t *i14 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_reg(DR_REG_EBX));

            // NOTE: /* .LoopNE_k0 */

            // mov (%rsp, %rbx, 4), %r13d
            instr_t *i15 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R13D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, 0, OPSZ_4));

            // mov 32(%rsp, %rbx, 4), %r14d
            instr_t *i16 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R14D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, SIZE_OF_YMM, OPSZ_4));

            // cmp %r14d, %r13d
            instr_t *i17 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_R13D), opnd_create_reg(DR_REG_R14D));

            // jne .MatchNE_k0 (Jump if Not Equal)
            instr_t *i18 = INSTR_CREATE_jcc(dcontext, OP_jne, opnd_create_instr(MATCH_NE_K0));

            // btr %r9d, %ebx (Is Equal: clear bit j)
            instr_t *i19 = INSTR_CREATE_btr(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // NOTE: /* .NextIter_k0 */
            // inc %ebx
            instr_t *i20 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // cmp $8, %ebx
            instr_t *i21 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // jl .LoopNE_k0
            instr_t *i22 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_NE_K0));

            // jmp .DoneNE_k0
            instr_t *i23 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(DONE_NE_K0));

            // NOTE: /* MatchNE_k0 */
            // bts %r9d, %ebx (Not Equal: set bit j)
            instr_t *i24 = INSTR_CREATE_bts(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // inc %ebx
            instr_t *i25 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // cmp $8, %ebx
            instr_t *i26 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // jl .LoopNE_k0
            instr_t *i27 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_NE_K0));

            // NOTE: /* .DoneNE_k0 */
            // and $0x00FF, %r9d
            instr_t *i28 =
                INSTR_CREATE_and(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_immed_int(0x00FF, OPSZ_4));
            // mov %r9, tls(output_mask)
            instr_t *i29 = SAVE_TO_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

            // add $64, %rsp
            instr_t *i30 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            // popf
            instr_t *i31 = INSTR_CREATE_popf(dcontext);

            // restore rax, rbx, rcx, r9, r10, r11, r12...
            instr_t *i32 = INSTR_CREATE_pop(dcontext, opnd_r14);
            instr_t *i33 = INSTR_CREATE_pop(dcontext, opnd_r13);
            instr_t *i34 = INSTR_CREATE_pop(dcontext, opnd_r12);
            instr_t *i35 = INSTR_CREATE_pop(dcontext, opnd_r11);
            instr_t *i36 = INSTR_CREATE_pop(dcontext, opnd_r10);
            instr_t *i37 = INSTR_CREATE_pop(dcontext, opnd_r9);
            instr_t *i38 = INSTR_CREATE_pop(dcontext, opnd_rcx);
            instr_t *i39 = INSTR_CREATE_pop(dcontext, opnd_rbx);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 42, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14,
                                         LOOP_NE_K0, i15, i16, i17, i18, i19, /* NEXT_ITER_K0 (i20) */ i20, i21, i22,
                                         i23, MATCH_NE_K0, i24, i25, i26, i27, DONE_NE_K0, i28, i29, i30, i31, i32, i33,
                                         i34, i35, i36, i37, i38, i39);
#endif
            instrlist_concat_next_instr(ilist, 42, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14,
                                        LOOP_NE_K0, i15, i16, i17, i18, i19, /* NEXT_ITER_K0 (i20) */ i20, i21, i22,
                                        i23, MATCH_NE_K0, i24, i25, i26, i27, DONE_NE_K0, i28, i29, i30, i31, i32, i33,
                                        i34, i35, i36, i37, i38, i39);
            return i1;
        } else {
            // all we need to save/restore gprs are:
            // rax, rbx, rcx, r9, r10, r11, r12, r13, r14
            instr_t *LOOP_NE = INSTR_CREATE_label(dcontext);
            instr_t *SKIP_NE = INSTR_CREATE_label(dcontext);
            instr_t *MATCH_NE = INSTR_CREATE_label(dcontext);
            instr_t *DONE_NE = INSTR_CREATE_label(dcontext);

            opnd_t opnd_rbx = opnd_create_reg(DR_REG_RBX);
            opnd_t opnd_rcx = opnd_create_reg(DR_REG_RCX);
            opnd_t opnd_r9 = opnd_create_reg(DR_REG_R9);
            opnd_t opnd_r10 = opnd_create_reg(DR_REG_R10);
            opnd_t opnd_r11 = opnd_create_reg(DR_REG_R11);
            opnd_t opnd_r12 = opnd_create_reg(DR_REG_R12);
            opnd_t opnd_r13 = opnd_create_reg(DR_REG_R13);
            opnd_t opnd_r14 = opnd_create_reg(DR_REG_R14);

            // save rax, rbx, rcx, r9, r10, r11, r12, r13, r14
            instr_t *i1 = INSTR_CREATE_push(dcontext, opnd_rbx);
            instr_t *i2 = INSTR_CREATE_push(dcontext, opnd_rcx);
            instr_t *i3 = INSTR_CREATE_push(dcontext, opnd_r9);
            instr_t *i4 = INSTR_CREATE_push(dcontext, opnd_r10);
            instr_t *i5 = INSTR_CREATE_push(dcontext, opnd_r11);
            instr_t *i6 = INSTR_CREATE_push(dcontext, opnd_r12);
            instr_t *i7 = INSTR_CREATE_push(dcontext, opnd_r13);
            instr_t *i8 = INSTR_CREATE_push(dcontext, opnd_r14);

            // pushf
            instr_t *i9 = INSTR_CREATE_pushf(dcontext);

            //  sub $64, %rsp                   | reserve 64bytes(512 bits = 2 ymm registers slot) for the spill
            instr_t *i10 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            //  vmovdqu %ymm0, (%rsp)           | save ymm0 to stack
            instr_t *i11 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32),
                                                src1_opnd);

            //  vmovdqu %ymm2, 32(%rsp)         | save ymm2 to stack
            instr_t *i12 = INSTR_CREATE_vmovdqu(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, SIZE_OF_YMM, OPSZ_32), src2_opnd);

            // tls_slot(output_mask) -> r9      | accmulate mask result, r9d is the output mask, r9d is tls spill
            // register
            instr_t *i13 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_R9D));

            //  xor %ebx, %ebx                  | j = 0
            instr_t *i14 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_reg(DR_REG_EBX));

            // tls(%k2, input_mask) -> %r10 | get the input mask into r10
            // scratch register is %r10
            instr_t *i15 = RESTORE_FROM_TLS(dcontext, DR_REG_R10, TLS_K_idx_SLOT(input_mask_idx));

            // NOTE: /* .LoopNE */
            // mov %r10d, %r11d                 | get the input mask into r11
            instr_t *i16 = INSTR_CREATE_mov_ld(dcontext, opnd_r11, opnd_r10);
            // mov $1, %r12d                    | prepare bit mask 1 << j
            instr_t *i17 =
                INSTR_CREATE_mov_imm(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_immed_int(1, OPSZ_4));

            // mov %bl, %cl                     | j -> cl, move j to cl for shift count
            instr_t *i18 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_CL), opnd_create_reg(DR_REG_BL));

            // shl %cl, %r12d                   | shift left by j
            instr_t *i19 = INSTR_CREATE_shl(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_CL));

            // test %r11d, %r12d                | test if jth element is enabled
            instr_t *i20 = INSTR_CREATE_test(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_R11D));

            // jz .SkipNE                       | if not enabled, skip
            instr_t *i21 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_NE));

            // mov (%rsp, %rbx, 4), %r13d       | r13d = src_reg1[j], ymm0[j] -> r13d, load the j-th dword of ymm0
            instr_t *i22 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R13D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, 0, OPSZ_4));

            // mov 32(%rsp, %rbx, 4), %r14d     | r14d = src_reg2[j], ymm2[j] -> r14d, load the j-th dword of ymm2
            instr_t *i23 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R14D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, SIZE_OF_YMM, OPSZ_4));

            // cmp %r14d, %r13d                 | compare src_reg1[j] with src_reg2[j]
            instr_t *i24 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_R13D), opnd_create_reg(DR_REG_R14D));

            // jne .MatchNE                     | if equal, set bit j in output mask
            instr_t *i25 = INSTR_CREATE_jcc(dcontext, OP_jne, opnd_create_instr(MATCH_NE));

            instr_t *i25a = INSTR_CREATE_btr(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // NOTE: /* .SkipNE */
            // inc %ebx                         | j++
            instr_t *i26 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // cmp $8, %ebx                     | compare j with 8, for 256-bits ymm, one can only hold 8 dwords
            // elements
            instr_t *i27 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // jl .LoopNE                       | loop if j < 8
            instr_t *i28 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_NE));

            // jmp .DoneNE
            instr_t *i29 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(DONE_NE));

            // NOTE: /* MatchNE */
            // bts %r12d, %r9d                   | set bit j in output mask
            instr_t *i30 = INSTR_CREATE_bts(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // inc %ebx                         | j++
            instr_t *i31 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // cmp $8, %ebx                     | compare j with 8 check if < 8
            instr_t *i32 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // jl .LoopNE                       | loop if j < 8
            instr_t *i33 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_NE));

            // NOTE: /* .DoneNE */
            // movzx %r9b, tls(%k5, output_mask) | move the output mask to rax, r10 is the tls spill register
            // but since %r9 is 0 initialized and we only need to set the bit, so we can just use %r9 as the tls spill
            // register, and directly save it to tls
            instr_t *i34a =
                INSTR_CREATE_and(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_immed_int(0x00FF, OPSZ_4));
            instr_t *i34 = SAVE_TO_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

            // add $64, %rsp
            instr_t *i35 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            // popf
            instr_t *i36 = INSTR_CREATE_popf(dcontext);

            // restore rax, rbx, rcx, r9, r10, r11, r12
            instr_t *i37 = INSTR_CREATE_pop(dcontext, opnd_r14);
            instr_t *i38 = INSTR_CREATE_pop(dcontext, opnd_r13);
            instr_t *i39 = INSTR_CREATE_pop(dcontext, opnd_r12);
            instr_t *i40 = INSTR_CREATE_pop(dcontext, opnd_r11);
            instr_t *i41 = INSTR_CREATE_pop(dcontext, opnd_r10);
            instr_t *i42 = INSTR_CREATE_pop(dcontext, opnd_r9);
            instr_t *i43 = INSTR_CREATE_pop(dcontext, opnd_rcx);
            instr_t *i44 = INSTR_CREATE_pop(dcontext, opnd_rbx);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 50, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         LOOP_NE, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i25a, SKIP_NE, i26,
                                         i27, i28, i29, MATCH_NE, i30, i31, i32, i33, DONE_NE, i34a, i34, i35, i36, i37,
                                         i38, i39, i40, i41, i42, i43, i44);
#endif
            instrlist_concat_next_instr(ilist, 50, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        LOOP_NE, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i25a, SKIP_NE, i26,
                                        i27, i28, i29, MATCH_NE, i30, i31, i32, i33, DONE_NE, i34a, i34, i35, i36, i37,
                                        i38, i39, i40, i41, i42, i43, i44);
            return i1;
        }
    } break;
    case 1: { // only src1 need spill
              // rax, rbx, rcx, r9, r10, r11, r12, r13, r14
        if (input_mask_idx == 0) {
            // vpcmpd {%k0} $0x04 %ymm1 %ymm2 -> %k1
            // k0 is treated as all 1s (all lanes active)
            instr_t *LOOP_NE_K0 = INSTR_CREATE_label(dcontext);
            instr_t *MATCH_NE_K0 = INSTR_CREATE_label(dcontext);
            instr_t *DONE_NE_K0 = INSTR_CREATE_label(dcontext);

            reg_id_t spill_src1_reg = find_one_available_spill_ymm(src2_reg);
            opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);

            opnd_t opnd_rbx = opnd_create_reg(DR_REG_RBX);
            opnd_t opnd_rcx = opnd_create_reg(DR_REG_RCX);
            opnd_t opnd_r9 = opnd_create_reg(DR_REG_R9);
            opnd_t opnd_r10 = opnd_create_reg(DR_REG_R10);
            opnd_t opnd_r11 = opnd_create_reg(DR_REG_R11);
            opnd_t opnd_r12 = opnd_create_reg(DR_REG_R12);
            opnd_t opnd_r13 = opnd_create_reg(DR_REG_R13);
            opnd_t opnd_r14 = opnd_create_reg(DR_REG_R14);

            // save rax, rbx, rcx, r9, r10, r11, r12, r13, r14
            instr_t *i1 = INSTR_CREATE_push(dcontext, opnd_rbx);
            instr_t *i2 = INSTR_CREATE_push(dcontext, opnd_rcx);
            instr_t *i3 = INSTR_CREATE_push(dcontext, opnd_r9);
            instr_t *i4 = INSTR_CREATE_push(dcontext, opnd_r10);
            instr_t *i5 = INSTR_CREATE_push(dcontext, opnd_r11);
            instr_t *i6 = INSTR_CREATE_push(dcontext, opnd_r12);
            instr_t *i7 = INSTR_CREATE_push(dcontext, opnd_r13);
            instr_t *i8 = INSTR_CREATE_push(dcontext, opnd_r14);

            // pushf
            instr_t *i9 = INSTR_CREATE_pushf(dcontext);

            //  sub $64, %rsp
            instr_t *i10 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            // spill_src1_reg -> tls_slot(spill_src1_reg)
            instr_t *i11 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);

            // tls_slot(src1_reg) -> spill_src1_reg
            instr_t *i12 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);

            //  vmovdqu spill_src1 (src1), (%rsp)
            instr_t *i13 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32),
                                                spill_src1_opnd);

            // tls_slot(spill_src1_reg) -> spill_src1_reg
            instr_t *i14 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);

            //  vmovdqu %ymm2 (src2), 32(%rsp)
            instr_t *i15 = INSTR_CREATE_vmovdqu(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, SIZE_OF_YMM, OPSZ_32), src2_opnd);

            // xor %r9d, %r9d
            instr_t *i16 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_R9D));

            //  xor %ebx, %ebx  | j = 0
            instr_t *i17 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_reg(DR_REG_EBX));

            // NOTE: /* .LoopNE_k0 */

            // mov (%rsp, %rbx, 4), %r13d
            instr_t *i18 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R13D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, 0, OPSZ_4));

            // mov 32(%rsp, %rbx, 4), %r14d
            instr_t *i19 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R14D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, SIZE_OF_YMM, OPSZ_4));

            // cmp %r14d, %r13d
            instr_t *i20 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_R13D), opnd_create_reg(DR_REG_R14D));

            // jne .MatchNE_k0 (Jump if Not Equal)
            instr_t *i21 = INSTR_CREATE_jcc(dcontext, OP_jne, opnd_create_instr(MATCH_NE_K0));

            // btr %r9d, %ebx (Is Equal: clear bit j)
            instr_t *i22 = INSTR_CREATE_btr(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // NOTE: /* .NextIter_k0 */
            // inc %ebx
            instr_t *i23 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // cmp $8, %ebx
            instr_t *i24 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // jl .LoopNE_k0
            instr_t *i25 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_NE_K0));

            // jmp .DoneNE_k0
            instr_t *i26 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(DONE_NE_K0));

            // NOTE: /* MatchNE_k0 */
            // bts %r9d, %ebx (Not Equal: set bit j)
            instr_t *i27 = INSTR_CREATE_bts(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // inc %ebx
            instr_t *i28 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // cmp $8, %ebx
            instr_t *i29 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // jl .LoopNE_k0
            instr_t *i30 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_NE_K0));

            // NOTE: /* .DoneNE_k0 */
            // and $0x00FF, %r9d
            instr_t *i31 =
                INSTR_CREATE_and(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_immed_int(0x00FF, OPSZ_4));
            // mov %r9, tls(output_mask)
            instr_t *i32 = SAVE_TO_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

            // add $64, %rsp
            instr_t *i33 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            // popf
            instr_t *i34 = INSTR_CREATE_popf(dcontext);

            // restore rax, rbx, rcx, r9, r10, r11, r12...
            instr_t *i35 = INSTR_CREATE_pop(dcontext, opnd_r14);
            instr_t *i36 = INSTR_CREATE_pop(dcontext, opnd_r13);
            instr_t *i37 = INSTR_CREATE_pop(dcontext, opnd_r12);
            instr_t *i38 = INSTR_CREATE_pop(dcontext, opnd_r11);
            instr_t *i39 = INSTR_CREATE_pop(dcontext, opnd_r10);
            instr_t *i40 = INSTR_CREATE_pop(dcontext, opnd_r9);
            instr_t *i41 = INSTR_CREATE_pop(dcontext, opnd_rcx);
            instr_t *i42 = INSTR_CREATE_pop(dcontext, opnd_rbx);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 45, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         i16, i17, LOOP_NE_K0, i18, i19, i20, i21, i22, i23, i24, i25, i26, MATCH_NE_K0,
                                         i27, i28, i29, DONE_NE_K0, i30, i31, i32, i33, i34, i35, i36, i37, i38, i39,
                                         i40, i41, i42);
#endif
            instrlist_concat_next_instr(ilist, 45, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, LOOP_NE_K0, i18, i19, i20, i21, i22, i23, i24, i25, i26, MATCH_NE_K0,
                                        i27, i28, i29, DONE_NE_K0, i30, i31, i32, i33, i34, i35, i36, i37, i38, i39,
                                        i40, i41, i42);
            return i1;
        } else {
            instr_t *LOOP_NE = INSTR_CREATE_label(dcontext);
            instr_t *SKIP_NE = INSTR_CREATE_label(dcontext);
            instr_t *MATCH_NE = INSTR_CREATE_label(dcontext);
            instr_t *DONE_NE = INSTR_CREATE_label(dcontext);

            opnd_t opnd_rbx = opnd_create_reg(DR_REG_RBX);
            opnd_t opnd_rcx = opnd_create_reg(DR_REG_RCX);
            opnd_t opnd_r9 = opnd_create_reg(DR_REG_R9);
            opnd_t opnd_r10 = opnd_create_reg(DR_REG_R10);
            opnd_t opnd_r11 = opnd_create_reg(DR_REG_R11);
            opnd_t opnd_r12 = opnd_create_reg(DR_REG_R12);
            opnd_t opnd_r13 = opnd_create_reg(DR_REG_R13);
            opnd_t opnd_r14 = opnd_create_reg(DR_REG_R14);

            // save rax, rbx, rcx, r9, r10, r11, r12, r13, r14
            instr_t *i1 = INSTR_CREATE_push(dcontext, opnd_rbx);
            instr_t *i2 = INSTR_CREATE_push(dcontext, opnd_rcx);
            instr_t *i3 = INSTR_CREATE_push(dcontext, opnd_r9);
            instr_t *i4 = INSTR_CREATE_push(dcontext, opnd_r10);
            instr_t *i5 = INSTR_CREATE_push(dcontext, opnd_r11);
            instr_t *i6 = INSTR_CREATE_push(dcontext, opnd_r12);
            instr_t *i7 = INSTR_CREATE_push(dcontext, opnd_r13);
            instr_t *i8 = INSTR_CREATE_push(dcontext, opnd_r14);

            // spill_src1_reg use YMM_SPILL_SLOT0
            reg_id_t spill_src1_reg = YMM_SPILL_SLOT0;
            opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);

            // pushf
            instr_t *i9 = INSTR_CREATE_pushf(dcontext);

            // sub $64, %rsp                   | reserve 64bytes(512 bits = 2 ymm registers slot) for the spill
            instr_t *i10 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            // spill_src1_reg -> tls_slot(spill_src1_reg)
            instr_t *i11 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);

            // tls_slot(src1_reg) -> spill_src1_reg
            instr_t *i12 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);

            //  vmovdqu spill_src1_reg, (%rsp)           | save ymm0 to stack
            instr_t *i13 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32),
                                                spill_src1_opnd);

            //  vmovdqu %ymm2, 32(%rsp)         | save ymm2 to stack
            instr_t *i14 = INSTR_CREATE_vmovdqu(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, SIZE_OF_YMM, OPSZ_32), src2_opnd);

            // tls_slot(spill_src1_reg) -> spill_src1_reg
            instr_t *i15 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);

            //  xor %r9d, %r9d                  | accmulate mask result, r9d is the output mask, r9d is tls spill
            //  register
            instr_t *i16 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_R9D));

            //  xor %ebx, %ebx                  | j = 0
            instr_t *i17 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_reg(DR_REG_EBX));

            // tls(%k2, input_mask) -> %r10 | get the input mask into r10
            // scratch register is %r10
            instr_t *i18 = RESTORE_FROM_TLS(dcontext, DR_REG_R10, TLS_K_idx_SLOT(input_mask_idx));

            // NOTE: /* .LoopNE */
            // mov %r10d, %r11d                 | get the input mask into r11
            instr_t *i19 = INSTR_CREATE_mov_ld(dcontext, opnd_r11, opnd_r10);
            // mov $1, %r12d                    | prepare bit mask 1 << j
            instr_t *i20 =
                INSTR_CREATE_mov_imm(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_immed_int(1, OPSZ_4));

            // mov %bl, %cl                     | j -> cl, move j to cl for shift count
            instr_t *i21 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_CL), opnd_create_reg(DR_REG_BL));

            // shl %cl, %r12d                   | shift left by j
            instr_t *i22 = INSTR_CREATE_shl(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_CL));

            // test %r11d, %r12d                | test if jth element is enabled
            instr_t *i23 = INSTR_CREATE_test(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_R11D));

            // jz .SkipNE                       | if not enabled, skip
            instr_t *i24 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_NE));

            // mov (%rsp, %rbx, 4), %r13d       | r13d = src_reg1[j], ymm0[j] -> r13d, load the j-th dword of ymm0
            instr_t *i25 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R13D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, 0, OPSZ_4));

            // mov 32(%rsp, %rbx, 4), %r14d     | r14d = src_reg2[j], ymm2[j] -> r14d, load the j-th dword of ymm2
            instr_t *i26 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R14D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, SIZE_OF_YMM, OPSZ_4));

            // cmp %r14d, %r13d                 | compare src_reg1[j] with src_reg2[j]
            instr_t *i27 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_R13D), opnd_create_reg(DR_REG_R14D));

            // jne .MatchNE                     | if equal, set bit j in output mask
            instr_t *i28 = INSTR_CREATE_jcc(dcontext, OP_jne, opnd_create_instr(MATCH_NE));

            instr_t *i28a = INSTR_CREATE_btr(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // NOTE: /* .SkipNE */
            // inc %ebx                         | j++
            instr_t *i29 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // cmp $8, %ebx                     | compare j with 8, for 256-bits ymm, one can only hold 8 dwords
            // elements
            instr_t *i30 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // jl .LoopNE                       | loop if j < 8
            instr_t *i31 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_NE));

            // jmp .DoneNE
            instr_t *i32 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(DONE_NE));

            // NOTE: /* MatchNE */
            // bts %r12d, %r9d                   | set bit j in output mask
            instr_t *i33 = INSTR_CREATE_bts(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // inc %ebx                         | j++
            instr_t *i34 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // cmp $8, %ebx                     | compare j with 8 check if < 8
            instr_t *i35 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // jl .LoopNE                       | loop if j < 8
            instr_t *i36 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_NE));

            // NOTE: /* .DoneNE */
            // movzx %r9b, tls(%k5, output_mask) | move the output mask to rax, r10 is the tls spill register
            // but since %r9 is 0 initialized and we only need to set the bit, so we can just use %r9 as the tls spill
            // register, and directly save it to tls
            instr_t *i37a =
                INSTR_CREATE_and(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_immed_int(0x00FF, OPSZ_4));
            instr_t *i37 = SAVE_TO_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

            // add $64, %rsp
            instr_t *i38 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            // popf
            instr_t *i39 = INSTR_CREATE_popf(dcontext);

            // restore rax, rbx, rcx, r9, r10, r11, r12
            instr_t *i40 = INSTR_CREATE_pop(dcontext, opnd_r14);
            instr_t *i41 = INSTR_CREATE_pop(dcontext, opnd_r13);
            instr_t *i42 = INSTR_CREATE_pop(dcontext, opnd_r12);
            instr_t *i43 = INSTR_CREATE_pop(dcontext, opnd_r11);
            instr_t *i44 = INSTR_CREATE_pop(dcontext, opnd_r10);
            instr_t *i45 = INSTR_CREATE_pop(dcontext, opnd_r9);
            instr_t *i46 = INSTR_CREATE_pop(dcontext, opnd_rcx);
            instr_t *i47 = INSTR_CREATE_pop(dcontext, opnd_rbx);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 53, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         i16, i17, i18, LOOP_NE, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i28a,
                                         SKIP_NE, i29, i30, i31, i32, MATCH_NE, i33, i34, i35, i36, DONE_NE, i37a, i37,
                                         i38, i39, i40, i41, i42, i43, i44, i45, i46, i47);
#endif
            instrlist_concat_next_instr(ilist, 53, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, i18, LOOP_NE, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i28a,
                                        SKIP_NE, i29, i30, i31, i32, MATCH_NE, i33, i34, i35, i36, DONE_NE, i37a, i37,
                                        i38, i39, i40, i41, i42, i43, i44, i45, i46, i47);
            return i1;
        }
    } break;
    case 2: { // only src2 need spill

    } break;
    case 3: { // both src1 and src2 need spill

    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpcmpd EQ ymm and ymm pattern not support"); return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t * /* 0x04 */
rw_func_vpcmpd_NEQ_ymm_m256(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src2_opnd,
                            reg_id_t src1_reg, reg_id_t mask_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x04 */
rw_func_vpcmpd_NEQ_xmm_xmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x04 */
rw_func_vpcmpd_NEQ_xmm_m128(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src2_opnd,
                            reg_id_t src1_reg, reg_id_t mask_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x04 */
rw_func_vpcmpd_NEQ_zmm_zmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x04 */
rw_func_vpcmpd_NEQ_zmm_m512(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src2_opnd,
                            reg_id_t src1_reg, reg_id_t mask_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x05 */
rw_func_vpcmpd_NLT_ymm_ymm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x05 */
rw_func_vpcmpd_NLT_ymm_m256(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src2_opnd,
                            reg_id_t src1_reg, reg_id_t mask_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x05 */
rw_func_vpcmpd_NLT_xmm_xmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x05 */
rw_func_vpcmpd_NLT_xmm_m128(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src2_opnd,
                            reg_id_t src1_reg, reg_id_t mask_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x05 */
rw_func_vpcmpd_NLT_zmm_zmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x05 */
rw_func_vpcmpd_NLT_zmm_m512(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src2_opnd,
                            reg_id_t src1_reg, reg_id_t mask_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x06 */
rw_func_vpcmpd_NLE_ymm_ymm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    opnd_t src1_opnd = opnd_create_reg(src1_reg);
    opnd_t src2_opnd = opnd_create_reg(src2_reg);
    int input_mask_idx = TO_K_REG_INDEX(mask_reg);
    int output_mask_idx = TO_K_REG_INDEX(dst_mask_reg);

    const uint src1_need_spill = NEED_SPILL_YMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill = NEED_SPILL_YMM(src2_reg) ? 2 : 0;
    const uint need_spill = src1_need_spill | src2_need_spill;

    switch (need_spill) {
    case 0: { /* no spill */
        // no spill needed
        instr_t *LOOP_NLE = INSTR_CREATE_label(dcontext);
        instr_t *SKIP_NLE = INSTR_CREATE_label(dcontext);
        instr_t *MATCH_NLE = INSTR_CREATE_label(dcontext);
        instr_t *DONE_NLE = INSTR_CREATE_label(dcontext);

        opnd_t opnd_rbx = opnd_create_reg(DR_REG_RBX);
        opnd_t opnd_rcx = opnd_create_reg(DR_REG_RCX);
        opnd_t opnd_r9 = opnd_create_reg(DR_REG_R9);
        opnd_t opnd_r10 = opnd_create_reg(DR_REG_R10);
        opnd_t opnd_r11 = opnd_create_reg(DR_REG_R11);
        opnd_t opnd_r12 = opnd_create_reg(DR_REG_R12);
        opnd_t opnd_r13 = opnd_create_reg(DR_REG_R13);
        opnd_t opnd_r14 = opnd_create_reg(DR_REG_R14);

        // save rbx, rcx, r9, r10, r11, r12, r13, r14
        instr_t *i1 = INSTR_CREATE_push(dcontext, opnd_rbx);
        instr_t *i2 = INSTR_CREATE_push(dcontext, opnd_rcx);
        instr_t *i3 = INSTR_CREATE_push(dcontext, opnd_r9);
        instr_t *i4 = INSTR_CREATE_push(dcontext, opnd_r10);
        instr_t *i5 = INSTR_CREATE_push(dcontext, opnd_r11);
        instr_t *i6 = INSTR_CREATE_push(dcontext, opnd_r12);
        instr_t *i7 = INSTR_CREATE_push(dcontext, opnd_r13);
        instr_t *i8 = INSTR_CREATE_push(dcontext, opnd_r14);

        // pushf
        instr_t *i9 = INSTR_CREATE_pushf(dcontext);

        //  sub $64, %rsp                   | reserve 64bytes(512 bits = 2 ymm registers slot) for the spill
        instr_t *i10 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

        //  vmovdqu %ymm_src1, (%rsp)       | save src1 to stack
        instr_t *i11 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32), src1_opnd);

        //  vmovdqu %ymm_src2, 32(%rsp)     | save src2 to stack
        instr_t *i12 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, SIZE_OF_YMM, OPSZ_32), src2_opnd);

        // xor %r9d, %r9d     | accumulate mask result, r9d is the output mask
        instr_t *i13 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_R9D));

        //  xor %ebx, %ebx                  | j = 0
        instr_t *i14 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_reg(DR_REG_EBX));

        // tls(input_mask) -> %r10 | get the input mask into r10
        instr_t *i15 = RESTORE_FROM_TLS(dcontext, DR_REG_R10, TLS_K_idx_SLOT(input_mask_idx));

        // NOTE: /* .LoopNLE */
        // mov %r10d, %r11d                 | get the input mask into r11
        instr_t *i16 = INSTR_CREATE_mov_ld(dcontext, opnd_r11, opnd_r10);

        // mov $1, %r12d                    | prepare bit mask 1 << j
        instr_t *i17 = INSTR_CREATE_mov_imm(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_immed_int(1, OPSZ_4));

        // mov %bl, %cl                     | j -> cl, move j to cl for shift count
        instr_t *i18 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_CL), opnd_create_reg(DR_REG_BL));

        // shl %cl, %r12d                   | shift left by j
        instr_t *i19 = INSTR_CREATE_shl(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_CL));

        // test %r11d, %r12d                | test if jth element is enabled
        instr_t *i20 = INSTR_CREATE_test(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_R11D));

        // jz .SkipNLE                      | if not enabled, skip
        instr_t *i21 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_NLE));

        // mov (%rsp, %rbx, 4), %r13d       | r13d = src1[j], load the j-th dword of src1
        instr_t *i22 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R13D),
                                           opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, 0, OPSZ_4));

        // mov 32(%rsp, %rbx, 4), %r14d     | r14d = src2[j], load the j-th dword of src2
        instr_t *i23 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R14D),
                                           opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, SIZE_OF_YMM, OPSZ_4));

        // cmp %r14d, %r13d                 | compare src1[j] with src2[j]
        instr_t *i24 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_R13D), opnd_create_reg(DR_REG_R14D));

        // jg .MatchNLE                     | if greater than, set bit j in output mask (NLE = not less than or equal =
        // greater than)
        instr_t *i25 = INSTR_CREATE_jcc(dcontext, OP_jg, opnd_create_instr(MATCH_NLE));

        instr_t *i25a = INSTR_CREATE_btr(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

        // NOTE: /* .SkipNLE */
        // inc %ebx                         | j++
        instr_t *i26 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

        // cmp $8, %ebx                     | compare j with 8, for 256-bits ymm, one can only hold 8 dwords elements
        instr_t *i27 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

        // jl .LoopNLE                      | loop if j < 8
        instr_t *i28 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_NLE));

        // jmp .DoneNLE
        instr_t *i29 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(DONE_NLE));

        // NOTE: /* MatchNLE */
        // bts %r12d, %r9d                   | set bit j in output mask
        instr_t *i30 = INSTR_CREATE_bts(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

        // inc %ebx                         | j++
        instr_t *i31 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

        // cmp $8, %ebx                     | compare j with 8 check if < 8
        instr_t *i32 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

        // jl .LoopNLE                      | loop if j < 8
        instr_t *i33 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_NLE));

        // NOTE: /* .DoneNLE */
        instr_t *i34a = INSTR_CREATE_and(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_immed_int(0x00FF, OPSZ_4));
        // save output mask to tls
        instr_t *i34 = SAVE_TO_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

        // add $64, %rsp
        instr_t *i35 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

        // popf
        instr_t *i36 = INSTR_CREATE_popf(dcontext);

        // restore registers
        instr_t *i37 = INSTR_CREATE_pop(dcontext, opnd_r14);
        instr_t *i38 = INSTR_CREATE_pop(dcontext, opnd_r13);
        instr_t *i39 = INSTR_CREATE_pop(dcontext, opnd_r12);
        instr_t *i40 = INSTR_CREATE_pop(dcontext, opnd_r11);
        instr_t *i41 = INSTR_CREATE_pop(dcontext, opnd_r10);
        instr_t *i42 = INSTR_CREATE_pop(dcontext, opnd_r9);
        instr_t *i43 = INSTR_CREATE_pop(dcontext, opnd_rcx);
        instr_t *i44 = INSTR_CREATE_pop(dcontext, opnd_rbx);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 50, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, LOOP_NLE, i17, i18, i19, i20, i21, i22, i23, i24, i25, i25a, SKIP_NLE, i26,
                                     i27, i28, i29, MATCH_NLE, i30, i31, i32, i33, DONE_NLE, i34a, i34, i35, i36, i37,
                                     i38, i39, i40, i41, i42, i43, i44);
#endif
        instrlist_concat_next_instr(ilist, 50, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    LOOP_NLE, i17, i18, i19, i20, i21, i22, i23, i24, i25, i25a, SKIP_NLE, i26, i27,
                                    i28, i29, MATCH_NLE, i30, i31, i32, i33, DONE_NLE, i34a, i34, i35, i36, i37, i38,
                                    i39, i40, i41, i42, i43, i44);
        return i1;
    } break;
    case 1: { /* only src1 need spill */

    } break;
    case 2: { /* only src2 need spill */

    } break;
    case 3: { /* both src1 and src2 need spill */

    } break;
    default: REWRITE_ERROR(STD_OUTF, "invalid spill case: %d\n", need_spill); return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t * /* 0x06 */
rw_func_vpcmpd_NLE_ymm_m256(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src2_opnd,
                            reg_id_t src1_reg, reg_id_t mask_reg, reg_id_t dst_mask_reg)
{
    // vpcmpd {%k7} $0x06 %ymm2 <rel> 0x00007feb06bde380[32byte] -> %k1
    //      input mask:  %k7
    //      input imm8:  $0x06
    //      input src1:  %ymm0
    //      input src2:  <rel> 0x00007feb06bde380
    //      output mask:  %k1

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    opnd_t src1_opnd = opnd_create_reg(src1_reg);
    int input_mask_idx = TO_K_REG_INDEX(mask_reg);
    int output_mask_idx = TO_K_REG_INDEX(dst_mask_reg);

    const uint src1_need_spill = NEED_SPILL_YMM(src1_reg) ? 1 : 0;

    switch (src1_need_spill) {
    case 0: { // no spill
        // all we need to save/restore gprs are:
        // rax, rbx, rcx, r9, r10, r11, r12, r13, r14
        instr_t *LOOP_NLE = INSTR_CREATE_label(dcontext);
        instr_t *SKIP_NLE = INSTR_CREATE_label(dcontext);
        instr_t *MATCH_NLE = INSTR_CREATE_label(dcontext);
        instr_t *DONE_NLE = INSTR_CREATE_label(dcontext);

        opnd_t opnd_rbx = opnd_create_reg(DR_REG_RBX);
        opnd_t opnd_rcx = opnd_create_reg(DR_REG_RCX);
        opnd_t opnd_r9 = opnd_create_reg(DR_REG_R9);
        opnd_t opnd_r10 = opnd_create_reg(DR_REG_R10);
        opnd_t opnd_r11 = opnd_create_reg(DR_REG_R11);
        opnd_t opnd_r12 = opnd_create_reg(DR_REG_R12);
        opnd_t opnd_r13 = opnd_create_reg(DR_REG_R13);
        opnd_t opnd_r14 = opnd_create_reg(DR_REG_R14);

        // save rax, rbx, rcx, r9, r10, r11, r12, r13, r14
        instr_t *i1 = INSTR_CREATE_push(dcontext, opnd_rbx);
        instr_t *i2 = INSTR_CREATE_push(dcontext, opnd_rcx);
        instr_t *i3 = INSTR_CREATE_push(dcontext, opnd_r9);
        instr_t *i4 = INSTR_CREATE_push(dcontext, opnd_r10);
        instr_t *i5 = INSTR_CREATE_push(dcontext, opnd_r11);
        instr_t *i6 = INSTR_CREATE_push(dcontext, opnd_r12);
        instr_t *i7 = INSTR_CREATE_push(dcontext, opnd_r13);
        instr_t *i8 = INSTR_CREATE_push(dcontext, opnd_r14);

        // tmp reg
        reg_id_t spill_ymm_reg = YMM_SPILL_SLOT0;
        opnd_t spill_ymm_opnd = opnd_create_reg(spill_ymm_reg);

        // pushf
        instr_t *i9 = INSTR_CREATE_pushf(dcontext);

        //  sub $64, %rsp                   | reserve 64bytes(512 bits = 2 ymm registers slot) for the spill
        instr_t *i10 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

        //  vmovdqu %ymm0, (%rsp)           | save ymm0 to stack
        instr_t *i11 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32), src1_opnd);

        // spill_ymm_reg -> tls_slot(spill_ymm_reg)
        instr_t *i12 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_ymm_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_ymm_reg)), OPSZ_32);

        // vmovdqu <rel>, spill_ymm_reg
        instr_t *i13 = INSTR_CREATE_vmovdqu(dcontext, spill_ymm_opnd, src2_opnd);

        //  vmovdqu spill_ymm_reg, 32(%rsp)         | save ymm2 to stack
        instr_t *i14 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, SIZE_OF_YMM, OPSZ_32), spill_ymm_opnd);

        // tls_slot(spill_ymm_reg) -> spill_ymm_reg
        instr_t *i15 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_ymm_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_ymm_reg)), OPSZ_32);

        // tls_slot(output_mask) -> r9      | accmulate mask result, r9d is the output mask, r9d is tls spill register
        instr_t *i16 = RESTORE_FROM_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

        //  xor %ebx, %ebx                  | j = 0
        instr_t *i17 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_reg(DR_REG_EBX));

        // tls(%k2, input_mask) -> %r10 | get the input mask into r10
        // scratch register is %r10
        instr_t *i18 = RESTORE_FROM_TLS(dcontext, DR_REG_R10, TLS_K_idx_SLOT(input_mask_idx));

        // NOTE: /* .LoopNLE */
        // mov %r10d, %r11d                 | get the input mask into r11
        instr_t *i19 = INSTR_CREATE_mov_ld(dcontext, opnd_r11, opnd_r10);

        // mov $1, %r12d                    | prepare bit mask 1 << j
        instr_t *i20 = INSTR_CREATE_mov_imm(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_immed_int(1, OPSZ_4));

        // mov %bl, %cl                     | j -> cl, move j to cl for shift count
        instr_t *i21 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_CL), opnd_create_reg(DR_REG_BL));

        // shl %cl, %r12d                   | shift left by j
        instr_t *i22 = INSTR_CREATE_shl(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_CL));

        // test %r11d, %r12d                | test if jth element is enabled
        instr_t *i23 = INSTR_CREATE_test(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_R11D));

        // jz .SkipNLE                       | if not enabled, skip
        instr_t *i24 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_NLE));

        // mov (%rsp, %rbx, 4), %r13d       | r13d = src_reg1[j], ymm0[j] -> r13d, load the j-th dword of ymm0
        instr_t *i25 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R13D),
                                           opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, 0, OPSZ_4));

        // mov 32(%rsp, %rbx, 4), %r14d     | r14d = src_reg2[j], ymm2[j] -> r14d, load the j-th dword of ymm2
        instr_t *i26 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R14D),
                                           opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, SIZE_OF_YMM, OPSZ_4));

        // cmp %r14d, %r13d                 | compare src_reg1[j] with src_reg2[j]
        instr_t *i27 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_R13D), opnd_create_reg(DR_REG_R14D));

        // jg .MatchNLE                     | if greater than, set bit j in output mask (NLE = not less than or equal =
        // greater than)
        instr_t *i28 = INSTR_CREATE_jcc(dcontext, OP_jg, opnd_create_instr(MATCH_NLE));

        instr_t *i28a = INSTR_CREATE_btr(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

        // NOTE: /* .SkipNLE */
        // inc %ebx                         | j++
        instr_t *i29 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

        // cmp $8, %ebx                     | compare j with 8, for 256-bits ymm, one can only hold 8 dwords elements
        instr_t *i30 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

        // jl .LoopNLE                       | loop if j < 8
        instr_t *i31 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_NLE));

        // jmp .DoneNLE
        instr_t *i32 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(DONE_NLE));

        // NOTE: /* MatchNLE */
        // bts %r12d, %r9d                   | set bit j in output mask
        instr_t *i33 = INSTR_CREATE_bts(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

        // inc %ebx                         | j++
        instr_t *i34 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

        // cmp $8, %ebx                     | compare j with 8 check if < 8
        instr_t *i35 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

        // jl .LoopNLE                       | loop if j < 8
        instr_t *i36 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_NLE));

        // NOTE: /* .DoneNLE */
        // movzx %r9b, tls(%k5, output_mask) | move the output mask to rax, r10 is the tls spill register
        // but since %r9 is 0 initialized and we only need to set the bit, so we can just use %r9 as the tls spill
        // register, and directly save it to tls
        instr_t *i37a = INSTR_CREATE_and(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_immed_int(0x00FF, OPSZ_4));
        instr_t *i37 = SAVE_TO_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

        // add $64, %rsp
        instr_t *i38 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

        // popf
        instr_t *i39 = INSTR_CREATE_popf(dcontext);

        // restore rax, rbx, rcx, r9, r10, r11, r12
        instr_t *i40 = INSTR_CREATE_pop(dcontext, opnd_r14);
        instr_t *i41 = INSTR_CREATE_pop(dcontext, opnd_r13);
        instr_t *i42 = INSTR_CREATE_pop(dcontext, opnd_r12);
        instr_t *i43 = INSTR_CREATE_pop(dcontext, opnd_r11);
        instr_t *i44 = INSTR_CREATE_pop(dcontext, opnd_r10);
        instr_t *i45 = INSTR_CREATE_pop(dcontext, opnd_r9);
        instr_t *i46 = INSTR_CREATE_pop(dcontext, opnd_rcx);
        instr_t *i47 = INSTR_CREATE_pop(dcontext, opnd_rbx);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 53, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, LOOP_NLE, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i28a,
                                     SKIP_NLE, i29, i30, i31, i32, MATCH_NLE, i33, i34, i35, i36, DONE_NLE, i37a, i37,
                                     i38, i39, i40, i41, i42, i43, i44, i45, i46, i47);
#endif
        instrlist_concat_next_instr(ilist, 53, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, LOOP_NLE, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i28a,
                                    SKIP_NLE, i29, i30, i31, i32, MATCH_NLE, i33, i34, i35, i36, DONE_NLE, i37a, i37,
                                    i38, i39, i40, i41, i42, i43, i44, i45, i46, i47);
        return i1;
    } break;
    case 1: { // only src1 need spill
    } break;
    default: return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t * /* 0x06 */
rw_func_vpcmpd_NLE_xmm_xmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x06 */
rw_func_vpcmpd_NLE_xmm_m128(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src2_opnd,
                            reg_id_t src1_reg, reg_id_t mask_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x06 */
rw_func_vpcmpd_NLE_zmm_zmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x06 */
rw_func_vpcmpd_NLE_zmm_m512(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src2_opnd,
                            reg_id_t src1_reg, reg_id_t mask_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x07 */
rw_func_vpcmpd_TRUE_ymm_ymm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                            reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)

{
    return NULL_INSTR;
}

instr_t * /* 0x07 */
rw_func_vpcmpd_TRUE_ymm_m256(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src2_opnd,
                             reg_id_t src1_reg, reg_id_t mask_reg, reg_id_t dst_mask_reg)

{
    return NULL_INSTR;
}

instr_t * /* 0x07 */
rw_func_vpcmpd_TRUE_xmm_xmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                            reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x07 */
rw_func_vpcmpd_TRUE_xmm_m128(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src2_opnd,
                             reg_id_t src1_reg, reg_id_t mask_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x07 */
rw_func_vpcmpd_TRUE_zmm_zmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                            reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x07 */
rw_func_vpcmpd_TRUE_zmm_m512(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t src2_opnd,
                             reg_id_t src1_reg, reg_id_t mask_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 626 */
rw_func_vpcmpd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vpcmpd {%k0} $0x04 %ymm1 %ymm2 -> %k1
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t imm8_opnd = instr_get_src(instr, 1);
    opnd_t src1_opnd = instr_get_src(instr, 2);
    opnd_t src2_opnd = instr_get_src(instr, 3);
    opnd_t dst_mask_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting vpcmpd at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, mask_opnd, "input mask: ");
    dr_print_opnd(dcontext, STD_OUTF, imm8_opnd, "input imm8: ");
    dr_print_opnd(dcontext, STD_OUTF, src1_opnd, "input src1: ");
    dr_print_opnd(dcontext, STD_OUTF, src2_opnd, "input src2: ");
    dr_print_opnd(dcontext, STD_OUTF, dst_mask_opnd, "output mask: ");
#endif
    /* a dispatch function for different imm8 values */
    // CASE (COMPARISON PREDICATE) OF
    //     0: OP := EQ;
    //     1: OP := LT;
    //     2: OP := LE;
    //     3: OP := FALSE;
    //     4: OP := NEQ;
    //     5: OP := NLT;
    //     6: OP := NLE;
    //     7: OP := TRUE;
    // ESAC;
    int imm8 = opnd_get_immed_int(imm8_opnd);
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t dst_mask_reg = opnd_get_reg(dst_mask_opnd);
    reg_id_t src1_reg = opnd_get_reg(src1_opnd);
    switch (imm8) {
    case 0x0: {
        if (IS_YMM_REG(src1_reg)) // only one is enough, items at the both sides of the scale are the same
        {
            switch (src2_opnd.kind) {
            case REG_kind: {
                reg_id_t src2_reg = opnd_get_reg(src2_opnd);
                return rw_func_vpcmpd_EQ_ymm_ymm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                                 src2_reg, dst_mask_reg);
            } break;
            case REL_ADDR_kind: {
                return rw_func_vpcmpd_EQ_ymm_m256(dcontext, ilist, instr, src1_opnd, src2_opnd, src1_reg, mask_reg,
                                                  dst_mask_reg);
            } break;
            default: {
                REWRITE_ERROR(STD_ERRF, "vpcmpd EQ ymm pattern: unknown src2 kind %d", src2_opnd.kind);
                return NULL_INSTR;
            }
            }
        }
        if (IS_XMM_REG(src1_reg)) {
            switch (src2_opnd.kind) {
            case REG_kind: {
                reg_id_t src2_reg = opnd_get_reg(src2_opnd);
                return rw_func_vpcmpd_EQ_xmm_xmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
            } break;
            case REL_ADDR_kind: {
                return rw_func_vpcmpd_EQ_xmm_m128(dcontext, ilist, instr, src2_opnd, src1_reg, mask_reg, dst_mask_reg);
            } break;
            default: {
                REWRITE_ERROR(STD_ERRF, "vpcmpd EQ xmm pattern: unknown src2 kind %d", src2_opnd.kind);
                return NULL_INSTR;
            }
            }
        }
        if (IS_ZMM_REG(src1_reg)) {
            switch (src2_opnd.kind) {
            case REG_kind: {
                reg_id_t src2_reg = opnd_get_reg(src2_opnd);
                return rw_func_vpcmpd_EQ_zmm_zmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
            } break;
            case REL_ADDR_kind: {
                return rw_func_vpcmpd_EQ_zmm_m512(dcontext, ilist, instr, src2_opnd, src1_reg, mask_reg, dst_mask_reg);
                return NULL_INSTR;
            } break;
            default: {
                REWRITE_ERROR(STD_ERRF, "vpcmpd EQ zmm pattern: unknown src2 kind %d", src2_opnd.kind);
                return NULL_INSTR;
            }
            }
        }
    } break;
    case 0x1: {
        if (IS_YMM_REG(src1_reg)) // only one is enough, items at the both sides of the scale are the same
        {
            switch (src2_opnd.kind) {
            case REG_kind: {
                reg_id_t src2_reg = opnd_get_reg(src2_opnd);
                return rw_func_vpcmpd_LT_ymm_ymm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
            } break;
            case REL_ADDR_kind: {
                return rw_func_vpcmpd_LT_ymm_m256(dcontext, ilist, instr, src2_opnd, src1_reg, mask_reg, dst_mask_reg);
            } break;
            default: {
                REWRITE_ERROR(STD_ERRF, "vpcmpd LT ymm pattern: unknown src2 kind %d", src2_opnd.kind);
                return NULL_INSTR;
            }
            }
        }
        if (IS_XMM_REG(src1_reg)) {
            switch (src2_opnd.kind) {
            case REG_kind: {
                reg_id_t src2_reg = opnd_get_reg(src2_opnd);
                return rw_func_vpcmpd_LT_xmm_xmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
            } break;
            case REL_ADDR_kind: {
                return rw_func_vpcmpd_LT_xmm_m128(dcontext, ilist, instr, src2_opnd, src1_reg, mask_reg, dst_mask_reg);
            } break;
            default: {
                REWRITE_ERROR(STD_ERRF, "vpcmpd LT xmm pattern: unknown src2 kind %d", src2_opnd.kind);
                return NULL_INSTR;
            }
            }
        }
        if (IS_ZMM_REG(src1_reg)) {
            switch (src2_opnd.kind) {
            case REG_kind: {
                reg_id_t src2_reg = opnd_get_reg(src2_opnd);
                return rw_func_vpcmpd_LT_zmm_zmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
            } break;
            case REL_ADDR_kind: {
                return rw_func_vpcmpd_LT_zmm_m512(dcontext, ilist, instr, src2_opnd, src1_reg, mask_reg, dst_mask_reg);
            } break;
            default: {
                REWRITE_ERROR(STD_ERRF, "vpcmpd LT zmm pattern: unknown src2 kind %d", src2_opnd.kind);
                return NULL_INSTR;
            }
            }
        }
    } break;
    case 0x2: {
        if (IS_YMM_REG(src1_reg)) {
            switch (src2_opnd.kind) {
            case REG_kind: {
                reg_id_t src2_reg = opnd_get_reg(src2_opnd);
                return rw_func_vpcmpd_LE_ymm_ymm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                                 src2_reg, dst_mask_reg);
            } break;
            case REL_ADDR_kind: {
                return rw_func_vpcmpd_LE_ymm_m256(dcontext, ilist, instr, src1_opnd, src2_opnd, src1_reg, mask_reg,
                                                  dst_mask_reg);
            } break;
            default: {
                REWRITE_ERROR(STD_ERRF, "vpcmpd LE ymm pattern: unknown src2 kind %d", src2_opnd.kind);
                return NULL_INSTR;
            }
            }
        }
        if (IS_XMM_REG(src1_reg)) {
            switch (src2_opnd.kind) {
            case REG_kind: {
                reg_id_t src2_reg = opnd_get_reg(src2_opnd);
                return rw_func_vpcmpd_LE_xmm_xmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
            } break;
            case REL_ADDR_kind: {
                return rw_func_vpcmpd_LE_xmm_m128(dcontext, ilist, instr, src2_opnd, src1_reg, mask_reg, dst_mask_reg);
            } break;
            default: {
                REWRITE_ERROR(STD_ERRF, "vpcmpd LE xmm pattern: unknown src2 kind %d", src2_opnd.kind);
                return NULL_INSTR;
            }
            }
        }
        if (IS_ZMM_REG(src1_reg)) {
            switch (src2_opnd.kind) {
            case REG_kind: {
                reg_id_t src2_reg = opnd_get_reg(src2_opnd);
                return rw_func_vpcmpd_LE_zmm_zmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
            } break;
            case REL_ADDR_kind: {
                return rw_func_vpcmpd_LE_zmm_m512(dcontext, ilist, instr, src2_opnd, src1_reg, mask_reg, dst_mask_reg);
            } break;
            default: {
                REWRITE_ERROR(STD_ERRF, "vpcmpd LE zmm pattern: unknown src2 kind %d", src2_opnd.kind);
                return NULL_INSTR;
            }
            }
        }
    } break;
    case 0x3: {
        if (IS_YMM_REG(src1_reg)) {
            switch (src2_opnd.kind) {
            case REG_kind: {
                reg_id_t src2_reg = opnd_get_reg(src2_opnd);
                return rw_func_vpcmpd_FALSE_ymm_ymm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
            } break;
            case REL_ADDR_kind: {
                return rw_func_vpcmpd_FALSE_ymm_m256(dcontext, ilist, instr, src2_opnd, src1_reg, mask_reg,
                                                     dst_mask_reg);
            } break;
            default: {
                REWRITE_ERROR(STD_ERRF, "vpcmpd FALSE ymm pattern: unknown src2 kind %d", src2_opnd.kind);
                return NULL_INSTR;
            }
            }
        }
        if (IS_XMM_REG(src1_reg)) {
            switch (src2_opnd.kind) {
            case REG_kind: {
                reg_id_t src2_reg = opnd_get_reg(src2_opnd);
                return rw_func_vpcmpd_FALSE_xmm_xmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
            } break;
            case REL_ADDR_kind: {
                return rw_func_vpcmpd_FALSE_xmm_m128(dcontext, ilist, instr, src2_opnd, src1_reg, mask_reg,
                                                     dst_mask_reg);
            } break;
            default: {
                REWRITE_ERROR(STD_ERRF, "vpcmpd FALSE xmm pattern: unknown src2 kind %d", src2_opnd.kind);
                return NULL_INSTR;
            }
            }
        }
        if (IS_ZMM_REG(src1_reg)) {
            switch (src2_opnd.kind) {
            case REG_kind: {
                reg_id_t src2_reg = opnd_get_reg(src2_opnd);
                return rw_func_vpcmpd_FALSE_zmm_zmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
            } break;
            case REL_ADDR_kind: {
                return rw_func_vpcmpd_FALSE_zmm_m512(dcontext, ilist, instr, src2_opnd, src1_reg, mask_reg,
                                                     dst_mask_reg);
            } break;
            default: {
                REWRITE_ERROR(STD_ERRF, "vpcmpd FALSE zmm pattern: unknown src2 kind %d", src2_opnd.kind);
                return NULL_INSTR;
            }
            }
        }
    } break;
    case 0x4: {
        if (IS_YMM_REG(src1_reg)) {
            switch (src2_opnd.kind) {
            case REG_kind: {
                reg_id_t src2_reg = opnd_get_reg(src2_opnd);
                return rw_func_vpcmpd_NEQ_ymm_ymm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                                  src2_reg, dst_mask_reg);
            } break;
            case REL_ADDR_kind: {
                return rw_func_vpcmpd_NEQ_ymm_m256(dcontext, ilist, instr, src2_opnd, src1_reg, mask_reg, dst_mask_reg);
            } break;
            default: {
                REWRITE_ERROR(STD_ERRF, "vpcmpd NEQ ymm pattern: unknown src2 kind %d", src2_opnd.kind);
                return NULL_INSTR;
            }
            }
        }
        if (IS_XMM_REG(src1_reg)) {
            switch (src2_opnd.kind) {
            case REG_kind: {
                reg_id_t src2_reg = opnd_get_reg(src2_opnd);
                return rw_func_vpcmpd_NEQ_xmm_xmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
            } break;
            case REL_ADDR_kind: {
                return rw_func_vpcmpd_NEQ_xmm_m128(dcontext, ilist, instr, src2_opnd, src1_reg, mask_reg, dst_mask_reg);
            } break;
            default: {
                REWRITE_ERROR(STD_ERRF, "vpcmpd NEQ xmm pattern: unknown src2 kind %d", src2_opnd.kind);
                return NULL_INSTR;
            }
            }
        }
        if (IS_ZMM_REG(src1_reg)) {
            switch (src2_opnd.kind) {
            case REG_kind: {
                reg_id_t src2_reg = opnd_get_reg(src2_opnd);
                return rw_func_vpcmpd_NEQ_zmm_zmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
            } break;
            case REL_ADDR_kind: {
                return rw_func_vpcmpd_NEQ_zmm_m512(dcontext, ilist, instr, src2_opnd, src1_reg, mask_reg, dst_mask_reg);
            } break;
            default: {
                REWRITE_ERROR(STD_ERRF, "vpcmpd NEQ zmm pattern: unknown src2 kind %d", src2_opnd.kind);
                return NULL_INSTR;
            }
            }
        }
    } break;
    case 0x5: {
        if (IS_YMM_REG(src1_reg)) {
            switch (src2_opnd.kind) {
            case REG_kind: {
                reg_id_t src2_reg = opnd_get_reg(src2_opnd);
                return rw_func_vpcmpd_NLT_ymm_ymm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
            } break;
            case REL_ADDR_kind: {
                return rw_func_vpcmpd_NLT_ymm_m256(dcontext, ilist, instr, src2_opnd, src1_reg, mask_reg, dst_mask_reg);
            } break;
            default: {
                REWRITE_ERROR(STD_ERRF, "vpcmpd NLT ymm pattern: unknown src2 kind %d", src2_opnd.kind);
                return NULL_INSTR;
            }
            }
        }
        if (IS_XMM_REG(src1_reg)) {
            switch (src2_opnd.kind) {
            case REG_kind: {
                reg_id_t src2_reg = opnd_get_reg(src2_opnd);
                return rw_func_vpcmpd_NLT_xmm_xmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
            } break;
            case REL_ADDR_kind: {
                return rw_func_vpcmpd_NLT_xmm_m128(dcontext, ilist, instr, src2_opnd, src1_reg, mask_reg, dst_mask_reg);
            } break;
            default: {
                REWRITE_ERROR(STD_ERRF, "vpcmpd NLT xmm pattern: unknown src2 kind %d", src2_opnd.kind);
                return NULL_INSTR;
            }
            }
        }
        if (IS_ZMM_REG(src1_reg)) {
            switch (src2_opnd.kind) {
            case REG_kind: {
                reg_id_t src2_reg = opnd_get_reg(src2_opnd);
                return rw_func_vpcmpd_NLT_zmm_zmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
            } break;
            case REL_ADDR_kind: {
                return rw_func_vpcmpd_NLT_zmm_m512(dcontext, ilist, instr, src2_opnd, src1_reg, mask_reg, dst_mask_reg);
            } break;
            default: {
                REWRITE_ERROR(STD_ERRF, "vpcmpd NLT zmm pattern: unknown src2 kind %d", src2_opnd.kind);
                return NULL_INSTR;
            }
            }
        }
    } break;
    case 0x6: {
        if (IS_YMM_REG(src1_reg)) {
            switch (src2_opnd.kind) {
            case REG_kind: {
                reg_id_t src2_reg = opnd_get_reg(src2_opnd);
                return rw_func_vpcmpd_NLE_ymm_ymm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
            } break;
            case REL_ADDR_kind: {
                return rw_func_vpcmpd_NLE_ymm_m256(dcontext, ilist, instr, src2_opnd, src1_reg, mask_reg, dst_mask_reg);
            } break;
            default: {
                REWRITE_ERROR(STD_ERRF, "vpcmpd NLE ymm pattern: unknown src2 kind %d", src2_opnd.kind);
                return NULL_INSTR;
            }
            }
        }
        if (IS_XMM_REG(src1_reg)) {
            switch (src2_opnd.kind) {
            case REG_kind: {
                reg_id_t src2_reg = opnd_get_reg(src2_opnd);
                return rw_func_vpcmpd_NLE_xmm_xmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
            } break;
            case REL_ADDR_kind: {
                return rw_func_vpcmpd_NLE_xmm_m128(dcontext, ilist, instr, src2_opnd, src1_reg, mask_reg, dst_mask_reg);
            } break;
            default: {
                REWRITE_ERROR(STD_ERRF, "vpcmpd NLE xmm pattern: unknown src2 kind %d", src2_opnd.kind);
                return NULL_INSTR;
            }
            }
        }
        if (IS_ZMM_REG(src1_reg)) {
            switch (src2_opnd.kind) {
            case REG_kind: {
                reg_id_t src2_reg = opnd_get_reg(src2_opnd);
                return rw_func_vpcmpd_NLE_zmm_zmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
            } break;
            case REL_ADDR_kind: {
                return rw_func_vpcmpd_NLE_zmm_m512(dcontext, ilist, instr, src2_opnd, src1_reg, mask_reg, dst_mask_reg);
            } break;
            default: {
                REWRITE_ERROR(STD_ERRF, "vpcmpd NLE zmm pattern: unknown src2 kind %d", src2_opnd.kind);
                return NULL_INSTR;
            }
            }
        }
    } break;
    case 0x7: {
        if (IS_YMM_REG(src1_reg)) {
            switch (src2_opnd.kind) {
            case REG_kind: {
                reg_id_t src2_reg = opnd_get_reg(src2_opnd);
                return rw_func_vpcmpd_TRUE_ymm_ymm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
            } break;
            case REL_ADDR_kind: {
                return rw_func_vpcmpd_TRUE_ymm_m256(dcontext, ilist, instr, src2_opnd, src1_reg, mask_reg,
                                                    dst_mask_reg);
            } break;
            default: {
                REWRITE_ERROR(STD_ERRF, "vpcmpd TRUE ymm pattern: unknown src2 kind %d", src2_opnd.kind);
                return NULL_INSTR;
            }
            }
        }
        if (IS_XMM_REG(src1_reg)) {
            switch (src2_opnd.kind) {
            case REG_kind: {
                reg_id_t src2_reg = opnd_get_reg(src2_opnd);
                return rw_func_vpcmpd_TRUE_xmm_xmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
            } break;
            case REL_ADDR_kind: {
                return rw_func_vpcmpd_TRUE_xmm_m128(dcontext, ilist, instr, src2_opnd, src1_reg, mask_reg,
                                                    dst_mask_reg);
            } break;
            default: {
                REWRITE_ERROR(STD_ERRF, "vpcmpd TRUE xmm pattern: unknown src2 kind %d", src2_opnd.kind);
                return NULL_INSTR;
            }
            }
        }
        if (IS_ZMM_REG(src1_reg)) {
            switch (src2_opnd.kind) {
            case REG_kind: {
                reg_id_t src2_reg = opnd_get_reg(src2_opnd);
                return rw_func_vpcmpd_TRUE_zmm_zmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
            } break;
            case REL_ADDR_kind: {
                return rw_func_vpcmpd_TRUE_zmm_m512(dcontext, ilist, instr, src2_opnd, src1_reg, mask_reg,
                                                    dst_mask_reg);
            } break;
            default: {
                REWRITE_ERROR(STD_ERRF, "vpcmpd TRUE zmm pattern: unknown src2 kind %d", src2_opnd.kind);
                return NULL_INSTR;
            }
            }
        }
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpcmpd imm8 %d not support", imm8); return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t * /* 627 */
rw_func_vpcmpq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vpcmpud
 * ============================================= */

instr_t * /* 0x00 */
rw_func_vpcmpud_EQ_ymm_ymm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t dst_mask_reg)
{
    // vpcmpud {%k0} $0x00 %ymm1 %ymm2 -> %k1
    // vpcmpud {%k0} $0x00 %ymm0 <rel> 0x00007f336514a360[32byte] -> %k0
    //     [REWRITE INFO]:   ymm_bitmap: 0
    //     mask: %k0
    //     src1: %ymm1 (always register)
    //     src2: %ymm2 (register) or memory operand
    /* Helper function for no-spill case of vpcmpud EQ ymm operations */
    //     dst: %k1
    //     EQ: Equal comparison

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    // int input_mask_idx = TO_K_REG_INDEX(mask_reg);
    // int output_mask_idx = TO_K_REG_INDEX(dst_mask_reg);

    // Handle both register and memory operands for src2
    bool src2_is_reg = opnd_is_reg(src2_opnd);
    reg_id_t src2_reg = src2_is_reg ? opnd_get_reg(src2_opnd) : DR_REG_NULL;

    const uint src1_need_spill = NEED_SPILL_YMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill = (src2_is_reg && NEED_SPILL_YMM(src2_reg)) ? 2 : 0;
    const uint need_spill = src1_need_spill | src2_need_spill;

    switch (need_spill) {
    case 0: { // no spill
        return NULL_INSTR;
    } break;
    case 1: { // only src1 need spill
        REWRITE_ERROR(STD_ERRF, "vpcmpud EQ ymm pattern: src1 spill case not implemented");
        return NULL_INSTR;
    } break;
    case 2: { // only src2 need spill
        REWRITE_ERROR(STD_ERRF, "vpcmpud EQ ymm pattern: src2 spill case not implemented");
        return NULL_INSTR;
    } break;
    case 3: { // both src1 and src2 need spill
        REWRITE_ERROR(STD_ERRF, "vpcmpud EQ ymm pattern: both operands spill case not implemented");
        return NULL_INSTR;
    } break;
    default:
        REWRITE_ERROR(STD_ERRF, "vpcmpud EQ ymm pattern: unknown spill configuration %d", need_spill);
        return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t * /* 0x00 */
rw_func_vpcmpud_EQ_xmm_xmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x00 */
rw_func_vpcmpud_EQ_zmm_zmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x01 */
rw_func_vpcmpud_LT_ymm_ymm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x01 */
rw_func_vpcmpud_LT_xmm_xmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x01 */
rw_func_vpcmpud_LT_zmm_zmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x02 */
rw_func_vpcmpud_LE_ymm_ymm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x02 */
rw_func_vpcmpud_LE_xmm_xmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x02 */
rw_func_vpcmpud_LE_zmm_zmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x03 */
rw_func_vpcmpud_FALSE_ymm_ymm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                              opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x03 */
rw_func_vpcmpud_FALSE_xmm_xmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                              opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x03 */
rw_func_vpcmpud_FALSE_zmm_zmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                              opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x04 */
rw_func_vpcmpud_NEQ_ymm_ymm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                            opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t dst_mask_reg)
{
    // vpcmpd {%k0} $0x04 %ymm1 %ymm2 -> %k1
    //     [REWRITE INFO]:   ymm_bitmap: 0
    //     mask: %k0
    //     src1: %ymm1
    //     src2: %ymm2
    //     dst: %k1

    return NULL_INSTR;
}

instr_t * /* 0x04 */
rw_func_vpcmpud_NEQ_xmm_xmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                            opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x04 */
rw_func_vpcmpud_NEQ_zmm_zmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                            opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x05 */
rw_func_vpcmpud_NLT_ymm_ymm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                            opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x05 */
rw_func_vpcmpud_NLT_xmm_xmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                            opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x05 */
rw_func_vpcmpud_NLT_zmm_zmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                            opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x06 */
rw_func_vpcmpud_NLE_ymm_ymm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                            opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t dst_mask_reg)
{
    // vpcmpud {%k0} $0x06 %ymm1 %ymm2 -> %k1
    //     [REWRITE INFO]:   ymm_bitmap: 0
    //     mask: %k0
    //     src1: %ymm1
    //     src2: %ymm2
    //     dst: %k1
    //     NLE: Not Less or Equal (unsigned greater than)

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    int input_mask_idx = TO_K_REG_INDEX(mask_reg);
    int output_mask_idx = TO_K_REG_INDEX(dst_mask_reg);

    // Extract src2_reg from src2_opnd since it's missing from function signature
    bool src2_is_reg = opnd_is_reg(src2_opnd);
    reg_id_t src2_reg = src2_is_reg ? opnd_get_reg(src2_opnd) : DR_REG_NULL;

    const uint src1_need_spill = NEED_SPILL_YMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill = (src2_is_reg && NEED_SPILL_YMM(src2_reg)) ? 2 : 0;
    const uint need_spill = src1_need_spill | src2_need_spill;

    switch (need_spill) {
    case 0: { // no spi
        if (input_mask_idx == 0) {
            instr_t *LOOP_NLE_K0 = INSTR_CREATE_label(dcontext);
            instr_t *MATCH_NLE_K0 = INSTR_CREATE_label(dcontext);
            instr_t *DONE_NLE_K0 = INSTR_CREATE_label(dcontext);

            reg_id_t temp_ymm_reg = find_one_available_spill_ymm(src1_reg);
            opnd_t temp_ymm_opnd = opnd_create_reg(temp_ymm_reg);

            opnd_t opnd_rbx = opnd_create_reg(DR_REG_RBX);
            opnd_t opnd_rcx = opnd_create_reg(DR_REG_RCX);
            opnd_t opnd_r9 = opnd_create_reg(DR_REG_R9);
            opnd_t opnd_r10 = opnd_create_reg(DR_REG_R10);
            opnd_t opnd_r11 = opnd_create_reg(DR_REG_R11);
            opnd_t opnd_r12 = opnd_create_reg(DR_REG_R12);
            opnd_t opnd_r13 = opnd_create_reg(DR_REG_R13);
            opnd_t opnd_r14 = opnd_create_reg(DR_REG_R14);

            // save rax, rbx, rcx, r9, r10, r11, r12, r13, r14
            instr_t *i1 = INSTR_CREATE_push(dcontext, opnd_rbx);
            instr_t *i2 = INSTR_CREATE_push(dcontext, opnd_rcx);
            instr_t *i3 = INSTR_CREATE_push(dcontext, opnd_r9);
            instr_t *i4 = INSTR_CREATE_push(dcontext, opnd_r10);
            instr_t *i5 = INSTR_CREATE_push(dcontext, opnd_r11);
            instr_t *i6 = INSTR_CREATE_push(dcontext, opnd_r12);
            instr_t *i7 = INSTR_CREATE_push(dcontext, opnd_r13);
            instr_t *i8 = INSTR_CREATE_push(dcontext, opnd_r14);

            // (i9) pushf
            instr_t *i9 = INSTR_CREATE_pushf(dcontext);

            // (i10) sub $64, %rsp
            instr_t *i10 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            // (i11) vmovdqu %ymm0, (%rsp)
            instr_t *i11 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32),
                                                src1_opnd);

            // spill temp reg
            instr_t *i12 = SAVE_SIMD_TO_SIZED_TLS(dcontext, temp_ymm_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(temp_ymm_reg)), OPSZ_32);

            // vmovdqu src2_opnd -> temp_ymm_reg
            instr_t *i13 = INSTR_CREATE_vmovdqu(dcontext, temp_ymm_opnd, src2_opnd);

            //  vmovdqu temp_reg, 32(%rsp)         | save temp_ymm_reg to stack
            instr_t *i14 = INSTR_CREATE_vmovdqu(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, SIZE_OF_YMM, OPSZ_32), temp_ymm_opnd);

            // restore temp_ymm_reg
            instr_t *i15 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, temp_ymm_reg,
                                                       TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(temp_ymm_reg)), OPSZ_32);

            // (i13) xor %r9d, %r9d
            instr_t *i16 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_R9D));

            // (i14) xor %ebx, %ebx  | j = 0
            instr_t *i17 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_reg(DR_REG_EBX));

            // NOTE: /* .LoopNle_k0 */

            // (i15) mov (%rsp, %rbx, 4), %r13d
            instr_t *i18 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R13D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, 0, OPSZ_4));

            // (i16) mov 32(%rsp, %rbx, 4), %r14d
            instr_t *i19 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R14D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, SIZE_OF_YMM, OPSZ_4));

            // (i17) cmp %r13d, %r14d (cmp src1[j] and src2[j])
            instr_t *i20 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_R13D), opnd_create_reg(DR_REG_R14D));

            // (i18) ja .MatchNle_k0 (Jump if Above - Unsigned Greater Than)
            instr_t *i21 = INSTR_CREATE_jcc(dcontext, OP_jg, opnd_create_instr(MATCH_NLE_K0));

            // (i19) btr %r9d, %ebx (Not NLE, so clear bit)
            instr_t *i22 = INSTR_CREATE_btr(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // NOTE: /* .NextIter_k0 */
            // (i20) inc %ebx
            instr_t *i23 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // (i21) cmp $8, %ebx
            instr_t *i24 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // (i22) jl .LoopNle_k0
            instr_t *i25 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_NLE_K0));

            // (i23) jmp .DoneNle_k0
            instr_t *i26 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(DONE_NLE_K0));

            // NOTE: /* MatchNle_k0 */
            // (i24) bts %r9d, %ebx (Is NLE, so set bit)
            instr_t *i27 = INSTR_CREATE_bts(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // (i25) inc %ebx
            instr_t *i28 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // (i26) cmp $8, %ebx
            instr_t *i29 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // (i27) jl .LoopNle_k0
            instr_t *i30 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_NLE_K0));

            // NOTE: /* .DoneNle_k0 */
            // (i28) and $0x00FF, %r9d
            instr_t *i31 =
                INSTR_CREATE_and(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_immed_int(0x00FF, OPSZ_4));
            // (i29) mov %r9, tls(output_mask)
            instr_t *i32 = SAVE_TO_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

            // (i30) add $64, %rsp
            instr_t *i33 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            // (i31) popf
            instr_t *i34 = INSTR_CREATE_popf(dcontext);

            // (i32-i39) restore gprs
            instr_t *i35 = INSTR_CREATE_pop(dcontext, opnd_r14);
            instr_t *i36 = INSTR_CREATE_pop(dcontext, opnd_r13);
            instr_t *i37 = INSTR_CREATE_pop(dcontext, opnd_r12);
            instr_t *i38 = INSTR_CREATE_pop(dcontext, opnd_r11);
            instr_t *i39 = INSTR_CREATE_pop(dcontext, opnd_r10);
            instr_t *i40 = INSTR_CREATE_pop(dcontext, opnd_r9);
            instr_t *i41 = INSTR_CREATE_pop(dcontext, opnd_rcx);
            instr_t *i42 = INSTR_CREATE_pop(dcontext, opnd_rbx);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 45, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         i16, i17, LOOP_NLE_K0, i18, i19, i20, i21, i22, i23, i24, i25, i26,
                                         MATCH_NLE_K0, i27, i28, i29, i30, DONE_NLE_K0, i31, i32, i33, i34, i35, i36,
                                         i37, i38, i39, i40, i41, i42);
#endif
            instrlist_concat_next_instr(ilist, 45, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, LOOP_NLE_K0, i18, i19, i20, i21, i22, i23, i24, i25, i26,
                                        MATCH_NLE_K0, i27, i28, i29, i30, DONE_NLE_K0, i31, i32, i33, i34, i35, i36,
                                        i37, i38, i39, i40, i41, i42);
            return i1;
        } else {
            // all we need to save/restore gprs are:
            // rax, rbx, rcx, r9, r10, r11, r12, r13, r14
            instr_t *LOOP_NLE = INSTR_CREATE_label(dcontext);
            instr_t *SKIP_NLE = INSTR_CREATE_label(dcontext);
            instr_t *MATCH_NLE = INSTR_CREATE_label(dcontext);
            instr_t *DONE_NLE = INSTR_CREATE_label(dcontext);

            reg_id_t temp_ymm_reg = find_one_available_spill_ymm(src1_reg);
            opnd_t temp_ymm_opnd = opnd_create_reg(temp_ymm_reg);

            opnd_t opnd_rbx = opnd_create_reg(DR_REG_RBX);
            opnd_t opnd_rcx = opnd_create_reg(DR_REG_RCX);
            opnd_t opnd_r9 = opnd_create_reg(DR_REG_R9);
            opnd_t opnd_r10 = opnd_create_reg(DR_REG_R10);
            opnd_t opnd_r11 = opnd_create_reg(DR_REG_R11);
            opnd_t opnd_r12 = opnd_create_reg(DR_REG_R12);
            opnd_t opnd_r13 = opnd_create_reg(DR_REG_R13);
            opnd_t opnd_r14 = opnd_create_reg(DR_REG_R14);

            // save rbx, rcx, r9, r10, r11, r12, r13, r14
            instr_t *i1 = INSTR_CREATE_push(dcontext, opnd_rbx);
            instr_t *i2 = INSTR_CREATE_push(dcontext, opnd_rcx);
            instr_t *i3 = INSTR_CREATE_push(dcontext, opnd_r9);
            instr_t *i4 = INSTR_CREATE_push(dcontext, opnd_r10);
            instr_t *i5 = INSTR_CREATE_push(dcontext, opnd_r11);
            instr_t *i6 = INSTR_CREATE_push(dcontext, opnd_r12);
            instr_t *i7 = INSTR_CREATE_push(dcontext, opnd_r13);
            instr_t *i8 = INSTR_CREATE_push(dcontext, opnd_r14);

            // pushf
            instr_t *i9 = INSTR_CREATE_pushf(dcontext);

            //  sub $64, %rsp                   | reserve 64bytes(512 bits = 2 ymm registers slot) for the spill
            instr_t *i10 =
                INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            //  vmovdqu %ymm0, (%rsp)           | save ymm0 to stack
            instr_t *i11 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32),
                                                src1_opnd);

            // spill temp reg
            instr_t *i11a = SAVE_SIMD_TO_SIZED_TLS(dcontext, temp_ymm_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(temp_ymm_reg)), OPSZ_32);

            // vmovdqu src2_opnd -> temp_ymm_reg
            instr_t *i11b = INSTR_CREATE_vmovdqu(dcontext, temp_ymm_opnd, src2_opnd);

            //  vmovdqu temp_reg, 32(%rsp)         | save temp_ymm_reg to stack
            instr_t *i12 = INSTR_CREATE_vmovdqu(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, SIZE_OF_YMM, OPSZ_32), temp_ymm_opnd);

            // restore temp_ymm_reg
            instr_t *i12a = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, temp_ymm_reg,
                                                        TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(temp_ymm_reg)), OPSZ_32);

            // tls_slot(input_mask) -> r9                  | accmulate mask result, r9d is the output mask
            instr_t *i13 = RESTORE_FROM_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

            //  xor %ebx, %ebx                  | j = 0
            instr_t *i14 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_reg(DR_REG_EBX));

            // tls(%k2, input_mask) -> %r10 | get the input mask into r10
            instr_t *i15 = RESTORE_FROM_TLS(dcontext, DR_REG_R10, TLS_K_idx_SLOT(input_mask_idx));

            // NOTE: /* .LoopNLE */
            // mov %r10d, %r11d                 | get the input mask into r11
            instr_t *i16 = INSTR_CREATE_mov_ld(dcontext, opnd_r11, opnd_r10);

            // mov $1, %r12d                    | prepare bit mask 1 << j
            instr_t *i17 =
                INSTR_CREATE_mov_imm(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_immed_int(1, OPSZ_4));

            // mov %bl, %cl                     | j -> cl, move j to cl for shift count
            instr_t *i18 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_CL), opnd_create_reg(DR_REG_BL));

            // shl %cl, %r12d                   | shift left by j
            instr_t *i19 = INSTR_CREATE_shl(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_CL));

            // test %r11d, %r12d                | test if jth element is enabled
            instr_t *i20 = INSTR_CREATE_test(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_R11D));

            // jz .SkipNLE                       | if not enabled, skip
            instr_t *i21 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_NLE));

            // mov (%rsp, %rbx, 4), %r13d       | r13d = src_reg1[j], load the j-th dword of ymm0
            instr_t *i22 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R13D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, 0, OPSZ_4));

            // mov 32(%rsp, %rbx, 4), %r14d     | r14d = src_reg2[j], load the j-th dword of ymm2
            instr_t *i23 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_R14D),
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 4, SIZE_OF_YMM, OPSZ_4));

            // cmp %r14d, %r13d                 | compare src_reg1[j] with src_reg2[j]
            instr_t *i24 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_R13D), opnd_create_reg(DR_REG_R14D));

            // ja .MatchNLE                     | if src1 > src2 (unsigned), set bit j in output mask
            instr_t *i25 = INSTR_CREATE_jcc(dcontext, OP_jg, opnd_create_instr(MATCH_NLE));

            instr_t *i25a = INSTR_CREATE_btr(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // NOTE: /* .SkipNLE */
            // inc %ebx                         | j++
            instr_t *i26 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // cmp $8, %ebx                     | compare j with 8, for 256-bits ymm, one can only hold 8 dwords
            // elements
            instr_t *i27 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // jl .LoopNLE                       | loop if j < 8
            instr_t *i28 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_NLE));

            // jmp .DoneNLE
            instr_t *i29 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(DONE_NLE));

            // NOTE: /* MatchNLE */
            // bts  %r12d, %r9d                   | set bit j in output mask
            instr_t *i30 = INSTR_CREATE_bts(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

            // inc %ebx                         | j++
            instr_t *i31 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

            // cmp $8, %ebx                     | compare j with 8 check if < 8
            instr_t *i32 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(8, OPSZ_4));

            // jl .LoopNLE                       | loop if j < 8
            instr_t *i33 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_NLE));

            // NOTE: /* .DoneNLE */
            // and output_mask & 0x00FF
            instr_t *i34a =
                INSTR_CREATE_and(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_immed_int(0x00FF, OPSZ_4));
            // save the output mask to tls
            instr_t *i34 = SAVE_TO_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

            // add $64, %rsp
            instr_t *i35 =
                INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

            // popf
            instr_t *i36 = INSTR_CREATE_popf(dcontext);

            // restore rbx, rcx, r9, r10, r11, r12, r13, r14
            instr_t *i37 = INSTR_CREATE_pop(dcontext, opnd_r14);
            instr_t *i38 = INSTR_CREATE_pop(dcontext, opnd_r13);
            instr_t *i39 = INSTR_CREATE_pop(dcontext, opnd_r12);
            instr_t *i40 = INSTR_CREATE_pop(dcontext, opnd_r11);
            instr_t *i41 = INSTR_CREATE_pop(dcontext, opnd_r10);
            instr_t *i42 = INSTR_CREATE_pop(dcontext, opnd_r9);
            instr_t *i43 = INSTR_CREATE_pop(dcontext, opnd_rcx);
            instr_t *i44 = INSTR_CREATE_pop(dcontext, opnd_rbx);

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 53, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i11a, i11b, i12,
                                         i12a, i13, i14, i15, LOOP_NLE, i16, i17, i18, i19, i20, i21, i22, i23, i24,
                                         i25, i25a, SKIP_NLE, i26, i27, i28, i29, MATCH_NLE, i30, i31, i32, i33,
                                         DONE_NLE, i34a, i34, i35, i36, i37, i38, i39, i40, i41, i42, i43, i44);
#endif
            instrlist_concat_next_instr(ilist, 53, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i11a, i11b, i12, i12a,
                                        i13, i14, i15, LOOP_NLE, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i25a,
                                        SKIP_NLE, i26, i27, i28, i29, MATCH_NLE, i30, i31, i32, i33, DONE_NLE, i34a,
                                        i34, i35, i36, i37, i38, i39, i40, i41, i42, i43, i44);
            return i1;
        }
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpcmpud NLE ymm and ymm pattern not support"); return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t * /* 0x06 */
rw_func_vpcmpud_NLE_xmm_xmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                            opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x06 */
rw_func_vpcmpud_NLE_zmm_zmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                            opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x07 */
rw_func_vpcmpud_TRUE_ymm_ymm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                             opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t dst_mask_reg)

{
    return NULL_INSTR;
}

instr_t * /* 0x07 */
rw_func_vpcmpud_TRUE_xmm_xmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                             opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x07 */
rw_func_vpcmpud_TRUE_zmm_zmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                             opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 629 */
rw_func_vpcmpud(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vpcmpud {%k0} $0x04 %ymm1 %ymm2 -> %k1
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t imm8_opnd = instr_get_src(instr, 1);
    opnd_t src1_opnd = instr_get_src(instr, 2);
    opnd_t src2_opnd = instr_get_src(instr, 3);
    opnd_t dst_mask_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting vpcmpud at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, mask_opnd, "input mask: ");
    dr_print_opnd(dcontext, STD_OUTF, imm8_opnd, "input imm8: ");
    dr_print_opnd(dcontext, STD_OUTF, src1_opnd, "input src1: ");
    dr_print_opnd(dcontext, STD_OUTF, src2_opnd, "input src2: ");
    dr_print_opnd(dcontext, STD_OUTF, dst_mask_opnd, "output mask: ");
#endif
    /* a dispatch function for different imm8 values */
    // CASE (COMPARISON PREDICATE) OF
    //     0: OP := EQ;
    //     1: OP := LT;
    //     2: OP := LE;
    //     3: OP := FALSE;
    //     4: OP := NEQ;
    //     5: OP := NLT;
    //     6: OP := NLE;
    //     7: OP := TRUE;
    // ESAC;
    int imm8 = opnd_get_immed_int(imm8_opnd);
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t dst_mask_reg = opnd_get_reg(dst_mask_opnd);
    reg_id_t src1_reg = opnd_get_reg(src1_opnd);
    switch (imm8) {
    case 0x0: {
        if (IS_YMM_REG(src1_reg)) // only one is enough, items at the both sides of the scale are the same
            return rw_func_vpcmpud_EQ_ymm_ymm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                              dst_mask_reg);
        if (IS_XMM_REG(src1_reg))
            return rw_func_vpcmpud_EQ_xmm_xmm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                              dst_mask_reg);
        if (IS_ZMM_REG(src1_reg))
            return rw_func_vpcmpud_EQ_zmm_zmm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                              dst_mask_reg);
    } break;
    case 0x1: {
        if (IS_YMM_REG(src1_reg))
            return rw_func_vpcmpud_LT_ymm_ymm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                              dst_mask_reg);
        if (IS_XMM_REG(src1_reg))
            return rw_func_vpcmpud_LT_xmm_xmm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                              dst_mask_reg);
        if (IS_ZMM_REG(src1_reg))
            return rw_func_vpcmpud_LT_zmm_zmm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                              dst_mask_reg);
    } break;
    case 0x2: {
        if (IS_YMM_REG(src1_reg))
            return rw_func_vpcmpud_LE_ymm_ymm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                              dst_mask_reg);
        if (IS_XMM_REG(src1_reg))
            return rw_func_vpcmpud_LE_xmm_xmm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                              dst_mask_reg);
        if (IS_ZMM_REG(src1_reg))
            return rw_func_vpcmpud_LE_zmm_zmm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                              dst_mask_reg);
    } break;
    case 0x3: {
        if (IS_YMM_REG(src1_reg))
            return rw_func_vpcmpud_FALSE_ymm_ymm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                                 dst_mask_reg);
        if (IS_XMM_REG(src1_reg))
            return rw_func_vpcmpud_FALSE_xmm_xmm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                                 dst_mask_reg);
        if (IS_ZMM_REG(src1_reg))
            return rw_func_vpcmpud_FALSE_zmm_zmm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                                 dst_mask_reg);
    } break;
    case 0x4: {
        if (IS_YMM_REG(src1_reg))
            return rw_func_vpcmpud_NEQ_ymm_ymm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                               dst_mask_reg);
        if (IS_XMM_REG(src1_reg))
            return rw_func_vpcmpud_NEQ_xmm_xmm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                               dst_mask_reg);
        if (IS_ZMM_REG(src1_reg))
            return rw_func_vpcmpud_NEQ_zmm_zmm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                               dst_mask_reg);
    } break;
    case 0x5: {
        if (IS_YMM_REG(src1_reg))
            return rw_func_vpcmpud_NLT_ymm_ymm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                               dst_mask_reg);
        if (IS_XMM_REG(src1_reg))
            return rw_func_vpcmpud_NLT_xmm_xmm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                               dst_mask_reg);
        if (IS_ZMM_REG(src1_reg))
            return rw_func_vpcmpud_NLT_zmm_zmm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                               dst_mask_reg);
    } break;
    case 0x6: {
        if (IS_YMM_REG(src1_reg))
            return rw_func_vpcmpud_NLE_ymm_ymm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                               dst_mask_reg);
        if (IS_XMM_REG(src1_reg))
            return rw_func_vpcmpud_NLE_xmm_xmm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                               dst_mask_reg);
        if (IS_ZMM_REG(src1_reg))
            return rw_func_vpcmpud_NLE_zmm_zmm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                               dst_mask_reg);
    } break;
    case 0x7: {
        if (IS_YMM_REG(src1_reg))
            return rw_func_vpcmpud_TRUE_ymm_ymm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                                dst_mask_reg);
        if (IS_XMM_REG(src1_reg))
            return rw_func_vpcmpud_TRUE_xmm_xmm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                                dst_mask_reg);
        if (IS_ZMM_REG(src1_reg))
            return rw_func_vpcmpud_TRUE_zmm_zmm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                                dst_mask_reg);
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpcmpud imm8 %d not support", imm8); return NULL_INSTR;
    }
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vpcmpw
 * ============================================= */

instr_t * /* 0x00: EQ */
rw_func_vpcmpw_EQ_ymm_ymm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg, opnd_t src1_opnd,
                          opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    // vpcmpw {%k_in} $0x00 %ymmSRC1 %ymmSRC2 -> %k_dst
    // KL=16 (YMM  16-bit). Merging semantics (no {z})

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const int input_mask_idx = TO_K_REG_INDEX(mask_reg);
    const int output_mask_idx = TO_K_REG_INDEX(dst_mask_reg);

    const uint src1_need_spill = NEED_SPILL_YMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill = NEED_SPILL_YMM(src2_reg) ? 2 : 0;
    const uint need_spill = src1_need_spill | src2_need_spill;

    switch (need_spill) {
    case 0: { // no spill
        instr_t *LOOP_EQ = INSTR_CREATE_label(dcontext);
        instr_t *SKIP_EQ = INSTR_CREATE_label(dcontext);
        instr_t *MATCH_EQ = INSTR_CREATE_label(dcontext);
        instr_t *DONE_EQ = INSTR_CREATE_label(dcontext);

        opnd_t opnd_rbx = opnd_create_reg(DR_REG_RBX);
        opnd_t opnd_rcx = opnd_create_reg(DR_REG_RCX);
        opnd_t opnd_r9 = opnd_create_reg(DR_REG_R9);
        opnd_t opnd_r10 = opnd_create_reg(DR_REG_R10);
        opnd_t opnd_r11 = opnd_create_reg(DR_REG_R11);
        opnd_t opnd_r12 = opnd_create_reg(DR_REG_R12);
        opnd_t opnd_r13 = opnd_create_reg(DR_REG_R13);
        opnd_t opnd_r14 = opnd_create_reg(DR_REG_R14);

        // save gprs we use + eflags
        instr_t *i1 = INSTR_CREATE_push(dcontext, opnd_rbx);
        instr_t *i2 = INSTR_CREATE_push(dcontext, opnd_rcx);
        instr_t *i3 = INSTR_CREATE_push(dcontext, opnd_r9);
        instr_t *i4 = INSTR_CREATE_push(dcontext, opnd_r10);
        instr_t *i5 = INSTR_CREATE_push(dcontext, opnd_r11);
        instr_t *i6 = INSTR_CREATE_push(dcontext, opnd_r12);
        instr_t *i7 = INSTR_CREATE_push(dcontext, opnd_r13);
        instr_t *i8 = INSTR_CREATE_push(dcontext, opnd_r14);
        instr_t *i9 = INSTR_CREATE_pushf(dcontext);

        // reserve 64B (2YMM)
        instr_t *i10 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

        // spill src vectors to stack
        instr_t *i11 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32), src1_opnd);
        instr_t *i12 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, SIZE_OF_YMM, OPSZ_32), src2_opnd);

        instr_t *i13 = RESTORE_FROM_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

        // j = 0
        instr_t *i14 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_reg(DR_REG_EBX));

        instr_t *i15 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_R10W, TLS_K_idx_SLOT(input_mask_idx), OPSZ_2);

        // LOOP:
        instr_t *i16 = INSTR_CREATE_mov_ld(dcontext, opnd_r11, opnd_r10); // r11 = k_in snapshot
        instr_t *i17 = INSTR_CREATE_mov_imm(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_immed_int(1, OPSZ_4));
        instr_t *i18 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_CL), opnd_create_reg(DR_REG_BL)); // cl=j
        instr_t *i19 = INSTR_CREATE_shl(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_CL));  // 1<<j

        instr_t *i20 = INSTR_CREATE_test(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_R11D));
        instr_t *i21 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_EQ));

        instr_t *i22 = INSTR_CREATE_movzx(dcontext, opnd_create_reg(DR_REG_R13D),
                                          opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 2, 0, OPSZ_2));
        instr_t *i23 = INSTR_CREATE_movzx(dcontext, opnd_create_reg(DR_REG_R14D),
                                          opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 2, SIZE_OF_YMM, OPSZ_2));
        instr_t *i24 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_R13D), opnd_create_reg(DR_REG_R14D));
        instr_t *i25 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(MATCH_EQ));

        instr_t *i25a = INSTR_CREATE_btr(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

        // j++ / loop
        instr_t *i26 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));
        instr_t *i27 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(16, OPSZ_4));
        instr_t *i28 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_EQ));
        instr_t *i29 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(DONE_EQ));

        instr_t *i30 = INSTR_CREATE_bts(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

        instr_t *i31 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));
        instr_t *i32 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(16, OPSZ_4));
        instr_t *i33 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_EQ));

        // DONE
        instr_t *i34a = INSTR_CREATE_and(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_immed_int(0xFFFF, OPSZ_4));
        instr_t *i34 = SAVE_TO_SIZED_TLS(dcontext, DR_REG_R9W, TLS_K_idx_SLOT(output_mask_idx), OPSZ_2);

        // tear down
        instr_t *i35 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));
        instr_t *i36 = INSTR_CREATE_popf(dcontext);
        instr_t *i37 = INSTR_CREATE_pop(dcontext, opnd_r14);
        instr_t *i38 = INSTR_CREATE_pop(dcontext, opnd_r13);
        instr_t *i39 = INSTR_CREATE_pop(dcontext, opnd_r12);
        instr_t *i40 = INSTR_CREATE_pop(dcontext, opnd_r11);
        instr_t *i41 = INSTR_CREATE_pop(dcontext, opnd_r10);
        instr_t *i42 = INSTR_CREATE_pop(dcontext, opnd_r9);
        instr_t *i43 = INSTR_CREATE_pop(dcontext, opnd_rcx);
        instr_t *i44 = INSTR_CREATE_pop(dcontext, opnd_rbx);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 50, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     LOOP_EQ, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i25a, SKIP_EQ, i26, i27,
                                     i28, i29, MATCH_EQ, i30, i31, i32, i33, DONE_EQ, i34a, i34, i35, i36, i37, i38,
                                     i39, i40, i41, i42, i43, i44);
#endif
        instrlist_concat_next_instr(ilist, 50, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                    LOOP_EQ, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i25a, SKIP_EQ, i26, i27,
                                    i28, i29, MATCH_EQ, i30, i31, i32, i33, DONE_EQ, i34a, i34, i35, i36, i37, i38, i39,
                                    i40, i41, i42, i43, i44);
        return i1;
    } break;

    case 1: { // only src1 need spill
        REWRITE_ERROR(STD_ERRF, "vpcmpw EQ ymm and ymm pattern src1 spill not implemented");
        return NULL_INSTR;
    } break;
    case 2: { // only src2 need spill
        REWRITE_ERROR(STD_ERRF, "vpcmpw EQ ymm and ymm pattern src2 spill not implemented");
        return NULL_INSTR;
    } break;
    case 3: { // both src1 and src2 need spill
        REWRITE_ERROR(STD_ERRF, "vpcmpw EQ ymm and ymm pattern both spill not implemented");
        return NULL_INSTR;
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpcmpw EQ ymm and ymm pattern not support"); return NULL_INSTR;
    }
}

instr_t *
rw_func_vpcmpw_EQ_xmm_xmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                          reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t *
rw_func_vpcmpw_EQ_zmm_zmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                          reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x01 */
rw_func_vpcmpw_LT_ymm_ymm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                          reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x01 */
rw_func_vpcmpw_LT_xmm_xmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                          reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x01 */
rw_func_vpcmpw_LT_zmm_zmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                          reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x02 */
rw_func_vpcmpw_LE_ymm_ymm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                          reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x02 */
rw_func_vpcmpw_LE_xmm_xmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                          reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x02 */
rw_func_vpcmpw_LE_zmm_zmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                          reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x03 */
rw_func_vpcmpw_FALSE_ymm_ymm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                             reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x03 */
rw_func_vpcmpw_FALSE_xmm_xmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                             reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x03 */
rw_func_vpcmpw_FALSE_zmm_zmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                             reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x04 */
rw_func_vpcmpw_NEQ_ymm_ymm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           opnd_t src1_opnd, opnd_t src2_opnd, reg_id_t src1_reg, reg_id_t src2_reg,
                           reg_id_t dst_mask_reg)
{
    //  vpcmpw    $0x04, %ymm2, %ymm1, %k2{%k1}
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    int input_mask_idx = TO_K_REG_INDEX(mask_reg);
    int output_mask_idx = TO_K_REG_INDEX(dst_mask_reg);

    const uint src1_need_spill = NEED_SPILL_YMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill = NEED_SPILL_YMM(src2_reg) ? 2 : 0;
    const uint need_spill = src1_need_spill | src2_need_spill;

    switch (need_spill) {
    case 0: { // no spill
        // all we need to save/restore gprs are:
        // rax, rbx, rcx, r9, r10, r11, r12, r13, r14
        instr_t *LOOP_NE = INSTR_CREATE_label(dcontext);
        instr_t *SKIP_NE = INSTR_CREATE_label(dcontext);
        instr_t *MATCH_NE = INSTR_CREATE_label(dcontext);
        instr_t *DONE_NE = INSTR_CREATE_label(dcontext);

        opnd_t opnd_rbx = opnd_create_reg(DR_REG_RBX);
        opnd_t opnd_rcx = opnd_create_reg(DR_REG_RCX);
        opnd_t opnd_r9 = opnd_create_reg(DR_REG_R9);
        opnd_t opnd_r10 = opnd_create_reg(DR_REG_R10);
        opnd_t opnd_r11 = opnd_create_reg(DR_REG_R11);
        opnd_t opnd_r12 = opnd_create_reg(DR_REG_R12);
        opnd_t opnd_r13 = opnd_create_reg(DR_REG_R13);
        opnd_t opnd_r14 = opnd_create_reg(DR_REG_R14);

        // save rax, rbx, rcx, r9, r10, r11, r12, r13, r14
        instr_t *i1 = INSTR_CREATE_push(dcontext, opnd_rbx);
        instr_t *i2 = INSTR_CREATE_push(dcontext, opnd_rcx);
        instr_t *i3 = INSTR_CREATE_push(dcontext, opnd_r9);
        instr_t *i4 = INSTR_CREATE_push(dcontext, opnd_r10);
        instr_t *i5 = INSTR_CREATE_push(dcontext, opnd_r11);
        instr_t *i6 = INSTR_CREATE_push(dcontext, opnd_r12);
        instr_t *i7 = INSTR_CREATE_push(dcontext, opnd_r13);
        instr_t *i8 = INSTR_CREATE_push(dcontext, opnd_r14);

        // pushf
        instr_t *i9 = INSTR_CREATE_pushf(dcontext);

        //  sub $64, %rsp                   | reserve 64bytes(512 bits = 2 ymm registers slot) for the spill
        instr_t *i10 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

        //  vmovdqu %ymm0, (%rsp)           | save ymm0 to stack
        instr_t *i11 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32), src1_opnd);

        //  vmovdqu %ymm2, 32(%rsp)         | save ymm2 to stack
        instr_t *i12 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, SIZE_OF_YMM, OPSZ_32), src2_opnd);

        //  xor %r9d, %r9d                  | accmulate mask result, r9d is the output mask, r9d is tls spill register
        instr_t *i13 = RESTORE_FROM_TLS(dcontext, DR_REG_R9, TLS_K_idx_SLOT(output_mask_idx));

        //  xor %ebx, %ebx                  | j = 0
        instr_t *i14 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_reg(DR_REG_EBX));

        // tls(%k2, input_mask) -> %r10 | get the input mask into r10
        // scratch register is %r10
        instr_t *i15 = RESTORE_FROM_SIZED_TLS(dcontext, DR_REG_R10W, TLS_K_idx_SLOT(input_mask_idx), OPSZ_2);

        // NOTE: /* .LoopNE */
        // mov %r10d, %r11d                 | get the input mask into r11
        instr_t *i16 = INSTR_CREATE_mov_ld(dcontext, opnd_r11, opnd_r10);

        // mov $1, %r12d                    | prepare bit mask 1 << j
        instr_t *i17 = INSTR_CREATE_mov_imm(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_immed_int(1, OPSZ_4));

        // mov %bl, %cl                     | j -> cl, move j to cl for shift count
        instr_t *i18 = INSTR_CREATE_mov_ld(dcontext, opnd_create_reg(DR_REG_CL), opnd_create_reg(DR_REG_BL));

        // shl %cl, %r12d                   | shift left by j
        instr_t *i19 = INSTR_CREATE_shl(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_CL));

        // test %r11d, %r12d                | test if jth element is enabled
        instr_t *i20 = INSTR_CREATE_test(dcontext, opnd_create_reg(DR_REG_R12D), opnd_create_reg(DR_REG_R11D));

        // jz .SkipNE                       | if not enabled, skip
        instr_t *i21 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(SKIP_NE));

        // movzwl (%rsp, %rbx, 2), %r13d       | r13d = src_reg1[j], ymm0[j] -> r13d, load the j-th dword of ymm0
        instr_t *i22 = INSTR_CREATE_movzx(dcontext, opnd_create_reg(DR_REG_R13D),
                                          opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 2, 0, OPSZ_2));

        // movzwl 32(%rsp, %rbx, 2), %r14d     | r14d = src_reg2[j], ymm2[j] -> r14d, load the j-th dword of ymm2
        instr_t *i23 = INSTR_CREATE_movzx(dcontext, opnd_create_reg(DR_REG_R14D),
                                          opnd_create_base_disp(DR_REG_RSP, DR_REG_RBX, 2, SIZE_OF_YMM, OPSZ_2));

        // cmp %r14d, %r13d                 | compare src_reg1[j] with src_reg2[j]
        instr_t *i24 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_R13D),
                                        opnd_create_reg(DR_REG_R14D)); 

        // jne .MatchNE                     | if equal, set bit j in output mask
        instr_t *i25 = INSTR_CREATE_jcc(dcontext, OP_jne, opnd_create_instr(MATCH_NE));

        instr_t *i25a = INSTR_CREATE_btr(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_EBX));

        // NOTE: /* .SkipNE */
        // inc %ebx                         | j++
        instr_t *i26 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

        // cmp $16, %ebx                     | compare j with 8, for 256-bits ymm, one can only hold 8 dwords elements
        instr_t *i27 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(16, OPSZ_4));

        // jl .LoopNE                       | loop if j < 8
        instr_t *i28 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_NE));

        // jmp .DoneNE
        instr_t *i29 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(DONE_NE));

        // NOTE: /* MatchNE */
        // or %r12d, %r9d                   | set bit j in output mask
        instr_t *i30 = INSTR_CREATE_bts(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_reg(DR_REG_R12D));

        // inc %ebx                         | j++
        instr_t *i31 = INSTR_CREATE_inc(dcontext, opnd_create_reg(DR_REG_EBX));

        // cmp $16, %ebx                     | compare j with 8 check if < 8
        instr_t *i32 = INSTR_CREATE_cmp(dcontext, opnd_create_reg(DR_REG_EBX), opnd_create_immed_int(16, OPSZ_4));

        // jl .LoopNE                       | loop if j < 16
        instr_t *i33 = INSTR_CREATE_jcc(dcontext, OP_jl, opnd_create_instr(LOOP_NE));

        // NOTE: /* .DoneNE */
        // movzx %r9w, tls(%k5, output_mask) | move the output mask to rax, r10 is the tls spill register
        // but since %r9 is 0 initialized and we only need to set the bit, so we can just use %r9 as the tls spill
        // register, and directly save it to tls,
        instr_t *i34a = INSTR_CREATE_and(dcontext, opnd_create_reg(DR_REG_R9D), opnd_create_immed_int(0xFFFF, OPSZ_4));
        instr_t *i34 = SAVE_TO_SIZED_TLS(dcontext, DR_REG_R9W, TLS_K_idx_SLOT(output_mask_idx), OPSZ_2);

        // add $64, %rsp
        instr_t *i35 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));

        // popf
        instr_t *i36 = INSTR_CREATE_popf(dcontext);

        // restore rax, rbx, rcx, r9, r10, r11, r12
        instr_t *i37 = INSTR_CREATE_pop(dcontext, opnd_r14);
        instr_t *i38 = INSTR_CREATE_pop(dcontext, opnd_r13);
        instr_t *i39 = INSTR_CREATE_pop(dcontext, opnd_r12);
        instr_t *i40 = INSTR_CREATE_pop(dcontext, opnd_r11);
        instr_t *i41 = INSTR_CREATE_pop(dcontext, opnd_r10);
        instr_t *i42 = INSTR_CREATE_pop(dcontext, opnd_r9);
        instr_t *i43 = INSTR_CREATE_pop(dcontext, opnd_rcx);
        instr_t *i44 = INSTR_CREATE_pop(dcontext, opnd_rbx);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 50, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     LOOP_NE, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i25a, SKIP_NE, i26, i27,
                                     i28, i29, MATCH_NE, i30, i31, i32, i33, DONE_NE, i34a, i34, i35, i36, i37, i38,
                                     i39, i40, i41, i42, i43, i44);
#endif
        instrlist_concat_next_instr(ilist, 50, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                    LOOP_NE, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i25a, SKIP_NE, i26, i27,
                                    i28, i29, MATCH_NE, i30, i31, i32, i33, DONE_NE, i34a, i34, i35, i36, i37, i38, i39,
                                    i40, i41, i42, i43, i44);
        return i1;
    } break;
    case 1: { // only src1 need spill

    } break;
    case 2: { // only src2 need spill

    } break;
    case 3: { // both src1 and src2 need spill

    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpcmpw EQ ymm and ymm pattern not support"); return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t * /* 0x04 */
rw_func_vpcmpw_NEQ_xmm_xmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x04 */
rw_func_vpcmpw_NEQ_zmm_zmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x05 */
rw_func_vpcmpw_NLT_ymm_ymm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x05 */
rw_func_vpcmpw_NLT_xmm_xmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x05 */
rw_func_vpcmpw_NLT_zmm_zmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x06 */
rw_func_vpcmpw_NLE_ymm_ymm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x06 */
rw_func_vpcmpw_NLE_xmm_xmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x06 */
rw_func_vpcmpw_NLE_zmm_zmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                           reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x07 */
rw_func_vpcmpw_TRUE_ymm_ymm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                            reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)

{
    return NULL_INSTR;
}

instr_t * /* 0x07 */
rw_func_vpcmpw_TRUE_xmm_xmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                            reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 0x07 */
rw_func_vpcmpw_TRUE_zmm_zmm(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t mask_reg,
                            reg_id_t src1_reg, reg_id_t src2_reg, reg_id_t dst_mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 632 */
rw_func_vpcmpw(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t imm8_opnd = instr_get_src(instr, 1);
    opnd_t src1_opnd = instr_get_src(instr, 2);
    opnd_t src2_opnd = instr_get_src(instr, 3);
    opnd_t dst_mask_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting vpcmpw at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, mask_opnd, "input mask: ");
    dr_print_opnd(dcontext, STD_OUTF, imm8_opnd, "input imm8: ");
    dr_print_opnd(dcontext, STD_OUTF, src1_opnd, "input src1: ");
    dr_print_opnd(dcontext, STD_OUTF, src2_opnd, "input src2: ");
    dr_print_opnd(dcontext, STD_OUTF, dst_mask_opnd, "output mask: ");
#endif
    /* a dispatch function for different imm8 values */
    // CASE (COMPARISON PREDICATE) OF
    //     0: OP := EQ;
    //     1: OP := LT;
    //     2: OP := LE;
    //     3: OP := FALSE;
    //     4: OP := NEQ;
    //     5: OP := NLT;
    //     6: OP := NLE;
    //     7: OP := TRUE;
    // ESAC;
    int imm8 = opnd_get_immed_int(imm8_opnd);
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t dst_mask_reg = opnd_get_reg(dst_mask_opnd);
    reg_id_t src1_reg = opnd_get_reg(src1_opnd);
    reg_id_t src2_reg = opnd_get_reg(src2_opnd);
    switch (imm8) {
    case 0x0: {
        if (IS_YMM_REG(src1_reg)) // only one is enough, items at the both sides of the scale are the same
            return rw_func_vpcmpw_EQ_ymm_ymm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg, src2_reg,
                                             dst_mask_reg);
        if (IS_XMM_REG(src1_reg))
            return rw_func_vpcmpw_EQ_xmm_xmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
        if (IS_ZMM_REG(src1_reg))
            return rw_func_vpcmpw_EQ_zmm_zmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
    } break;
    case 0x1: {
        if (IS_YMM_REG(src1_reg))
            return rw_func_vpcmpw_LT_ymm_ymm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
        if (IS_XMM_REG(src1_reg))
            return rw_func_vpcmpw_LT_xmm_xmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
        if (IS_ZMM_REG(src1_reg))
            return rw_func_vpcmpw_LT_zmm_zmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
    } break;
    case 0x2: {
        if (IS_YMM_REG(src1_reg))
            return rw_func_vpcmpw_LE_ymm_ymm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
        if (IS_XMM_REG(src1_reg))
            return rw_func_vpcmpw_LE_xmm_xmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
        if (IS_ZMM_REG(src1_reg))
            return rw_func_vpcmpw_LE_zmm_zmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
    } break;
    case 0x3: {
        if (IS_YMM_REG(src1_reg))
            return rw_func_vpcmpw_FALSE_ymm_ymm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
        if (IS_XMM_REG(src1_reg))
            return rw_func_vpcmpw_FALSE_xmm_xmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
        if (IS_ZMM_REG(src1_reg))
            return rw_func_vpcmpw_FALSE_zmm_zmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
    } break;
    case 0x4: {
        if (IS_YMM_REG(src1_reg))
            return rw_func_vpcmpw_NEQ_ymm_ymm(dcontext, ilist, instr, mask_reg, src1_opnd, src2_opnd, src1_reg,
                                              src2_reg, dst_mask_reg);
        if (IS_XMM_REG(src1_reg))
            return rw_func_vpcmpw_NEQ_xmm_xmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
        if (IS_ZMM_REG(src1_reg))
            return rw_func_vpcmpw_NEQ_zmm_zmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
    } break;
    case 0x5: {
        if (IS_YMM_REG(src1_reg))
            return rw_func_vpcmpw_NLT_ymm_ymm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
        if (IS_XMM_REG(src1_reg))
            return rw_func_vpcmpw_NLT_xmm_xmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
        if (IS_ZMM_REG(src1_reg))
            return rw_func_vpcmpw_NLT_zmm_zmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
    } break;
    case 0x6: {
        if (IS_YMM_REG(src1_reg))
            return rw_func_vpcmpw_NLE_ymm_ymm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
        if (IS_XMM_REG(src1_reg))
            return rw_func_vpcmpw_NLE_xmm_xmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
        if (IS_ZMM_REG(src1_reg))
            return rw_func_vpcmpw_NLE_zmm_zmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
    } break;
    case 0x7: {
        if (IS_YMM_REG(src1_reg))
            return rw_func_vpcmpw_TRUE_ymm_ymm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
        if (IS_XMM_REG(src1_reg))
            return rw_func_vpcmpw_TRUE_xmm_xmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
        if (IS_ZMM_REG(src1_reg))
            return rw_func_vpcmpw_TRUE_zmm_zmm(dcontext, ilist, instr, mask_reg, src1_reg, src2_reg, dst_mask_reg);
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpcmpw imm8 %d not support", imm8); return NULL_INSTR;
    }
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vpermi2q
 * ============================================= */

instr_t *
vpermi2q_k_m32_ymm_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           opnd_t src2_data_opnd, reg_id_t dst_idx_reg, reg_id_t mask_reg)

{
    // vpermi2q {%k0} %ymm7 0x20(%rdi)[32byte] -> %ymm0
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    if (mask_reg == DR_REG_K0) {

        enum { REDZONE = 128, Y = SIZE_OF_YMM };         // Y==32
        enum { SCRATCH = 4 * Y /*dst, idx, src, out*/ }; // 128
        enum { SAVE = 8 /*rflags*/ + 8 * 4 /*rax,rdx,rcx,r11*/ };
        enum { SLACK_FOR_PUSH = 8 };
        enum { FRAME = ((REDZONE + SCRATCH + SAVE + SLACK_FOR_PUSH + 15) & ~15) };

        const int OFF_IDX = REDZONE + 0 * Y;
        const int OFF_TBL1 = REDZONE + 1 * Y;
        const int OFF_TBL2 = REDZONE + 2 * Y;
        const int OFF_DST = REDZONE + 3 * Y;
        const int OFF_RFLAGS = REDZONE + 4 * Y;
        const int OFF_RAX = OFF_RFLAGS + 8;
        const int OFF_RDX = OFF_RAX + 8;
        const int OFF_RCX = OFF_RDX + 8;

        opnd_t op_rax = opnd_create_reg(DR_REG_RAX);
        opnd_t op_rdx = opnd_create_reg(DR_REG_RDX);
        opnd_t op_rcx = opnd_create_reg(DR_REG_RCX);
        opnd_t op_ecx = opnd_create_reg(DR_REG_ECX);

        reg_id_t ymm_spill = find_available_spill_ymm_avoiding(src1_idx_reg, dst_idx_reg, DR_REG_NULL);
        opnd_t op_ymm_spill = opnd_create_reg(ymm_spill);

        /*****************  Register & stack bookkeeping  *****************/
        instr_t *LOOP_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *FROM_TBL1_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *STORE_LABEL = INSTR_CREATE_label(dcontext);

        instr_t *i1 = INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), OPND_CREATE_INT32(FRAME));

        // pushf, save xflags
        instr_t *i2 = INSTR_CREATE_pushf(dcontext);

        // save rax, rdx, rcx
        instr_t *i3 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8), op_rdx);
        instr_t *i4 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8), op_rax);
        instr_t *i5 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8), op_rcx);

        /* Spill vectors to stack. Layout:
         *   031   : index (dst_idx_reg)
         *   3263  : table1 (src1_tbl_reg)
         *   6495  : table2 (src2_tbl_reg)
         *   96127 : result (filled later)
         */
        instr_t *i6 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_IDX, OPSZ_32),
                                 opnd_create_reg(dst_idx_reg));
        instr_t *i7 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_TBL1, OPSZ_32),
                                 opnd_create_reg(src1_idx_reg));
        instr_t *i8 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_spill, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill)), OPSZ_32);
        instr_t *i9 = INSTR_CREATE_vmovdqu(dcontext, op_ymm_spill, src2_data_opnd);
        instr_t *i10 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_TBL2, OPSZ_32), op_ymm_spill);
        instr_t *i11 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_spill, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill)), OPSZ_32);

        /* ECX = loop counter. */
        instr_t *i12 = INSTR_CREATE_xor(dcontext, op_ecx, op_ecx);

        /**********************  Main permutation loop  *******************/
        /* LOOP_LABEL: */
        instr_t *i13 = LOOP_LABEL;

        /* RAX = 64bit index from index array. */
        instr_t *i14 =
            INSTR_CREATE_mov_ld(dcontext, op_rax, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 8, OFF_IDX, OPSZ_8));
        /* Test bit 2  table selector (for 4 elements: 0-3). */
        instr_t *i15 = INSTR_CREATE_test(dcontext, op_rax, OPND_CREATE_INT32(0x4));
        /* If bit2 == 0 -> FROM_TBL1_LABEL. */
        instr_t *i16 = INSTR_CREATE_jcc_short(dcontext, OP_jz, opnd_create_instr(FROM_TBL1_LABEL));

        /* ---- Select from table2 (bit2 == 1) ---- */
        instr_t *i17 = INSTR_CREATE_and(dcontext, op_rax, opnd_create_immed_int(0x3, OPSZ_1));
        instr_t *i18 =
            INSTR_CREATE_mov_ld(dcontext, op_rdx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 8, OFF_TBL2, OPSZ_8));
        instr_t *i19 = INSTR_CREATE_jmp_short(dcontext, opnd_create_instr(STORE_LABEL));

        /* ---- FROM_TBL1_LABEL: Select from table1 ---- */
        instr_t *i20 = FROM_TBL1_LABEL;
        instr_t *i21 = INSTR_CREATE_and(dcontext, op_rax, opnd_create_immed_int(0x3, OPSZ_1));
        instr_t *i22 =
            INSTR_CREATE_mov_ld(dcontext, op_rdx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 8, OFF_TBL1, OPSZ_8));

        /* ---- STORE_LABEL ---- */
        instr_t *i23 = STORE_LABEL;
        instr_t *i24 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 8, OFF_DST, OPSZ_8), op_rdx);

        /* i++ and loop if i < 4. */
        instr_t *i25 = INSTR_CREATE_inc(dcontext, op_ecx);
        instr_t *i26 = INSTR_CREATE_cmp(dcontext, op_ecx, OPND_CREATE_INT32(0x4));
        instr_t *i27 = INSTR_CREATE_jcc_short(dcontext, OP_jne, opnd_create_instr(LOOP_LABEL));

        /*********************  Finish & restore state  ********************/
        /* Load result YMM and free stack. */
        instr_t *i28 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_reg(dst_idx_reg),
                                            opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DST, OPSZ_32));
        instr_t *i29 =
            INSTR_CREATE_mov_ld(dcontext, op_rcx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8));
        instr_t *i30 =
            INSTR_CREATE_mov_ld(dcontext, op_rax, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8));
        instr_t *i31 =
            INSTR_CREATE_mov_ld(dcontext, op_rdx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8));
        instr_t *i32 = INSTR_CREATE_popf(dcontext);
        instr_t *i33 = INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), OPND_CREATE_INT32(FRAME));

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 33, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32, i33);
#endif
        instrlist_concat_next_instr(ilist, 33, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32,
                                    i33);

        return i1;
    }
    return NULL_INSTR;
}

instr_t *
vpermi2q_k_ymm_ymm_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr,
                           reg_id_t src1_tbl_reg, /* table 1 */
                           reg_id_t src2_tbl_reg, /* table 2 */
                           reg_id_t dst_idx_reg,  /* index vector + destination */
                           reg_id_t mask_reg)
{
    /*
     * AT&T syntax example:
     *     vpermi2q  %ymm0, %ymm2, %ymm1    # k0 disabled
     *          src1   src2     dst/index
     *
     * Semantics (no writemask):
     *   For i = 0..3
     *       idx  = dst_index[i];  // 64bit index element
     *       src  = (idx & 0x4) ? src2_tbl[idx & 0x3]
     *                            : src1_tbl[idx & 0x3];
     *       result[i] = src;
     *   dst = result;
     */

    /* Replace the original instruction with our IR sequence. */
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    /* Only the k0mask (i.e., no mask) variant is implemented for now. */
    if (mask_reg == DR_REG_K0) {

        enum { REDZONE = 128, Y = SIZE_OF_YMM };         // Y==32
        enum { SCRATCH = 4 * Y /*dst, idx, src, out*/ }; // 128
        enum { SAVE = 8 /*rflags*/ + 8 * 4 /*rax,rdx,rcx,r11*/ };
        enum { SLACK_FOR_PUSH = 8 };
        enum { FRAME = ((REDZONE + SCRATCH + SAVE + SLACK_FOR_PUSH + 15) & ~15) };

        const int OFF_IDX = REDZONE + 0 * Y;
        const int OFF_TBL1 = REDZONE + 1 * Y;
        const int OFF_TBL2 = REDZONE + 2 * Y;
        const int OFF_DST = REDZONE + 3 * Y;
        const int OFF_RFLAGS = REDZONE + 4 * Y;
        const int OFF_RAX = OFF_RFLAGS + 8;
        const int OFF_RDX = OFF_RAX + 8;
        const int OFF_RCX = OFF_RDX + 8;
        // const int OFF_R11 = OFF_RCX + 8;

        opnd_t op_rax = opnd_create_reg(DR_REG_RAX);
        opnd_t op_rdx = opnd_create_reg(DR_REG_RDX);
        opnd_t op_rcx = opnd_create_reg(DR_REG_RCX);
        opnd_t op_ecx = opnd_create_reg(DR_REG_ECX);

        /*****************  Register & stack bookkeeping  *****************/
        instr_t *LOOP_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *FROM_TBL1_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *STORE_LABEL = INSTR_CREATE_label(dcontext);

        /* Reserve 128 bytes: index + tbl1 + tbl2 + result (4YMM). */
        instr_t *i1 = INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), OPND_CREATE_INT32(FRAME));

        // pushf, save xflags
        instr_t *i2 = INSTR_CREATE_pushf(dcontext);

        // save rax, rdx, rcx
        instr_t *i3 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8), op_rdx);
        instr_t *i4 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8), op_rax);
        instr_t *i5 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8), op_rcx);

        /* Spill vectors to stack. Layout:
         *   031   : index (dst_idx_reg)
         *   3263  : table1 (src1_tbl_reg)
         *   6495  : table2 (src2_tbl_reg)
         *   96127 : result (filled later)
         */
        instr_t *i6 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_IDX, OPSZ_32),
                                 opnd_create_reg(dst_idx_reg));
        instr_t *i7 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_TBL1, OPSZ_32),
                                 opnd_create_reg(src1_tbl_reg));
        instr_t *i8 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_TBL2, OPSZ_32),
                                 opnd_create_reg(src2_tbl_reg));

        /* ECX = loop counter. */
        instr_t *i9 = INSTR_CREATE_xor(dcontext, op_ecx, op_ecx);

        /**********************  Main permutation loop  *******************/
        /* LOOP_LABEL: */
        instr_t *i10 = LOOP_LABEL;

        /* RAX = 64bit index from index array. */
        instr_t *i11 =
            INSTR_CREATE_mov_ld(dcontext, op_rax, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 8, OFF_IDX, OPSZ_8));
        /* Test bit 2  table selector (for 4 elements: 0-3). */
        instr_t *i12 = INSTR_CREATE_test(dcontext, op_rax, OPND_CREATE_INT32(0x4));
        /* If bit2 == 0 -> FROM_TBL1_LABEL. */
        instr_t *i13 = INSTR_CREATE_jcc_short(dcontext, OP_jz, opnd_create_instr(FROM_TBL1_LABEL));

        /* ---- Select from table2 (bit2 == 1) ---- */
        instr_t *i14 = INSTR_CREATE_and(dcontext, op_rax, opnd_create_immed_int(0x3, OPSZ_1));
        instr_t *i15 =
            INSTR_CREATE_mov_ld(dcontext, op_rdx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 8, OFF_TBL2, OPSZ_8));
        instr_t *i16 = INSTR_CREATE_jmp_short(dcontext, opnd_create_instr(STORE_LABEL));

        /* ---- FROM_TBL1_LABEL: Select from table1 ---- */
        instr_t *i17 = FROM_TBL1_LABEL;
        instr_t *i18 = INSTR_CREATE_and(dcontext, op_rax, opnd_create_immed_int(0x3, OPSZ_1));
        instr_t *i19 =
            INSTR_CREATE_mov_ld(dcontext, op_rdx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 8, OFF_TBL1, OPSZ_8));

        /* ---- STORE_LABEL ---- */
        instr_t *i20 = STORE_LABEL;
        instr_t *i21 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 8, OFF_DST, OPSZ_8), op_rdx);

        /* i++ and loop if i < 4. */
        instr_t *i22 = INSTR_CREATE_inc(dcontext, op_ecx);
        instr_t *i23 = INSTR_CREATE_cmp(dcontext, op_ecx, OPND_CREATE_INT32(0x4));
        instr_t *i24 = INSTR_CREATE_jcc_short(dcontext, OP_jne, opnd_create_instr(LOOP_LABEL));

        /*********************  Finish & restore state  ********************/
        /* Load result YMM and free stack. */
        instr_t *i25 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_reg(dst_idx_reg),
                                            opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DST, OPSZ_32));
        instr_t *i26 =
            INSTR_CREATE_mov_ld(dcontext, op_rcx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8));
        instr_t *i27 =
            INSTR_CREATE_mov_ld(dcontext, op_rax, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8));
        instr_t *i28 =
            INSTR_CREATE_mov_ld(dcontext, op_rdx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8));
        instr_t *i29 = INSTR_CREATE_popf(dcontext);
        instr_t *i30 = INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), OPND_CREATE_INT32(FRAME));

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 30, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30);
#endif
        instrlist_concat_next_instr(ilist, 30, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30);

        return i1; /* First instr in new sequence. */
    }

    return NULL_INSTR;
}

instr_t *
vpermi2q_k_xmm_xmm_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           reg_id_t src2_data_reg, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpermi2q_k_m16_xmm_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           opnd_t src2_data_opnd, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpermi2q_k_zmm_zmm_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           reg_id_t src2_data_reg, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpermi2q_k_m64_zmm_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           opnd_t src2_data_opnd, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 642 */
rw_func_vpermi2q(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vpermi2q {%k0} %ymm7 0x20(%rdi)[32byte] -> %ymm0

    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src1_opnd = instr_get_src(instr, 1); // ymm3, src1_data is vector reg, which is certain
    opnd_t src2_opnd = instr_get_src(instr, 2); // ymm4, src2_data, src can be vector reg or memory
    opnd_t dst_opnd = instr_get_dst(instr, 0);  // ymm0, idx array, and dst_data array both

#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpermtiw", true, true, true, true);
#endif

    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    reg_id_t src1_reg = opnd_get_reg(src1_opnd);

    switch (src2_opnd.kind) {
    case REG_kind: {
        reg_id_t src2_reg = opnd_get_reg(src2_opnd);
        if (IS_YMM_REG(src2_reg))
            return vpermi2q_k_ymm_ymm_ymm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
        if (IS_XMM_REG(src2_reg))
            return vpermi2q_k_xmm_xmm_xmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
        if (IS_ZMM_REG(src2_reg))
            return vpermi2q_k_zmm_zmm_zmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
    } break;
    case BASE_DISP_kind: {
        if (IS_YMM_REG(dst_reg))
            return vpermi2q_k_m32_ymm_ymm_gen(dcontext, ilist, instr, src1_reg, src2_opnd, dst_reg, mask_reg);
        if (IS_XMM_REG(dst_reg))
            return vpermi2q_k_m16_xmm_xmm_gen(dcontext, ilist, instr, src1_reg, src2_opnd, dst_reg, mask_reg);
        if (IS_ZMM_REG(dst_reg))
            return vpermi2q_k_m64_zmm_zmm_gen(dcontext, ilist, instr, src1_reg, src2_opnd, dst_reg, mask_reg);
    } break;
    case REL_ADDR_kind: {
        if (IS_YMM_REG(dst_reg))
            return vpermi2q_k_m32_ymm_ymm_gen(dcontext, ilist, instr, src1_reg, src2_opnd, dst_reg, mask_reg);
        if (IS_XMM_REG(dst_reg))
            return vpermi2q_k_m16_xmm_xmm_gen(dcontext, ilist, instr, src1_reg, src2_opnd, dst_reg, mask_reg);
        if (IS_ZMM_REG(dst_reg))
            return vpermi2q_k_m64_zmm_zmm_gen(dcontext, ilist, instr, src1_reg, src2_opnd, dst_reg, mask_reg);
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpermi2w src2_data_opnd kind %d not support", src2_opnd.kind); return NULL_INSTR;
    }
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vpermi2w
 * ============================================= */

instr_t *
vpermi2w_k_ymm_ymm_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr,
                           reg_id_t src1_tbl_reg, /* table 1 */
                           reg_id_t src2_tbl_reg, /* table 2 */
                           reg_id_t dst_idx_reg,  /* index vector + destination */
                           reg_id_t mask_reg)
{
    /*
     * AT&T syntax example:
     *     vpermi2w  %ymm0, %ymm2, %ymm1    # k0 disabled
     *          src1   src2     dst/index
     *
     * Semantics (no writemask):
     *   For i = 0..15
     *       idx  = dst_index[i];  // 16bit index element
     *       src  = (idx & 0x10) ? src2_tbl[idx & 0x0F]
     *                              : src1_tbl[idx & 0x0F];
     *       result[i] = src;
     *   dst = result;
     */

    /* Replace the original instruction with our IR sequence. */
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    /* Only the k0mask (i.e., no mask) variant is implemented for now. */
    if (mask_reg == DR_REG_K0) {

        enum { REDZONE = 128, Y = SIZE_OF_YMM };         // Y==32
        enum { SCRATCH = 4 * Y /*dst, idx, src, out*/ }; // 128
        enum { SAVE = 8 /*rflags*/ + 8 * 4 /*rax,rdx,rcx,r11*/ };
        enum { SLACK_FOR_PUSH = 8 };
        enum { FRAME = ((REDZONE + SCRATCH + SAVE + SLACK_FOR_PUSH + 15) & ~15) };

        const int OFF_IDX = REDZONE + 0 * Y;
        const int OFF_TBL1 = REDZONE + 1 * Y;
        const int OFF_TBL2 = REDZONE + 2 * Y;
        const int OFF_DST = REDZONE + 3 * Y;
        const int OFF_RFLAGS = REDZONE + 4 * Y;
        const int OFF_RAX = OFF_RFLAGS + 8;
        const int OFF_RDX = OFF_RAX + 8;
        const int OFF_RCX = OFF_RDX + 8;
        // const int OFF_R11 = OFF_RCX + 8;

        opnd_t op_rax = opnd_create_reg(DR_REG_RAX);
        opnd_t op_rdx = opnd_create_reg(DR_REG_RDX);
        opnd_t op_rcx = opnd_create_reg(DR_REG_RCX);
        opnd_t op_eax = opnd_create_reg(DR_REG_EAX);
        opnd_t op_ecx = opnd_create_reg(DR_REG_ECX);
        opnd_t op_edx = opnd_create_reg(DR_REG_EDX);

        /*****************  Register & stack bookkeeping  *****************/
        instr_t *LOOP_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *FROM_TBL1_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *STORE_LABEL = INSTR_CREATE_label(dcontext);

        // allcate frame, skip the red zone, plus scratch + save + slack for push
        instr_t *i1 = INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), OPND_CREATE_INT32(FRAME));

        // pushf, save xflags
        instr_t *i2 = INSTR_CREATE_pushf(dcontext);

        // save rax, rdx, rcx
        instr_t *i3 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8), op_rdx);
        instr_t *i4 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8), op_rax);
        instr_t *i5 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8), op_rcx);

        /* Spill vectors to stack. Layout:
         *   031   : index (dst_idx_reg)
         *   3263  : table1 (src1_tbl_reg)
         *   6495  : table2 (src2_tbl_reg)
         *   96127 : result (filled later)
         */
        instr_t *i6 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_IDX, OPSZ_32),
                                 opnd_create_reg(dst_idx_reg));
        instr_t *i7 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_TBL1, OPSZ_32),
                                 opnd_create_reg(src1_tbl_reg));
        instr_t *i8 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_TBL2, OPSZ_32),
                                 opnd_create_reg(src2_tbl_reg));

        /* ECX = loop counter. */
        instr_t *i9 = INSTR_CREATE_xor(dcontext, op_ecx, op_ecx);

        /**********************  Main permutation loop  *******************/
        /* LOOP_LABEL: */
        instr_t *i10 = LOOP_LABEL;

        /* EAX = zeroextended 16bit index from index array. */
        instr_t *i11 =
            INSTR_CREATE_movzx(dcontext, op_eax, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 2, OFF_IDX, OPSZ_2));
        /* Test bit 4  table selector. */
        instr_t *i12 = INSTR_CREATE_test(dcontext, op_eax, OPND_CREATE_INT32(0x10));
        /* If bit4 == 0 -> FROM_TBL1_LABEL. */
        instr_t *i13 = INSTR_CREATE_jcc_short(dcontext, OP_jz, opnd_create_instr(FROM_TBL1_LABEL));

        /* ---- Select from table2 (bit4 == 1) ---- */
        instr_t *i14 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x0F, OPSZ_1));
        instr_t *i15 =
            INSTR_CREATE_movzx(dcontext, op_edx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 2, OFF_TBL2, OPSZ_2));
        instr_t *i16 = INSTR_CREATE_jmp_short(dcontext, opnd_create_instr(STORE_LABEL));

        /* ---- FROM_TBL1_LABEL: Select from table1 ---- */
        // FROM_TBL1 = FROM_TBL1_LABEL; /* just a label placeholder */
        instr_t *i17 = FROM_TBL1_LABEL;
        instr_t *i18 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x0F, OPSZ_1));
        instr_t *i19 =
            INSTR_CREATE_movzx(dcontext, op_edx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 2, OFF_TBL1, OPSZ_2));
        /* ---- STORE_LABEL ---- */
        // STORE_LABEL; /* another label placeholder */
        instr_t *i20 = STORE_LABEL;
        instr_t *i21 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 2, OFF_DST, OPSZ_2),
                                           opnd_create_reg(DR_REG_DX));

        /* i++ and loop if i < 16. */
        instr_t *i22 = INSTR_CREATE_inc(dcontext, op_ecx);
        instr_t *i23 = INSTR_CREATE_cmp(dcontext, op_ecx, OPND_CREATE_INT32(0x10));
        instr_t *i24 = INSTR_CREATE_jcc_short(dcontext, OP_jne, opnd_create_instr(LOOP_LABEL));

        /*********************  Finish & restore state  ********************/
        /* Load result YMM and free stack. */
        instr_t *i25 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_reg(dst_idx_reg),
                                            opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DST, OPSZ_32));

        instr_t *i26 =
            INSTR_CREATE_mov_ld(dcontext, op_rcx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8));
        instr_t *i27 =
            INSTR_CREATE_mov_ld(dcontext, op_rax, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8));
        instr_t *i28 =
            INSTR_CREATE_mov_ld(dcontext, op_rdx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8));
        instr_t *i29 = INSTR_CREATE_popf(dcontext);
        instr_t *i30 = INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), OPND_CREATE_INT32(FRAME));

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 30, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30);
#endif
        instrlist_concat_next_instr(ilist, 30, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30);

        return i1;
    }
    return NULL_INSTR;
}

instr_t *
vpermi2w_k_m32_ymm_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_tbl_reg,
                           opnd_t src2_tbl_opnd, reg_id_t dst_idx_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    if (mask_reg == DR_REG_K0) {

        enum { REDZONE = 128, Y = SIZE_OF_YMM };         // Y==32
        enum { SCRATCH = 4 * Y /*dst, idx, src, out*/ }; // 128
        enum { SAVE = 8 /*rflags*/ + 8 * 4 /*rax,rdx,rcx,r11*/ };
        enum { SLACK_FOR_PUSH = 8 };
        enum { FRAME = ((REDZONE + SCRATCH + SAVE + SLACK_FOR_PUSH + 15) & ~15) };

        const int OFF_IDX = REDZONE + 0 * Y;
        const int OFF_TBL1 = REDZONE + 1 * Y;
        const int OFF_TBL2 = REDZONE + 2 * Y;
        const int OFF_DST = REDZONE + 3 * Y;
        const int OFF_RFLAGS = REDZONE + 4 * Y;
        const int OFF_RAX = OFF_RFLAGS + 8;
        const int OFF_RDX = OFF_RAX + 8;
        const int OFF_RCX = OFF_RDX + 8;
        // const int OFF_R11 = OFF_RCX + 8;

        opnd_t op_rax = opnd_create_reg(DR_REG_RAX);
        opnd_t op_rdx = opnd_create_reg(DR_REG_RDX);
        opnd_t op_rcx = opnd_create_reg(DR_REG_RCX);
        opnd_t op_eax = opnd_create_reg(DR_REG_EAX);
        opnd_t op_ecx = opnd_create_reg(DR_REG_ECX);
        opnd_t op_edx = opnd_create_reg(DR_REG_EDX);

        reg_id_t ymm_spill = find_available_spill_ymm_avoiding(src1_tbl_reg, dst_idx_reg, DR_REG_NULL);
        opnd_t op_ymm_spill = opnd_create_reg(ymm_spill);

        /*****************  Register & stack bookkeeping  *****************/
        instr_t *LOOP_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *FROM_TBL1_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *STORE_LABEL = INSTR_CREATE_label(dcontext);

        // allcate frame, skip the red zone, plus scratch + save + slack for push
        instr_t *i1 = INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), OPND_CREATE_INT32(FRAME));

        // pushf, save xflags
        instr_t *i2 = INSTR_CREATE_pushf(dcontext);

        // save rax, rdx, rcx
        instr_t *i3 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8), op_rdx);
        instr_t *i4 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8), op_rax);
        instr_t *i5 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8), op_rcx);

        /* Spill vectors to stack. Layout:
         *   031   : index (dst_idx_reg)
         *   3263  : table1 (src1_tbl_reg)
         *   6495  : table2 (src2_tbl_reg)
         *   96127 : result (filled later)
         */
        instr_t *i6 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_IDX, OPSZ_32),
                                 opnd_create_reg(dst_idx_reg));
        instr_t *i7 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_TBL1, OPSZ_32),
                                 opnd_create_reg(src1_tbl_reg));
        instr_t *i8_pre1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_spill, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill)), OPSZ_32);
        instr_t *i8_pre2 = INSTR_CREATE_vmovdqu(dcontext, op_ymm_spill, src2_tbl_opnd);
        instr_t *i8 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_TBL2, OPSZ_32), op_ymm_spill);
        instr_t *i8_epi1 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_spill, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill)), OPSZ_32);

        /* ECX = loop counter. */
        instr_t *i9 = INSTR_CREATE_xor(dcontext, op_ecx, op_ecx);

        /**********************  Main permutation loop  *******************/
        /* LOOP_LABEL: */
        instr_t *i10 = LOOP_LABEL;

        /* EAX = zeroextended 16bit index from index array. */
        instr_t *i11 =
            INSTR_CREATE_movzx(dcontext, op_eax, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 2, OFF_IDX, OPSZ_2));
        /* Test bit 4  table selector. */
        instr_t *i12 = INSTR_CREATE_test(dcontext, op_eax, OPND_CREATE_INT32(0x10));
        /* If bit4 == 0 -> FROM_TBL1_LABEL. */
        instr_t *i13 = INSTR_CREATE_jcc_short(dcontext, OP_jz, opnd_create_instr(FROM_TBL1_LABEL));

        /* ---- Select from table2 (bit4 == 1) ---- */
        instr_t *i14 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x0F, OPSZ_1));
        instr_t *i15 =
            INSTR_CREATE_movzx(dcontext, op_edx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 2, OFF_TBL2, OPSZ_2));
        instr_t *i16 = INSTR_CREATE_jmp_short(dcontext, opnd_create_instr(STORE_LABEL));

        /* ---- FROM_TBL1_LABEL: Select from table1 ---- */
        // FROM_TBL1 = FROM_TBL1_LABEL; /* just a label placeholder */
        instr_t *i17 = FROM_TBL1_LABEL;
        instr_t *i18 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x0F, OPSZ_1));
        instr_t *i19 =
            INSTR_CREATE_movzx(dcontext, op_edx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 2, OFF_TBL1, OPSZ_2));

        /* ---- STORE_LABEL ---- */
        // STORE_LABEL; /* another label placeholder */
        instr_t *i20 = STORE_LABEL;
        instr_t *i21 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 2, OFF_DST, OPSZ_2),
                                           opnd_create_reg(DR_REG_DX));

        /* i++ and loop if i < 16. */
        instr_t *i22 = INSTR_CREATE_inc(dcontext, op_ecx);
        instr_t *i23 = INSTR_CREATE_cmp(dcontext, op_ecx, OPND_CREATE_INT32(0x10));
        instr_t *i24 = INSTR_CREATE_jcc_short(dcontext, OP_jne, opnd_create_instr(LOOP_LABEL));

        /*********************  Finish & restore state  ********************/
        /* Load result YMM and free stack. */
        instr_t *i25 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_reg(dst_idx_reg),
                                            opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DST, OPSZ_32));

        instr_t *i26 =
            INSTR_CREATE_mov_ld(dcontext, op_rcx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8));
        instr_t *i27 =
            INSTR_CREATE_mov_ld(dcontext, op_rax, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8));
        instr_t *i28 =
            INSTR_CREATE_mov_ld(dcontext, op_rdx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8));
        instr_t *i29 = INSTR_CREATE_popf(dcontext);
        instr_t *i30 = INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), OPND_CREATE_INT32(FRAME));

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 33, i1, i2, i3, i4, i5, i6, i7, i8_pre1, i8_pre2, i8, i8_epi1, i9, i10,
                                     i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26,
                                     i27, i28, i29, i30);
#endif
        instrlist_concat_next_instr(ilist, 33, i1, i2, i3, i4, i5, i6, i7, i8_pre1, i8_pre2, i8, i8_epi1, i9, i10, i11,
                                    i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28,
                                    i29, i30);

        return i1;
    }
    return NULL_INSTR;
}

instr_t *
vpermi2w_k_xmm_xmm_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           reg_id_t src2_data_reg, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpermi2w_k_m16_xmm_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           opnd_t src2_data_opnd, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpermi2w_k_zmm_zmm_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           reg_id_t src2_data_reg, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpermi2w_k_m64_zmm_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           opnd_t src2_data_opnd, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 643 */
rw_func_vpermi2w(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vpermi2w  %ymm2, %ymm0, %ymm1{%k0}

    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src1_opnd = instr_get_src(instr, 1); // ymm3, src1_data is vector reg, which is certain
    opnd_t src2_opnd = instr_get_src(instr, 2); // ymm4, src2_data, src can be vector reg or memory
    opnd_t dst_opnd = instr_get_dst(instr, 0);  // ymm0, idx array, and dst_data array both

#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpermtiw", true, true, true, true);
#endif

    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    reg_id_t src1_reg = opnd_get_reg(src1_opnd);

    switch (src2_opnd.kind) {
    case REG_kind: {
        reg_id_t src2_reg = opnd_get_reg(src2_opnd);
        if (IS_YMM_REG(src2_reg))
            return vpermi2w_k_ymm_ymm_ymm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
        if (IS_XMM_REG(src2_reg))
            return vpermi2w_k_xmm_xmm_xmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
        if (IS_ZMM_REG(src2_reg))
            return vpermi2w_k_zmm_zmm_zmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
    } break;
    case BASE_DISP_kind: {
        if (IS_YMM_REG(dst_reg))
            return vpermi2w_k_m32_ymm_ymm_gen(dcontext, ilist, instr, src1_reg, src2_opnd, dst_reg, mask_reg);
        if (IS_XMM_REG(dst_reg))
            return vpermi2w_k_m16_xmm_xmm_gen(dcontext, ilist, instr, src1_reg, src2_opnd, dst_reg, mask_reg);
        if (IS_ZMM_REG(dst_reg))
            return vpermi2w_k_m64_zmm_zmm_gen(dcontext, ilist, instr, src1_reg, src2_opnd, dst_reg, mask_reg);
    } break;
    case REL_ADDR_kind: {
        if (IS_YMM_REG(dst_reg))
            return vpermi2w_k_m32_ymm_ymm_gen(dcontext, ilist, instr, src1_reg, src2_opnd, dst_reg, mask_reg);
        if (IS_XMM_REG(dst_reg))
            return vpermi2w_k_m16_xmm_xmm_gen(dcontext, ilist, instr, src1_reg, src2_opnd, dst_reg, mask_reg);
        if (IS_ZMM_REG(dst_reg))
            return vpermi2w_k_m64_zmm_zmm_gen(dcontext, ilist, instr, src1_reg, src2_opnd, dst_reg, mask_reg);
    } break;
    default: REWRITE_ERROR(STD_ERRF, "vpermi2w src2_data_opnd kind %d not support", src2_opnd.kind); return NULL_INSTR;
    }
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vpermt2ps
 * ============================================= */
instr_t *
vpermt2ps_k_ymm_ymm_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t op_idx, opnd_t op_tbl1,
                            opnd_t op_dst, reg_id_t mask_reg)
{
    /* Only k0 (no opmask) semantics are implemented in this rewriter path. */
    DR_ASSERT(opnd_is_reg(op_idx) && reg_is_ymm(opnd_get_reg(op_idx)));
    DR_ASSERT(opnd_is_reg(op_dst) && reg_is_ymm(opnd_get_reg(op_dst)));
    DR_ASSERT(opnd_is_reg(op_tbl1) && reg_is_ymm(opnd_get_reg(op_tbl1)));

    reg_id_t idx_reg = opnd_get_reg(op_idx);   /* e.g. %ymm4 */
    reg_id_t dst_reg = opnd_get_reg(op_dst);   /* e.g. %ymm0 */
    reg_id_t tbl1_reg = opnd_get_reg(op_tbl1); /* e.g. %ymm5 */

    /* ---- Request two temporary YMM registers: for mask and perm1 ----
     * Both temps must avoid clobbering idx, dst, and tbl1. Also they must be distinct.
     */
    reg_id_t ymm_mask = find_available_spill_ymm_avoiding(idx_reg, dst_reg, tbl1_reg);
    reg_id_t ymm_tmp = find_available_spill_ymm_avoiding_variadic(4, idx_reg, dst_reg, tbl1_reg, ymm_mask);

    DR_ASSERT(ymm_mask != DR_REG_NULL && ymm_tmp != DR_REG_NULL);
    DR_ASSERT(ymm_mask != idx_reg && ymm_mask != dst_reg && ymm_mask != tbl1_reg);
    DR_ASSERT(ymm_tmp != idx_reg && ymm_tmp != dst_reg && ymm_tmp != tbl1_reg);
    DR_ASSERT(ymm_tmp != ymm_mask);

    opnd_t op_ymm_mask = opnd_create_reg(ymm_mask);
    opnd_t op_ymm_tmp = opnd_create_reg(ymm_tmp);
    opnd_t op_ymm_idx = opnd_create_reg(idx_reg);
    opnd_t op_ymm_dst = opnd_create_reg(dst_reg);

    /* ---- Remove original AVX512 instruction ---- */
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    /* ---- Save the two temporary YMM registers to TLS ---- */
    instr_t *i1 =
        SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_mask, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32); // spill mask
    instr_t *i2 =
        SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_tmp, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_tmp)), OPSZ_32); // spill tmp

    /* ---- Build lane mask from idx: mask = (idx << 28) >>_arith 31
     * For VL=256, the table-select id bit is bit3 of each 32b index. Shift it to the sign bit
     * and arithmetic-shift to spread to all bits (0x00000000 or 0xFFFFFFFF).
     */
    instr_t *i3 = INSTR_CREATE_vpslld(dcontext, op_ymm_mask, OPND_CREATE_INT8(28), op_ymm_idx);  // << 28
    instr_t *i4 = INSTR_CREATE_vpsrad(dcontext, op_ymm_mask, OPND_CREATE_INT8(31), op_ymm_mask); // >>_arith 31

    /* ---- Permute from table_0 (original dst value): perm0 = vpermps(idx, dst)  overwrite dst ---- */
    instr_t *i5 = INSTR_CREATE_vpermps(dcontext, op_ymm_dst, op_ymm_idx, op_ymm_dst); // perm0 in dst

    /* ---- Lane selection for table_0: dst = (~mask) & perm0 ---- */
    instr_t *i6 = INSTR_CREATE_vpandn(dcontext, op_ymm_dst, op_ymm_mask, op_ymm_dst); // ~mask & perm0

    /* ---- Permute from table_1 (3rd operand register): perm1 = vpermps(idx, tbl1)  tmp ---- */
    instr_t *i7 = INSTR_CREATE_vpermps(dcontext, op_ymm_tmp, op_ymm_idx, op_tbl1); // perm1 in tmp

    /* ---- Lane selection for table_1: tmp = mask & perm1 ---- */
    instr_t *i8 = INSTR_CREATE_vpand(dcontext, op_ymm_tmp, op_ymm_tmp, op_ymm_mask); // mask & perm1

    /* ---- Merge: dst = dst | tmp ---- */
    instr_t *i9 = INSTR_CREATE_vpor(dcontext, op_ymm_dst, op_ymm_dst, op_ymm_tmp); // final result

    /* ---- Restore temps ---- */
    instr_t *i10 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_tmp, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_tmp)), OPSZ_32);
    instr_t *i11 =
        RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_mask, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);

#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 11, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);
#endif
    instrlist_concat_next_instr(ilist, 11, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);

    return i1;
}

instr_t *
vpermt2ps_k_m32_ymm_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, opnd_t op_idx, opnd_t op_tbl1,
                            opnd_t op_dst, reg_id_t mask_reg)
{

    DR_ASSERT(opnd_is_reg(op_idx) && reg_is_ymm(opnd_get_reg(op_idx)));
    DR_ASSERT(opnd_is_reg(op_dst) && reg_is_ymm(opnd_get_reg(op_dst)));
    /* table1 can be YMM register or 32B memory, both supported by vpermps, no need to assert its type */

    reg_id_t idx_reg = opnd_get_reg(op_idx); /* e.g. %ymm4 */
    reg_id_t dst_reg = opnd_get_reg(op_dst); /* e.g. %ymm0 */

    /* ---- Request two temporary YMM registers: for mask and perm1 ---- */
    reg_id_t ymm_mask = find_available_spill_ymm_avoiding(idx_reg, dst_reg, DR_REG_NULL);
    reg_id_t ymm_tmp = find_available_spill_ymm_avoiding(idx_reg, dst_reg, ymm_mask);
    DR_ASSERT(ymm_mask != DR_REG_NULL && ymm_tmp != DR_REG_NULL);

    opnd_t op_ymm_mask = opnd_create_reg(ymm_mask);
    opnd_t op_ymm_tmp = opnd_create_reg(ymm_tmp);
    opnd_t op_ymm_idx = opnd_create_reg(idx_reg);
    opnd_t op_ymm_dst = opnd_create_reg(dst_reg);

    /* ---- Remove original AVX512 instruction ---- */
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    /* ---- Save two temporary YMM registers to TLS to avoid corrupting registers used by application ---- */
    instr_t *i1 =
        SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_mask, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32); // spill mask
    instr_t *i2 =
        SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_tmp, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_tmp)), OPSZ_32); // spill tmp

    /* ---- Generate lane mask from idx: mask = (idx << 28) >>_arith 31 ----
       Logic: Move bit3 of each dword to sign bit, then arithmetic right shift by 31 to extend to all 0s/1s. */
    instr_t *i3 = INSTR_CREATE_vpslld(dcontext, op_ymm_mask, OPND_CREATE_INT8(28), op_ymm_idx);  // << 28
    instr_t *i4 = INSTR_CREATE_vpsrad(dcontext, op_ymm_mask, OPND_CREATE_INT8(31), op_ymm_mask); // >>_arith 31

    /* ---- Permute from table0 (original dst value): perm0 = vpermps(idx, dst)  overwrite to dst ----
       vpermps in YMM mode implicitly uses the low 3 bits of idx, so no need to mask with 7. */
    instr_t *i5 = INSTR_CREATE_vpermps(dcontext, op_ymm_dst, op_ymm_idx, op_ymm_dst); // perm0 in dst

    /* ---- Lane selection: dst = (~mask) & perm0 ---- */
    instr_t *i6 = INSTR_CREATE_vpandn(dcontext, op_ymm_dst, op_ymm_mask, op_ymm_dst); // ~mask & perm0

    /* ---- Permute from table1 (reg/mem): perm1 = vpermps(idx, tbl1)  store in tmp ---- */
    instr_t *i7 = INSTR_CREATE_vpermps(dcontext, op_ymm_tmp, op_ymm_idx, op_tbl1); // perm1 in tmp

    /* ---- Lane selection: tmp = mask & perm1 ---- */
    instr_t *i8 = INSTR_CREATE_vpand(dcontext, op_ymm_tmp, op_ymm_tmp, op_ymm_mask); // mask & perm1

    /* ---- Merge: dst = dst | tmp ---- */
    instr_t *i9 = INSTR_CREATE_vpor(dcontext, op_ymm_dst, op_ymm_dst, op_ymm_tmp); // final result

    /* ---- Restore used temporary YMM registers ---- */
    instr_t *i10 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_tmp, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_tmp)), OPSZ_32);
    instr_t *i11 =
        RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_mask, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_mask)), OPSZ_32);

#ifdef DEBUG
    /* For debugging: print all at once */
    print_rewrite_variadic_instr(dcontext, 11, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);
#endif
    /* Concatenate generated instructions into the list */
    instrlist_concat_next_instr(ilist, 11, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);

    /* Return the first instruction for framework to process */
    return i1;
}

instr_t * /* 647 */
rw_func_vpermt2ps(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    /* vpermt2ps {%k0} <idx: ymmR1>, <tbl1: ymmR2/m256> -> <dst: ymmR0>
     * Only implements k0 (no mask) semantics.
     * Approach: Two vpermps operations (table0/table1), convert idx.bit3 to full-word mask using shifts,
     * then mix using vpandn/vpand/vpor.
     */
    opnd_t mask_opnd = instr_get_src(instr, 0);
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);

    /* ---- Extract 3 operands: idx(YMM), table1(YMM/MEM), dst(YMM) ---- */
    /* Assumes this rewriter is called after matching vpermt2ps, with operand order:
       src0: idx (YMM), src1: table1 (YMM or memory), dst0: dst (YMM) */
    opnd_t op_idx = instr_get_src(instr, 1);
    opnd_t op_tbl1 = instr_get_src(instr, 2);
    opnd_t op_dst = instr_get_dst(instr, 0);

#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpermt2ps", true, true, true, true);
#endif

    if (op_tbl1.kind == REG_kind) {
        return vpermt2ps_k_ymm_ymm_ymm_gen(dcontext, ilist, instr, op_idx, op_tbl1, op_dst, mask_reg);
    } else { /* memory kind */
        return vpermt2ps_k_m32_ymm_ymm_gen(dcontext, ilist, instr, op_idx, op_tbl1, op_dst, mask_reg);
    }
}

/* ==============================================
 *         Helper func for vpermt2q
 * ============================================= */

instr_t *
vpermt2q_k_ymm_ymm_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           reg_id_t src2_data_reg, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    // e.g. vpermt2q {%k0}  %ymm3    %ymm4  ->  %ymm0
    //                      src1     src2        dst
    // AT&T format:  vpermt2q  %ymm4, %ymm3, %ymm0

    // vpermt2q {%k0} %ymm3 %ymm4 -> %ymm0
    //     [REWRITE INFO]:   ymm_bitmap: 0
    //     mask: %k0
    //     src1: %ymm3
    //     src2: %ymm4
    //     dst: %ymm0

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    // if k0 no mask
    if (mask_reg == DR_REG_K0) {

        enum { REDZONE = 128, Y = SIZE_OF_YMM };         // Y==32
        enum { SCRATCH = 4 * Y /*dst, idx, src, out*/ }; // 128
        enum { SAVE = 8 /*rflags*/ + 8 * 4 /*rax,rdx,rcx,r11*/ };
        enum { SLACK_FOR_PUSH = 8 };
        enum { FRAME = ((REDZONE + SCRATCH + SAVE + SLACK_FOR_PUSH + 15) & ~15) };

        const int OFF_DST = REDZONE + 0 * Y;
        const int OFF_MEM = REDZONE + 1 * Y;
        const int OFF_IDX = REDZONE + 2 * Y;
        const int OFF_DATA = REDZONE + 3 * Y;
        const int OFF_RFLAGS = REDZONE + 4 * Y;
        const int OFF_RAX = OFF_RFLAGS + 8;
        const int OFF_RDX = OFF_RAX + 8;
        const int OFF_RCX = OFF_RDX + 8;
        // const int OFF_R11 = OFF_RCX + 8;

        opnd_t op_rax = opnd_create_reg(DR_REG_RAX);
        opnd_t op_rdx = opnd_create_reg(DR_REG_RDX);
        opnd_t op_rcx = opnd_create_reg(DR_REG_RCX);
        opnd_t op_eax = opnd_create_reg(DR_REG_EAX);
        opnd_t op_ecx = opnd_create_reg(DR_REG_ECX);
        opnd_t op_rsp = opnd_create_reg(DR_REG_RSP);

        /* main logic of loop-based vpermt2q emulation */
        instr_t *LOOP_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *FROM_DATA_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *STORE_LABEL = INSTR_CREATE_label(dcontext);

        // allocate stack space avoid red zone
        instr_t *i1 = INSTR_CREATE_sub(dcontext, op_rsp, OPND_CREATE_INT32(FRAME));
        /* pushf, save xflags to avoid pollution */
        // pushf
        instr_t *i2 = INSTR_CREATE_pushf(dcontext);
        instr_t *i3 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8), op_rax);
        instr_t *i4 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8), op_rdx);
        instr_t *i5 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8), op_rcx);

        /* store the 3 ymm regs to stack */
        // vmovdqu %ymm0, OFF_DATA(%rsp)        # [rsp+OFF_DATA]  data_array[0..3]
        instr_t *i6 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DATA, OPSZ_32),
                                 opnd_create_reg(dst_data_reg));
        // vmovdqu %ymm3, OFF_IDX(%rsp)         # [rsp+OFF_IDX]   index_array[0..3]
        instr_t *i7 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_IDX, OPSZ_32),
                                 opnd_create_reg(src1_idx_reg));
        // vmovdqu %ymm4, OFF_MEM(%rsp)         # [rsp+OFF_MEM]   mem_array[0..3]
        instr_t *i8 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_MEM, OPSZ_32),
                                 opnd_create_reg(src2_data_reg));

        /* init loop counter */
        // xor %ecx, %ecx    # i = 0
        instr_t *i9 = INSTR_CREATE_xor(dcontext, opnd_create_reg(DR_REG_ECX), opnd_create_reg(DR_REG_ECX));

        /* loop label */
        // .L_loop:  instr_t *LOOP_LABEL
        instr_t *i10 = LOOP_LABEL;

        /* load index = index_array[i] */
        // movq  OFF_IDX(%rsp,%rcx,8), %rax  # rax = *(uint64_t*)(rsp+ OFF_IDX + i*8)
        instr_t *i11 =
            INSTR_CREATE_mov_ld(dcontext, op_rax, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 8, OFF_IDX, OPSZ_8));
        // test $0x4, %eax               # test bit2 (0x4)
        instr_t *i12 = INSTR_CREATE_test(dcontext, op_eax, OPND_CREATE_INT32(0x4));
        // jz .Lfrom_data                 # if bit2 is 0, jump to .Lfrom_data
        instr_t *i13 = INSTR_CREATE_jcc_short(dcontext, OP_jz, opnd_create_instr(FROM_DATA_LABEL));

        /* fallthrough branch to select from mem_array */
        // and $0x3, %eax                # eax = eax & 0x3 keep lower 2 bits [1:0]
        instr_t *i14 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x3, OPSZ_1));
        // movq  64(%rsp, %rax, 8), %rdx   # rdx = mem_array[idx]
        instr_t *i15 =
            INSTR_CREATE_mov_ld(dcontext, op_rdx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 8, OFF_MEM, OPSZ_8));
        // jmp .Lstore
        instr_t *i16 = INSTR_CREATE_jmp_short(dcontext, opnd_create_instr(STORE_LABEL));

        /* from data label */
        // .Lfrom_data: instr_t *FROM_DATA_LABEL
        instr_t *i17 = FROM_DATA_LABEL;

        // and $0x3, %eax                # eax = eax & 0x3 keep lower 2 bits [1:0]
        instr_t *i18 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x3, OPSZ_1));
        // movq  (%rsp,%rax,8), %rdx     # rdx = data_array[idx]
        instr_t *i19 =
            INSTR_CREATE_mov_ld(dcontext, op_rdx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 8, OFF_DATA, OPSZ_8));
        /* store label */
        // .Lstore: instr_t *STORE_LABEL
        instr_t *i20 = STORE_LABEL;

        // movq    %rdx, 96(%rsp,%rcx,8)       # *(uint64_t*)(rsp + 96 + i*8) = rdx
        instr_t *i21 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 8, OFF_DST, OPSZ_8), op_rdx);
        // inc     %ecx                    # i++
        instr_t *i22 = INSTR_CREATE_inc(dcontext, op_ecx);
        // cmp     $4, %ecx
        instr_t *i23 = INSTR_CREATE_cmp(dcontext, op_ecx, OPND_CREATE_INT32(0x4));
        // jne     .Loop                   # If i < 4, continue
        instr_t *i24 = INSTR_CREATE_jcc_short(dcontext, OP_jne, opnd_create_instr(LOOP_LABEL));

        // vmovdqu 96(%rsp), %ymm0
        instr_t *i25 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_reg(dst_data_reg),
                                            opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DST, OPSZ_32));

        // Restore stack and return
        instr_t *i26 =
            INSTR_CREATE_mov_ld(dcontext, op_rcx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8));
        instr_t *i27 =
            INSTR_CREATE_mov_ld(dcontext, op_rdx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8));
        instr_t *i28 =
            INSTR_CREATE_mov_ld(dcontext, op_rax, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8));
        instr_t *i29 = INSTR_CREATE_popf(dcontext);
        instr_t *i30 = INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), OPND_CREATE_INT32(FRAME));

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 30, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30);
#endif
        instrlist_concat_next_instr(ilist, 30, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30);

        return i1;
    } else { // writemask, need to know merging mode or zero mode
    }
    return NULL_INSTR;
}

instr_t *
vpermt2q_k_m32_ymm_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           opnd_t src2_data_opnd, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    // e.g. vpermt2q {%k0} %ymm3 %ymm4 -> %ymm0
    // AT&T format:  vpermt2q  %ymm4, %ymm3, %ymm0
    // serve for both BASE DISP Format and REL ADDRESS Format
    // vpermt2q {%k0} %ymm3 0x20(%r12,%rax,2)[32byte] -> %ymm1
    // vpermt2q {%k0} %ymm3 <rel> 0x00007f9b617aa840[32byte] -> %ymm1
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    // if k0 no mask
    if (mask_reg == DR_REG_K0) {

        enum { REDZONE = 128, Y = SIZE_OF_YMM };         // Y==32
        enum { SCRATCH = 4 * Y /*dst, idx, src, out*/ }; // 128
        enum { SAVE = 8 /*rflags*/ + 8 * 4 /*rax,rdx,rcx,r11*/ };
        enum { SLACK_FOR_PUSH = 8 };
        enum { FRAME = ((REDZONE + SCRATCH + SAVE + SLACK_FOR_PUSH + 15) & ~15) };

        const int OFF_DST = REDZONE + 0 * Y;
        const int OFF_MEM = REDZONE + 1 * Y;
        const int OFF_IDX = REDZONE + 2 * Y;
        const int OFF_DATA = REDZONE + 3 * Y;
        const int OFF_RFLAGS = REDZONE + 4 * Y;
        const int OFF_RAX = OFF_RFLAGS + 8;
        const int OFF_RDX = OFF_RAX + 8;
        const int OFF_RCX = OFF_RDX + 8;

        opnd_t op_rax = opnd_create_reg(DR_REG_RAX);
        opnd_t op_rdx = opnd_create_reg(DR_REG_RDX);
        opnd_t op_rcx = opnd_create_reg(DR_REG_RCX);
        opnd_t op_eax = opnd_create_reg(DR_REG_EAX);
        opnd_t op_ecx = opnd_create_reg(DR_REG_ECX);
        opnd_t op_rsp = opnd_create_reg(DR_REG_RSP);

        reg_id_t ymm_spill = find_available_spill_ymm_avoiding(src1_idx_reg, dst_data_reg, DR_REG_NULL);
        opnd_t op_ymm_spill = opnd_create_reg(ymm_spill);

        /* main logic of loop-based vpermt2q emulation */
        instr_t *LOOP_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *FROM_DATA_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *STORE_LABEL = INSTR_CREATE_label(dcontext);

        // allocate stack space avoid red zone
        instr_t *i1 = INSTR_CREATE_sub(dcontext, op_rsp, OPND_CREATE_INT32(FRAME));

        /* pushf, save xflags to avoid pollution */
        // spill src1_idx_reg
        instr_t *i2 = INSTR_CREATE_pushf(dcontext);
        instr_t *i3 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8), op_rax);
        instr_t *i4 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8), op_rdx);
        instr_t *i5 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8), op_rcx);

        /* store the 3 ymm regs to stack */
        // vmovdqu %ymm0, (%rsp)           # [rsp+0]    data_array[0..3]
        instr_t *i6 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DATA, OPSZ_32),
                                 opnd_create_reg(dst_data_reg));
        // vmovdqu %ymm3, 32(%rsp)         # [rsp+32]   index_array[0..3]
        instr_t *i7 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_IDX, OPSZ_32),
                                 opnd_create_reg(src1_idx_reg));

        // ymm_spill -> tls(ymm_spill)
        instr_t *i8 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_spill, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill)), OPSZ_32);
        // vmovdqu  0x20(%r12,%rax,2)[32byte] -> ymm_spill
        instr_t *i9 = INSTR_CREATE_vmovdqu(dcontext, op_ymm_spill, src2_data_opnd);
        // vmovdqu %ymm_spill, OFF_MEM(%rsp)         # [rsp+64]   mem_array[0..3], we borrow %ymm3 as temp reg
        instr_t *i10 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_MEM, OPSZ_32), op_ymm_spill);
        // tls(ymm_spill) -> ymm_spill
        instr_t *i11 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_spill, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill)), OPSZ_32);

        /* init loop counter */
        // xor %ecx, %ecx    # i = 0
        instr_t *i12 = INSTR_CREATE_xor(dcontext, op_ecx, op_ecx);

        /* loop label */
        // .L_loop:  instr_t *LOOP_LABEL
        instr_t *i13 = LOOP_LABEL;

        /* load index = index_array[i] */
        // movq  32(%rsp,%rcx,8), %rax  # rax = *(uint64_t*)(rsp+32 + i*8)
        instr_t *i14 =
            INSTR_CREATE_mov_ld(dcontext, op_rax, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 8, OFF_IDX, OPSZ_8));
        // test $0x4, %eax              # test bit2 (0x4)
        instr_t *i15 = INSTR_CREATE_test(dcontext, op_eax, OPND_CREATE_INT32(0x4));
        // jz .Lfrom_data               # if bit2 is 0, jump to .Lfrom_data
        instr_t *i16 = INSTR_CREATE_jcc_short(dcontext, OP_jz, opnd_create_instr(FROM_DATA_LABEL));

        /* fallthrough branch to select from mem_array */
        // and $0x3, %eax               # eax = eax & 0x3 keep lower 2 bits [1:0]
        instr_t *i17 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x3, OPSZ_1));
        // movq  64(%rsp, %rax, 8), %rdx   # rdx = mem_array[idx]
        instr_t *i18 =
            INSTR_CREATE_mov_ld(dcontext, op_rdx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 8, OFF_MEM, OPSZ_8));
        // jmp .Lstore
        instr_t *i19 = INSTR_CREATE_jmp_short(dcontext, opnd_create_instr(STORE_LABEL));

        /* from data label */
        // .Lfrom_data: instr_t *FROM_DATA_LABEL
        instr_t *i20 = FROM_DATA_LABEL;

        // and $0x3, %eax               # eax = eax & 0x3 keep lower 2 bits [1:0]
        instr_t *i21 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x3, OPSZ_1));
        // movq  (%rsp,%rax,8), %rdx    # rdx = data_array[idx]
        instr_t *i22 =
            INSTR_CREATE_mov_ld(dcontext, op_rdx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 8, OFF_DATA, OPSZ_8));

        /* store label */
        // .Lstore: instr_t *STORE_LABEL
        instr_t *i23 = STORE_LABEL;
        // movq  %rdx, 96(%rsp,%rcx,8)  # *(uint64_t*)(rsp + 96 + i*8) = rdx
        instr_t *i24 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 8, OFF_DST, OPSZ_8), op_rdx);
        // inc     %ecx                 # i++
        instr_t *i25 = INSTR_CREATE_inc(dcontext, op_ecx);
        // cmp     $4, %ecx
        instr_t *i26 = INSTR_CREATE_cmp(dcontext, op_ecx, OPND_CREATE_INT32(0x4));
        // jne     .Loop                # If i < 4, continue
        instr_t *i27 = INSTR_CREATE_jcc_short(dcontext, OP_jne, opnd_create_instr(LOOP_LABEL));

        // vmovdqu 96(%rsp), %ymm0
        instr_t *i28 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_reg(dst_data_reg),
                                            opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DST, OPSZ_32));

        // Restore stack and return
        instr_t *i29 =
            INSTR_CREATE_mov_ld(dcontext, op_rax, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8));
        instr_t *i30 =
            INSTR_CREATE_mov_ld(dcontext, op_rdx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8));
        instr_t *i31 =
            INSTR_CREATE_mov_ld(dcontext, op_rcx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8));
        instr_t *i32 = INSTR_CREATE_popf(dcontext);
        instr_t *i33 = INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), OPND_CREATE_INT32(FRAME));

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 33, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32, i33);
#endif
        instrlist_concat_next_instr(ilist, 33, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32,
                                    i33);

        return i1;
    } else { // writemask, need to know merging mode or zero mode
    }
    return NULL_INSTR;
}

instr_t *
vpermt2q_k_xmm_xmm_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           reg_id_t src2_data_reg, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpermt2q_k_m16_xmm_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           opnd_t src2_data_opnd, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpermt2q_k_zmm_zmm_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           reg_id_t src2_data_reg, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpermt2q_k_m64_zmm_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           opnd_t src2_data_opnd, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 648 */
rw_func_vpermt2q(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vpermt2q {%k0} %ymm0 0x20(%rdi)[32byte] -> %ymm4
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src1_idx_opnd = instr_get_src(instr, 1);  // ymm3, src1_idx is vector reg, which is certain
    opnd_t src2_data_opnd = instr_get_src(instr, 2); // ymm4, src2_data, src can be vector reg or memory
    opnd_t dst_data_opnd = instr_get_dst(instr, 0);  // ymm0, dst_data

#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpermt2q", true, true, true, true);
#endif
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t dst_data_reg = opnd_get_reg(dst_data_opnd);
    reg_id_t src1_idx_reg = opnd_get_reg(src1_idx_opnd);

    switch (src2_data_opnd.kind) {
    case REG_kind: {
        reg_id_t src2_data_reg = opnd_get_reg(src2_data_opnd);
        if (IS_YMM_REG(dst_data_reg)) {
            return vpermt2q_k_ymm_ymm_ymm_gen(dcontext, ilist, instr, src1_idx_reg, src2_data_reg, dst_data_reg,
                                              mask_reg);
        }
        if (IS_XMM_REG(dst_data_reg)) {
            return vpermt2q_k_xmm_xmm_xmm_gen(dcontext, ilist, instr, src1_idx_reg, src2_data_reg, dst_data_reg,
                                              mask_reg);
        }
        if (IS_ZMM_REG(dst_data_reg)) {
            return vpermt2q_k_zmm_zmm_zmm_gen(dcontext, ilist, instr, src1_idx_reg, src2_data_reg, dst_data_reg,
                                              mask_reg);
        }
        REWRITE_ERROR(STD_ERRF, "vpermt2q pattern not support, dst_data_reg matches no simd reg");
    } break;
    case BASE_DISP_kind: {
        if (IS_YMM_REG(dst_data_reg)) {
            return vpermt2q_k_m32_ymm_ymm_gen(dcontext, ilist, instr, src1_idx_reg, src2_data_opnd, dst_data_reg,
                                              mask_reg);
        }
        if (IS_XMM_REG(dst_data_reg)) {
            return vpermt2q_k_m16_xmm_xmm_gen(dcontext, ilist, instr, src1_idx_reg, src2_data_opnd, dst_data_reg,
                                              mask_reg);
        }
        if (IS_ZMM_REG(dst_data_reg)) {
            return vpermt2q_k_m64_zmm_zmm_gen(dcontext, ilist, instr, src1_idx_reg, src2_data_opnd, dst_data_reg,
                                              mask_reg);
        }
        REWRITE_ERROR(STD_ERRF, "vpermt2q pattern not support, dst_data_reg matches no simd reg");
    } break;
    case REL_ADDR_kind: {
        if (IS_YMM_REG(dst_data_reg)) {
            return vpermt2q_k_m32_ymm_ymm_gen(dcontext, ilist, instr, src1_idx_reg, src2_data_opnd, dst_data_reg,
                                              mask_reg);
        }
        if (IS_XMM_REG(dst_data_reg)) {
            return vpermt2q_k_m16_xmm_xmm_gen(dcontext, ilist, instr, src1_idx_reg, src2_data_opnd, dst_data_reg,
                                              mask_reg);
        }
        if (IS_ZMM_REG(dst_data_reg)) {
            return vpermt2q_k_m64_zmm_zmm_gen(dcontext, ilist, instr, src1_idx_reg, src2_data_opnd, dst_data_reg,
                                              mask_reg);
        }
        REWRITE_ERROR(STD_ERRF, "vpermt2q pattern not support, dst_data_reg matches no simd reg");
    } break;
    default: {
        REWRITE_ERROR(STD_ERRF, "vpermt2q pattern not support");
        return NULL_INSTR;
    }
    }
    REWRITE_ERROR(STD_ERRF, "vpermt2q pattern not support");
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vpermt2w
 * ============================================= */

instr_t *
vpermt2w_k_ymm_ymm_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           reg_id_t src2_data_reg, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    // e.g. vpermt2w {%k0}  %ymm3    %ymm4  ->  %ymm0
    //                      src1     src2        dst
    // AT&T format:  vpermt2w  %ymm4, %ymm3, %ymm0

    // vpermt2w {%k0} %ymm3 %ymm4 -> %ymm0
    //     [REWRITE INFO]:   ymm_bitmap: 0
    //     mask: %k0
    //     src1: %ymm3
    //     src2: %ymm4
    //     dst: %ymm0

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    // if k0 no mask
    if (mask_reg == DR_REG_K0) {

        enum { REDZONE = 128, Y = SIZE_OF_YMM };         // Y==32
        enum { SCRATCH = 4 * Y /*dst, idx, src, out*/ }; // 128
        enum { SAVE = 8 /*rflags*/ + 8 * 4 /*rax,rdx,rcx,r11*/ };
        enum { SLACK_FOR_PUSH = 8 };
        enum { FRAME = ((REDZONE + SCRATCH + SAVE + SLACK_FOR_PUSH + 15) & ~15) };

        const int OFF_DST = REDZONE + 0 * Y;
        const int OFF_MEM = REDZONE + 1 * Y;
        const int OFF_IDX = REDZONE + 2 * Y;
        const int OFF_DATA = REDZONE + 3 * Y;
        const int OFF_RFLAGS = REDZONE + 4 * Y;
        const int OFF_RAX = OFF_RFLAGS + 8;
        const int OFF_RDX = OFF_RAX + 8;
        const int OFF_RCX = OFF_RDX + 8;
        // const int OFF_R11 = OFF_RCX + 8;

        opnd_t op_rax = opnd_create_reg(DR_REG_RAX);
        opnd_t op_rdx = opnd_create_reg(DR_REG_RDX);
        opnd_t op_rcx = opnd_create_reg(DR_REG_RCX);
        opnd_t op_eax = opnd_create_reg(DR_REG_EAX);
        opnd_t op_ecx = opnd_create_reg(DR_REG_ECX);
        opnd_t op_edx = opnd_create_reg(DR_REG_EDX);

        /* main logic of loop-based vpermt2w emulation */
        instr_t *LOOP_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *FROM_DATA_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *STORE_LABEL = INSTR_CREATE_label(dcontext);

        // allcate frame, skip the red zone, plus scratch + save + slack for push
        instr_t *i1 = INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), OPND_CREATE_INT32(FRAME));

        // pushf, save xflags
        instr_t *i2 = INSTR_CREATE_pushf(dcontext);
        // save rax, rdx, rcx
        instr_t *i3 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8), op_rax);
        instr_t *i4 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8), op_rdx);
        instr_t *i5 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8), op_rcx);

        /* storea the 3 ymm regs to stack */
        // vmovdqu %ymm0, (%rsp)           # [rsp+0]    data_array[0..15]
        instr_t *i6 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DATA, OPSZ_32),
                                 opnd_create_reg(dst_data_reg));
        // vmovdqu %ymm3, 32(%rsp)         # [rsp+32]   index_array[0..15]
        instr_t *i7 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_IDX, OPSZ_32),
                                 opnd_create_reg(src1_idx_reg));
        // vmovdqu %ymm4, 64(%rsp)         # [rsp+64]   mem_array[0..15]
        instr_t *i8 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_MEM, OPSZ_32),
                                 opnd_create_reg(src2_data_reg));

        /* init loop counter */
        // xor %ecx, %ecx    # i = 0
        instr_t *i9 = INSTR_CREATE_xor(dcontext, op_ecx, op_ecx);

        /* loop label */
        // .L_loop:  instr_t *LOOP_LABEL
        instr_t *i10 = LOOP_LABEL;

        /* load index = index_array[i] */
        // movzwl  32(%rsp,%rcx,2), %eax  # eax = *(uint16_t*)(rsp+32 + i*2)
        instr_t *i11 =
            INSTR_CREATE_movzx(dcontext, op_eax, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 2, OFF_IDX, OPSZ_2));
        // test $0x10, %eax               # test bit4 (0x10)
        instr_t *i12 = INSTR_CREATE_test(dcontext, op_eax, OPND_CREATE_INT32(0x10));
        // jz .Lfrom_data                 # if bit4 is 0, jump to .Lfrom_data
        instr_t *i13 = INSTR_CREATE_jcc_short(dcontext, OP_jz, opnd_create_instr(FROM_DATA_LABEL));

        /* fallthrough branch to select from mem_array */
        // and $0x0f, %eax                # eax = eax & 0x0f keep lower 4 bits [3:0]
        instr_t *i14 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x0f, OPSZ_1));
        // movzwl  64(%rsp, %rax, 2), %edx   # edx = mem_array[idx]
        instr_t *i15 =
            INSTR_CREATE_movzx(dcontext, op_edx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 2, OFF_MEM, OPSZ_2));
        // jmp .Lstore
        instr_t *i16 = INSTR_CREATE_jmp_short(dcontext, opnd_create_instr(STORE_LABEL));

        /* from data label */
        // .Lfrom_data: instr_t *FROM_DATA_LABEL
        instr_t *i17 = FROM_DATA_LABEL;

        // and $0x0f, %eax                # eax = eax & 0x0f keep lower 4 bits [3:0]
        instr_t *i18 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x0f, OPSZ_1));
        // movzwl  (%rsp,%rax,2), %edx     # edx = data_array[idx]
        instr_t *i19 =
            INSTR_CREATE_movzx(dcontext, op_edx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 2, OFF_DATA, OPSZ_2));

        /* store label */
        // .Lstore: instr_t *STORE_LABEL
        instr_t *i20 = STORE_LABEL;

        // movw    %dx, $96(%rsp,%rcx,2)       # *(uint16_t*)(rsp + i*2) = dx
        instr_t *i21 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 2, OFF_DST, OPSZ_2),
                                           opnd_create_reg(DR_REG_DX));
        // inc     %ecx                    # i++
        instr_t *i22 = INSTR_CREATE_inc(dcontext, op_ecx);
        // cmp     $16, %ecx
        instr_t *i23 = INSTR_CREATE_cmp(dcontext, op_ecx, OPND_CREATE_INT32(0x10));
        // jne     .Loop                   # If i < 16, continue
        instr_t *i24 = INSTR_CREATE_jcc_short(dcontext, OP_jne, opnd_create_instr(LOOP_LABEL));

        // vmovdqu 96(%rsp), %ymm0
        instr_t *i25 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_reg(dst_data_reg),
                                            opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DST, OPSZ_32));

        // Restore stack and return
        // save rax, rdx, rcx
        instr_t *i26 =
            INSTR_CREATE_mov_ld(dcontext, op_rax, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8));
        instr_t *i27 =
            INSTR_CREATE_mov_ld(dcontext, op_rdx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8));
        instr_t *i28 =
            INSTR_CREATE_mov_ld(dcontext, op_rcx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8));
        instr_t *i29 = INSTR_CREATE_popf(dcontext);
        instr_t *i30 = INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), OPND_CREATE_INT32(FRAME));

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 30, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30);
#endif
        instrlist_concat_next_instr(ilist, 30, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30);

        return i1;
    } else { // writemask, need to know merging mode or zero mode
    }
    return NULL_INSTR;
}

instr_t *
vpermt2w_k_m32_ymm_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           opnd_t src2_data_opnd, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    // e.g. vpermt2w {%k0} %ymm3 %ymm4 -> %ymm0
    // AT&T format:  vpermt2w  %ymm4, %ymm3, %ymm0
    // server for both BASE DISP Format and REL ADDRESS Format
    // vpermt2w {%k0} %ymm3 0x20(%r12,%rax,2)[32byte] -> %ymm1
    // vpermt2w {%k0} %ymm3 <rel> 0x00007f9b617aa840[32byte] -> %ymm1
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    // if k0 no mask
    if (mask_reg == DR_REG_K0) {

        enum { REDZONE = 128, Y = SIZE_OF_YMM };         // Y==32
        enum { SCRATCH = 4 * Y /*dst, idx, src, out*/ }; // 128
        enum { SAVE = 8 /*rflags*/ + 8 * 4 /*rax,rdx,rcx,r11*/ };
        enum { SLACK_FOR_PUSH = 8 };
        enum { FRAME = ((REDZONE + SCRATCH + SAVE + SLACK_FOR_PUSH + 15) & ~15) };

        const int OFF_DST = REDZONE + 0 * Y;
        const int OFF_MEM = REDZONE + 1 * Y;
        const int OFF_IDX = REDZONE + 2 * Y;
        const int OFF_DATA = REDZONE + 3 * Y;
        const int OFF_RFLAGS = REDZONE + 4 * Y;
        const int OFF_RAX = OFF_RFLAGS + 8;
        const int OFF_RDX = OFF_RAX + 8;
        const int OFF_RCX = OFF_RDX + 8;
        // const int OFF_R11 = OFF_RCX + 8;

        opnd_t op_rax = opnd_create_reg(DR_REG_RAX);
        opnd_t op_rdx = opnd_create_reg(DR_REG_RDX);
        opnd_t op_rcx = opnd_create_reg(DR_REG_RCX);
        opnd_t op_eax = opnd_create_reg(DR_REG_EAX);
        opnd_t op_ecx = opnd_create_reg(DR_REG_ECX);
        opnd_t op_edx = opnd_create_reg(DR_REG_EDX);
        opnd_t op_rsp = opnd_create_reg(DR_REG_RSP);

        // free ymm register
        reg_id_t ymm_spill = find_available_spill_ymm_avoiding(src1_idx_reg, dst_data_reg, DR_REG_NULL);
        opnd_t op_ymm_spill = opnd_create_reg(ymm_spill);

        /* main logic of loop-based vpermt2w emulation */
        instr_t *LOOP_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *FROM_DATA_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *STORE_LABEL = INSTR_CREATE_label(dcontext);

        /* pushf, save xflags to avoid pollution */
        // allcate frame, skip the red zone, plus scratch + save + slack for push
        instr_t *i1 = INSTR_CREATE_sub(dcontext, op_rsp, OPND_CREATE_INT32(FRAME));

        // push, save xflags
        instr_t *i2 = INSTR_CREATE_pushf(dcontext);
        // save rax, rdx, rcx
        instr_t *i3 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8), op_rax);
        instr_t *i4 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8), op_rdx);
        instr_t *i5 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8), op_rcx);

        /* storea the 3 ymm regs to stack */
        // vmovdqu %ymm0, (%rsp)           # [rsp+0]    data_array[0..15]
        instr_t *i6 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DATA, OPSZ_32),
                                 opnd_create_reg(dst_data_reg));
        // vmovdqu %ymm3, 32(%rsp)         # [rsp+32]   index_array[0..15]
        instr_t *i7 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_IDX, OPSZ_32),
                                 opnd_create_reg(src1_idx_reg));
        // ymm_spill -> tls(ymm_spill)
        instr_t *i8 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_spill, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill)), OPSZ_32);
        // vmovdqu  0x20(%r12,%rax,2)[32byte] -> %ymm_spill
        instr_t *i9 = INSTR_CREATE_vmovdqu(dcontext, op_ymm_spill, src2_data_opnd);
        // vmovdqu %ymm_spill -> 64(%rsp)   # [rsp+64]   mem_array[0..15],
        instr_t *i10 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_MEM, OPSZ_32), op_ymm_spill);
        // tls(ymm_spill) -> ymm_spill
        instr_t *i11 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_spill, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill)), OPSZ_32);

        /* init loop counter */
        // xor %ecx, %ecx    # i = 0
        instr_t *i12 = INSTR_CREATE_xor(dcontext, op_ecx, op_ecx);

        /* loop label */
        // .L_loop:  instr_t *LOOP_LABEL
        instr_t *i13 = LOOP_LABEL;

        /* load index = index_array[i] */
        // movzwl  32(%rsp,%rcx,2), %eax   # eax = *(uint16_t*)(rsp+32 + i*2)
        instr_t *i14 = INSTR_CREATE_movzx(dcontext, op_eax, // OP_movzx => movzxwl
                                          opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 2, OFF_IDX, OPSZ_2));
        // test $0x10, %eax                # test bit4 (0x10)
        instr_t *i15 = INSTR_CREATE_test(dcontext, op_eax, OPND_CREATE_INT32(0x10));
        // jz .Lfrom_data                  # if bit4 is 0, jump to .Lfrom_data
        instr_t *i16 = INSTR_CREATE_jcc_short(dcontext, OP_jz, opnd_create_instr(FROM_DATA_LABEL));

        /* fallthrough branch to select from mem_array */
        // and $0x0f, %eax                 # eax = eax & 0x0f keep lower 4 bits [3:0]
        instr_t *i17 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x0f, OPSZ_1));
        // movzwl  64(%rsp, %rax, 2), %edx   # edx = mem_array[idx]
        instr_t *i18 =
            INSTR_CREATE_movzx(dcontext, op_edx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 2, OFF_MEM, OPSZ_2));
        // jmp .Lstore
        instr_t *i19 = INSTR_CREATE_jmp_short(dcontext, opnd_create_instr(STORE_LABEL));

        /* from data label */
        // .Lfrom_data: instr_t *FROM_DATA_LABEL
        instr_t *i20 = FROM_DATA_LABEL;

        // and $0x0f, %eax                 # eax = eax & 0x0f keep lower 4 bits [3:0]
        instr_t *i21 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x0f, OPSZ_1));
        // movzwl  (%rsp,%rax,2), %edx     # edx = data_array[idx]
        instr_t *i22 =
            INSTR_CREATE_movzx(dcontext, op_edx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 2, OFF_DATA, OPSZ_2));
        /* store label */
        // .Lstore: instr_t *STORE_LABEL
        instr_t *i23 = STORE_LABEL;

        // movw    %dx, $96(%rsp,%rcx,2)   # *(uint16_t*)(rsp + i*2) = dx
        instr_t *i24 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 2, OFF_DST, OPSZ_2),
                                           opnd_create_reg(DR_REG_DX));
        // inc     %ecx                    # i++
        instr_t *i25 = INSTR_CREATE_inc(dcontext, op_ecx);
        // cmp     $16, %ecx
        instr_t *i26 = INSTR_CREATE_cmp(dcontext, op_ecx, OPND_CREATE_INT32(0x10));
        // jne     .Loop                   # If i < 16, continue
        instr_t *i27 = INSTR_CREATE_jcc_short(dcontext, OP_jne, opnd_create_instr(LOOP_LABEL));

        // vmovdqu 96(%rsp), %ymm0
        instr_t *i28 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_reg(dst_data_reg),
                                            opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DST, OPSZ_32));

        // Restore stack and return
        // add     $128, %rsp
        // save rax, rdx, rcx
        instr_t *i29 =
            INSTR_CREATE_mov_ld(dcontext, op_rax, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8));
        instr_t *i30 =
            INSTR_CREATE_mov_ld(dcontext, op_rdx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8));
        instr_t *i31 =
            INSTR_CREATE_mov_ld(dcontext, op_rcx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8));
        instr_t *i32 = INSTR_CREATE_popf(dcontext);
        instr_t *i33 = INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), OPND_CREATE_INT32(FRAME));

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 33, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32, i33);
#endif
        instrlist_concat_next_instr(ilist, 33, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32,
                                    i33);

        return i1;
    } else { // writemask, need to know merging mode or zero mode
    }
    return NULL_INSTR;
}

instr_t *
vpermt2w_k_xmm_xmm_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           reg_id_t src2_data_reg, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    // e.g. vpermt2w {%k0} %xmm3 %xmm4 -> %xmm0
    // AT&T format:  vpermt2w  %xmm4, %xmm3, %xmm0
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    // if k0 no mask
    if (mask_reg == DR_REG_K0) {

        enum { REDZONE = 128, X = SIZE_OF_XMM };         // X==16
        enum { SCRATCH = 4 * X /*dst, idx, src, out*/ }; // 64
        enum { SAVE = 8 /*rflags*/ + 8 * 3 /*rax,rdx,rcx*/ };
        enum { SLACK_FOR_PUSH = 8 };
        enum { FRAME = ((REDZONE + SCRATCH + SAVE + SLACK_FOR_PUSH + 15) & ~15) };

        const int OFF_DST = REDZONE + 0 * X;
        const int OFF_MEM = REDZONE + 1 * X;
        const int OFF_IDX = REDZONE + 2 * X;
        const int OFF_DATA = REDZONE + 3 * X;
        const int OFF_RFLAGS = REDZONE + 4 * X;
        const int OFF_RAX = OFF_RFLAGS + 8;
        const int OFF_RDX = OFF_RAX + 8;
        const int OFF_RCX = OFF_RDX + 8;

        opnd_t op_rax = opnd_create_reg(DR_REG_RAX);
        opnd_t op_rdx = opnd_create_reg(DR_REG_RDX);
        opnd_t op_rcx = opnd_create_reg(DR_REG_RCX);
        opnd_t op_eax = opnd_create_reg(DR_REG_EAX);
        opnd_t op_ecx = opnd_create_reg(DR_REG_ECX);
        opnd_t op_edx = opnd_create_reg(DR_REG_EDX);
        opnd_t op_rsp = opnd_create_reg(DR_REG_RSP);

        /* main logic of loop-based vpermt2w emulation */
        instr_t *LOOP_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *FROM_DATA_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *STORE_LABEL = INSTR_CREATE_label(dcontext);

        /* pushf, save xflags to avoid pollution */

        const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_idx_reg) ? 1 : 0;
        const uint src2_need_spill_flag = NEED_SPILL_XMM(src2_data_reg) ? 2 : 0;
        const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_data_reg) ? 4 : 0;

        const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

        switch (need_spill_flag) {
        case 0: {
            // allcate frame, skip the red zone, plus scratch + save + slack for push
            instr_t *i1 = INSTR_CREATE_sub(dcontext, op_rsp, OPND_CREATE_INT32(FRAME));

            // push, save xflags
            instr_t *i2 = INSTR_CREATE_pushf(dcontext);
            // save rax, rdx, rcx
            instr_t *i3 = INSTR_CREATE_mov_st(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8), op_rax);
            instr_t *i4 = INSTR_CREATE_mov_st(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8), op_rdx);
            instr_t *i5 = INSTR_CREATE_mov_st(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8), op_rcx);

            /* store the 3 xmm regs to stack */
            // vmovdqu %xmm0, (%rsp)           # [rsp+0]    data_array[0..7]
            instr_t *i6 =
                INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DATA, OPSZ_16),
                                     opnd_create_reg(dst_data_reg));
            // vmovdqu %xmm3, 16(%rsp)         # [rsp+16]   index_array[0..7]
            instr_t *i7 =
                INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_IDX, OPSZ_16),
                                     opnd_create_reg(src1_idx_reg));
            // vmovdqu %xmm4, 32(%rsp)         # [rsp+32]   mem_array[0..7]
            instr_t *i8 =
                INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_MEM, OPSZ_16),
                                     opnd_create_reg(src2_data_reg));

            /* init loop counter */
            // xor %ecx, %ecx    # i = 0
            instr_t *i9 = INSTR_CREATE_xor(dcontext, op_ecx, op_ecx);

            /* loop label */
            // .L_loop:  instr_t *LOOP_LABEL
            instr_t *i10 = LOOP_LABEL;

            /* load index = index_array[i] */
            // movzwl  16(%rsp,%rcx,2), %eax   # eax = *(uint16_t*)(rsp+16 + i*2)
            instr_t *i11 = INSTR_CREATE_movzx(dcontext, op_eax, // OP_movzx => movzxwl
                                              opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 2, OFF_IDX, OPSZ_2));
            // test $0x08, %eax                # test bit3 (0x08) for XMM
            instr_t *i12 = INSTR_CREATE_test(dcontext, op_eax, OPND_CREATE_INT32(0x08));
            // jz .Lfrom_data                  # if bit3 is 0, jump to .Lfrom_data
            instr_t *i13 = INSTR_CREATE_jcc_short(dcontext, OP_jz, opnd_create_instr(FROM_DATA_LABEL));

            /* fallthrough branch to select from mem_array */
            // and $0x07, %eax                 # eax = eax & 0x07 keep lower 3 bits [2:0] for XMM
            instr_t *i14 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x07, OPSZ_1));
            // movzwl  32(%rsp, %rax, 2), %edx   # edx = mem_array[idx]
            instr_t *i15 =
                INSTR_CREATE_movzx(dcontext, op_edx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 2, OFF_MEM, OPSZ_2));
            // jmp .Lstore
            instr_t *i16 = INSTR_CREATE_jmp_short(dcontext, opnd_create_instr(STORE_LABEL));

            /* from data label */
            // .Lfrom_data: instr_t *FROM_DATA_LABEL
            instr_t *i17 = FROM_DATA_LABEL;

            // and $0x07, %eax                 # eax = eax & 0x07 keep lower 3 bits [2:0] for XMM
            instr_t *i18 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x07, OPSZ_1));
            // movzwl  (%rsp,%rax,2), %edx     # edx = data_array[idx]
            instr_t *i19 = INSTR_CREATE_movzx(dcontext, op_edx,
                                              opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 2, OFF_DATA, OPSZ_2));
            /* store label */
            // .Lstore: instr_t *STORE_LABEL
            instr_t *i20 = STORE_LABEL;

            // movw    %dx, 48(%rsp,%rcx,2)   # *(uint16_t*)(rsp + i*2) = dx
            instr_t *i21 =
                INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 2, OFF_DST, OPSZ_2),
                                    opnd_create_reg(DR_REG_DX));
            // inc     %ecx                    # i++
            instr_t *i22 = INSTR_CREATE_inc(dcontext, op_ecx);
            // cmp     $8, %ecx                # Compare with 8 for XMM (8 elements)
            instr_t *i23 = INSTR_CREATE_cmp(dcontext, op_ecx, OPND_CREATE_INT32(0x08));
            // jne     .Loop                   # If i < 8, continue
            instr_t *i24 = INSTR_CREATE_jcc_short(dcontext, OP_jne, opnd_create_instr(LOOP_LABEL));

            // vmovdqu 48(%rsp), %xmm0
            instr_t *i25 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_reg(dst_data_reg),
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DST, OPSZ_16));

            // Restore stack and return
            // restore rax, rdx, rcx
            instr_t *i26 = INSTR_CREATE_mov_ld(dcontext, op_rax,
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8));
            instr_t *i27 = INSTR_CREATE_mov_ld(dcontext, op_rdx,
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8));
            instr_t *i28 = INSTR_CREATE_mov_ld(dcontext, op_rcx,
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8));
            instr_t *i29 = INSTR_CREATE_popf(dcontext);
            instr_t *i30 = INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), OPND_CREATE_INT32(FRAME));

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 30, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                         i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30);
#endif
            instrlist_concat_next_instr(ilist, 30, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                        i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30);

            return i1;
        } break;
        case 1: { // src1 spill
            reg_id_t spill_src1_reg = find_available_spill_xmm_avoiding(src2_data_reg, dst_data_reg, DR_REG_NULL);
            opnd_t op_spill_src1 = opnd_create_reg(spill_src1_reg);

            // allcate frame, skip the red zone, plus scratch + save + slack for push
            instr_t *i1 = INSTR_CREATE_sub(dcontext, op_rsp, OPND_CREATE_INT32(FRAME));

            // push, save xflags
            instr_t *i2 = INSTR_CREATE_pushf(dcontext);
            // save rax, rdx, rcx
            instr_t *i3 = INSTR_CREATE_mov_st(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8), op_rax);
            instr_t *i4 = INSTR_CREATE_mov_st(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8), op_rdx);
            instr_t *i5 = INSTR_CREATE_mov_st(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8), op_rcx);

            /* store the 3 xmm regs to stack */
            // spill_src1 -> tls(spill_src1)
            instr_t *i6a = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);

            // tls(src2) -> spill_src2
            instr_t *i6b = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_idx_reg)), OPSZ_16);

            // vmovdqu %xmm0, (%rsp)           # [rsp+0]    data_array[0..7]
            instr_t *i6 =
                INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DATA, OPSZ_16),
                                     opnd_create_reg(dst_data_reg));
            // vmovdqu %xmm3, 16(%rsp)         # [rsp+16]   index_array[0..7]
            instr_t *i7 = INSTR_CREATE_vmovdqu(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_IDX, OPSZ_16), op_spill_src1);
            // vmovdqu %xmm4, 32(%rsp)         # [rsp+32]   mem_array[0..7]
            instr_t *i8 =
                INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_MEM, OPSZ_16),
                                     opnd_create_reg(src2_data_reg));

            // tls(spill_src1) -> spill_src1
            instr_t *i8a = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);

            /* init loop counter */
            // xor %ecx, %ecx    # i = 0
            instr_t *i9 = INSTR_CREATE_xor(dcontext, op_ecx, op_ecx);

            /* loop label */
            // .L_loop:  instr_t *LOOP_LABEL
            instr_t *i10 = LOOP_LABEL;

            /* load index = index_array[i] */
            // movzwl  16(%rsp,%rcx,2), %eax   # eax = *(uint16_t*)(rsp+16 + i*2)
            instr_t *i11 = INSTR_CREATE_movzx(dcontext, op_eax, // OP_movzx => movzxwl
                                              opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 2, OFF_IDX, OPSZ_2));
            // test $0x08, %eax                # test bit3 (0x08) for XMM
            instr_t *i12 = INSTR_CREATE_test(dcontext, op_eax, OPND_CREATE_INT32(0x08));
            // jz .Lfrom_data                  # if bit3 is 0, jump to .Lfrom_data
            instr_t *i13 = INSTR_CREATE_jcc_short(dcontext, OP_jz, opnd_create_instr(FROM_DATA_LABEL));

            /* fallthrough branch to select from mem_array */
            // and $0x07, %eax                 # eax = eax & 0x07 keep lower 3 bits [2:0] for XMM
            instr_t *i14 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x07, OPSZ_1));
            // movzwl  32(%rsp, %rax, 2), %edx   # edx = mem_array[idx]
            instr_t *i15 =
                INSTR_CREATE_movzx(dcontext, op_edx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 2, OFF_MEM, OPSZ_2));
            // jmp .Lstore
            instr_t *i16 = INSTR_CREATE_jmp_short(dcontext, opnd_create_instr(STORE_LABEL));

            /* from data label */
            // .Lfrom_data: instr_t *FROM_DATA_LABEL
            instr_t *i17 = FROM_DATA_LABEL;

            // and $0x07, %eax                 # eax = eax & 0x07 keep lower 3 bits [2:0] for XMM
            instr_t *i18 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x07, OPSZ_1));
            // movzwl  (%rsp,%rax,2), %edx     # edx = data_array[idx]
            instr_t *i19 = INSTR_CREATE_movzx(dcontext, op_edx,
                                              opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 2, OFF_DATA, OPSZ_2));
            /* store label */
            // .Lstore: instr_t *STORE_LABEL
            instr_t *i20 = STORE_LABEL;

            // movw    %dx, 48(%rsp,%rcx,2)   # *(uint16_t*)(rsp + i*2) = dx
            instr_t *i21 =
                INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 2, OFF_DST, OPSZ_2),
                                    opnd_create_reg(DR_REG_DX));
            // inc     %ecx                    # i++
            instr_t *i22 = INSTR_CREATE_inc(dcontext, op_ecx);
            // cmp     $8, %ecx                # Compare with 8 for XMM (8 elements)
            instr_t *i23 = INSTR_CREATE_cmp(dcontext, op_ecx, OPND_CREATE_INT32(0x08));
            // jne     .Loop                   # If i < 8, continue
            instr_t *i24 = INSTR_CREATE_jcc_short(dcontext, OP_jne, opnd_create_instr(LOOP_LABEL));

            // vmovdqu 48(%rsp), %xmm0
            instr_t *i25 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_reg(dst_data_reg),
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DST, OPSZ_16));

            // Restore stack and return
            // restore rax, rdx, rcx
            instr_t *i26 = INSTR_CREATE_mov_ld(dcontext, op_rax,
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8));
            instr_t *i27 = INSTR_CREATE_mov_ld(dcontext, op_rdx,
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8));
            instr_t *i28 = INSTR_CREATE_mov_ld(dcontext, op_rcx,
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8));
            instr_t *i29 = INSTR_CREATE_popf(dcontext);
            instr_t *i30 = INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), OPND_CREATE_INT32(FRAME));

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 33, i1, i2, i3, i4, i5, i6a, i6b, i6, i7, i8, i8a, i9, i10, i11, i12,
                                         i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28,
                                         i29, i30);
#endif
            instrlist_concat_next_instr(ilist, 33, i1, i2, i3, i4, i5, i6a, i6b, i6, i7, i8, i8a, i9, i10, i11, i12,
                                        i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28,
                                        i29, i30);

            return i1;
        } break;
        case 2: { // src2 spill
            reg_id_t spill_src2_reg = find_available_spill_xmm_avoiding(src1_idx_reg, dst_data_reg, DR_REG_NULL);
            opnd_t op_spill_src2 = opnd_create_reg(spill_src2_reg);

            // allcate frame, skip the red zone, plus scratch + save + slack for push
            instr_t *i1 = INSTR_CREATE_sub(dcontext, op_rsp, OPND_CREATE_INT32(FRAME));

            // push, save xflags
            instr_t *i2 = INSTR_CREATE_pushf(dcontext);
            // save rax, rdx, rcx
            instr_t *i3 = INSTR_CREATE_mov_st(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8), op_rax);
            instr_t *i4 = INSTR_CREATE_mov_st(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8), op_rdx);
            instr_t *i5 = INSTR_CREATE_mov_st(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8), op_rcx);

            /* store the 3 xmm regs to stack */
            // spill_src2 -> tls(spill_src2)
            instr_t *i6a = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);

            // tls(src2) -> spill_src2
            instr_t *i6b = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_data_reg)), OPSZ_16);

            // vmovdqu %xmm0, (%rsp)           # [rsp+0]    data_array[0..7]
            instr_t *i6 =
                INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DATA, OPSZ_16),
                                     opnd_create_reg(dst_data_reg));
            // vmovdqu %xmm3, 16(%rsp)         # [rsp+16]   index_array[0..7]
            instr_t *i7 =
                INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_IDX, OPSZ_16),
                                     opnd_create_reg(src1_idx_reg));
            // vmovdqu %xmm4, 32(%rsp)         # [rsp+32]   mem_array[0..7]
            instr_t *i8 = INSTR_CREATE_vmovdqu(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_MEM, OPSZ_16), op_spill_src2);

            // tls(spill_src2) -> spill_src2
            instr_t *i8a = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);

            /* init loop counter */
            // xor %ecx, %ecx    # i = 0
            instr_t *i9 = INSTR_CREATE_xor(dcontext, op_ecx, op_ecx);

            /* loop label */
            // .L_loop:  instr_t *LOOP_LABEL
            instr_t *i10 = LOOP_LABEL;

            /* load index = index_array[i] */
            // movzwl  16(%rsp,%rcx,2), %eax   # eax = *(uint16_t*)(rsp+16 + i*2)
            instr_t *i11 = INSTR_CREATE_movzx(dcontext, op_eax, // OP_movzx => movzxwl
                                              opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 2, OFF_IDX, OPSZ_2));
            // test $0x08, %eax                # test bit3 (0x08) for XMM
            instr_t *i12 = INSTR_CREATE_test(dcontext, op_eax, OPND_CREATE_INT32(0x08));
            // jz .Lfrom_data                  # if bit3 is 0, jump to .Lfrom_data
            instr_t *i13 = INSTR_CREATE_jcc_short(dcontext, OP_jz, opnd_create_instr(FROM_DATA_LABEL));

            /* fallthrough branch to select from mem_array */
            // and $0x07, %eax                 # eax = eax & 0x07 keep lower 3 bits [2:0] for XMM
            instr_t *i14 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x07, OPSZ_1));
            // movzwl  32(%rsp, %rax, 2), %edx   # edx = mem_array[idx]
            instr_t *i15 =
                INSTR_CREATE_movzx(dcontext, op_edx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 2, OFF_MEM, OPSZ_2));
            // jmp .Lstore
            instr_t *i16 = INSTR_CREATE_jmp_short(dcontext, opnd_create_instr(STORE_LABEL));

            /* from data label */
            // .Lfrom_data: instr_t *FROM_DATA_LABEL
            instr_t *i17 = FROM_DATA_LABEL;

            // and $0x07, %eax                 # eax = eax & 0x07 keep lower 3 bits [2:0] for XMM
            instr_t *i18 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x07, OPSZ_1));
            // movzwl  (%rsp,%rax,2), %edx     # edx = data_array[idx]
            instr_t *i19 = INSTR_CREATE_movzx(dcontext, op_edx,
                                              opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 2, OFF_DATA, OPSZ_2));
            /* store label */
            // .Lstore: instr_t *STORE_LABEL
            instr_t *i20 = STORE_LABEL;

            // movw    %dx, 48(%rsp,%rcx,2)   # *(uint16_t*)(rsp + i*2) = dx
            instr_t *i21 =
                INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 2, OFF_DST, OPSZ_2),
                                    opnd_create_reg(DR_REG_DX));
            // inc     %ecx                    # i++
            instr_t *i22 = INSTR_CREATE_inc(dcontext, op_ecx);
            // cmp     $8, %ecx                # Compare with 8 for XMM (8 elements)
            instr_t *i23 = INSTR_CREATE_cmp(dcontext, op_ecx, OPND_CREATE_INT32(0x08));
            // jne     .Loop                   # If i < 8, continue
            instr_t *i24 = INSTR_CREATE_jcc_short(dcontext, OP_jne, opnd_create_instr(LOOP_LABEL));

            // vmovdqu 48(%rsp), %xmm0
            instr_t *i25 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_reg(dst_data_reg),
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DST, OPSZ_16));

            // Restore stack and return
            // restore rax, rdx, rcx
            instr_t *i26 = INSTR_CREATE_mov_ld(dcontext, op_rax,
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8));
            instr_t *i27 = INSTR_CREATE_mov_ld(dcontext, op_rdx,
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8));
            instr_t *i28 = INSTR_CREATE_mov_ld(dcontext, op_rcx,
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8));
            instr_t *i29 = INSTR_CREATE_popf(dcontext);
            instr_t *i30 = INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), OPND_CREATE_INT32(FRAME));

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 33, i1, i2, i3, i4, i5, i6a, i6b, i6, i7, i8, i8a, i9, i10, i11, i12,
                                         i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28,
                                         i29, i30);
#endif
            instrlist_concat_next_instr(ilist, 33, i1, i2, i3, i4, i5, i6a, i6b, i6, i7, i8, i8a, i9, i10, i11, i12,
                                        i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28,
                                        i29, i30);

            return i1;
        } break;
        case 3: { // src1 and src2 spill
            REWRITE_ERROR(STD_OUTF, "not implemented\n");
        } break;
        case 4: { // dst spill
            reg_id_t spill_dst_reg = find_available_spill_xmm_avoiding(src1_idx_reg, src2_data_reg, DR_REG_NULL);
            opnd_t op_spill_dst = opnd_create_reg(spill_dst_reg);

            // allcate frame, skip the red zone, plus scratch + save + slack for push
            instr_t *i1 = INSTR_CREATE_sub(dcontext, op_rsp, OPND_CREATE_INT32(FRAME));

            // push, save xflags
            instr_t *i2 = INSTR_CREATE_pushf(dcontext);
            // save rax, rdx, rcx
            instr_t *i3 = INSTR_CREATE_mov_st(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8), op_rax);
            instr_t *i4 = INSTR_CREATE_mov_st(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8), op_rdx);
            instr_t *i5 = INSTR_CREATE_mov_st(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8), op_rcx);

            /* store the 3 xmm regs to stack */
            // spill_dst -> tls(spill_dst)
            instr_t *i6a = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);

            // tls(dst) -> spill_dst
            instr_t *i6b = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_data_reg)), OPSZ_16);

            // vmovdqu %spill_dst, (%rsp)           # [rsp+0]    data_array[0..7]
            instr_t *i6 = INSTR_CREATE_vmovdqu(
                dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DATA, OPSZ_16), op_spill_dst);
            // vmovdqu %xmm3, 16(%rsp)         # [rsp+16]   index_array[0..7]
            instr_t *i7 =
                INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_IDX, OPSZ_16),
                                     opnd_create_reg(src1_idx_reg));
            // vmovdqu %xmm4, 32(%rsp)         # [rsp+32]   mem_array[0..7]
            instr_t *i8 =
                INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_MEM, OPSZ_16),
                                     opnd_create_reg(src2_data_reg));

            /* init loop counter */
            // xor %ecx, %ecx    # i = 0
            instr_t *i9 = INSTR_CREATE_xor(dcontext, op_ecx, op_ecx);

            /* loop label */
            // .L_loop:  instr_t *LOOP_LABEL
            instr_t *i10 = LOOP_LABEL;

            /* load index = index_array[i] */
            // movzwl  16(%rsp,%rcx,2), %eax   # eax = *(uint16_t*)(rsp+16 + i*2)
            instr_t *i11 = INSTR_CREATE_movzx(dcontext, op_eax, // OP_movzx => movzxwl
                                              opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 2, OFF_IDX, OPSZ_2));
            // test $0x08, %eax                # test bit3 (0x08) for XMM
            instr_t *i12 = INSTR_CREATE_test(dcontext, op_eax, OPND_CREATE_INT32(0x08));
            // jz .Lfrom_data                  # if bit3 is 0, jump to .Lfrom_data
            instr_t *i13 = INSTR_CREATE_jcc_short(dcontext, OP_jz, opnd_create_instr(FROM_DATA_LABEL));

            /* fallthrough branch to select from mem_array */
            // and $0x07, %eax                 # eax = eax & 0x07 keep lower 3 bits [2:0] for XMM
            instr_t *i14 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x07, OPSZ_1));
            // movzwl  32(%rsp, %rax, 2), %edx   # edx = mem_array[idx]
            instr_t *i15 =
                INSTR_CREATE_movzx(dcontext, op_edx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 2, OFF_MEM, OPSZ_2));
            // jmp .Lstore
            instr_t *i16 = INSTR_CREATE_jmp_short(dcontext, opnd_create_instr(STORE_LABEL));

            /* from data label */
            // .Lfrom_data: instr_t *FROM_DATA_LABEL
            instr_t *i17 = FROM_DATA_LABEL;

            // and $0x07, %eax                 # eax = eax & 0x07 keep lower 3 bits [2:0] for XMM
            instr_t *i18 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x07, OPSZ_1));
            // movzwl  (%rsp,%rax,2), %edx     # edx = data_array[idx]
            instr_t *i19 = INSTR_CREATE_movzx(dcontext, op_edx,
                                              opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 2, OFF_DATA, OPSZ_2));
            /* store label */
            // .Lstore: instr_t *STORE_LABEL
            instr_t *i20 = STORE_LABEL;

            // movw    %dx, 48(%rsp,%rcx,2)   # *(uint16_t*)(rsp + i*2) = dx
            instr_t *i21 =
                INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 2, OFF_DST, OPSZ_2),
                                    opnd_create_reg(DR_REG_DX));
            // inc     %ecx                    # i++
            instr_t *i22 = INSTR_CREATE_inc(dcontext, op_ecx);
            // cmp     $8, %ecx                # Compare with 8 for XMM (8 elements)
            instr_t *i23 = INSTR_CREATE_cmp(dcontext, op_ecx, OPND_CREATE_INT32(0x08));
            // jne     .Loop                   # If i < 8, continue
            instr_t *i24 = INSTR_CREATE_jcc_short(dcontext, OP_jne, opnd_create_instr(LOOP_LABEL));

            // vmovdqu 48(%rsp), spill_dst
            instr_t *i25 = INSTR_CREATE_vmovdqu(dcontext, op_spill_dst,
                                                opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DST, OPSZ_16));

            // spill_dst -> tls(dst)
            instr_t *i26a = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                   TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_data_reg)), OPSZ_16);
            // tls(spill_dst) -> spill_dst
            instr_t *i26b = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                        TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);

            // Restore stack and return
            // restore rax, rdx, rcx
            instr_t *i26 = INSTR_CREATE_mov_ld(dcontext, op_rax,
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8));
            instr_t *i27 = INSTR_CREATE_mov_ld(dcontext, op_rdx,
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8));
            instr_t *i28 = INSTR_CREATE_mov_ld(dcontext, op_rcx,
                                               opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8));
            instr_t *i29 = INSTR_CREATE_popf(dcontext);
            instr_t *i30 = INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), OPND_CREATE_INT32(FRAME));

#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 34, i1, i2, i3, i4, i5, i6a, i6b, i6, i7, i8, i9, i10, i11, i12, i13,
                                         i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i26a, i26b,
                                         i27, i28, i29, i30);
#endif
            instrlist_concat_next_instr(ilist, 34, i1, i2, i3, i4, i5, i6a, i6b, i6, i7, i8, i9, i10, i11, i12, i13,
                                        i14, i15, i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i26a, i26b,
                                        i27, i28, i29, i30);

            return i1;
        } break;
        case 5: { // src1 and dst spill
            REWRITE_ERROR(STD_OUTF, "not implemented\n");
        } break;
        case 6: { // src2 and dst spill
            REWRITE_ERROR(STD_OUTF, "not implemented\n");
        } break;
        case 7: { // src1, src2 and dst spill
            REWRITE_ERROR(STD_OUTF, "not implemented\n");
        } break;
        default: {
            REWRITE_INFO(STD_OUTF, "vpermt2w xmm and xmm pattern not support\n");
        } break;
        }
    } else { // writemask, need to know merging mode or zero mode
    }
    return NULL_INSTR;
}

instr_t *
vpermt2w_k_m16_xmm_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           opnd_t src2_data_opnd, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    // e.g. vpermt2w {%k0} %xmm3 %xmm4 -> %xmm0
    // AT&T format:  vpermt2w  %xmm4, %xmm3, %xmm0
    // server for both BASE DISP Format and REL ADDRESS Format
    // vpermt2w {%k0} %xmm3 0x20(%r12,%rax,2)[16byte] -> %xmm1
    // vpermt2w {%k0} %xmm3 <rel> 0x00007f9b617aa840[16byte] -> %xmm1
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    // if k0 no mask
    if (mask_reg == DR_REG_K0) {

        enum { REDZONE = 128, X = SIZE_OF_XMM };         // X==16
        enum { SCRATCH = 4 * X /*dst, idx, src, out*/ }; // 64
        enum { SAVE = 8 /*rflags*/ + 8 * 3 /*rax,rdx,rcx*/ };
        enum { SLACK_FOR_PUSH = 8 };
        enum { FRAME = ((REDZONE + SCRATCH + SAVE + SLACK_FOR_PUSH + 15) & ~15) };

        const int OFF_DST = REDZONE + 0 * X;
        const int OFF_MEM = REDZONE + 1 * X;
        const int OFF_IDX = REDZONE + 2 * X;
        const int OFF_DATA = REDZONE + 3 * X;
        const int OFF_RFLAGS = REDZONE + 4 * X;
        const int OFF_RAX = OFF_RFLAGS + 8;
        const int OFF_RDX = OFF_RAX + 8;
        const int OFF_RCX = OFF_RDX + 8;

        opnd_t op_rax = opnd_create_reg(DR_REG_RAX);
        opnd_t op_rdx = opnd_create_reg(DR_REG_RDX);
        opnd_t op_rcx = opnd_create_reg(DR_REG_RCX);
        opnd_t op_eax = opnd_create_reg(DR_REG_EAX);
        opnd_t op_ecx = opnd_create_reg(DR_REG_ECX);
        opnd_t op_edx = opnd_create_reg(DR_REG_EDX);
        opnd_t op_rsp = opnd_create_reg(DR_REG_RSP);

        // free xmm register
        reg_id_t xmm_spill = find_available_spill_xmm_avoiding(src1_idx_reg, dst_data_reg, DR_REG_NULL);
        opnd_t op_xmm_spill = opnd_create_reg(xmm_spill);

        /* main logic of loop-based vpermt2w emulation */
        instr_t *LOOP_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *FROM_DATA_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *STORE_LABEL = INSTR_CREATE_label(dcontext);

        /* pushf, save xflags to avoid pollution */
        // allcate frame, skip the red zone, plus scratch + save + slack for push
        instr_t *i1 = INSTR_CREATE_sub(dcontext, op_rsp, OPND_CREATE_INT32(FRAME));

        // push, save xflags
        instr_t *i2 = INSTR_CREATE_pushf(dcontext);
        // save rax, rdx, rcx
        instr_t *i3 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8), op_rax);
        instr_t *i4 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8), op_rdx);
        instr_t *i5 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8), op_rcx);

        /* store the 3 xmm regs to stack */
        // vmovdqu %xmm0, (%rsp)           # [rsp+0]    data_array[0..7]
        instr_t *i6 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DATA, OPSZ_16),
                                 opnd_create_reg(dst_data_reg));
        // vmovdqu %xmm3, 16(%rsp)         # [rsp+16]   index_array[0..7]
        instr_t *i7 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_IDX, OPSZ_16),
                                 opnd_create_reg(src1_idx_reg));
        // xmm_spill -> tls(xmm_spill)
        instr_t *i8 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, xmm_spill, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill)), OPSZ_16);
        // vmovdqu  0x20(%r12,%rax,2)[16byte] -> %xmm_spill
        instr_t *i9 = INSTR_CREATE_vmovdqu(dcontext, op_xmm_spill, src2_data_opnd);
        // vmovdqu %xmm_spill -> 32(%rsp)   # [rsp+32]   mem_array[0..7]
        instr_t *i10 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_MEM, OPSZ_16), op_xmm_spill);
        // tls(xmm_spill) -> xmm_spill
        instr_t *i11 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, xmm_spill, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(xmm_spill)), OPSZ_16);

        /* init loop counter */
        // xor %ecx, %ecx    # i = 0
        instr_t *i12 = INSTR_CREATE_xor(dcontext, op_ecx, op_ecx);

        /* loop label */
        // .L_loop:  instr_t *LOOP_LABEL
        instr_t *i13 = LOOP_LABEL;

        /* load index = index_array[i] */
        // movzwl  16(%rsp,%rcx,2), %eax   # eax = *(uint16_t*)(rsp+16 + i*2)
        instr_t *i14 = INSTR_CREATE_movzx(dcontext, op_eax, // OP_movzx => movzxwl
                                          opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 2, OFF_IDX, OPSZ_2));
        // test $0x08, %eax                # test bit3 (0x08) for XMM
        instr_t *i15 = INSTR_CREATE_test(dcontext, op_eax, OPND_CREATE_INT32(0x08));
        // jz .Lfrom_data                  # if bit3 is 0, jump to .Lfrom_data
        instr_t *i16 = INSTR_CREATE_jcc_short(dcontext, OP_jz, opnd_create_instr(FROM_DATA_LABEL));

        /* fallthrough branch to select from mem_array */
        // and $0x07, %eax                 # eax = eax & 0x07 keep lower 3 bits [2:0] for XMM
        instr_t *i17 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x07, OPSZ_1));
        // movzwl  32(%rsp, %rax, 2), %edx   # edx = mem_array[idx]
        instr_t *i18 =
            INSTR_CREATE_movzx(dcontext, op_edx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 2, OFF_MEM, OPSZ_2));
        // jmp .Lstore
        instr_t *i19 = INSTR_CREATE_jmp_short(dcontext, opnd_create_instr(STORE_LABEL));

        /* from data label */
        // .Lfrom_data: instr_t *FROM_DATA_LABEL
        instr_t *i20 = FROM_DATA_LABEL;

        // and $0x07, %eax                 # eax = eax & 0x07 keep lower 3 bits [2:0] for XMM
        instr_t *i21 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x07, OPSZ_1));
        // movzwl  (%rsp,%rax,2), %edx     # edx = data_array[idx]
        instr_t *i22 =
            INSTR_CREATE_movzx(dcontext, op_edx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 2, OFF_DATA, OPSZ_2));
        /* store label */
        // .Lstore: instr_t *STORE_LABEL
        instr_t *i23 = STORE_LABEL;

        // movw    %dx, 48(%rsp,%rcx,2)   # *(uint16_t*)(rsp + i*2) = dx
        instr_t *i24 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 2, OFF_DST, OPSZ_2),
                                           opnd_create_reg(DR_REG_DX));
        // inc     %ecx                    # i++
        instr_t *i25 = INSTR_CREATE_inc(dcontext, op_ecx);
        // cmp     $8, %ecx                # Compare with 8 for XMM (8 elements)
        instr_t *i26 = INSTR_CREATE_cmp(dcontext, op_ecx, OPND_CREATE_INT32(0x08));
        // jne     .Loop                   # If i < 8, continue
        instr_t *i27 = INSTR_CREATE_jcc_short(dcontext, OP_jne, opnd_create_instr(LOOP_LABEL));

        // vmovdqu 48(%rsp), %xmm0
        instr_t *i28 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_reg(dst_data_reg),
                                            opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DST, OPSZ_16));

        // Restore stack and return
        // restore rax, rdx, rcx
        instr_t *i29 =
            INSTR_CREATE_mov_ld(dcontext, op_rax, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8));
        instr_t *i30 =
            INSTR_CREATE_mov_ld(dcontext, op_rdx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8));
        instr_t *i31 =
            INSTR_CREATE_mov_ld(dcontext, op_rcx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8));
        instr_t *i32 = INSTR_CREATE_popf(dcontext);
        instr_t *i33 = INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), OPND_CREATE_INT32(FRAME));

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 33, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32, i33);
#endif
        instrlist_concat_next_instr(ilist, 33, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32,
                                    i33);

        return i1;
    } else { // writemask, need to know merging mode or zero mode
    }
    return NULL_INSTR;
}

instr_t *
vpermt2w_k_zmm_zmm_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           reg_id_t src2_data_reg, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    // e.g. vpermt2w {%k0} %zmm3 %zmm4 -> %zmm0
    // AT&T format:  vpermt2w  %zmm4, %zmm3, %zmm0
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    // if k0 no mask
    if (mask_reg == DR_REG_K0) {

        enum { REDZONE = 128, Z = SIZE_OF_ZMM };         // Z==64
        enum { SCRATCH = 4 * Z /*dst, idx, src, out*/ }; // 256
        enum { SAVE = 8 /*rflags*/ + 8 * 3 /*rax,rdx,rcx*/ };
        enum { SLACK_FOR_PUSH = 8 };
        enum { FRAME = ((REDZONE + SCRATCH + SAVE + SLACK_FOR_PUSH + 15) & ~15) };

        const int OFF_DST = REDZONE + 0 * Z;
        const int OFF_SRC = REDZONE + 1 * Z;
        const int OFF_IDX = REDZONE + 2 * Z;
        const int OFF_DATA = REDZONE + 3 * Z;
        const int OFF_RFLAGS = REDZONE + 4 * Z;
        const int OFF_RAX = OFF_RFLAGS + 8;
        const int OFF_RDX = OFF_RAX + 8;
        const int OFF_RCX = OFF_RDX + 8;

        opnd_t op_rax = opnd_create_reg(DR_REG_RAX);
        opnd_t op_rdx = opnd_create_reg(DR_REG_RDX);
        opnd_t op_rcx = opnd_create_reg(DR_REG_RCX);
        opnd_t op_eax = opnd_create_reg(DR_REG_EAX);
        opnd_t op_ecx = opnd_create_reg(DR_REG_ECX);
        opnd_t op_edx = opnd_create_reg(DR_REG_EDX);
        opnd_t op_rsp = opnd_create_reg(DR_REG_RSP);

        // free ymm registers for ZMM operations
        reg_id_t ymm_spill1 = find_available_spill_ymm_avoiding_variadic(
            3, ZMM_TO_YMM(src1_idx_reg), ZMM_TO_YMM(src2_data_reg), ZMM_TO_YMM(dst_data_reg));
        reg_id_t ymm_spill2 = find_available_spill_ymm_avoiding_variadic(
            4, ZMM_TO_YMM(src1_idx_reg), ZMM_TO_YMM(src2_data_reg), ZMM_TO_YMM(dst_data_reg), ymm_spill1);
        reg_id_t ymm_spill3 = find_available_spill_ymm_avoiding_variadic(
            5, ZMM_TO_YMM(src1_idx_reg), ZMM_TO_YMM(src2_data_reg), ZMM_TO_YMM(dst_data_reg), ymm_spill1, ymm_spill2);

        /* main logic of loop-based vpermt2w emulation */
        instr_t *LOOP_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *FROM_DATA_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *STORE_LABEL = INSTR_CREATE_label(dcontext);

        /* pushf, save xflags to avoid pollution */
        // allocate frame, skip the red zone, plus scratch + save + slack for push
        instr_t *i1 = INSTR_CREATE_sub(dcontext, op_rsp, OPND_CREATE_INT32(FRAME));

        // push, save xflags
        instr_t *i2 = INSTR_CREATE_pushf(dcontext);
        // save rax, rdx, rcx
        instr_t *i3 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8), op_rax);
        instr_t *i4 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8), op_rdx);
        instr_t *i5 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8), op_rcx);

        // save spill registers
        instr_t *i6 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_spill1, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill1)), OPSZ_32);
        instr_t *i7 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_spill2, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill2)), OPSZ_32);
        instr_t *i8 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_spill3, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill3)), OPSZ_32);

        /* store the 3 zmm regs to stack using YMM operations */
        // Store dst_data_reg (lower half)
        instr_t *i9 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_spill1,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_data_reg)), OPSZ_32);
        instr_t *i10 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DATA, OPSZ_32),
                                 opnd_create_reg(ymm_spill1));
        // Store dst_data_reg (upper half)
        instr_t *i11 = RESTORE_SIMD_FROM_SIZED_TLS(
            dcontext, ymm_spill1, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_data_reg)) + SIZE_OF_YMM, OPSZ_32);
        instr_t *i12 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DATA + SIZE_OF_YMM, OPSZ_32),
            opnd_create_reg(ymm_spill1));

        // Store src1_idx_reg (lower half)
        instr_t *i13 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_spill1,
                                                   TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_idx_reg)), OPSZ_32);
        instr_t *i14 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_IDX, OPSZ_32), opnd_create_reg(ymm_spill1));
        // Store src1_idx_reg (upper half)
        instr_t *i15 = RESTORE_SIMD_FROM_SIZED_TLS(
            dcontext, ymm_spill1, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_idx_reg)) + SIZE_OF_YMM, OPSZ_32);
        instr_t *i16 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_IDX + SIZE_OF_YMM, OPSZ_32),
            opnd_create_reg(ymm_spill1));

        // Store src2_data_reg (lower half)
        instr_t *i17 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_spill1,
                                                   TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_data_reg)), OPSZ_32);
        instr_t *i18 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_SRC, OPSZ_32), opnd_create_reg(ymm_spill1));
        // Store src2_data_reg (upper half)
        instr_t *i19 = RESTORE_SIMD_FROM_SIZED_TLS(
            dcontext, ymm_spill1, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src2_data_reg)) + SIZE_OF_YMM, OPSZ_32);
        instr_t *i20 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_SRC + SIZE_OF_YMM, OPSZ_32),
            opnd_create_reg(ymm_spill1));

        /* init loop counter */
        // xor %ecx, %ecx    # i = 0
        instr_t *i21 = INSTR_CREATE_xor(dcontext, op_ecx, op_ecx);

        /* loop label */
        // .L_loop:  instr_t *LOOP_LABEL
        instr_t *i22 = LOOP_LABEL;

        /* load index = index_array[i] */
        // movzwl  OFF_IDX(%rsp,%rcx,2), %eax   # eax = *(uint16_t*)(rsp+OFF_IDX + i*2)
        instr_t *i23 =
            INSTR_CREATE_movzx(dcontext, op_eax, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 2, OFF_IDX, OPSZ_2));
        // test $0x20, %eax                # test bit5 (0x20) for ZMM
        instr_t *i24 = INSTR_CREATE_test(dcontext, op_eax, OPND_CREATE_INT32(0x20));
        // jz .Lfrom_data                  # if bit5 is 0, jump to .Lfrom_data
        instr_t *i25 = INSTR_CREATE_jcc_short(dcontext, OP_jz, opnd_create_instr(FROM_DATA_LABEL));

        /* fallthrough branch to select from src_array */
        // and $0x1f, %eax                 # eax = eax & 0x1f keep lower 5 bits [4:0] for ZMM
        instr_t *i26 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x1f, OPSZ_1));
        // movzwl  OFF_SRC(%rsp, %rax, 2), %edx   # edx = src_array[idx]
        instr_t *i27 =
            INSTR_CREATE_movzx(dcontext, op_edx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 2, OFF_SRC, OPSZ_2));
        // jmp .Lstore
        instr_t *i28 = INSTR_CREATE_jmp_short(dcontext, opnd_create_instr(STORE_LABEL));

        /* from data label */
        // .Lfrom_data: instr_t *FROM_DATA_LABEL
        instr_t *i29 = FROM_DATA_LABEL;

        // and $0x1f, %eax                 # eax = eax & 0x1f keep lower 5 bits [4:0] for ZMM
        instr_t *i30 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x1f, OPSZ_1));
        // movzwl  OFF_DATA(%rsp,%rax,2), %edx     # edx = data_array[idx]
        instr_t *i31 =
            INSTR_CREATE_movzx(dcontext, op_edx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 2, OFF_DATA, OPSZ_2));
        /* store label */
        // .Lstore: instr_t *STORE_LABEL
        instr_t *i32 = STORE_LABEL;

        // movw    %dx, OFF_DST(%rsp,%rcx,2)   # *(uint16_t*)(rsp + OFF_DST + i*2) = dx
        instr_t *i33 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 2, OFF_DST, OPSZ_2),
                                           opnd_create_reg(DR_REG_DX));
        // inc     %ecx                    # i++
        instr_t *i34 = INSTR_CREATE_inc(dcontext, op_ecx);
        // cmp     $32, %ecx                # Compare with 32 for ZMM (32 elements)
        instr_t *i35 = INSTR_CREATE_cmp(dcontext, op_ecx, OPND_CREATE_INT32(0x20));
        // jne     .Loop                   # If i < 32, continue
        instr_t *i36 = INSTR_CREATE_jcc_short(dcontext, OP_jne, opnd_create_instr(LOOP_LABEL));

        // Load result back to zmm register (lower half)
        instr_t *i37 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_reg(ymm_spill1),
                                            opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DST, OPSZ_32));
        instr_t *i38 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_spill1, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_data_reg)), OPSZ_32);
        // Load result back to zmm register (upper half)
        instr_t *i39 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_reg(ymm_spill1),
                                 opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DST + SIZE_OF_YMM, OPSZ_32));
        instr_t *i40 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_spill1,
                                              TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_data_reg)) + SIZE_OF_YMM, OPSZ_32);

        // restore spill registers
        instr_t *i41 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_spill1, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill1)), OPSZ_32);
        instr_t *i42 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_spill2, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill2)), OPSZ_32);
        instr_t *i43 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_spill3, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill3)), OPSZ_32);

        // Restore stack and return
        // restore rax, rdx, rcx
        instr_t *i44 =
            INSTR_CREATE_mov_ld(dcontext, op_rax, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8));
        instr_t *i45 =
            INSTR_CREATE_mov_ld(dcontext, op_rdx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8));
        instr_t *i46 =
            INSTR_CREATE_mov_ld(dcontext, op_rcx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8));
        instr_t *i47 = INSTR_CREATE_popf(dcontext);
        instr_t *i48 = INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), OPND_CREATE_INT32(FRAME));

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 48, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32, i33, i34, i35, i36, i37, i38, i39, i40, i41, i42, i43, i44, i45, i46, i47,
                                     i48);
#endif
        instrlist_concat_next_instr(ilist, 48, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32, i33,
                                    i34, i35, i36, i37, i38, i39, i40, i41, i42, i43, i44, i45, i46, i47, i48);

        return i1;
    } else { // writemask, need to know merging mode or zero mode
    }
    return NULL_INSTR;
}

instr_t *
vpermt2w_k_m64_zmm_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           opnd_t src2_data_opnd, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    // e.g. vpermt2w {%k0} %zmm3 0x20(%r12,%rax,2)[64byte] -> %zmm0
    // vpermt2w {%k0} %zmm3 <rel> 0x00007f9b617aa840[64byte] -> %zmm0
    // server for both BASE DISP Format and REL ADDRESS Format
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    // if k0 no mask
    if (mask_reg == DR_REG_K0) {

        enum { REDZONE = 128, Z = SIZE_OF_ZMM };         // Z==64
        enum { SCRATCH = 4 * Z /*dst, idx, mem, out*/ }; // 256
        enum { SAVE = 8 /*rflags*/ + 8 * 3 /*rax,rdx,rcx*/ };
        enum { SLACK_FOR_PUSH = 8 };
        enum { FRAME = ((REDZONE + SCRATCH + SAVE + SLACK_FOR_PUSH + 15) & ~15) };

        const int OFF_DST = REDZONE + 0 * Z;
        const int OFF_MEM = REDZONE + 1 * Z;
        const int OFF_IDX = REDZONE + 2 * Z;
        const int OFF_DATA = REDZONE + 3 * Z;
        const int OFF_RFLAGS = REDZONE + 4 * Z;
        const int OFF_RAX = OFF_RFLAGS + 8;
        const int OFF_RDX = OFF_RAX + 8;
        const int OFF_RCX = OFF_RDX + 8;

        opnd_t op_rax = opnd_create_reg(DR_REG_RAX);
        opnd_t op_rdx = opnd_create_reg(DR_REG_RDX);
        opnd_t op_rcx = opnd_create_reg(DR_REG_RCX);
        opnd_t op_eax = opnd_create_reg(DR_REG_EAX);
        opnd_t op_ecx = opnd_create_reg(DR_REG_ECX);
        opnd_t op_edx = opnd_create_reg(DR_REG_EDX);
        opnd_t op_rsp = opnd_create_reg(DR_REG_RSP);

        // free ymm registers for ZMM operations
        reg_id_t ymm_spill1 =
            find_available_spill_ymm_avoiding_variadic(2, ZMM_TO_YMM(src1_idx_reg), ZMM_TO_YMM(dst_data_reg));
        reg_id_t ymm_spill2 = find_available_spill_ymm_avoiding_variadic(3, ZMM_TO_YMM(src1_idx_reg),
                                                                         ZMM_TO_YMM(dst_data_reg), ymm_spill1);
        reg_id_t ymm_spill3 = find_available_spill_ymm_avoiding_variadic(
            4, ZMM_TO_YMM(src1_idx_reg), ZMM_TO_YMM(dst_data_reg), ymm_spill1, ymm_spill2);

        /* main logic of loop-based vpermt2w emulation */
        instr_t *LOOP_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *FROM_DATA_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *STORE_LABEL = INSTR_CREATE_label(dcontext);

        /* pushf, save xflags to avoid pollution */
        // allocate frame, skip the red zone, plus scratch + save + slack for push
        instr_t *i1 = INSTR_CREATE_sub(dcontext, op_rsp, OPND_CREATE_INT32(FRAME));

        // push, save xflags
        instr_t *i2 = INSTR_CREATE_pushf(dcontext);
        // save rax, rdx, rcx
        instr_t *i3 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8), op_rax);
        instr_t *i4 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8), op_rdx);
        instr_t *i5 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8), op_rcx);

        // save spill registers
        instr_t *i6 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_spill1, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill1)), OPSZ_32);
        instr_t *i7 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_spill2, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill2)), OPSZ_32);
        instr_t *i8 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_spill3, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill3)), OPSZ_32);

        /* store the zmm regs to stack using YMM operations */
        // Store dst_data_reg (lower half)
        instr_t *i9 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_spill1,
                                                  TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_data_reg)), OPSZ_32);
        instr_t *i10 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DATA, OPSZ_32),
                                 opnd_create_reg(ymm_spill1));
        // Store dst_data_reg (upper half)
        instr_t *i11 = RESTORE_SIMD_FROM_SIZED_TLS(
            dcontext, ymm_spill1, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_data_reg)) + SIZE_OF_YMM, OPSZ_32);
        instr_t *i12 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DATA + SIZE_OF_YMM, OPSZ_32),
            opnd_create_reg(ymm_spill1));

        // Store src1_idx_reg (lower half)
        instr_t *i13 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_spill1,
                                                   TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_idx_reg)), OPSZ_32);
        instr_t *i14 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_IDX, OPSZ_32), opnd_create_reg(ymm_spill1));
        // Store src1_idx_reg (upper half)
        instr_t *i15 = RESTORE_SIMD_FROM_SIZED_TLS(
            dcontext, ymm_spill1, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(src1_idx_reg)) + SIZE_OF_YMM, OPSZ_32);
        instr_t *i16 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_IDX + SIZE_OF_YMM, OPSZ_32),
            opnd_create_reg(ymm_spill1));

        // Load memory data and store to stack (lower half)
        instr_t *i17 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_reg(ymm_spill1),
            opnd_create_base_disp(opnd_get_base(src2_data_opnd), opnd_get_index(src2_data_opnd),
                                  opnd_get_scale(src2_data_opnd), opnd_get_disp(src2_data_opnd), OPSZ_32));
        instr_t *i18 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_MEM, OPSZ_32), opnd_create_reg(ymm_spill1));
        // Load memory data and store to stack (upper half)
        instr_t *i19 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_reg(ymm_spill1),
                                 opnd_create_base_disp(opnd_get_base(src2_data_opnd), opnd_get_index(src2_data_opnd),
                                                       opnd_get_scale(src2_data_opnd),
                                                       opnd_get_disp(src2_data_opnd) + SIZE_OF_YMM, OPSZ_32));
        instr_t *i20 = INSTR_CREATE_vmovdqu(
            dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_MEM + SIZE_OF_YMM, OPSZ_32),
            opnd_create_reg(ymm_spill1));

        /* init loop counter */
        // xor %ecx, %ecx    # i = 0
        instr_t *i21 = INSTR_CREATE_xor(dcontext, op_ecx, op_ecx);

        /* loop label */
        // .L_loop:  instr_t *LOOP_LABEL
        instr_t *i22 = LOOP_LABEL;

        /* load index = index_array[i] */
        // movzwl  OFF_IDX(%rsp,%rcx,2), %eax   # eax = *(uint16_t*)(rsp+OFF_IDX + i*2)
        instr_t *i23 =
            INSTR_CREATE_movzx(dcontext, op_eax, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 2, OFF_IDX, OPSZ_2));
        // test $0x20, %eax                # test bit5 (0x20) for ZMM
        instr_t *i24 = INSTR_CREATE_test(dcontext, op_eax, OPND_CREATE_INT32(0x20));
        // jz .Lfrom_data                  # if bit5 is 0, jump to .Lfrom_data
        instr_t *i25 = INSTR_CREATE_jcc_short(dcontext, OP_jz, opnd_create_instr(FROM_DATA_LABEL));

        /* fallthrough branch to select from mem_array */
        // and $0x1f, %eax                 # eax = eax & 0x1f keep lower 5 bits [4:0] for ZMM
        instr_t *i26 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x1f, OPSZ_1));
        // movzwl  OFF_MEM(%rsp, %rax, 2), %edx   # edx = mem_array[idx]
        instr_t *i27 =
            INSTR_CREATE_movzx(dcontext, op_edx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 2, OFF_MEM, OPSZ_2));
        // jmp .Lstore
        instr_t *i28 = INSTR_CREATE_jmp_short(dcontext, opnd_create_instr(STORE_LABEL));

        /* from data label */
        // .Lfrom_data: instr_t *FROM_DATA_LABEL
        instr_t *i29 = FROM_DATA_LABEL;

        // and $0x1f, %eax                 # eax = eax & 0x1f keep lower 5 bits [4:0] for ZMM
        instr_t *i30 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(0x1f, OPSZ_1));
        // movzwl  OFF_DATA(%rsp,%rax,2), %edx     # edx = data_array[idx]
        instr_t *i31 =
            INSTR_CREATE_movzx(dcontext, op_edx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 2, OFF_DATA, OPSZ_2));
        /* store label */
        // .Lstore: instr_t *STORE_LABEL
        instr_t *i32 = STORE_LABEL;

        // movw    %dx, OFF_DST(%rsp,%rcx,2)   # *(uint16_t*)(rsp + OFF_DST + i*2) = dx
        instr_t *i33 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 2, OFF_DST, OPSZ_2),
                                           opnd_create_reg(DR_REG_DX));
        // inc     %ecx                    # i++
        instr_t *i34 = INSTR_CREATE_inc(dcontext, op_ecx);
        // cmp     $32, %ecx                # Compare with 32 for ZMM (32 elements)
        instr_t *i35 = INSTR_CREATE_cmp(dcontext, op_ecx, OPND_CREATE_INT32(0x20));
        // jne     .Loop                   # If i < 32, continue
        instr_t *i36 = INSTR_CREATE_jcc_short(dcontext, OP_jne, opnd_create_instr(LOOP_LABEL));

        // Load result back to zmm register (lower half)
        instr_t *i37 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_reg(ymm_spill1),
                                            opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DST, OPSZ_32));
        instr_t *i38 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_spill1, TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_data_reg)), OPSZ_32);
        // Load result back to zmm register (upper half)
        instr_t *i39 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_reg(ymm_spill1),
                                 opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DST + SIZE_OF_YMM, OPSZ_32));
        instr_t *i40 = SAVE_SIMD_TO_SIZED_TLS(dcontext, ymm_spill1,
                                              TLS_ZMM_idx_SLOT(TO_ZMM_REG_INDEX(dst_data_reg)) + SIZE_OF_YMM, OPSZ_32);

        // restore spill registers
        instr_t *i41 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_spill1, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill1)), OPSZ_32);
        instr_t *i42 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_spill2, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill2)), OPSZ_32);
        instr_t *i43 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, ymm_spill3, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(ymm_spill3)), OPSZ_32);

        // Restore stack and return
        // restore rax, rdx, rcx
        instr_t *i44 =
            INSTR_CREATE_mov_ld(dcontext, op_rax, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8));
        instr_t *i45 =
            INSTR_CREATE_mov_ld(dcontext, op_rdx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8));
        instr_t *i46 =
            INSTR_CREATE_mov_ld(dcontext, op_rcx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8));
        instr_t *i47 = INSTR_CREATE_popf(dcontext);
        instr_t *i48 = INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), OPND_CREATE_INT32(FRAME));

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 48, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32, i33, i34, i35, i36, i37, i38, i39, i40, i41, i42, i43, i44, i45, i46, i47,
                                     i48);
#endif
        instrlist_concat_next_instr(ilist, 48, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32, i33,
                                    i34, i35, i36, i37, i38, i39, i40, i41, i42, i43, i44, i45, i46, i47, i48);

        return i1;
    } else { // writemask, need to know merging mode or zero mode
    }
    return NULL_INSTR;
}

/**
 * @brief 649 vpermt2w rewrite function
 */
instr_t *
rw_func_vpermt2w(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vpermt2w {%k0} %ymm3 %ymm4 -> %ymm0
    // EVEX.256.66.0F38.W1 7D /r VPERMT2W ymm1 {k1}{z}, ymm2, ymm3/m256, intel syntax
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src1_idx_opnd = instr_get_src(instr, 1);  // ymm3, src1_idx is vector reg, which is certain
    opnd_t src2_data_opnd = instr_get_src(instr, 2); // ymm4, src2_data, src can be vector reg or memory
    opnd_t dst_data_opnd = instr_get_dst(instr, 0);  // ymm0, dst_data

#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpermt2w", true, true, true, true);
#endif
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t dst_data_reg = opnd_get_reg(dst_data_opnd);
    reg_id_t src1_idx_reg = opnd_get_reg(src1_idx_opnd);

    switch (src2_data_opnd.kind) {
    case REG_kind: {
        reg_id_t src2_data_reg = opnd_get_reg(src2_data_opnd);
        if (IS_YMM_REG(dst_data_reg)) {
            return vpermt2w_k_ymm_ymm_ymm_gen(dcontext, ilist, instr, src1_idx_reg, src2_data_reg, dst_data_reg,
                                              mask_reg);
        }
        if (IS_XMM_REG(dst_data_reg)) {
            return vpermt2w_k_xmm_xmm_xmm_gen(dcontext, ilist, instr, src1_idx_reg, src2_data_reg, dst_data_reg,
                                              mask_reg);
        }
        if (IS_ZMM_REG(dst_data_reg)) {
            return vpermt2w_k_zmm_zmm_zmm_gen(dcontext, ilist, instr, src1_idx_reg, src2_data_reg, dst_data_reg,
                                              mask_reg);
        }
        REWRITE_ERROR(STD_ERRF, "vpermt2w pattern not support, dst_data_reg matches no simd reg");
    } break;
    case BASE_DISP_kind: {
        if (IS_YMM_REG(dst_data_reg)) {
            return vpermt2w_k_m32_ymm_ymm_gen(dcontext, ilist, instr, src1_idx_reg, src2_data_opnd, dst_data_reg,
                                              mask_reg);
        }
        if (IS_XMM_REG(dst_data_reg)) {
            return vpermt2w_k_m16_xmm_xmm_gen(dcontext, ilist, instr, src1_idx_reg, src2_data_opnd, dst_data_reg,
                                              mask_reg);
        }
        if (IS_ZMM_REG(dst_data_reg)) {
            return vpermt2w_k_m64_zmm_zmm_gen(dcontext, ilist, instr, src1_idx_reg, src2_data_opnd, dst_data_reg,
                                              mask_reg);
        }
        REWRITE_ERROR(STD_ERRF, "vpermt2w pattern not support, dst_data_reg matches no simd reg");
    } break;
    case REL_ADDR_kind: {
        if (IS_YMM_REG(dst_data_reg)) {
            return vpermt2w_k_m32_ymm_ymm_gen(dcontext, ilist, instr, src1_idx_reg, src2_data_opnd, dst_data_reg,
                                              mask_reg);
        }
        if (IS_XMM_REG(dst_data_reg)) {
            return vpermt2w_k_m16_xmm_xmm_gen(dcontext, ilist, instr, src1_idx_reg, src2_data_opnd, dst_data_reg,
                                              mask_reg);
        }
        if (IS_ZMM_REG(dst_data_reg)) {
            return vpermt2w_k_m64_zmm_zmm_gen(dcontext, ilist, instr, src1_idx_reg, src2_data_opnd, dst_data_reg,
                                              mask_reg);
        }
        REWRITE_ERROR(STD_ERRF, "vpermt2w pattern not support, dst_data_reg matches no simd reg");
    } break;
    default: {
        REWRITE_ERROR(STD_ERRF, "vpermt2w pattern not support");
        return NULL_INSTR;
    }
    }
    REWRITE_ERROR(STD_ERRF, "vpermt2w pattern not support");
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vpermt2d
 * ============================================= */

instr_t *
vpermt2d_k_xmm_xmm_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           reg_id_t src2_data_reg, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpermt2d_k_m16_xmm_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           opnd_t src2_data_opnd, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpermt2d_k_ymm_ymm_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           reg_id_t src2_data_reg, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    /* vpermt2d {%k0} src1_idx_reg, src2_data_reg -> dst_data_reg */
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    /* Only implement no-mask (k0) case for now */
    if (mask_reg == DR_REG_K0) {

        enum { REDZONE = 128, Y = SIZE_OF_YMM };         // Y==32
        enum { SCRATCH = 4 * Y /*dst, idx, src, out*/ }; // 128
        enum { SAVE = 8 /*rflags*/ + 8 * 4 /*rax,rdx,rcx,r11*/ };
        enum { SLACK_FOR_PUSH = 8 };
        enum { FRAME = ((REDZONE + SCRATCH + SAVE + SLACK_FOR_PUSH + 15) & ~15) };

        const int OFF_DST = REDZONE + 0 * Y;
        const int OFF_MEM = REDZONE + 1 * Y;
        const int OFF_IDX = REDZONE + 2 * Y;
        const int OFF_DATA = REDZONE + 3 * Y;
        const int OFF_RFLAGS = REDZONE + 4 * Y;
        const int OFF_RAX = OFF_RFLAGS + 8;
        const int OFF_RDX = OFF_RAX + 8;
        const int OFF_RCX = OFF_RDX + 8;

        opnd_t op_rax = opnd_create_reg(DR_REG_RAX);
        opnd_t op_rdx = opnd_create_reg(DR_REG_RDX);
        opnd_t op_rcx = opnd_create_reg(DR_REG_RCX);
        opnd_t op_eax = opnd_create_reg(DR_REG_EAX);
        opnd_t op_edx = opnd_create_reg(DR_REG_EDX);
        opnd_t op_ecx = opnd_create_reg(DR_REG_ECX);

        /* Labels for control flow */
        instr_t *LOOP_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *FROM_DATA_LABEL = INSTR_CREATE_label(dcontext);
        instr_t *STORE_LABEL = INSTR_CREATE_label(dcontext);

        /* Reserve 128 bytes: index + tbl1 + tbl2 + result (4YMM). */
        instr_t *i1 = INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), OPND_CREATE_INT32(FRAME));

        // pushf, save xflags
        instr_t *i2 = INSTR_CREATE_pushf(dcontext);

        // save rax, rdx, rcx
        instr_t *i3 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8), op_rdx);
        instr_t *i4 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8), op_rax);
        instr_t *i5 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8), op_rcx);

        /* Spill YMM regs: data_array <- dst, index_array <- src1, mem_array <- src2 */
        // vmovdqu %ymm0, OFF_DATA(%rsp)        # [rsp+OFF_DATA]  data_array[0..3]
        instr_t *i6 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DATA, OPSZ_32),
                                 opnd_create_reg(dst_data_reg));
        // vmovdqu %ymm3, OFF_IDX(%rsp)         # [rsp+OFF_IDX]   index_array[0..3]
        instr_t *i7 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_IDX, OPSZ_32),
                                 opnd_create_reg(src1_idx_reg));
        // vmovdqu %ymm4, OFF_MEM(%rsp)         # [rsp+OFF_MEM]   mem_array[0..3]
        instr_t *i8 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_MEM, OPSZ_32),
                                 opnd_create_reg(src2_data_reg));

        /* Initialize loop counter i = 0 */
        instr_t *i9 = INSTR_CREATE_xor(dcontext, op_ecx, op_ecx);

        /* Begin loop */
        /* .L_loop: */
        instr_t *i10 = LOOP_LABEL;

        /* Load index = index_array[i] */
        instr_t *i11 =
            INSTR_CREATE_mov_ld(dcontext, op_eax, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 4, OFF_IDX, OPSZ_4));
        /* test bit3 (0x8) */
        instr_t *i12 = INSTR_CREATE_test(dcontext, op_eax, OPND_CREATE_INT32(0x8));
        /* if zero, jump to .FromData */
        instr_t *i13 = INSTR_CREATE_jcc_short(dcontext, OP_jz, opnd_create_instr(FROM_DATA_LABEL));

        /* From mem_array path */
        /* idx &= 7 */
        instr_t *i14 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(7, OPSZ_4));
        /* edx = mem_array[idx] */
        instr_t *i15 =
            INSTR_CREATE_mov_ld(dcontext, op_edx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 4, OFF_MEM, OPSZ_4));
        /* jump to store */
        instr_t *i16 = INSTR_CREATE_jmp_short(dcontext, opnd_create_instr(STORE_LABEL));

        /* .FromData: */
        instr_t *i17 = FROM_DATA_LABEL;
        /* idx &= 7 */
        instr_t *i18 = INSTR_CREATE_and(dcontext, op_eax, opnd_create_immed_int(7, OPSZ_4));
        /* edx = data_array[idx] */
        instr_t *i19 =
            INSTR_CREATE_mov_ld(dcontext, op_edx, opnd_create_base_disp(DR_REG_RSP, DR_REG_RAX, 4, OFF_DATA, OPSZ_4));

        /* .Store: */
        instr_t *i20 = STORE_LABEL;
        /* result[i] = edx */
        instr_t *i21 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_RCX, 4, OFF_DST, OPSZ_4), op_edx);
        /* i++ */
        instr_t *i22 = INSTR_CREATE_inc(dcontext, op_ecx);
        /* if i < 8, loop */
        instr_t *i23 = INSTR_CREATE_cmp(dcontext, op_ecx, OPND_CREATE_INT32(8));
        instr_t *i24 = INSTR_CREATE_jcc_short(dcontext, OP_jne, opnd_create_instr(LOOP_LABEL));

        /* Load back result into dst_data_reg */
        instr_t *i25 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_reg(dst_data_reg),
                                            opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_DST, OPSZ_32));

        /* Restore stack and regs */
        instr_t *i26 =
            INSTR_CREATE_mov_ld(dcontext, op_rcx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RCX, OPSZ_8));
        instr_t *i27 =
            INSTR_CREATE_mov_ld(dcontext, op_rdx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RDX, OPSZ_8));
        instr_t *i28 =
            INSTR_CREATE_mov_ld(dcontext, op_rax, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, OFF_RAX, OPSZ_8));
        instr_t *i29 = INSTR_CREATE_popf(dcontext);
        instr_t *i30 = INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), OPND_CREATE_INT32(FRAME));

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 30, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30);
#endif
        instrlist_concat_next_instr(ilist, 30, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30);

        return i1;
    } else {
    }
    return NULL_INSTR;
}
instr_t *
vpermt2d_k_m32_ymm_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           opnd_t src2_data_opnd, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpermt2d_k_zmm_zmm_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           reg_id_t src2_data_reg, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpermt2d_k_m64_zmm_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_idx_reg,
                           opnd_t src2_data_opnd, reg_id_t dst_data_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
rw_func_vpermt2d(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vpermt2d {%k0} %ymm8 %ymm3 -> %ymm0
    // EVEX.256.66.0F38.W0 7E /r VPERMT2D ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src1_idx_opnd = instr_get_src(instr, 1);  // ymm3, src1_idx is vector reg, which is certain
    opnd_t src2_data_opnd = instr_get_src(instr, 2); // ymm4, src2_data, src can be vector reg or memory
    opnd_t dst_data_opnd = instr_get_dst(instr, 0);  // ymm0, dst_data
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpermt2d", true, true, true, true);
#endif
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t dst_data_reg = opnd_get_reg(dst_data_opnd);
    reg_id_t src1_idx_reg = opnd_get_reg(src1_idx_opnd);
    switch (src2_data_opnd.kind) {
    case REG_kind: {
        reg_id_t src2_data_reg = opnd_get_reg(src2_data_opnd);
        if (IS_YMM_REG(dst_data_reg)) {
            return vpermt2d_k_ymm_ymm_ymm_gen(dcontext, ilist, instr, src1_idx_reg, src2_data_reg, dst_data_reg,
                                              mask_reg);
        }
        if (IS_XMM_REG(dst_data_reg)) {
            return vpermt2d_k_xmm_xmm_xmm_gen(dcontext, ilist, instr, src1_idx_reg, src2_data_reg, dst_data_reg,
                                              mask_reg);
        }
        if (IS_ZMM_REG(dst_data_reg)) {
            return vpermt2d_k_zmm_zmm_zmm_gen(dcontext, ilist, instr, src1_idx_reg, src2_data_reg, dst_data_reg,
                                              mask_reg);
        }
    } break;
    case BASE_DISP_kind: {
        if (IS_YMM_REG(dst_data_reg)) {
            return vpermt2d_k_m32_ymm_ymm_gen(dcontext, ilist, instr, src1_idx_reg, src2_data_opnd, dst_data_reg,
                                              mask_reg);
        }
        if (IS_XMM_REG(dst_data_reg)) {
            return vpermt2d_k_m16_xmm_xmm_gen(dcontext, ilist, instr, src1_idx_reg, src2_data_opnd, dst_data_reg,
                                              mask_reg);
        }
        if (IS_ZMM_REG(dst_data_reg)) {
            return vpermt2d_k_m64_zmm_zmm_gen(dcontext, ilist, instr, src1_idx_reg, src2_data_opnd, dst_data_reg,
                                              mask_reg);
        }
    } break;
    default: {
        REWRITE_ERROR(STD_ERRF, "vpermt2d pattern not support");
        return NULL_INSTR;
    }
    }
    return NULL_INSTR;
}

instr_t *
rw_func_vpextr_(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vpextrq %xmm29[8byte] $0x01 -> 0x40(%r8)[8byte]

    reg_id_t src1_reg = opnd_get_reg(instr_get_src(instr, 0));
    const uint src1_need_spill = NEED_SPILL_XMM(src1_reg) ? 1 : 0;

    opnd_t src1_opnd = instr_get_src(instr, 0);
    opnd_t imm8_opnd = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);

    if (instr->opcode == OP_vpextrq) {
#ifdef DEBUG
        print_rewrite_info(dcontext, ilist, instr, instr_start, "vpextrq", true, true, false, true);
#endif
        instrlist_remove(ilist, instr);
        instr_destroy(dcontext, instr);
        if (src1_need_spill) { // src1 xmm need spill
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);

            // spill_src1 -> tls_slot(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls_slot(src1_reg) -> spill_src1
            instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // vpextrq spill_src1, 0x01 -> dst
            instr_t *i3 = INSTR_CREATE_vpextrd(dcontext, dst_opnd, spill_src1_opnd, imm8_opnd);
            // tls_slot(spill_src1) -> spill_src1
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
            instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
            return i1;
        } else { // no need spill
            // vpextrq src1, 0x01 -> dst
            instr_t *i1 = INSTR_CREATE_vpextrd(dcontext, dst_opnd, src1_opnd, imm8_opnd);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
            return i1;
        }
    }
    if (instr->opcode == OP_vpextrd) {
#ifdef DEBUG
        print_rewrite_info(dcontext, ilist, instr, instr_start, "vpextrd", true, true, false, true);
#endif
        instrlist_remove(ilist, instr);
        instrlist_remove(ilist, instr);
        instr_destroy(dcontext, instr);
        if (src1_need_spill) { // src1 xmm need spill
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);

            // spill_src1 -> tls_slot(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls_slot(src1_reg) -> spill_src1
            instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // vpextrq spill_src1, 0x01 -> dst
            instr_t *i3 = INSTR_CREATE_vpextrd(dcontext, dst_opnd, spill_src1_opnd, imm8_opnd);
            // tls_slot(spill_src1) -> spill_src1
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
            instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
            return i1;
        } else { // no need spill
            // vpextrq src1, 0x01 -> dst
            instr_t *i1 = INSTR_CREATE_vpextrd(dcontext, dst_opnd, src1_opnd, imm8_opnd);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
            return i1;
        }
    }
    if (instr->opcode == OP_vpextrb) {
#ifdef DEBUG
        print_rewrite_info(dcontext, ilist, instr, instr_start, "vpextrb", true, true, false, true);
#endif
        instrlist_remove(ilist, instr);
        instr_destroy(dcontext, instr);
        if (src1_need_spill) { // src1 xmm need spill
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);

            // spill_src1 -> tls_slot(spill_src1)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls_slot(src1_reg) -> spill_src1
            instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // vpextrq spill_src1, 0x01 -> dst
            instr_t *i3 = INSTR_CREATE_vpextrb(dcontext, dst_opnd, spill_src1_opnd, imm8_opnd);
            // tls_slot(spill_src1) -> spill_src1
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
            instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
            return i1;
        } else { // no need spill
            // vpextrq src1, 0x01 -> dst
            instr_t *i1 = INSTR_CREATE_vpextrb(dcontext, dst_opnd, src1_opnd, imm8_opnd);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
            return i1;
        }
    }
    REWRITE_INFO(STD_OUTF, "vpextr_ pattern not support");
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vpmullq
 * ============================================= */
instr_t *
vpmullq_xmm_and_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg1, reg_id_t src_reg2,
                        reg_id_t dst_reg, reg_id_t mask_reg, opnd_t src1_opnd, opnd_t src2_opnd, opnd_t dst_opnd,
                        bool broadcast)
{
    // e.g.: vpmullq {%k0} %xmm1 %xmm0 -> %xmm0
    //                      src1  src2     dst
    opnd_t rax_opnd = opnd_create_reg(DR_REG_RAX);
    opnd_t rbx_opnd = opnd_create_reg(DR_REG_RBX);
    opnd_t rcx_opnd = opnd_create_reg(DR_REG_RCX);
    opnd_t rdx_opnd = opnd_create_reg(DR_REG_RDX);

    // Use a free simd register to store the result of the first mul, we choose xmm15
    opnd_t xmm15_free_opnd = opnd_create_reg(DR_REG_XMM15);

    /* context save and restore */
    // push rax
    instr_t *new_instr1 = INSTR_CREATE_push(dcontext, opnd_create_reg(DR_REG_RAX));
    // push rbx
    instr_t *new_instr2 = INSTR_CREATE_push(dcontext, opnd_create_reg(DR_REG_RBX));
    // push rcx
    instr_t *new_instr3 = INSTR_CREATE_push(dcontext, opnd_create_reg(DR_REG_RCX));
    // push rdx
    instr_t *new_instr4 = INSTR_CREATE_push(dcontext, opnd_create_reg(DR_REG_RDX));
    // pushf  # we need to save the flags, b.c. imul will change the flags in some cases
    instr_t *new_instr5 = INSTR_CREATE_RAW_pushf(dcontext);
    // save spill simd register xmm15 into tls slot
    instr_t *new_instr6 = SAVE_SIMD_TO_SIZED_TLS(dcontext, DR_REG_XMM15, TLS_ZMM_idx_SLOT(15), OPSZ_16);

    // vmovq %xmm1(src1), %rax(dst)
    instr_t *new_instr7 = INSTR_CREATE_vmovq(dcontext, rax_opnd, src1_opnd);
    // vmovq %xmm0(src2), %rbx(dst)
    instr_t *new_instr8 = INSTR_CREATE_vmovq(dcontext, rbx_opnd, src2_opnd);

    // pextrq  $0x01, %xmm1(src1), %rcx
    instr_t *new_instr9 =
        instr_create_1dst_2src(dcontext, OP_pextrq, rcx_opnd, src1_opnd, opnd_create_immed_int(0x01, OPSZ_1));
    // pextrq  $0x01, %xmm0(src2), %rdx
    instr_t *new_instr10 =
        instr_create_1dst_2src(dcontext, OP_pextrq, rdx_opnd, src2_opnd, opnd_create_immed_int(0x01, OPSZ_1));

    // imul %rbx(src), %rax(dst)
    instr_t *new_instr11 = INSTR_CREATE_imul(dcontext, rax_opnd, rbx_opnd);
    // imul %rcx(src), %rdx(dst)
    instr_t *new_instr12 = INSTR_CREATE_imul(dcontext, rdx_opnd, rcx_opnd);

    // vmovq %rax(src), %xmm0(dst) // NOTE: %xmm0 low 64 bits store the first mul value
    instr_t *new_instr13 = INSTR_CREATE_vmovq(dcontext, dst_opnd, rax_opnd);
    // vmovq %rdx(src), %xmm15(dst) // NOTE: %xmm15 low 64 bits store the second mul value
    instr_t *new_instr14 = INSTR_CREATE_vmovq(dcontext, xmm15_free_opnd, rdx_opnd);

    // vmovlhps %xmm0(dst), %xmm15, %xmm0(dst) // %xmm15 low 64 bits to %xmm0 high 64 bits 
    //                            xmm0
    // | ----- 64 bits high ------ | ----- 64 bits low ----- |
    // |      xmm15 low 64 bits    |      xmm0 low 64 bits   |
    instr_t *new_instr15 = instr_create_1dst_2src(dcontext, OP_vmovlhps, dst_opnd, dst_opnd, xmm15_free_opnd);

    // restore spill simd register xmm15 from tls slot
    instr_t *new_instr16 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, DR_REG_XMM15, TLS_ZMM_idx_SLOT(15), OPSZ_16);
    // popf
    instr_t *new_instr17 = INSTR_CREATE_RAW_popf(dcontext);
    // pop rdx
    instr_t *new_instr18 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RDX));
    // pop rcx
    instr_t *new_instr19 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RCX));
    // pop rbx
    instr_t *new_instr20 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RBX));
    // pop rax
    instr_t *new_instr21 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RAX));

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 21, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5, new_instr6,
                                 new_instr7, new_instr8, new_instr9, new_instr10, new_instr11, new_instr12, new_instr13,
                                 new_instr14, new_instr15, new_instr16, new_instr17, new_instr18, new_instr19,
                                 new_instr20, new_instr21);
#endif
    instrlist_concat_next_instr(ilist, 21, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5, new_instr6,
                                new_instr7, new_instr8, new_instr9, new_instr10, new_instr11, new_instr12, new_instr13,
                                new_instr14, new_instr15, new_instr16, new_instr17, new_instr18, new_instr19,
                                new_instr20, new_instr21);
    return new_instr1;
}

instr_t *
vpmullq_ymm_and_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                        reg_id_t dst_reg, reg_id_t mask_reg, opnd_t src1_opnd, opnd_t src2_opnd, opnd_t dst_opnd,
                        bool broadcast)
{
    // e.g. vpmullq {%k0} %ymm0 %ymm5 -> %ymm20
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    const uint src1_need_spill = NEED_SPILL_YMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill = NEED_SPILL_YMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill = NEED_SPILL_YMM(dst_reg) ? 4 : 0;

    uint need_spill_flag = src1_need_spill | src2_need_spill | dst_need_spill;

    reg_id_t rax_reg = DR_REG_RAX;
    reg_id_t rcx_reg = DR_REG_RCX;
    reg_id_t r9_reg = DR_REG_R9;
    reg_id_t r10_reg = DR_REG_R10;
    reg_id_t rdx_reg = DR_REG_RDX;
    opnd_t rax_opnd = opnd_create_reg(rax_reg);
    opnd_t rcx_opnd = opnd_create_reg(rcx_reg);
    opnd_t r9_opnd = opnd_create_reg(r9_reg);
    opnd_t r10_opnd = opnd_create_reg(r10_reg);
    opnd_t rdx_opnd = opnd_create_reg(rdx_reg);

    switch (need_spill_flag) {
    case 0: { /* no need spill */
        // pushf
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // pushq %rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, rax_opnd);
        // pushq %rcx
        instr_t *i3 = INSTR_CREATE_push(dcontext, rcx_opnd);
        // pushq %r9
        instr_t *i4 = INSTR_CREATE_push(dcontext, r9_opnd);
        // pushq %r10
        instr_t *i5 = INSTR_CREATE_push(dcontext, r10_opnd);
        // pushq %rdx
        instr_t *i6 = INSTR_CREATE_push(dcontext, rdx_opnd);

        // sub     $96, %rsp                         # 96byte scratch
        instr_t *i7 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));
        // vmovdqu %src1,   32(%rsp)                   # spill [rsp+0] <=> src1
        instr_t *i8 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_32), src1_opnd);
        // vmovdqu %src2,  64(%rsp)                  # spill [rsp+32] <=> src2
        instr_t *i9 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_32), src2_opnd);

        // movq    32(%rsp), %rax                      # a0 = src1[0]
        instr_t *i10 =
            INSTR_CREATE_mov_ld(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_8));
        // imulq   64(%rsp),  %rax                   # a0 *= src2[0]
        instr_t *i11 =
            INSTR_CREATE_imul(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_8));
        // movq    40(%rsp), %r9                      # a1 = src1[1]
        instr_t *i12 =
            INSTR_CREATE_mov_ld(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 40, OPSZ_8));
        // imulq   72(%rsp),  %r9                    # a1 *= src2[1]
        instr_t *i13 =
            INSTR_CREATE_imul(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 72, OPSZ_8));
        // movq    48(%rsp), %rcx                    # a2 = src1[2]
        instr_t *i14 =
            INSTR_CREATE_mov_ld(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 48, OPSZ_8));
        // imulq   80(%rsp), %rcx                    # a2 *= src2[2]
        instr_t *i15 =
            INSTR_CREATE_imul(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 80, OPSZ_8));
        // movq    56(%rsp), %r10                    # a3 = src1[3]
        instr_t *i16 =
            INSTR_CREATE_mov_ld(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 56, OPSZ_8));
        // imulq   88(%rsp), %r10                    # a3 *= src2[3]
        instr_t *i17 =
            INSTR_CREATE_imul(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 88, OPSZ_8));

        // movq    %rax,  (%rsp)
        instr_t *i18 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8), rax_opnd);
        // movq    %r9,   8(%rsp)
        instr_t *i19 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8), r9_opnd);
        // movq    %rcx,  16(%rsp)
        instr_t *i20 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8), rcx_opnd);
        // movq    %r10,  24(%rsp)
        instr_t *i21 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8), r10_opnd);

        // vmovdqu (%rsp), %dst
        instr_t *i22 =
            INSTR_CREATE_vmovdqu(dcontext, dst_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));

        // add     $96, %rsp
        instr_t *i23 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));
        // popq    %rdx
        instr_t *i24 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RDX));
        // popq    %r10
        instr_t *i25 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R10));
        // popq    %r9
        instr_t *i26 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R9));
        // popq    %rcx
        instr_t *i27 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RCX));
        // popq    %rax
        instr_t *i28 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RAX));
        // popf
        instr_t *i29 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 29, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29);
#endif
        instrlist_concat_next_instr(ilist, 29, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29);
        return i1;
    } break;
    case 1: { /* only src1 need spill */
        reg_id_t spill_src1 = find_one_available_spill_ymm(src2_reg);
        opnd_t spill_src1_opnd = opnd_create_reg(spill_src1);

        // pushf
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // pushq %rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, rax_opnd);
        // pushq %rcx
        instr_t *i3 = INSTR_CREATE_push(dcontext, rcx_opnd);
        // pushq %r9
        instr_t *i4 = INSTR_CREATE_push(dcontext, r9_opnd);
        // pushq %r10
        instr_t *i5 = INSTR_CREATE_push(dcontext, r10_opnd);
        // pushq %rdx
        instr_t *i6 = INSTR_CREATE_push(dcontext, rdx_opnd);

        // sub     $96, %rsp                         # 96byte scratch
        instr_t *i7 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));

        // spill_src1 -> tls_slot(spill_src1)
        instr_t *i8 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1)), OPSZ_32);

        // tls_slot(src1) -> spill_src1
        instr_t *i9 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);

        // vmovdqu %spill_src1,   32(%rsp)           # spill [rsp+0] <=> src1
        instr_t *i10 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_32),
                                            spill_src1_opnd);
        // vmovdqu %src2,  64(%rsp)                  # spill [rsp+32] <=> src2
        instr_t *i11 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_32), src2_opnd);

        // tls_slot(spill_src1) -> spill_src1
        instr_t *i12 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1)), OPSZ_32);

        // movq    32(%rsp), %rax                     # a0 = src1[0]
        instr_t *i13 =
            INSTR_CREATE_mov_ld(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_8));
        // imulq   64(%rsp),  %rax                    # a0 *= src2[0]
        instr_t *i14 =
            INSTR_CREATE_imul(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_8));
        // movq    40(%rsp), %r9                      # a1 = src1[1]
        instr_t *i15 =
            INSTR_CREATE_mov_ld(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 40, OPSZ_8));
        // imulq   72(%rsp),  %r9                    # a1 *= src2[1]
        instr_t *i16 =
            INSTR_CREATE_imul(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 72, OPSZ_8));
        // movq    48(%rsp), %rcx                    # a2 = src1[2]
        instr_t *i17 =
            INSTR_CREATE_mov_ld(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 48, OPSZ_8));
        // imulq   80(%rsp), %rcx                    # a2 *= src2[2]
        instr_t *i18 =
            INSTR_CREATE_imul(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 80, OPSZ_8));
        // movq    56(%rsp), %r10                    # a3 = src1[3]
        instr_t *i19 =
            INSTR_CREATE_mov_ld(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 56, OPSZ_8));
        // imulq   88(%rsp), %r10                    # a3 *= src2[3]
        instr_t *i20 =
            INSTR_CREATE_imul(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 88, OPSZ_8));

        // movq    %rax,  (%rsp)
        instr_t *i21 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8), rax_opnd);
        // movq    %r9,   8(%rsp)
        instr_t *i22 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8), r9_opnd);
        // movq    %rcx,  16(%rsp)
        instr_t *i23 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8), rcx_opnd);
        // movq    %r10,  24(%rsp)
        instr_t *i24 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8), r10_opnd);

        // vmovdqu (%rsp), %dst
        instr_t *i25 =
            INSTR_CREATE_vmovdqu(dcontext, dst_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));

        // add     $96, %rsp
        instr_t *i26 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));

        // popq    %rdx
        instr_t *i27 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RDX));
        // popq    %r10
        instr_t *i28 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R10));
        // popq    %r9
        instr_t *i29 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R9));
        // popq    %rcx
        instr_t *i30 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RCX));
        // popq    %rax
        instr_t *i31 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RAX));
        // popf
        instr_t *i32 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 32, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32);
#endif
        instrlist_concat_next_instr(ilist, 32, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32);
        return i1;
    } break;
    case 2: { /* only src2 need spill */
        reg_id_t spill_src2 = find_one_available_spill_ymm(src1_reg);
        opnd_t spill_src2_opnd = opnd_create_reg(spill_src2);

        // pushf
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // pushq %rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, rax_opnd);
        // pushq %rcx
        instr_t *i3 = INSTR_CREATE_push(dcontext, rcx_opnd);
        // pushq %r9
        instr_t *i4 = INSTR_CREATE_push(dcontext, r9_opnd);
        // pushq %r10
        instr_t *i5 = INSTR_CREATE_push(dcontext, r10_opnd);
        // pushq %rdx
        instr_t *i6 = INSTR_CREATE_push(dcontext, rdx_opnd);

        // sub     $96, %rsp                         # 96byte scratch
        instr_t *i7 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));

        // spill_src2 -> tls_slot(spill_src2)
        instr_t *i8 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2)), OPSZ_32);

        // tls_slot(src2) -> spill_src2
        instr_t *i9 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);

        // vmovdqu %src1,   32(%rsp)           # spill [rsp+0] <=> src1
        instr_t *i10 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_32), src1_opnd);
        // vmovdqu spill_src2,  64(%rsp)       # spill [rsp+32] <=> src2
        instr_t *i11 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_32),
                                            spill_src2_opnd);

        // tls_slot(spill_src2) -> spill_src2
        instr_t *i12 =
            RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2)), OPSZ_32);

        // movq    32(%rsp), %rax                     # a0 = src1[0]
        instr_t *i13 =
            INSTR_CREATE_mov_ld(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_8));
        // imulq   64(%rsp),  %rax                    # a0 *= src2[0]
        instr_t *i14 =
            INSTR_CREATE_imul(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_8));
        // movq    40(%rsp), %r9                      # a1 = src1[1]
        instr_t *i15 =
            INSTR_CREATE_mov_ld(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 40, OPSZ_8));
        // imulq   72(%rsp),  %r9                    # a1 *= src2[1]
        instr_t *i16 =
            INSTR_CREATE_imul(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 72, OPSZ_8));
        // movq    48(%rsp), %rcx                    # a2 = src1[2]
        instr_t *i17 =
            INSTR_CREATE_mov_ld(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 48, OPSZ_8));
        // imulq   80(%rsp), %rcx                    # a2 *= src2[2]
        instr_t *i18 =
            INSTR_CREATE_imul(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 80, OPSZ_8));
        // movq    56(%rsp), %r10                    # a3 = src1[3]
        instr_t *i19 =
            INSTR_CREATE_mov_ld(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 56, OPSZ_8));
        // imulq   88(%rsp), %r10                    # a3 *= src2[3]
        instr_t *i20 =
            INSTR_CREATE_imul(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 88, OPSZ_8));

        // movq    %rax,  (%rsp)
        instr_t *i21 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8), rax_opnd);
        // movq    %r9,   8(%rsp)
        instr_t *i22 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8), r9_opnd);
        // movq    %rcx,  16(%rsp)
        instr_t *i23 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8), rcx_opnd);
        // movq    %r10,  24(%rsp)
        instr_t *i24 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8), r10_opnd);

        // vmovdqu (%rsp), %dst
        instr_t *i25 =
            INSTR_CREATE_vmovdqu(dcontext, dst_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));

        // add     $96, %rsp
        instr_t *i26 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));

        // popq    %rdx
        instr_t *i27 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RDX));
        // popq    %r10
        instr_t *i28 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R10));
        // popq    %r9
        instr_t *i29 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R9));
        // popq    %rcx
        instr_t *i30 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RCX));
        // popq    %rax
        instr_t *i31 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RAX));
        // popf
        instr_t *i32 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 32, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32);
#endif
        instrlist_concat_next_instr(ilist, 32, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32);
        return i1;
    } break;
    case 3: { /* src1 and src2 need spill */
        // NOTE: if src1 == src2, should handle differently
        reg_id_t spill_src1_reg = find_one_available_spill_ymm(dst_reg);
        reg_id_t spill_src2_reg = find_available_spill_ymm_avoiding(dst_reg, spill_src1_reg, DR_REG_NULL);
        opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);
        opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);
        opnd_t dst_opnd = opnd_create_reg(dst_reg);

        // pushf
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // pushq %rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, rax_opnd);
        // pushq %rcx
        instr_t *i3 = INSTR_CREATE_push(dcontext, rcx_opnd);
        // pushq %r9
        instr_t *i4 = INSTR_CREATE_push(dcontext, r9_opnd);
        // pushq %r10
        instr_t *i5 = INSTR_CREATE_push(dcontext, r10_opnd);
        // pushq %rdx
        instr_t *i6 = INSTR_CREATE_push(dcontext, rdx_opnd);

        // sub     $96, %rsp                         # 96byte scratch
        instr_t *i7 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));

        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i8 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i9 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i10 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i11 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);

        // vmovdqu spill_src1, 32(%rsp)
        instr_t *i12 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_32),
                                            spill_src1_opnd);
        // vmovdqu spill_src2, 64(%rsp)
        instr_t *i13 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_32),
                                            spill_src2_opnd);
        // movq    32(%rsp), %rax                      # a0 = src1[0]
        instr_t *i14 =
            INSTR_CREATE_mov_ld(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_8));
        // imulq   64(%rsp),  %rax                   # a0 *= src2[0]
        instr_t *i15 =
            INSTR_CREATE_imul(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_8));
        // movq    40(%rsp), %r9                      # a1 = src1[1]
        instr_t *i16 =
            INSTR_CREATE_mov_ld(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 40, OPSZ_8));
        // imulq   72(%rsp),  %r9                    # a1 *= src2[1]
        instr_t *i17 =
            INSTR_CREATE_imul(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 72, OPSZ_8));
        // movq    48(%rsp), %rcx                    # a2 = src1[2]
        instr_t *i18 =
            INSTR_CREATE_mov_ld(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 48, OPSZ_8));
        // imulq   80(%rsp), %rcx                    # a2 *= src2[2]
        instr_t *i19 =
            INSTR_CREATE_imul(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 80, OPSZ_8));
        // movq    56(%rsp), %r10                    # a3 = src1[3]
        instr_t *i20 =
            INSTR_CREATE_mov_ld(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 56, OPSZ_8));
        // imulq   88(%rsp), %r10                    # a3 *= src2[3]
        instr_t *i21 =
            INSTR_CREATE_imul(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 88, OPSZ_8));

        // movq    %rax,  (%rsp)
        instr_t *i22 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8), rax_opnd);
        // movq    %r9,   8(%rsp)
        instr_t *i23 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8), r9_opnd);
        // movq    %rcx,  16(%rsp)
        instr_t *i24 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8), rcx_opnd);
        // movq    %r10,  24(%rsp)
        instr_t *i25 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8), r10_opnd);

        // vmovdqu (%rsp), %dst
        instr_t *i26 =
            INSTR_CREATE_vmovdqu(dcontext, dst_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));

        // tls(spill_src1_reg) -> spill_src1_reg
        instr_t *i27 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i28 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);

        // add     $96, %rsp
        instr_t *i29 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));

        // popq    %rdx
        instr_t *i30 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RDX));
        // popq    %r10
        instr_t *i31 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R10));
        // popq    %r9
        instr_t *i32 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R9));
        // popq    %rcx
        instr_t *i33 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RCX));
        // popq    %rax
        instr_t *i34 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RAX));
        // popf
        instr_t *i35 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 35, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32, i33, i34, i35);
#endif
        instrlist_concat_next_instr(ilist, 35, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32, i33,
                                    i34, i35);
        return i1;
    } break;
    case 4: { /* only dst need spill */
        reg_id_t spill_dst_reg = find_available_spill_ymm_avoiding(src1_reg, src2_reg, DR_REG_NULL);
        opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);

        // pushf
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // pushq %rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, rax_opnd);
        // pushq %rcx
        instr_t *i3 = INSTR_CREATE_push(dcontext, rcx_opnd);
        // pushq %r9
        instr_t *i4 = INSTR_CREATE_push(dcontext, r9_opnd);
        // pushq %r10
        instr_t *i5 = INSTR_CREATE_push(dcontext, r10_opnd);
        // pushq %rdx
        instr_t *i6 = INSTR_CREATE_push(dcontext, rdx_opnd);

        // sub     $96, %rsp                         # 96byte scratch
        instr_t *i7 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));
        // vmovdqu %src1,   32(%rsp)                   # spill [rsp+0] <=> src1
        instr_t *i8 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_32), src1_opnd);
        // vmovdqu %src2,  64(%rsp)                  # spill [rsp+32] <=> src2
        instr_t *i9 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_32), src2_opnd);

        // movq    32(%rsp), %rax                      # a0 = src1[0]
        instr_t *i10 =
            INSTR_CREATE_mov_ld(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_8));
        // imulq   64(%rsp),  %rax                   # a0 *= src2[0]
        instr_t *i11 =
            INSTR_CREATE_imul(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_8));
        // movq    40(%rsp), %r9                      # a1 = src1[1]
        instr_t *i12 =
            INSTR_CREATE_mov_ld(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 40, OPSZ_8));
        // imulq   72(%rsp),  %r9                    # a1 *= src2[1]
        instr_t *i13 =
            INSTR_CREATE_imul(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 72, OPSZ_8));
        // movq    48(%rsp), %rcx                    # a2 = src1[2]
        instr_t *i14 =
            INSTR_CREATE_mov_ld(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 48, OPSZ_8));
        // imulq   80(%rsp), %rcx                    # a2 *= src2[2]
        instr_t *i15 =
            INSTR_CREATE_imul(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 80, OPSZ_8));
        // movq    56(%rsp), %r10                    # a3 = src1[3]
        instr_t *i16 =
            INSTR_CREATE_mov_ld(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 56, OPSZ_8));
        // imulq   88(%rsp), %r10                    # a3 *= src2[3]
        instr_t *i17 =
            INSTR_CREATE_imul(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 88, OPSZ_8));

        // movq    %rax,  (%rsp)
        instr_t *i18 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8), rax_opnd);
        // movq    %r9,   8(%rsp)
        instr_t *i19 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8), r9_opnd);
        // movq    %rcx,  16(%rsp)
        instr_t *i20 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8), rcx_opnd);
        // movq    %r10,  24(%rsp)
        instr_t *i21 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8), r10_opnd);

        // spill_dst_reg -> tls(spill_dst_reg)
        instr_t *i22 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
        // vmovdqu (%rsp), %spill_dst_reg
        instr_t *i23 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd,
                                            opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i24 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
        // tls(spill_dst_reg) -> spill_dst_reg
        instr_t *i25 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);

        // add     $96, %rsp
        instr_t *i26 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));
        // popq    %rdx
        instr_t *i27 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RDX));
        // popq    %r10
        instr_t *i28 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R10));
        // popq    %r9
        instr_t *i29 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R9));
        // popq    %rcx
        instr_t *i30 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RCX));
        // popq    %rax
        instr_t *i31 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RAX));
        // popf
        instr_t *i32 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 32, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32);
#endif
        instrlist_concat_next_instr(ilist, 32, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32);
        return i1;
    } break;
    case 5: { /* src1 and dst need spill */
        reg_id_t spill_src1_reg = find_one_available_spill_ymm(src2_reg);
        reg_id_t spill_dst_reg = spill_src1_reg;
        opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);
        opnd_t spill_dst_opnd = spill_src1_opnd;

        // notice: spill src1 and spill dst can use the same spill register

        // pushf
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // pushq %rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, rax_opnd);
        // pushq %rcx
        instr_t *i3 = INSTR_CREATE_push(dcontext, rcx_opnd);
        // pushq %r9
        instr_t *i4 = INSTR_CREATE_push(dcontext, r9_opnd);
        // pushq %r10
        instr_t *i5 = INSTR_CREATE_push(dcontext, r10_opnd);
        // pushq %rdx
        instr_t *i6 = INSTR_CREATE_push(dcontext, rdx_opnd);

        // sub     $96, %rsp                         # 96byte scratch
        instr_t *i7 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));

        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i8 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
        // tls(src1_reg) -> spill_src1_reg
        instr_t *i9 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
        // vmovdqu spill_src1_reg,   32(%rsp)                   # spill [rsp+0] <=> src1
        instr_t *i10 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_32),
                                            spill_src1_opnd);
        // vmovdqu %src2,  64(%rsp)                  # spill [rsp+32] <=> src2
        instr_t *i11 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_32), src2_opnd);

        // movq    32(%rsp), %rax                      # a0 = src1[0]
        instr_t *i12 =
            INSTR_CREATE_mov_ld(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_8));
        // imulq   64(%rsp),  %rax                   # a0 *= src2[0]
        instr_t *i13 =
            INSTR_CREATE_imul(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_8));
        // movq    40(%rsp), %r9                      # a1 = src1[1]
        instr_t *i14 =
            INSTR_CREATE_mov_ld(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 40, OPSZ_8));
        // imulq   72(%rsp),  %r9                    # a1 *= src2[1]
        instr_t *i15 =
            INSTR_CREATE_imul(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 72, OPSZ_8));
        // movq    48(%rsp), %rcx                    # a2 = src1[2]
        instr_t *i16 =
            INSTR_CREATE_mov_ld(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 48, OPSZ_8));
        // imulq   80(%rsp), %rcx                    # a2 *= src2[2]
        instr_t *i17 =
            INSTR_CREATE_imul(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 80, OPSZ_8));
        // movq    56(%rsp), %r10                    # a3 = src1[3]
        instr_t *i18 =
            INSTR_CREATE_mov_ld(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 56, OPSZ_8));
        // imulq   88(%rsp), %r10                    # a3 *= src2[3]
        instr_t *i19 =
            INSTR_CREATE_imul(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 88, OPSZ_8));

        // movq    %rax,  (%rsp)
        instr_t *i20 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8), rax_opnd);
        // movq    %r9,   8(%rsp)
        instr_t *i21 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8), r9_opnd);
        // movq    %rcx,  16(%rsp)
        instr_t *i22 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8), rcx_opnd);
        // movq    %r10,  24(%rsp)
        instr_t *i23 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8), r10_opnd);

        // vmovdqu (%rsp), %spill_dst_reg
        instr_t *i24 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd,
                                            opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i25 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);

        // tls(spill_dst_reg) -> spill_dst_reg | is now the same as spill_src1_reg
        instr_t *i26 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);

        // add     $96, %rsp
        instr_t *i27 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));
        // popq    %rdx
        instr_t *i28 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RDX));
        // popq    %r10
        instr_t *i29 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R10));
        // popq    %r9
        instr_t *i30 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R9));
        // popq    %rcx
        instr_t *i31 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RCX));
        // popq    %rax
        instr_t *i32 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RAX));
        // popf
        instr_t *i33 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 33, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32, i33);
#endif
        instrlist_concat_next_instr(ilist, 33, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32,
                                    i33);
        return i1;
    } break;
    case 6: { /* src2 and dst need spill */
        reg_id_t spill_src2_reg = find_one_available_spill_ymm(src1_reg);
        reg_id_t spill_dst_reg = spill_src2_reg;
        opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);
        opnd_t spill_dst_opnd = spill_src2_opnd;

        // notice: spill src2 and spill dst can use the same spill register

        // pushf
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // pushq %rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, rax_opnd);
        // pushq %rcx
        instr_t *i3 = INSTR_CREATE_push(dcontext, rcx_opnd);
        // pushq %r9
        instr_t *i4 = INSTR_CREATE_push(dcontext, r9_opnd);
        // pushq %r10
        instr_t *i5 = INSTR_CREATE_push(dcontext, r10_opnd);
        // pushq %rdx
        instr_t *i6 = INSTR_CREATE_push(dcontext, rdx_opnd);

        // sub     $96, %rsp                         # 96byte scratch
        instr_t *i7 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));

        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i8 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i9 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                  TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
        // vmovdqu src1_reg,   32(%rsp)                   # spill [rsp+0] <=> src1
        instr_t *i10 =
            INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_32), src1_opnd);
        // vmovdqu spill_src2_reg,  64(%rsp)                  # spill [rsp+32] <=> spill_src2
        instr_t *i11 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_32),
                                            spill_src2_opnd);

        // movq    32(%rsp), %rax                      # a0 = src1[0]
        instr_t *i12 =
            INSTR_CREATE_mov_ld(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_8));
        // imulq   64(%rsp),  %rax                   # a0 *= src2[0]
        instr_t *i13 =
            INSTR_CREATE_imul(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_8));
        // movq    40(%rsp), %r9                      # a1 = src1[1]
        instr_t *i14 =
            INSTR_CREATE_mov_ld(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 40, OPSZ_8));
        // imulq   72(%rsp),  %r9                    # a1 *= src2[1]
        instr_t *i15 =
            INSTR_CREATE_imul(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 72, OPSZ_8));
        // movq    48(%rsp), %rcx                    # a2 = src1[2]
        instr_t *i16 =
            INSTR_CREATE_mov_ld(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 48, OPSZ_8));
        // imulq   80(%rsp), %rcx                    # a2 *= src2[2]
        instr_t *i17 =
            INSTR_CREATE_imul(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 80, OPSZ_8));
        // movq    56(%rsp), %r10                    # a3 = src1[3]
        instr_t *i18 =
            INSTR_CREATE_mov_ld(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 56, OPSZ_8));
        // imulq   88(%rsp), %r10                    # a3 *= src2[3]
        instr_t *i19 =
            INSTR_CREATE_imul(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 88, OPSZ_8));

        // movq    %rax,  (%rsp)
        instr_t *i20 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8), rax_opnd);
        // movq    %r9,   8(%rsp)
        instr_t *i21 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8), r9_opnd);
        // movq    %rcx,  16(%rsp)
        instr_t *i22 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8), rcx_opnd);
        // movq    %r10,  24(%rsp)
        instr_t *i23 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8), r10_opnd);

        // vmovdqu (%rsp), %spill_dst_reg
        instr_t *i24 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd,
                                            opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i25 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);

        // tls(spill_dst_reg) -> spill_dst_reg | is now the same as spill_src1_reg
        instr_t *i26 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);

        // add     $96, %rsp
        instr_t *i27 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));
        // popq    %rdx
        instr_t *i28 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RDX));
        // popq    %r10
        instr_t *i29 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R10));
        // popq    %r9
        instr_t *i30 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R9));
        // popq    %rcx
        instr_t *i31 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RCX));
        // popq    %rax
        instr_t *i32 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RAX));
        // popf
        instr_t *i33 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 33, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32, i33);
#endif
        instrlist_concat_next_instr(ilist, 33, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32,
                                    i33);
        return i1;
    } break;
    case 7: { /* src1, src2 and dst need spill */
        reg_id_t spill_src1_reg = YMM_SPILL_SLOT0;
        reg_id_t spill_src2_reg = YMM_SPILL_SLOT1;
        reg_id_t spill_dst_reg = spill_src1_reg;

        opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);
        opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);
        opnd_t spill_dst_opnd = spill_src1_opnd;

        // pushf
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // pushq %rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, rax_opnd);
        // pushq %rcx
        instr_t *i3 = INSTR_CREATE_push(dcontext, rcx_opnd);
        // pushq %r9
        instr_t *i4 = INSTR_CREATE_push(dcontext, r9_opnd);
        // pushq %r10
        instr_t *i5 = INSTR_CREATE_push(dcontext, r10_opnd);
        // pushq %rdx
        instr_t *i6 = INSTR_CREATE_push(dcontext, rdx_opnd);
        // sub     $96, %rsp                       # 96byte scratch
        instr_t *i7 =
            INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));
        // spill_src1_reg -> tls(spill_src1_reg)
        instr_t *i8 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);

        // spill_src2_reg -> tls(spill_src2_reg)
        instr_t *i9 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                             TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);

        // tls(src1_reg) -> spill_src1_reg
        instr_t *i10 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
        // tls(src2_reg) -> spill_src2_reg
        instr_t *i11 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);

        // vmovdqu spill_src1_reg,   32(%rsp)                 # spill [rsp+0] <=> spill_src1
        instr_t *i12 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_32),
                                            spill_src1_opnd);
        // vmovdqu spill_src2_reg,  64(%rsp)                  # spill [rsp+32] <=> spill_src2
        instr_t *i13 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_32),
                                            spill_src2_opnd);

        // movq    32(%rsp), %rax                     # a0 = src1[0]
        instr_t *i14 =
            INSTR_CREATE_mov_ld(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_8));
        // imulq   64(%rsp),  %rax                    # a0 *= src2[0]
        instr_t *i15 =
            INSTR_CREATE_imul(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_8));
        // movq    40(%rsp), %r9                      # a1 = src1[1]
        instr_t *i16 =
            INSTR_CREATE_mov_ld(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 40, OPSZ_8));
        // imulq   72(%rsp),  %r9                     # a1 *= src2[1]
        instr_t *i17 =
            INSTR_CREATE_imul(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 72, OPSZ_8));
        // movq    48(%rsp), %rcx                     # a2 = src1[2]
        instr_t *i18 =
            INSTR_CREATE_mov_ld(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 48, OPSZ_8));
        // imulq   80(%rsp), %rcx                     # a2 *= src2[2]
        instr_t *i19 =
            INSTR_CREATE_imul(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 80, OPSZ_8));
        // movq    56(%rsp), %r10                     # a3 = src1[3]
        instr_t *i20 =
            INSTR_CREATE_mov_ld(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 56, OPSZ_8));
        // imulq   88(%rsp), %r10                     # a3 *= src2[3]
        instr_t *i21 =
            INSTR_CREATE_imul(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 88, OPSZ_8));

        // movq    %rax,  (%rsp)
        instr_t *i22 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8), rax_opnd);
        // movq    %r9,   8(%rsp)
        instr_t *i23 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8), r9_opnd);
        // movq    %rcx,  16(%rsp)
        instr_t *i24 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8), rcx_opnd);
        // movq    %r10,  24(%rsp)
        instr_t *i25 =
            INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8), r10_opnd);

        // vmovdqu (%rsp), %spill_dst_reg
        instr_t *i26 = INSTR_CREATE_vmovdqu(dcontext, spill_dst_opnd,
                                            opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));
        // spill_dst_reg -> tls(dst_reg)
        instr_t *i27 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);

        // tls(spill_dst_reg) -> spill_dst_reg | is now the same as spill_src1_reg
        instr_t *i28 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);

        // tls(spill_src2_reg) -> spill_src2_reg
        instr_t *i29 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                   TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);

        // add     $96, %rsp
        instr_t *i30 =
            INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 3, OPSZ_4));
        // popq    %rdx
        instr_t *i31 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RDX));
        // popq    %r10
        instr_t *i32 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R10));
        // popq    %r9
        instr_t *i33 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R9));
        // popq    %rcx
        instr_t *i34 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RCX));
        // popq    %rax
        instr_t *i35 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RAX));
        // popf
        instr_t *i36 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 36, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
                                     i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
                                     i32, i33, i34, i35, i36);
#endif
        instrlist_concat_next_instr(ilist, 36, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                    i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32, i33,
                                    i34, i35, i36);
        return i1;
    } break;
    default: {
        REWRITE_ERROR(STD_ERRF, "vpmullq ymm and ymm not support");
        return NULL_INSTR;
    }
    }

#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "vpmullq ymm and ymm not support");
#endif
    return NULL_INSTR;
}

instr_t *
vpmullq_zmm_and_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg1, reg_id_t src_reg2,
                        reg_id_t dst_reg, reg_id_t mask_reg, opnd_t src1_opnd, opnd_t src2_opnd, opnd_t dst_opnd,
                        bool broadcast)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "vpmullq zmm and zmm not support");
#endif
    return NULL_INSTR;
}

instr_t *
vpmullq_xmm_and_mem_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg1, reg_id_t dst_reg,
                        reg_id_t mask_reg, opnd_t src1_opnd, opnd_t src2_opnd, opnd_t dst_opnd, bool broadcast)
{
    /* vpmullq {%k?} %xmm(src1), m128(src2) -> %xmm(dst)
     * k0-only semantics here (mask ignored).
     * Compute per-lane:
     *   rax = src1[0]; rbx = m[0]; rax *= rbx
     *   rcx = src1[1]; rdx = m[1]; rdx *= rcx
     *   pack {rdx, rax} back to %xmm dst
     */

    /* ---- Remove original ---- */
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    /* GPR opnds */
    opnd_t rax_opnd = opnd_create_reg(DR_REG_RAX);
    opnd_t rbx_opnd = opnd_create_reg(DR_REG_RBX);
    opnd_t rcx_opnd = opnd_create_reg(DR_REG_RCX);
    opnd_t rdx_opnd = opnd_create_reg(DR_REG_RDX);

    /* temp SIMD to hold hi-lane before vmovlhps */
    opnd_t xmm15_opnd = opnd_create_reg(DR_REG_XMM15);

    /* We push 4 GPRs + RFLAGS before first load from src2. */
    const int PRE_PUSH_BYTES = 5 * 8;

    /* Build two qword mem operands from src2 (base-disp expected). */
    DR_ASSERT_MSG(opnd_is_memory_reference(src2_opnd) && opnd_is_base_disp(src2_opnd),
                  "vpmullq_xmm_and_mem_gen expects base-disp memory src2");
    reg_id_t base = opnd_get_base(src2_opnd);
    reg_id_t idx = opnd_get_index(src2_opnd);
    int scl = opnd_get_scale(src2_opnd);
    int disp = opnd_get_disp(src2_opnd);

    /* If src2 was [%rsp + disp], compensate for our pushes. */
    if (base == DR_REG_RSP)
        disp += PRE_PUSH_BYTES;

    opnd_t mem_q0 = opnd_create_base_disp(base, idx, scl, disp + 0, OPSZ_8);
    opnd_t mem_q1 = opnd_create_base_disp(base, idx, scl, disp + 8, OPSZ_8);

    /* ---- Prologue ---- */
    instr_t *i1 = INSTR_CREATE_push(dcontext, opnd_create_reg(DR_REG_RAX));
    instr_t *i2 = INSTR_CREATE_push(dcontext, opnd_create_reg(DR_REG_RBX));
    instr_t *i3 = INSTR_CREATE_push(dcontext, opnd_create_reg(DR_REG_RCX));
    instr_t *i4 = INSTR_CREATE_push(dcontext, opnd_create_reg(DR_REG_RDX));
    instr_t *i5 = INSTR_CREATE_RAW_pushf(dcontext);
    instr_t *i6 = SAVE_SIMD_TO_SIZED_TLS(dcontext, DR_REG_XMM15, TLS_ZMM_idx_SLOT(15), OPSZ_16);

    /* ---- Lane 0 ---- */
    instr_t *i7 = INSTR_CREATE_vmovq(dcontext, rax_opnd, src1_opnd); /* rax = src1[0] */
    instr_t *i8 = INSTR_CREATE_mov_ld(dcontext, rbx_opnd, mem_q0);   /* rbx = src2[0] */
    instr_t *i9 = INSTR_CREATE_imul(dcontext, rax_opnd, rbx_opnd);   /* rax *= rbx    */

    /* ---- Lane 1 ---- */
    instr_t *i10 = instr_create_1dst_2src(dcontext, OP_pextrq, rcx_opnd, src1_opnd,
                                          opnd_create_immed_int(0x01, OPSZ_1)); /* rcx = src1[1] */
    instr_t *i11 = INSTR_CREATE_mov_ld(dcontext, rdx_opnd, mem_q1);             /* rdx = src2[1] */
    instr_t *i12 = INSTR_CREATE_imul(dcontext, rdx_opnd, rcx_opnd);             /* rdx *= rcx    */

    /* ---- Pack back to dst ---- */
    instr_t *i13 = INSTR_CREATE_vmovq(dcontext, dst_opnd, rax_opnd);                              /* dst.low  = rax */
    instr_t *i14 = INSTR_CREATE_vmovq(dcontext, xmm15_opnd, rdx_opnd);                            /* xmm15.low = rdx */
    instr_t *i15 = instr_create_1dst_2src(dcontext, OP_vmovlhps, dst_opnd, dst_opnd, xmm15_opnd); /* dst = {rdx, rax} */

    /* ---- Epilogue ---- */
    instr_t *i16 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, DR_REG_XMM15, TLS_ZMM_idx_SLOT(15), OPSZ_16);
    instr_t *i17 = INSTR_CREATE_RAW_popf(dcontext);
    instr_t *i18 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RDX));
    instr_t *i19 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RCX));
    instr_t *i20 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RBX));
    instr_t *i21 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RAX));

#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 21, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                 i17, i18, i19, i20, i21);
#endif
    instrlist_concat_next_instr(ilist, 21, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17,
                                i18, i19, i20, i21);
    return i1;
}

instr_t *
vpmullq_ymm_and_mem_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg1, reg_id_t dst_reg,
                        reg_id_t mask_reg, opnd_t src1_opnd, opnd_t src2_opnd, opnd_t dst_opnd, bool broadcast)
{
    /* vpmullq {%k?} %ymm(src1), m256(src2) -> %ymm(dst)
     * k0-only semantics. Compute 4x 64-bit lane products.
     */

    /* ---- Remove original ---- */
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    /* GPRs used */
    opnd_t rax_opnd = opnd_create_reg(DR_REG_RAX);
    opnd_t rcx_opnd = opnd_create_reg(DR_REG_RCX);
    opnd_t r9_opnd = opnd_create_reg(DR_REG_R9);
    opnd_t r10_opnd = opnd_create_reg(DR_REG_R10);
    opnd_t rdx_opnd = opnd_create_reg(DR_REG_RDX);

    /* Scratch frame size matches your existing case: 3*YMM = 96 */
    const int SCRATCH_BYTES = SIZE_OF_YMM * 3;                   /* 96 */
    const int PRE_PUSH_BYTES = 6 * 8;                            /* pushf + 5 GPR pushes = 48 */
    const int RSP_TOTAL_ADJUST = PRE_PUSH_BYTES + SCRATCH_BYTES; /* 144 */

    /* Disassemble src2 into 4 qword base-disp operands */
    DR_ASSERT_MSG(opnd_is_memory_reference(src2_opnd) && opnd_is_base_disp(src2_opnd),
                  "vpmullq_ymm_and_mem_gen expects base-disp memory src2");

    reg_id_t base = opnd_get_base(src2_opnd);
    reg_id_t idx = opnd_get_index(src2_opnd);
    int scl = opnd_get_scale(src2_opnd);
    int disp = opnd_get_disp(src2_opnd);

    if (base == DR_REG_RSP)
        disp += RSP_TOTAL_ADJUST;

    opnd_t mem_q0 = opnd_create_base_disp(base, idx, scl, disp + 0, OPSZ_8);
    opnd_t mem_q1 = opnd_create_base_disp(base, idx, scl, disp + 8, OPSZ_8);
    opnd_t mem_q2 = opnd_create_base_disp(base, idx, scl, disp + 16, OPSZ_8);
    opnd_t mem_q3 = opnd_create_base_disp(base, idx, scl, disp + 24, OPSZ_8);

    /* ---- Prologue ---- */
    instr_t *i1 = INSTR_CREATE_pushf(dcontext);
    instr_t *i2 = INSTR_CREATE_push(dcontext, rax_opnd);
    instr_t *i3 = INSTR_CREATE_push(dcontext, rcx_opnd);
    instr_t *i4 = INSTR_CREATE_push(dcontext, r9_opnd);
    instr_t *i5 = INSTR_CREATE_push(dcontext, r10_opnd);
    instr_t *i6 = INSTR_CREATE_push(dcontext, rdx_opnd);

    /* Sub 96 for scratch {dst[0..3], src1[0..3], src2[0..3]} */
    instr_t *i7 = INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SCRATCH_BYTES, OPSZ_4));

    /* Spill src1 to [rsp+32] (as in your existing code) */
    instr_t *i8 =
        INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_32), src1_opnd);

    /* Copy src2 (memory) into scratch [rsp+64..+88] via GPR rdx */
    instr_t *i9 = INSTR_CREATE_mov_ld(dcontext, rdx_opnd, mem_q0);
    instr_t *i10 =
        INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_8), rdx_opnd);

    instr_t *i11 = INSTR_CREATE_mov_ld(dcontext, rdx_opnd, mem_q1);
    instr_t *i12 =
        INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 72, OPSZ_8), rdx_opnd);

    instr_t *i13 = INSTR_CREATE_mov_ld(dcontext, rdx_opnd, mem_q2);
    instr_t *i14 =
        INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 80, OPSZ_8), rdx_opnd);

    instr_t *i15 = INSTR_CREATE_mov_ld(dcontext, rdx_opnd, mem_q3);
    instr_t *i16 =
        INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 88, OPSZ_8), rdx_opnd);

    /* ---- Do the four lane multiplies: load from scratch, imul, store back to scratch ---- */
    instr_t *i17 =
        INSTR_CREATE_mov_ld(dcontext, rax_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_8)); /* a0 */
    instr_t *i18 = INSTR_CREATE_imul(dcontext, rax_opnd,
                                     opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 64, OPSZ_8)); /* a0 *= b0 */
    instr_t *i19 =
        INSTR_CREATE_mov_ld(dcontext, r9_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 40, OPSZ_8)); /* a1 */
    instr_t *i20 = INSTR_CREATE_imul(dcontext, r9_opnd,
                                     opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 72, OPSZ_8)); /* a1 *= b1 */
    instr_t *i21 =
        INSTR_CREATE_mov_ld(dcontext, rcx_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 48, OPSZ_8)); /* a2 */
    instr_t *i22 = INSTR_CREATE_imul(dcontext, rcx_opnd,
                                     opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 80, OPSZ_8)); /* a2 *= b2 */
    instr_t *i23 =
        INSTR_CREATE_mov_ld(dcontext, r10_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 56, OPSZ_8)); /* a3 */
    instr_t *i24 = INSTR_CREATE_imul(dcontext, r10_opnd,
                                     opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 88, OPSZ_8)); /* a3 *= b3 */

    instr_t *i25 =
        INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_8), rax_opnd);
    instr_t *i26 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 8, OPSZ_8), r9_opnd);
    instr_t *i27 =
        INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 16, OPSZ_8), rcx_opnd);
    instr_t *i28 =
        INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 24, OPSZ_8), r10_opnd);

    /* Write results to dst */
    instr_t *i29 =
        INSTR_CREATE_vmovdqu(dcontext, dst_opnd, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32));

    /* ---- Epilogue ---- */
    instr_t *i30 =
        INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SCRATCH_BYTES, OPSZ_4));
    instr_t *i31 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RDX));
    instr_t *i32 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R10));
    instr_t *i33 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_R9));
    instr_t *i34 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RCX));
    instr_t *i35 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RAX));
    instr_t *i36 = INSTR_CREATE_popf(dcontext);

#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 36, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                 i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32, i33,
                                 i34, i35, i36);
#endif
    instrlist_concat_next_instr(ilist, 36, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17,
                                i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31, i32, i33, i34,
                                i35, i36);
    return i1;
}

instr_t *
vpmullq_zmm_and_mem_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg1, reg_id_t dst_reg,
                        reg_id_t mask_reg, opnd_t src1_opnd, opnd_t src2_opnd, opnd_t dst_opnd, bool broadcast)
{
    return NULL_INSTR;
}

/**
 * @brief 689 vpmullq rewrite function
 */
instr_t *
rw_func_vpmullq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vpmullq {%k0} %xmm1 %xmm0 -> %xmm0
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src1_opnd = instr_get_src(instr, 1);
    opnd_t src2_opnd = instr_get_src(instr, 2);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
    bool broadcast = instr_get_prefix_flag(instr, PREFIX_EVEX_b);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpmullq", true, true, true, true);
    REWRITE_INFO(STD_ERRF, "Need broadcast: %d\n", broadcast);
#endif
    if (src2_opnd.kind == REG_kind) {
        reg_id_t mask_reg = opnd_get_reg(mask_opnd);
        reg_id_t src1_reg = opnd_get_reg(src1_opnd);
        reg_id_t src2_reg = opnd_get_reg(src2_opnd);
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_XMM_REG(dst_reg)) {
            return vpmullq_xmm_and_xmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg, src1_opnd,
                                           src2_opnd, dst_opnd, broadcast);
        }
        if (IS_YMM_REG(dst_reg)) {
            return vpmullq_ymm_and_ymm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg, src1_opnd,
                                           src2_opnd, dst_opnd, broadcast);
        }
        if (IS_ZMM_REG(dst_reg)) {
            return vpmullq_zmm_and_zmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg, src1_opnd,
                                           src2_opnd, dst_opnd, broadcast);
        }
    } else { /* mem kind  */
        reg_id_t mask_reg = opnd_get_reg(mask_opnd);
        reg_id_t src1_reg = opnd_get_reg(src1_opnd);
        reg_id_t dst_reg = opnd_get_reg(dst_opnd);
        if (IS_XMM_REG(dst_reg)) {
            return vpmullq_xmm_and_mem_gen(dcontext, ilist, instr, src1_reg, dst_reg, mask_reg, src1_opnd, src2_opnd,
                                           dst_opnd, broadcast);
        }
        if (IS_YMM_REG(dst_reg)) {
            return vpmullq_ymm_and_mem_gen(dcontext, ilist, instr, src1_reg, dst_reg, mask_reg, src1_opnd, src2_opnd,
                                           dst_opnd, broadcast);
        }
        if (IS_ZMM_REG(dst_reg)) {
            return vpmullq_zmm_and_mem_gen(dcontext, ilist, instr, src1_reg, dst_reg, mask_reg, src1_opnd, src2_opnd,
                                           dst_opnd, broadcast);
        }
    }
    REWRITE_ERROR(STD_ERRF, "vpmullq pattern not support");
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vporq
 * ============================================= */

instr_t *
vporq_zmm_and_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg1, reg_id_t src_reg2,
                      reg_id_t dst_reg, reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "vporq zmm reg2reg not support");
#endif
    return NULL_INSTR;
}

instr_t *
vporq_ymm_and_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                      reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    int k_idx = TO_K_REG_INDEX(mask_reg);
    if (k_idx == 0) {

        // To make the generate code more efficient, we scarifice the source code simplicity
        const uint src1_need_spill = NEED_SPILL_YMM(src1_reg) ? 1 : 0;
        const uint src2_need_spill = NEED_SPILL_YMM(src2_reg) ? 2 : 0;
        const uint dst_need_spill = NEED_SPILL_YMM(dst_reg) ? 4 : 0;

        uint need_spill_flag = src1_need_spill | src2_need_spill | dst_need_spill;

        switch (need_spill_flag) {
        case 0: { /* no spill */
            opnd_t src1_opnd = opnd_create_reg(src1_reg);
            opnd_t src2_opnd = opnd_create_reg(src2_reg);
            opnd_t dst_opnd = opnd_create_reg(dst_reg);
            // VEX.128.66.0F.WIG EB /r VPOR ymm1, ymm2, ymm3/m256
            instr_t *i1 = INSTR_CREATE_vpor(dcontext, dst_opnd, src1_opnd, src2_opnd);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
            return i1;
        } break;
        case 1: { /* only src1 need spill */
            // vporq  {%k0} %ymm31 %ymm12 -> %ymm12
            reg_id_t spill_src1_reg = find_one_available_spill_ymm(src2_reg);
            opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);
            opnd_t src2_opnd = opnd_create_reg(src2_reg);
            opnd_t dst_opnd = opnd_create_reg(dst_reg);

            // spill_src1_reg -> tls(spill_src1_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // tls(src1_reg) -> spill_src1_reg
            instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
            // vpor spill_src1_reg, src2_reg, dst_reg
            instr_t *i3 = INSTR_CREATE_vpor(dcontext, dst_opnd, spill_src1_opnd, src2_opnd);
            // tls(spill_src1_reg) -> spill_src1_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
            instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
            return i1;
        } break;
        case 2: { /* only src2 need spill */
            // vporq  {%k0} %ymm12 %ymm30 -> %ymm31
            reg_id_t spill_src2_reg = find_one_available_spill_ymm(src1_reg);
            opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);
            opnd_t src1_opnd = opnd_create_reg(src1_reg);
            opnd_t dst_opnd = opnd_create_reg(dst_reg);

            // spill_src2_reg -> tls(spill_src2_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
            // tls(src2_reg) -> spill_src2_reg
            instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
            // vpor spill_src2_reg, src1_reg, dst_reg
            instr_t *i3 = INSTR_CREATE_vpor(dcontext, dst_opnd, src1_opnd, spill_src2_opnd);
            // tls(spill_src2_reg) -> spill_src2_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
            instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
            return i1;
        } break;
        case 3: { /* src1 and src2 need spill */
            // vporq  {%k0} %ymm31 %ymm25 -> %ymm5
            reg_id_t spill_src1_reg = find_one_available_spill_ymm(dst_reg);
            reg_id_t spill_src2_reg = find_available_spill_ymm_avoiding(dst_reg, spill_src1_reg, DR_REG_NULL);
            opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);
            opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);
            opnd_t dst_opnd = opnd_create_reg(dst_reg);

            // spill_src1_reg -> tls(spill_src1_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // spill_src2_reg -> tls(spill_src2_reg)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
            // tls(src1_reg) -> spill_src1_reg
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
            // tls(src2_reg) -> spill_src2_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
            // vpor spill_src1_reg, spill_src2_reg, dst_reg
            instr_t *i5 = INSTR_CREATE_vpor(dcontext, dst_opnd, spill_src1_opnd, spill_src2_opnd);
            // tls(spill_src1_reg) -> spill_src1_reg
            instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // tls(spill_src2_reg) -> spill_src2_reg
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
            instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
            return i1;
        } break;
        case 4: { /* only dst need spill */
            reg_id_t spill_dst_reg = find_available_spill_ymm_avoiding(src1_reg, src2_reg, DR_REG_NULL);
            opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
            opnd_t src1_opnd = opnd_create_reg(src1_reg);
            opnd_t src2_opnd = opnd_create_reg(src2_reg);

            // spill_dst_reg -> tls(spill_dst_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
            // vpor src1, src2 -> spill_dst_reg
            instr_t *i2 = INSTR_CREATE_vpor(dcontext, spill_dst_opnd, src1_opnd, src2_opnd);
            // spill_dst_reg -> tls(dst)
            instr_t *i3 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls(spill_dst_reg) -> spill_dst_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_dst_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
            instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
            return i1;
        } break;
        case 5: { /* src1 and dst need spill */
            // no matter src1 and dst are same or not, we only need to spill src1, since spill reg can as src and dst at
            // same time
            // vporq  {%k0} %ymm31 %ymm12 -> %ymm31
            reg_id_t spill_src1_reg = find_one_available_spill_ymm(src2_reg);
            reg_id_t spill_dst_reg = spill_src1_reg;
            opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);
            opnd_t src2_opnd = opnd_create_reg(src2_reg);
            opnd_t spill_dst_opnd = spill_src1_opnd;
            // spill_src1_reg -> tls(spill_src1_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
            // tls(src1_reg) -> spill_src1_reg
            instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
            // vpor spill_src1_reg, src2_reg, spill_dst_reg
            instr_t *i3 = INSTR_CREATE_vpor(dcontext, spill_dst_opnd, spill_src1_opnd, src2_opnd);

            // spill_dst_reg -> tls(dst_reg)
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);

            // tls(spill_src1_reg) -> spill_src1_reg
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } break;
        case 6: { /* src2 and dst need spill */
            // vporq  {%k0} %ymm12 %ymm20 -> %ymm21
            reg_id_t spill_src2_reg = find_one_available_spill_ymm(src1_reg);
            reg_id_t spill_dst_reg = spill_src2_reg;
            opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);
            opnd_t src1_opnd = opnd_create_reg(src1_reg);
            opnd_t spill_dst_opnd = spill_src2_opnd;
            // spill_src2_reg -> tls(spill_src2_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
            // tls(src2_reg) -> spill_src2_reg
            instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
            // vpor src1_reg, spill_src2_reg, spill_dst_reg
            instr_t *i3 = INSTR_CREATE_vpor(dcontext, spill_dst_opnd, src1_opnd, spill_src2_opnd);

            // spill_dst_reg -> tls(dst_reg)
            instr_t *i4 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);

            // tls(spill_src2_reg) -> spill_src2_reg
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2_reg)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
            instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
            return i1;
        } break;
        case 7: { /* src1, src2 and dst need spill */
            // we only need two spill reg
            reg_id_t spill_src1 = YMM_SPILL_SLOT0;
            reg_id_t spill_src2 = YMM_SPILL_SLOT1;
            reg_id_t spill_dst = spill_src1; // dst can be the same as any one of src1 or src2
            opnd_t spill_src1_opnd = opnd_create_reg(spill_src1);
            opnd_t spill_src2_opnd = opnd_create_reg(spill_src2);
            opnd_t spill_dst_opnd = spill_src1_opnd;

            // spill_src1_reg -> tls_slot(spill_src1_reg)
            instr_t *i1 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1)), OPSZ_32);
            // spill_src2_reg -> tls_slot(spill_src2_reg)
            instr_t *i2 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2)), OPSZ_32);
            // tls_slot(src1_reg) -> spill_src1
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src1_reg)), OPSZ_32);
            // tls_slot(src2_reg) -> spill_src2
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(src2_reg)), OPSZ_32);
            // vpor spill_src1_reg, spill_src2_reg, spill_dst_reg | spill_dst == spill_src1
            instr_t *i5 = INSTR_CREATE_vpor(dcontext, spill_dst_opnd, spill_src1_opnd, spill_src2_opnd);
            // spill_dst_reg -> tls_slot(dst_reg)
            instr_t *i6 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst, TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(dst_reg)), OPSZ_32);
            // tls_slot(src1_reg) -> spill_src1_reg
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src1)), OPSZ_32);
            // tls_slot(src2_reg) -> spill_src2_reg
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2,
                                                      TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_src2)), OPSZ_32);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
            instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
            return i1;
        } break;
        default: { /* all need spill */ REWRITE_ERROR(STD_ERRF, "vporq_ymm_and_ymm_gen not support pattern");
        } break;
        }
    } else {
        // unsigned char imm8 = rewrite_reserved_opmask[k_idx];
    }

    return NULL_INSTR;
}

instr_t *
vporq_xmm_and_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                      reg_id_t dst_reg, reg_id_t mask_reg)
{

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    // To make the generate code more efficient, we scarifice the source code simplicity
    const uint src1_need_spill = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
    const uint src2_need_spill = NEED_SPILL_XMM(src2_reg) ? 2 : 0;
    const uint dst_need_spill = NEED_SPILL_XMM(dst_reg) ? 4 : 0;

    uint need_spill_flag = src1_need_spill | src2_need_spill | dst_need_spill;

    // for special case, src1 == src2, src1 == dst, src2 == dst, when define seperate entry for them
    if (src1_reg == dst_reg && src1_need_spill) // since src1 and dst are same, we only need one condition to check
        need_spill_flag = 8;
    if (src2_reg == dst_reg && src2_need_spill) // since src2 and dst are same, we only need one condition to check
        need_spill_flag = 9;
    if (src1_reg == src2_reg && src1_need_spill) // since src1 and src2 are same, we only need one condition to check
        need_spill_flag = 10;
    if (src1_reg == dst_reg && src2_reg == dst_reg && src1_need_spill) // if all three are same
        need_spill_flag = 11;

    int k_idx = TO_K_REG_INDEX(mask_reg);
    if (k_idx == 0) { // mask not work

        switch (need_spill_flag) {
        case 0:
            // no need spill
            {
                opnd_t src1_opnd = opnd_create_reg(src1_reg);
                opnd_t src2_opnd = opnd_create_reg(src2_reg);
                opnd_t dst_opnd = opnd_create_reg(dst_reg);
                // VEX.128.66.0F.WIG EB /r VPOR xmm1, xmm2, xmm3/m128
                instr_t *new_instr1 = instr_create_1dst_2src(dcontext, OP_vpor, dst_opnd, src1_opnd, src2_opnd);
#ifdef DEBUG
                print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
                return new_instr1;
            }
            break;
        case 1:
            // only src1 need spill
            {
                reg_id_t spill_src1_reg = find_one_available_spill_xmm(src1_reg);

                opnd_t src2_opnd = opnd_create_reg(src2_reg);
                opnd_t dst_opnd = opnd_create_reg(dst_reg);
                opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);

                // spill_src1_reg -> tls(spill_src1_reg)
                instr_t *new_instr1 = SAVE_SIMD_TO_SIZED_TLS(
                    dcontext, spill_src1_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
                // tls(src1_reg) -> spill_src1_reg
                instr_t *new_instr2 = RESTORE_SIMD_FROM_SIZED_TLS(
                    dcontext, spill_src1_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
                // VEX.128.66.0F.WIG EB /r VPOR xmm1, xmm2, xmm3/m128
                instr_t *new_instr3 = instr_create_1dst_2src(dcontext, OP_vpor, dst_opnd, spill_src1_opnd, src2_opnd);
                // tls(spill_src1_reg) -> spill_src1_reg
                instr_t *new_instr4 = RESTORE_SIMD_FROM_SIZED_TLS(
                    dcontext, spill_src1_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
                print_rewrite_variadic_instr(dcontext, 4, new_instr1, new_instr2, new_instr3, new_instr4);
#endif
                instrlist_concat_next_instr(ilist, 4, new_instr1, new_instr2, new_instr3, new_instr4);
                return new_instr1;
            }
            break;
        case 2:
            // only src2 need spill
            {
                reg_id_t spill_src2_reg = find_one_available_spill_xmm(src2_reg);

                opnd_t src1_opnd = opnd_create_reg(src1_reg);
                opnd_t dst_opnd = opnd_create_reg(dst_reg);
                opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);

                // spill_src2_reg -> tls(spill_src2_reg)
                instr_t *new_instr1 = SAVE_SIMD_TO_SIZED_TLS(
                    dcontext, spill_src2_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
                // tls(src2_reg) -> spill_src2_reg
                instr_t *new_instr2 = RESTORE_SIMD_FROM_SIZED_TLS(
                    dcontext, spill_src2_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);

                // VEX.128.66.0F.WIG EB /r VPOR xmm1, xmm2, xmm3/m128
                instr_t *new_instr3 = instr_create_1dst_2src(dcontext, OP_vpor, dst_opnd, src1_opnd, spill_src2_opnd);

                // tls(spill_src2_reg) -> spill_src2_reg
                instr_t *new_instr4 = RESTORE_SIMD_FROM_SIZED_TLS(
                    dcontext, spill_src2_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
                print_rewrite_variadic_instr(dcontext, 4, new_instr1, new_instr2, new_instr3, new_instr4);
#endif
                instrlist_concat_next_instr(ilist, 4, new_instr1, new_instr2, new_instr3, new_instr4);
                return new_instr1;
            }
            break;
        case 3:
            // src1 and src2 need spill
            {
                spill_reg_pair_t spill_reg_pair = find_two_available_spill_xmms(src1_reg, src2_reg);
                reg_id_t spill_src1_reg = spill_reg_pair.reg1;
                reg_id_t spill_src2_reg = spill_reg_pair.reg2;

                opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);
                opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);
                opnd_t dst_opnd = opnd_create_reg(dst_reg);

                // spill_src1_reg -> tls(spill_src1_reg)
                instr_t *new_instr1 = SAVE_SIMD_TO_SIZED_TLS(
                    dcontext, spill_src1_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
                // spill_src2_reg -> tls(spill_src2_reg)
                instr_t *new_instr2 = SAVE_SIMD_TO_SIZED_TLS(
                    dcontext, spill_src2_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
                // tls(src1_reg) -> spill_src1_reg
                instr_t *new_instr3 = RESTORE_SIMD_FROM_SIZED_TLS(
                    dcontext, spill_src1_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
                // tls(src2_reg) -> spill_src2_reg
                instr_t *new_instr4 = RESTORE_SIMD_FROM_SIZED_TLS(
                    dcontext, spill_src2_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
                // VEX.128.66.0F.WIG EB /r VPOR xmm1, xmm2, xmm3/m128
                instr_t *new_instr5 =
                    instr_create_1dst_2src(dcontext, OP_vpor, dst_opnd, spill_src1_opnd, spill_src2_opnd);
                // tls(spill_src1_reg) -> spill_src1_reg
                instr_t *new_instr6 = RESTORE_SIMD_FROM_SIZED_TLS(
                    dcontext, spill_src1_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
                // tls(spill_src2_reg) -> spill_src2_reg
                instr_t *new_instr7 = RESTORE_SIMD_FROM_SIZED_TLS(
                    dcontext, spill_src2_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);

#ifdef DEBUG
                print_rewrite_variadic_instr(dcontext, 7, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5,
                                             new_instr6, new_instr7);
#endif
                instrlist_concat_next_instr(ilist, 7, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5,
                                            new_instr6, new_instr7);
                return new_instr1;
            }
            break;
        case 4:
            // only dst need spill
            {
                reg_id_t spill_dst_reg = find_one_available_spill_xmm(dst_reg);

                opnd_t src1_opnd = opnd_create_reg(src1_reg);
                opnd_t src2_opnd = opnd_create_reg(src2_reg);
                opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);

                // spill_dst_reg -> tls(spill_dst_reg)
                instr_t *new_instr1 = SAVE_SIMD_TO_SIZED_TLS(
                    dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
                // VEX.128.66.0F.WIG EB /r VPOR xmm1, xmm2, xmm3/m128
                instr_t *new_instr2 = instr_create_1dst_2src(dcontext, OP_vpor, spill_dst_opnd, src1_opnd, src2_opnd);
                // spill_dst_reg -> tls(dst_reg)
                instr_t *new_instr3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
                // tls(spill_dst_reg) -> spill_dst_reg
                instr_t *new_instr4 = RESTORE_SIMD_FROM_SIZED_TLS(
                    dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
                print_rewrite_variadic_instr(dcontext, 4, new_instr1, new_instr2, new_instr3, new_instr4);
#endif
                instrlist_concat_next_instr(ilist, 4, new_instr1, new_instr2, new_instr3, new_instr4);
                return new_instr1;
            }
            break;
        case 5:
            // src1 and dst need spill
            {
                spill_reg_pair_t spill_reg_pair = find_two_available_spill_xmms(src1_reg, dst_reg);
                reg_id_t spill_src1_reg = spill_reg_pair.reg1;
                reg_id_t spill_dst_reg = spill_reg_pair.reg2;

                opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);
                opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
                opnd_t src2_opnd = opnd_create_reg(src2_reg);

                // spill_src1_reg -> tls(spill_src1_reg)
                instr_t *new_instr1 = SAVE_SIMD_TO_SIZED_TLS(
                    dcontext, spill_src1_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
                // spill_dst_reg -> tls(spill_dst_reg)
                instr_t *new_instr2 = SAVE_SIMD_TO_SIZED_TLS(
                    dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
                // tls(src1_reg) -> spill_src1_reg
                instr_t *new_instr3 = RESTORE_SIMD_FROM_SIZED_TLS(
                    dcontext, spill_src1_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
                // VEX.128.66.0F.WIG EB /r VPOR xmm1, xmm2, xmm3/m128
                instr_t *new_instr4 =
                    instr_create_1dst_2src(dcontext, OP_vpor, spill_dst_opnd, spill_src1_opnd, src2_opnd);
                // spill_dst_reg -> tls(dst_reg)
                instr_t *new_instr5 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
                // tls(spill_dst_reg) -> spill_dst_reg
                instr_t *new_instr6 = RESTORE_SIMD_FROM_SIZED_TLS(
                    dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
                // tls(spill_src1_reg) -> spill_src1_reg
                instr_t *new_instr7 = RESTORE_SIMD_FROM_SIZED_TLS(
                    dcontext, spill_src1_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
                print_rewrite_variadic_instr(dcontext, 7, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5,
                                             new_instr6, new_instr7);
#endif

                instrlist_concat_next_instr(ilist, 7, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5,
                                            new_instr6, new_instr7);
                return new_instr1;
            }
            break;
        case 6:
            // src2 and dst need spill
            {
                spill_reg_pair_t spill_reg_pair = find_two_available_spill_xmms(src2_reg, dst_reg);
                reg_id_t spill_src2_reg = spill_reg_pair.reg1;
                reg_id_t spill_dst_reg = spill_reg_pair.reg2;

                opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);
                opnd_t spill_dst_opnd = opnd_create_reg(spill_dst_reg);
                opnd_t src1_opnd = opnd_create_reg(src1_reg);

                // spill_src2_reg -> tls(spill_src2_reg)
                instr_t *new_instr1 = SAVE_SIMD_TO_SIZED_TLS(
                    dcontext, spill_src2_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
                // spill_dst_reg -> tls(spill_dst_reg)
                instr_t *new_instr2 = SAVE_SIMD_TO_SIZED_TLS(
                    dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
                // tls(src2_reg) -> spill_src2_reg
                instr_t *new_instr3 = RESTORE_SIMD_FROM_SIZED_TLS(
                    dcontext, spill_src2_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
                // VEX.128.66.0F.WIG EB /r VPOR xmm1, xmm2, xmm3/m128
                instr_t *new_instr4 =
                    instr_create_1dst_2src(dcontext, OP_vpor, spill_dst_opnd, src1_opnd, spill_src2_opnd);
                // spill_dst_reg -> tls(dst_reg)
                instr_t *new_instr5 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                             TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
                // tls(spill_dst_reg) -> spill_dst_reg
                instr_t *new_instr6 = RESTORE_SIMD_FROM_SIZED_TLS(
                    dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
                // tls(spill_src2_reg) -> spill_src2_reg
                instr_t *new_instr7 = RESTORE_SIMD_FROM_SIZED_TLS(
                    dcontext, spill_src2_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
                print_rewrite_variadic_instr(dcontext, 7, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5,
                                             new_instr6, new_instr7);
#endif

                instrlist_concat_next_instr(ilist, 7, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5,
                                            new_instr6, new_instr7);
                return new_instr1;
            }
            break;
        case 7:
            // src1, src2 and dst need spill
            {
                REWRITE_ERROR(STD_ERRF, "vporq xmm and xmm need spill flag not support: src1, src2 and dst need spill");
                return NULL_INSTR;
            }
            break;
        case 8:
            // src1 and dst need spill, and src1 == dst
            {
                if (!src2_need_spill) { // src2 don't need spill

                    // if src1 and dst are the same register, we only spill one of them
                    // we choose to spill src1 explicity in code implementation
                    reg_id_t spill_src1_reg = find_one_available_spill_xmm(src1_reg);

                    if (spill_src1_reg == src2_reg) // if spill_src1_reg unexpectedly equals to src2_reg, we need to
                                                    // find another spill slot
                        spill_src1_reg = XMM_SPILL_SLOT0 + (spill_src1_reg - XMM_SPILL_SLOT0 + 1) % 6;

                    reg_id_t spill_dst_reg = spill_src1_reg; // still remain a spill_dst_reg for readability

                    opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);
                    opnd_t spill_dst_opnd = spill_src1_opnd;
                    opnd_t src2_opnd = opnd_create_reg(src2_reg);

                    // spill_src1_reg -> tls(spill_src1_reg)
                    instr_t *new_instr1 = SAVE_SIMD_TO_SIZED_TLS(
                        dcontext, spill_src1_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
                    // tls(src1_reg) -> spill_src1_reg
                    instr_t *new_instr2 = RESTORE_SIMD_FROM_SIZED_TLS(
                        dcontext, spill_src1_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
                    // VEX.128.66.0F.WIG EB /r VPOR xmm1, xmm2, xmm3/m128
                    instr_t *new_instr3 =
                        instr_create_1dst_2src(dcontext, OP_vpor, spill_dst_opnd, spill_src1_opnd, src2_opnd);
                    // spill_dst_reg -> tls(dst_reg)
                    instr_t *new_instr4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
                    // tls(spill_src1_reg) -> spill_src1_reg, tls(spill_dst_reg) -> spill_dst_reg
                    instr_t *new_instr5 = RESTORE_SIMD_FROM_SIZED_TLS(
                        dcontext, spill_src1_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
                    print_rewrite_variadic_instr(dcontext, 5, new_instr1, new_instr2, new_instr3, new_instr4,
                                                 new_instr5);
#endif
                    instrlist_concat_next_instr(ilist, 5, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5);
                    return new_instr1;
                } else { // src2 need spill

                    // if both src1==dst and src2 need spill, then we just find a pair xmm_spill_pair is enough,
                    // since there's no possiblity they will occupy the same spill slot  cause conflict
                    spill_reg_pair_t spill_reg_pair = find_two_available_spill_xmms(src1_reg, src2_reg);
                    reg_id_t spill_src1_reg = spill_reg_pair.reg1;
                    reg_id_t spill_dst_reg = spill_src1_reg; // they are the same register
                    reg_id_t spill_src2_reg = spill_reg_pair.reg2;

                    opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);
                    opnd_t spill_dst_opnd = spill_src1_opnd;
                    opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);

                    // spill_src1_reg -> tls(spill_src1_reg)
                    instr_t *new_instr1 = SAVE_SIMD_TO_SIZED_TLS(
                        dcontext, spill_src1_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
                    // spill_src2_reg -> tls(spill_src2_reg)
                    instr_t *new_instr2 = SAVE_SIMD_TO_SIZED_TLS(
                        dcontext, spill_src2_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
                    // tls(src1_reg) -> spill_src1_reg
                    instr_t *new_instr3 = RESTORE_SIMD_FROM_SIZED_TLS(
                        dcontext, spill_src1_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
                    // tls(src2_reg) -> spill_src2_reg
                    instr_t *new_instr4 = RESTORE_SIMD_FROM_SIZED_TLS(
                        dcontext, spill_src2_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
                    // VEX.128.66.0F.WIG EB /r VPOR xmm1, xmm2, xmm3/m128
                    instr_t *new_instr5 =
                        instr_create_1dst_2src(dcontext, OP_vpor, spill_dst_opnd, spill_src1_opnd, spill_src2_opnd);
                    // spill_dst_reg -> tls(dst_reg), which spill_dst_reg is the same as spill_src1_reg
                    instr_t *new_instr6 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
                    // tls(spill_src1_reg) -> spill_src1_reg | tls(spill_dst_reg) -> spill_dst_reg
                    instr_t *new_instr7 = RESTORE_SIMD_FROM_SIZED_TLS(
                        dcontext, spill_src1_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
                    // tls(spill_src2_reg) -> spill_src2_reg
                    instr_t *new_instr8 = RESTORE_SIMD_FROM_SIZED_TLS(
                        dcontext, spill_src2_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
                    print_rewrite_variadic_instr(dcontext, 8, new_instr1, new_instr2, new_instr3, new_instr4,
                                                 new_instr5, new_instr6, new_instr7, new_instr8);
#endif
                    instrlist_concat_next_instr(ilist, 8, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5,
                                                new_instr6, new_instr7, new_instr8);
                    return new_instr1;
                }
            }
            break;
        case 9:
            // src2 and dst need spill, and src2 == dst
            {
                if (!src1_need_spill) { // src1 don't need spill
                    // if src2 and dst are the same register, we only spill one of them
                    // we choose to spill src2 explicity in code implementation
                    // and we need to avoid src1_reg will equal to the spill_src2_reg, so use avoiding routine
                    reg_id_t spill_src2_reg = find_available_spill_xmm_avoiding(src2_reg, src1_reg, DR_REG_NULL);
                    reg_id_t spill_dst_reg = spill_src2_reg; // still remain a spill_dst_reg for readability

                    opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);
                    opnd_t spill_dst_opnd = spill_src2_opnd;
                    opnd_t src1_opnd = opnd_create_reg(src1_reg);

                    // spill_src2_reg -> tls(spill_src2_reg)
                    instr_t *new_instr1 = SAVE_SIMD_TO_SIZED_TLS(
                        dcontext, spill_src2_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
                    // tls(src2_reg) -> spill_src2_reg
                    instr_t *new_instr2 = RESTORE_SIMD_FROM_SIZED_TLS(
                        dcontext, spill_src2_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
                    // VEX.128.66.0F.WIG EB /r VPOR xmm1, xmm2, xmm3/m128
                    instr_t *new_instr3 =
                        instr_create_1dst_2src(dcontext, OP_vpor, spill_dst_opnd, src1_opnd, spill_src2_opnd);
                    // spill_dst_reg -> tls(dst_reg)
                    instr_t *new_instr4 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
                    // tls(spill_src2_reg) -> spill_src2_reg, tls(spill_dst_reg) -> spill_dst_reg
                    instr_t *new_instr5 = RESTORE_SIMD_FROM_SIZED_TLS(
                        dcontext, spill_src2_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
                    print_rewrite_variadic_instr(dcontext, 5, new_instr1, new_instr2, new_instr3, new_instr4,
                                                 new_instr5);
#endif
                    instrlist_concat_next_instr(ilist, 5, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5);
                    return new_instr1;
                } else { // src1 need spill, src2 == dst and both need spill
                    // if both src1==dst and src2 need spill, then we just find a pair xmm_spill_pair is enough,
                    // since there's no possiblity they will occupy the same spill slot
                    spill_reg_pair_t spill_reg_pair = find_two_available_spill_xmms(src1_reg, src2_reg);
                    reg_id_t spill_src1_reg = spill_reg_pair.reg1;
                    reg_id_t spill_src2_reg = spill_reg_pair.reg2;
                    reg_id_t spill_dst_reg = spill_src2_reg; // they are the same register

                    opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);
                    opnd_t spill_src2_opnd = opnd_create_reg(spill_src2_reg);
                    opnd_t spill_dst_opnd = spill_src2_opnd;

                    // spill_src1_reg -> tls(spill_src1_reg)
                    instr_t *new_instr1 = SAVE_SIMD_TO_SIZED_TLS(
                        dcontext, spill_src1_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
                    // spill_src2_reg -> tls(spill_src2_reg)
                    instr_t *new_instr2 = SAVE_SIMD_TO_SIZED_TLS(
                        dcontext, spill_src2_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
                    // tls(src1_reg) -> spill_src1_reg
                    instr_t *new_instr3 = RESTORE_SIMD_FROM_SIZED_TLS(
                        dcontext, spill_src1_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
                    // tls(src2_reg) -> spill_src2_reg
                    instr_t *new_instr4 = RESTORE_SIMD_FROM_SIZED_TLS(
                        dcontext, spill_src2_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
                    // VEX.128.66.0F.WIG EB /r VPOR xmm1, xmm2, xmm3/m128
                    instr_t *new_instr5 =
                        instr_create_1dst_2src(dcontext, OP_vpor, spill_dst_opnd, spill_src1_opnd, spill_src2_opnd);
                    // spill_dst_reg -> tls(dst_reg), which spill_dst_reg is the same as spill_src1_reg
                    instr_t *new_instr6 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
                    // tls(spill_src1_reg) -> spill_src1_reg
                    instr_t *new_instr7 = RESTORE_SIMD_FROM_SIZED_TLS(
                        dcontext, spill_src1_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
                    // tls(spill_src2_reg) -> spill_src2_reg, same as tls(spill_dst_reg) -> spill_dst_reg
                    instr_t *new_instr8 = RESTORE_SIMD_FROM_SIZED_TLS(
                        dcontext, spill_src2_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
                    print_rewrite_variadic_instr(dcontext, 8, new_instr1, new_instr2, new_instr3, new_instr4,
                                                 new_instr5, new_instr6, new_instr7, new_instr8);
#endif
                    instrlist_concat_next_instr(ilist, 8, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5,
                                                new_instr6, new_instr7, new_instr8);
                    return new_instr1;
                }
            }
            break;
        case 10:
            // src1 and src2 need spill, and src1 == src2
            {
                reg_id_t spill_src1_reg = find_one_available_spill_xmm(src1_reg);
                if (spill_src1_reg == dst_reg)
                    spill_src1_reg = spill_src1_reg + (spill_src1_reg - XMM_SPILL_SLOT0 + 1) % 6;

                opnd_t spill_src1_opnd = opnd_create_reg(spill_src1_reg);
                opnd_t spill_src2_opnd = spill_src1_opnd;
                opnd_t dst_opnd = opnd_create_reg(dst_reg);

                // spill_src1_reg -> tls(spill_src1_reg)
                instr_t *new_instr1 = SAVE_SIMD_TO_SIZED_TLS(
                    dcontext, spill_src1_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
                // tls(src1_reg) -> spill_src1_reg
                instr_t *new_instr2 = RESTORE_SIMD_FROM_SIZED_TLS(
                    dcontext, spill_src1_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
                //
                // VEX.128.66.0F.WIG EB /r VPOR xmm1, xmm2, xmm3/m128
                instr_t *new_instr3 = // here spill_src1_opnd == spill_src2_opnd
                    instr_create_1dst_2src(dcontext, OP_vpor, dst_opnd, spill_src1_opnd, spill_src2_opnd);
                // tls(spill_src1_reg) -> spill_src1_reg
                instr_t *new_instr4 = RESTORE_SIMD_FROM_SIZED_TLS(
                    dcontext, spill_src1_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
                print_rewrite_variadic_instr(dcontext, 4, new_instr1, new_instr2, new_instr3, new_instr4);
#endif
                instrlist_concat_next_instr(ilist, 4, new_instr1, new_instr2, new_instr3, new_instr4);
                return new_instr1;
            }
            break;
        default: REWRITE_ERROR(STD_ERRF, "vporq xmm and xmm need spill flag not support"); return NULL_INSTR;
        }
    } else { // need use mask
        // unsigned char imm8 = rewrite_reserved_opmask[k_idx];
        // then how to make it corrdinates with vpxorq's quadword,
    }
    return NULL_INSTR;
}

instr_t * /* 691 */
rw_func_vporq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src_opnd1 = instr_get_src(instr, 1);
    opnd_t src_opnd2 = instr_get_src(instr, 2);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vporq", true, true, true, true);
#endif
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t src1_reg = opnd_get_reg(src_opnd1);
    reg_id_t src2_reg = opnd_get_reg(src_opnd2);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    if (IS_XMM_REG(dst_reg)) {
        return vporq_xmm_and_xmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
    }
    if (IS_YMM_REG(dst_reg)) {
        return vporq_ymm_and_ymm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
    }
    if (IS_ZMM_REG(dst_reg)) {
        return vporq_zmm_and_zmm_gen(dcontext, ilist, instr, src1_reg, src2_reg, dst_reg, mask_reg);
    }
    REWRITE_ERROR(STD_ERRF, "vpmullq pattern not support");
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vprolq
 * ============================================= */
instr_t *
vprolq_xmm_and_immed_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                         int8_t imm_int /* already mod 64*/, reg_id_t dst_reg, reg_id_t mask_reg)
{
    // vprolq {%k1} $0x01 %xmm2 -> %xmm3
    opnd_t src_opnd = create_mapping_xmm_opnd(dcontext, src_reg);
    opnd_t dst_opnd = create_mapping_xmm_opnd(dcontext, dst_reg);
    int8_t right_rotate_imm = imm_int;
    int8_t left_rotate_imm = 64 - right_rotate_imm;

    // we need to spill two simd registers to tls, xmm14 and xmm15
    // vmovdqu %xmm14, tls_slot(14)
    instr_t *new_instr1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, DR_REG_XMM14, TLS_ZMM_idx_SLOT(14), OPSZ_16);
    // vmovdqu %xmm15, tls_slot(15)
    instr_t *new_instr2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, DR_REG_XMM15, TLS_ZMM_idx_SLOT(15), OPSZ_16);

    // vmovdqu %xmm2, %xmm14
    instr_t *new_instr3 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_reg(DR_REG_XMM14), src_opnd);
    // vmovdqu %xmm2, %xmm15
    instr_t *new_instr4 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_reg(DR_REG_XMM15), src_opnd);

    // psllq $0x01, %xmm14
    instr_t *new_instr5 =
        INSTR_CREATE_vpsllq(dcontext, opnd_create_reg(DR_REG_XMM14), opnd_create_immed_int(right_rotate_imm, OPSZ_1),
                            opnd_create_reg(DR_REG_XMM14));
    // psrlq $0x01, %xmm15
    instr_t *new_instr6 =
        INSTR_CREATE_vpsrlq(dcontext, opnd_create_reg(DR_REG_XMM15), opnd_create_immed_int(left_rotate_imm, OPSZ_1),
                            opnd_create_reg(DR_REG_XMM15));

    // vpor %xmm15, %xmm14, %xmm3
    instr_t *new_instr7 = instr_create_1dst_2src(dcontext, OP_vpor, dst_opnd, opnd_create_reg(DR_REG_XMM15),
                                                 opnd_create_reg(DR_REG_XMM14));

    // restore xmm14 and xmm15 from tls slot
    instr_t *new_instr8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, DR_REG_XMM14, TLS_ZMM_idx_SLOT(14), OPSZ_16);
    instr_t *new_instr9 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, DR_REG_XMM15, TLS_ZMM_idx_SLOT(15), OPSZ_16);

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    instrlist_concat_next_instr(ilist, 9, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5, new_instr6,
                                new_instr7, new_instr8, new_instr9);

#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 9, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5, new_instr6,
                                 new_instr7, new_instr8, new_instr9);
    NEWLINE(STD_OUTF);
#endif
    return new_instr1;
}

instr_t *
vprolq_xmm_and_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                       int8_t imm_int /* already mod 64*/, reg_id_t dst_reg, reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "vprolq {%k1} %ymm0 %ymm1 -> %ymm2 not support");
#endif
    return NULL_INSTR;
}

instr_t *
vprolq_ymm_and_immed_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                         int8_t imm_int /* already mod 64*/, reg_id_t dst_reg, reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "vprolq {%k1} %ymm0 %ymm1 -> %ymm2 not support");
#endif
    return NULL_INSTR;
}

instr_t *
vprolq_ymm_and_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                       int8_t imm_int /* already mod 64*/, reg_id_t dst_reg, reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "vprolq {%k1} %ymm0 %ymm1 -> %ymm2 not support");
#endif
    return NULL_INSTR;
}

instr_t *
vprolq_zmm_and_immed_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                         int8_t imm_int /* already mod 64*/, reg_id_t dst_reg, reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "vprolq {%k1} %zmm0 %zmm1 -> %zmm2 not support");
#endif
    return NULL_INSTR;
}

instr_t *
vprolq_zmm_and_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                       int8_t imm_int /* already mod 64*/, reg_id_t dst_reg, reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "vprolq {%k1} %zmm0 %zmm1 -> %zmm2 not support");
#endif
    return NULL_INSTR;
}

instr_t * /* 693 */
rw_func_vprolq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vprolq {%k0} $0x01 %xmm2 -> %xmm3
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vprolq", true, true, true, true);
#endif
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t imm_or_src1_opnd = instr_get_src(instr, 1); // need to check if this is imm or another src
    opnd_t src_opnd = instr_get_src(instr, 2);
    opnd_t dst_opnd = instr_get_dst(instr, 0);

    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t src2_reg = opnd_get_reg(src_opnd);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);

    int8_t imm_int = 0;
    reg_id_t src1_reg = 0;

    switch (imm_or_src1_opnd.kind) {
    case IMMED_INTEGER_kind:
        // imm8 is 1 in the above example
        imm_int = (opnd_get_immed_int(imm_or_src1_opnd)) % 64;
        if (IS_XMM_REG(dst_reg))
            return vprolq_xmm_and_immed_gen(dcontext, ilist, instr, src2_reg, imm_int, dst_reg, mask_reg);
        if (IS_YMM_REG(dst_reg))
            return vprolq_ymm_and_immed_gen(dcontext, ilist, instr, src2_reg, imm_int, dst_reg, mask_reg);
        if (IS_ZMM_REG(dst_reg))
            return vprolq_zmm_and_immed_gen(dcontext, ilist, instr, src2_reg, imm_int, dst_reg, mask_reg);
        break;
    case REG_kind:
        src1_reg = opnd_get_reg(imm_or_src1_opnd);
        if (IS_XMM_REG(dst_reg))
            return vprolq_xmm_and_xmm_gen(dcontext, ilist, instr, src1_reg, imm_int, dst_reg, mask_reg);
        if (IS_YMM_REG(dst_reg))
            return vprolq_ymm_and_ymm_gen(dcontext, ilist, instr, src1_reg, imm_int, dst_reg, mask_reg);
        if (IS_ZMM_REG(dst_reg))
            return vprolq_zmm_and_zmm_gen(dcontext, ilist, instr, src1_reg, imm_int, dst_reg, mask_reg);
        break;
    default: REWRITE_ERROR(STD_ERRF, "vprolq imm or src opnd kind not support"); return NULL_INSTR;
    }

    // 1. vprorq {%k1} $0x01 %xmm2 -> %xmm3  => VPRORD ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8
    // 2. vprorq {%k1} %ymm2, %ymm3 -> %ymm4 => VPRORVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst

    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vprord
 * ============================================= */

instr_t *
vprord_xmm_and_immed_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                         int8_t imm_int /* already mod 64*/, reg_id_t dst_reg, reg_id_t mask_reg)
{
    // vprord {%k0} $0x01 %xmm2 -> %xmm3
    opnd_t src_opnd = create_mapping_xmm_opnd(dcontext, src_reg);
    opnd_t dst_opnd = create_mapping_xmm_opnd(dcontext, dst_reg);
    int8_t right_rotate_imm = imm_int;
    int8_t left_rotate_imm = 64 - right_rotate_imm;

    // we need to spill two simd registers to tls, xmm14 and xmm15
    // vmovdqu %xmm14, tls_slot(14)
    instr_t *new_instr1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, DR_REG_XMM14, TLS_ZMM_idx_SLOT(14), OPSZ_16);
    // vmovdqu %xmm15, tls_slot(15)
    instr_t *new_instr2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, DR_REG_XMM15, TLS_ZMM_idx_SLOT(15), OPSZ_16);

    // vmovdqu %xmm2, %xmm14
    instr_t *new_instr3 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_reg(DR_REG_XMM14), src_opnd);
    // vmovdqu %xmm3, %xmm15
    instr_t *new_instr4 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_reg(DR_REG_XMM15), src_opnd);

    // psrld $0x01, %xmm14
    // psrld $0x01, %xmm14
    instr_t *new_instr5 =
        INSTR_CREATE_psrld(dcontext, opnd_create_reg(DR_REG_XMM14), opnd_create_immed_int(right_rotate_imm, OPSZ_1));
    // pslld $0x01, %xmm15
    // pslld $0x01, %xmm15
    instr_t *new_instr6 =
        INSTR_CREATE_pslld(dcontext, opnd_create_reg(DR_REG_XMM15), opnd_create_immed_int(left_rotate_imm, OPSZ_1));

    // vpor %xmm15, %xmm14, %xmm3
    instr_t *new_instr7 = instr_create_1dst_2src(dcontext, OP_vpor, dst_opnd, opnd_create_reg(DR_REG_XMM15),
                                                 opnd_create_reg(DR_REG_XMM14));

    // restore xmm14 and xmm15 from tls slot
    instr_t *new_instr8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, DR_REG_XMM14, TLS_ZMM_idx_SLOT(14), OPSZ_16);
    instr_t *new_instr9 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, DR_REG_XMM15, TLS_ZMM_idx_SLOT(15), OPSZ_16);

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    instrlist_concat_next_instr(ilist, 9, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5, new_instr6,
                                new_instr7, new_instr8, new_instr9);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 9, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5, new_instr6,
                                 new_instr7, new_instr8, new_instr9);
    NEWLINE(STD_OUTF);
#endif
    return new_instr1;
}

instr_t *
vprord_xmm_and_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                       int8_t imm_int /* already mod 64*/, reg_id_t dst_reg, reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "vprord {%k1} %xmm0 %xmm1 -> %xmm2 not support");
#endif
    return NULL_INSTR;
}

instr_t *
vprord_ymm_and_immed_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                         int8_t imm_int /* already mod 64*/, reg_id_t dst_reg, reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "vprord {%k1} %ymm0 %ymm1 -> %ymm2 not support");
#endif
    return NULL_INSTR;
}

instr_t *
vprord_ymm_and_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                       int8_t imm_int /* already mod 64*/, reg_id_t dst_reg, reg_id_t mask_reg)
{

    return NULL_INSTR;
}

instr_t *
vprord_zmm_and_immed_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                         int8_t imm_int /* already mod 64*/, reg_id_t dst_reg, reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "vprord {%k1} %zmm0 %zmm1 -> %zmm2 not support");
#endif
    return NULL_INSTR;
}

instr_t *
vprord_zmm_and_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                       int8_t imm_int /* already mod 64*/, reg_id_t dst_reg, reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "vprord {%k1} %zmm0 %zmm1 -> %zmm2 not support");
#endif
    return NULL_INSTR;
}

instr_t * /* 697 */
rw_func_vprord(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vprord {%k0} $0x01 %xmm2 -> %xmm3
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vprord", true, true, true, true);
#endif
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t imm_or_src1_opnd = instr_get_src(instr, 1);
    opnd_t imm_or_src1_opnd = instr_get_src(instr, 1);
    opnd_t src2_opnd = instr_get_src(instr, 2);
    opnd_t dst_opnd = instr_get_dst(instr, 0);

    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t src2_reg = opnd_get_reg(src2_opnd);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);

    int8_t imm_int = 0;
    reg_id_t src1_reg = 0;

    switch (imm_or_src1_opnd.kind) {
    case IMMED_INTEGER_kind:
        // imm8 is 1 in the above example
        imm_int = (opnd_get_immed_int(imm_or_src1_opnd)) % 64;
        if (IS_XMM_REG(dst_reg))
            return vprord_xmm_and_immed_gen(dcontext, ilist, instr, src2_reg, imm_int, dst_reg, mask_reg);
        if (IS_YMM_REG(dst_reg))
            return vprord_ymm_and_immed_gen(dcontext, ilist, instr, src2_reg, imm_int, dst_reg, mask_reg);
        if (IS_ZMM_REG(dst_reg))
            return vprord_zmm_and_immed_gen(dcontext, ilist, instr, src2_reg, imm_int, dst_reg, mask_reg);
        break;
    case REG_kind:
        src1_reg = opnd_get_reg(imm_or_src1_opnd);
        if (IS_XMM_REG(dst_reg))
            return vprord_xmm_and_xmm_gen(dcontext, ilist, instr, src1_reg, imm_int, dst_reg, mask_reg);
        if (IS_YMM_REG(dst_reg))
            return vprord_ymm_and_ymm_gen(dcontext, ilist, instr, src1_reg, imm_int, dst_reg, mask_reg);
        if (IS_ZMM_REG(dst_reg))
            return vprord_zmm_and_zmm_gen(dcontext, ilist, instr, src1_reg, imm_int, dst_reg, mask_reg);
        break;
    default: REWRITE_ERROR(STD_ERRF, "vprord imm or src opnd kind not support"); return NULL_INSTR;
    }
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vprorq
 * ============================================= */

instr_t *
vprorq_xmm_and_immed_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                         int8_t imm_int /* already mod 64*/, reg_id_t dst_reg, reg_id_t mask_reg)
{
    // vprorq {%k0} $0x01 %xmm2 -> %xmm3
    opnd_t src_opnd = create_mapping_xmm_opnd(dcontext, src_reg);
    opnd_t dst_opnd = create_mapping_xmm_opnd(dcontext, dst_reg);
    int8_t right_rotate_imm = imm_int;
    int8_t left_rotate_imm = 64 - right_rotate_imm;

    // we need to spill two simd registers to tls, xmm14 and xmm15
    // vmovdqu %xmm14, tls_slot(14)
    instr_t *new_instr1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, DR_REG_XMM14, TLS_ZMM_idx_SLOT(14), OPSZ_16);
    // vmovdqu %xmm15, tls_slot(15)
    instr_t *new_instr2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, DR_REG_XMM15, TLS_ZMM_idx_SLOT(15), OPSZ_16);

    // vmovdqu %xmm2, %xmm14
    instr_t *new_instr3 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_reg(DR_REG_XMM14), src_opnd);
    // vmovdqu %xmm3, %xmm15
    instr_t *new_instr4 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_reg(DR_REG_XMM15), src_opnd);

    // psrlq $0x01, %xmm14
    // psrlq $0x01, %xmm14
    instr_t *new_instr5 =
        INSTR_CREATE_vpsrlq(dcontext, opnd_create_reg(DR_REG_XMM14), opnd_create_immed_int(right_rotate_imm, OPSZ_1),
                            opnd_create_reg(DR_REG_XMM14));
    // psllq $0x01, %xmm15
        INSTR_CREATE_psrlq(dcontext, opnd_create_reg(DR_REG_XMM14), opnd_create_immed_int(right_rotate_imm, OPSZ_1));
    // psllq $0x01, %xmm15
    instr_t *new_instr6 =
        INSTR_CREATE_vpsllq(dcontext, opnd_create_reg(DR_REG_XMM15), opnd_create_immed_int(left_rotate_imm, OPSZ_1),
                            opnd_create_reg(DR_REG_XMM15));

    // vpor %xmm15, %xmm14, %xmm3
    instr_t *new_instr7 = instr_create_1dst_2src(dcontext, OP_vpor, dst_opnd, opnd_create_reg(DR_REG_XMM15),
                                                 opnd_create_reg(DR_REG_XMM14));

    // restore xmm14 and xmm15 from tls slot
    instr_t *new_instr8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, DR_REG_XMM14, TLS_ZMM_idx_SLOT(14), OPSZ_16);
    instr_t *new_instr9 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, DR_REG_XMM15, TLS_ZMM_idx_SLOT(15), OPSZ_16);

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    instrlist_concat_next_instr(ilist, 9, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5, new_instr6,
                                new_instr7, new_instr8, new_instr9);
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 9, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5, new_instr6,
                                 new_instr7, new_instr8, new_instr9);
    NEWLINE(STD_OUTF);
#endif
    return new_instr1;
}

instr_t *
vprorq_xmm_and_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                       int8_t imm_int /* already mod 64*/, reg_id_t dst_reg, reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "vprorq {%k1} %xmm0 %xmm1 -> %xmm2 not support");
#endif
    return NULL_INSTR;
}

instr_t *
vprorq_ymm_and_immed_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                         int8_t imm_int /* already mod 64*/, reg_id_t dst_reg, reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "vprorq {%k1} %ymm0 %ymm1 -> %ymm2 not support");
#endif
    return NULL_INSTR;
}

instr_t *
vprorq_ymm_and_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                       int8_t imm_int /* already mod 64*/, reg_id_t dst_reg, reg_id_t mask_reg)
{

    return NULL_INSTR;
}

instr_t *
vprorq_zmm_and_immed_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                         int8_t imm_int /* already mod 64*/, reg_id_t dst_reg, reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "vprorq {%k1} %zmm0 %zmm1 -> %zmm2 not support");
#endif
    return NULL_INSTR;
}

instr_t *
vprorq_zmm_and_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg,
                       int8_t imm_int /* already mod 64*/, reg_id_t dst_reg, reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "vprorq {%k1} %zmm0 %zmm1 -> %zmm2 not support");
#endif
    return NULL_INSTR;
}

instr_t * /* 697 */
rw_func_vprorq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vprorq {%k0} $0x01 %xmm2 -> %xmm3
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vprorq", true, true, true, true);
#endif
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t imm_or_src1_opnd = instr_get_src(instr, 1);
    opnd_t src2_opnd = instr_get_src(instr, 2);
    opnd_t dst_opnd = instr_get_dst(instr, 0);

    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t src2_reg = opnd_get_reg(src2_opnd);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);

    int8_t imm_int = 0;
    reg_id_t src1_reg = 0;

    switch (imm_or_src1_opnd.kind) {
    case IMMED_INTEGER_kind:
        // imm8 is 1 in the above example
        imm_int = (opnd_get_immed_int(imm_or_src1_opnd)) % 64;
        if (IS_XMM_REG(dst_reg))
            return vprorq_xmm_and_immed_gen(dcontext, ilist, instr, src2_reg, imm_int, dst_reg, mask_reg);
        if (IS_YMM_REG(dst_reg))
            return vprorq_ymm_and_immed_gen(dcontext, ilist, instr, src2_reg, imm_int, dst_reg, mask_reg);
        if (IS_ZMM_REG(dst_reg))
            return vprorq_zmm_and_immed_gen(dcontext, ilist, instr, src2_reg, imm_int, dst_reg, mask_reg);
        break;
    case REG_kind:
        src1_reg = opnd_get_reg(imm_or_src1_opnd);
        if (IS_XMM_REG(dst_reg))
            return vprorq_xmm_and_xmm_gen(dcontext, ilist, instr, src1_reg, imm_int, dst_reg, mask_reg);
        if (IS_YMM_REG(dst_reg))
            return vprorq_ymm_and_ymm_gen(dcontext, ilist, instr, src1_reg, imm_int, dst_reg, mask_reg);
        if (IS_ZMM_REG(dst_reg))
            return vprorq_zmm_and_zmm_gen(dcontext, ilist, instr, src1_reg, imm_int, dst_reg, mask_reg);
        break;
    default: REWRITE_ERROR(STD_ERRF, "vprorq imm or src opnd kind not support"); return NULL_INSTR;
    }
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vpscatterdd
 * ============================================= */

instr_t *
vpscatterdd_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t data_ymm_reg,
                    reg_id_t index_ymm_reg, opnd_t dst_mem_opnd, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
vpscatterdd_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t data_ymm_reg,
                    reg_id_t index_ymm_reg, opnd_t dst_mem_opnd, reg_id_t mask_reg)
{
    /* vpscatterdd {%k?} %ymm<data> -> (BASE,%ymm<index>,4) */

    /* ---- 0. parse operands ---- */
    reg_id_t base_reg = opnd_get_base(dst_mem_opnd); /* BASE GPR */

#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "data_ymm_reg: ymm%d", data_ymm_reg - DR_REG_YMM0);
    REWRITE_INFO(STD_OUTF, "index_ymm_reg: ymm%d", index_ymm_reg - DR_REG_YMM0);
    REWRITE_INFO(STD_OUTF, "mask_reg: k%d", mask_reg - DR_REG_K0);
    REWRITE_INFO(STD_OUTF, "base_reg: %d", base_reg);
#endif

    /* remove original instruction */
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    /* ---- 1. reserve stack & TLS ---- */
    int k_idx = TO_K_REG_INDEX(mask_reg);

    /* jump labels */
    instr_t *SKIP0 = INSTR_CREATE_label(dcontext);
    instr_t *SKIP1 = INSTR_CREATE_label(dcontext);
    instr_t *SKIP2 = INSTR_CREATE_label(dcontext);
    instr_t *SKIP3 = INSTR_CREATE_label(dcontext);
    instr_t *SKIP4 = INSTR_CREATE_label(dcontext);
    instr_t *SKIP5 = INSTR_CREATE_label(dcontext);
    instr_t *SKIP6 = INSTR_CREATE_label(dcontext);
    instr_t *SKIP7 = INSTR_CREATE_label(dcontext);

    /* alias for common operands */
    opnd_t op_rax = opnd_create_reg(DR_REG_RAX);
    opnd_t op_eax = opnd_create_reg(DR_REG_EAX);
    opnd_t op_rdx = opnd_create_reg(DR_REG_RDX);
    opnd_t op_rbx = opnd_create_reg(DR_REG_RBX);
    opnd_t op_rdi = opnd_create_reg(DR_REG_RDI);
    opnd_t op_rcx = opnd_create_reg(DR_REG_RCX);
    opnd_t op_ecx = opnd_create_reg(DR_REG_ECX);

    /* ---- 2. prologue (save registers/stack space) ---- */
    instr_t *i1 = INSTR_CREATE_push(dcontext, op_rax); /* save RAX   */
    instr_t *i2 = INSTR_CREATE_mov_ld(dcontext, op_rax, opnd_create_reg(base_reg));
    instr_t *i3 = INSTR_CREATE_push(dcontext, op_rdx); /* save RDX   */
    instr_t *i4 = INSTR_CREATE_push(dcontext, op_rbx); /* save RBX   */
    instr_t *i5 = INSTR_CREATE_push(dcontext, op_rdi); /* save RDI   */
    instr_t *i6 = INSTR_CREATE_push(dcontext, op_rcx); /* save RCX   */
    instr_t *i7 = INSTR_CREATE_pushf(dcontext);        /* save EFLAGS*/

    instr_t *i8 = INSTR_CREATE_sub(dcontext, opnd_create_reg(DR_REG_RSP),
                                   opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4)); /* 64B scratch*/

    /* store YMM data&index to stack */
    instr_t *i9 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0, OPSZ_32),
                                       opnd_create_reg(data_ymm_reg));
    instr_t *i10 = INSTR_CREATE_vmovdqu(dcontext, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32, OPSZ_32),
                                        opnd_create_reg(index_ymm_reg));

    /* RDX = mask k? */
    instr_t *i11 = RESTORE_FROM_TLS(dcontext, DR_REG_RDX, TLS_K_idx_SLOT(k_idx));
    /* RBX = BASE */
    instr_t *i12 = INSTR_CREATE_mov_ld(dcontext, op_rbx, op_rax);

    /* =========================================================
     *  Lane 0
     * ========================================================= */
    instr_t *i13 = INSTR_CREATE_bt(dcontext, op_rdx, opnd_create_immed_int(0, OPSZ_1));
    instr_t *i14 = INSTR_CREATE_jcc(dcontext, OP_jnb_short, opnd_create_instr(SKIP0));
    /* RAX = index[0] */
    instr_t *i15 =
        INSTR_CREATE_mov_ld(dcontext, op_eax, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32 + 0, OPSZ_4));
    /* RDI = BASE + index[0]*4 */
    instr_t *i16 = INSTR_CREATE_lea(dcontext, op_rdi, opnd_create_base_disp(DR_REG_RBX, DR_REG_RAX, 4, 0, OPSZ_lea));
    /* ECX = data[0] */
    instr_t *i17 =
        INSTR_CREATE_mov_ld(dcontext, op_ecx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0 + 0, OPSZ_4));
    /* *(addr) = ECX */
    instr_t *i18 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RDI, DR_REG_NULL, 0, 0, OPSZ_4), op_ecx);

    /* =========================================================
     *  Lane 1
     * ========================================================= */
    instr_t *i19 = INSTR_CREATE_bt(dcontext, op_rdx, opnd_create_immed_int(1, OPSZ_1));
    instr_t *i20 = INSTR_CREATE_jcc(dcontext, OP_jnb_short, opnd_create_instr(SKIP1));
    instr_t *i21 =
        INSTR_CREATE_mov_ld(dcontext, op_eax, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32 + 4, OPSZ_4));
    instr_t *i22 = INSTR_CREATE_lea(dcontext, op_rdi, opnd_create_base_disp(DR_REG_RBX, DR_REG_RAX, 4, 0, OPSZ_lea));
    instr_t *i23 =
        INSTR_CREATE_mov_ld(dcontext, op_ecx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0 + 4, OPSZ_4));
    instr_t *i24 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RDI, DR_REG_NULL, 0, 0, OPSZ_4), op_ecx);

    /* =========================================================
     *  Lane 2
     * ========================================================= */
    instr_t *i25 = INSTR_CREATE_bt(dcontext, op_rdx, opnd_create_immed_int(2, OPSZ_1));
    instr_t *i26 = INSTR_CREATE_jcc(dcontext, OP_jnb_short, opnd_create_instr(SKIP2));
    instr_t *i27 =
        INSTR_CREATE_mov_ld(dcontext, op_eax, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32 + 8, OPSZ_4));
    instr_t *i28 = INSTR_CREATE_lea(dcontext, op_rdi, opnd_create_base_disp(DR_REG_RBX, DR_REG_RAX, 4, 0, OPSZ_lea));
    instr_t *i29 =
        INSTR_CREATE_mov_ld(dcontext, op_ecx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0 + 8, OPSZ_4));
    instr_t *i30 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RDI, DR_REG_NULL, 0, 0, OPSZ_4), op_ecx);

    /* =========================================================
     *  Lane 3
     * ========================================================= */
    instr_t *i31 = INSTR_CREATE_bt(dcontext, op_rdx, opnd_create_immed_int(3, OPSZ_1));
    instr_t *i32 = INSTR_CREATE_jcc(dcontext, OP_jnb_short, opnd_create_instr(SKIP3));
    instr_t *i33 =
        INSTR_CREATE_mov_ld(dcontext, op_eax, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32 + 12, OPSZ_4));
    instr_t *i34 = INSTR_CREATE_lea(dcontext, op_rdi, opnd_create_base_disp(DR_REG_RBX, DR_REG_RAX, 4, 0, OPSZ_lea));
    instr_t *i35 =
        INSTR_CREATE_mov_ld(dcontext, op_ecx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0 + 12, OPSZ_4));
    instr_t *i36 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RDI, DR_REG_NULL, 0, 0, OPSZ_4), op_ecx);

    /* =========================================================
     *  Lane 4
     * ========================================================= */
    instr_t *i37 = INSTR_CREATE_bt(dcontext, op_rdx, opnd_create_immed_int(4, OPSZ_1));
    instr_t *i38 = INSTR_CREATE_jcc(dcontext, OP_jnb_short, opnd_create_instr(SKIP4));
    instr_t *i39 =
        INSTR_CREATE_mov_ld(dcontext, op_eax, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32 + 16, OPSZ_4));
    instr_t *i40 = INSTR_CREATE_lea(dcontext, op_rdi, opnd_create_base_disp(DR_REG_RBX, DR_REG_RAX, 4, 0, OPSZ_lea));
    instr_t *i41 =
        INSTR_CREATE_mov_ld(dcontext, op_ecx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0 + 16, OPSZ_4));
    instr_t *i42 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RDI, DR_REG_NULL, 0, 0, OPSZ_4), op_ecx);

    /* =========================================================
     *  Lane 5
     * ========================================================= */
    instr_t *i43 = INSTR_CREATE_bt(dcontext, op_rdx, opnd_create_immed_int(5, OPSZ_1));
    instr_t *i44 = INSTR_CREATE_jcc(dcontext, OP_jnb_short, opnd_create_instr(SKIP5));
    instr_t *i45 =
        INSTR_CREATE_mov_ld(dcontext, op_eax, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32 + 20, OPSZ_4));
    instr_t *i46 = INSTR_CREATE_lea(dcontext, op_rdi, opnd_create_base_disp(DR_REG_RBX, DR_REG_RAX, 4, 0, OPSZ_lea));
    instr_t *i47 =
        INSTR_CREATE_mov_ld(dcontext, op_ecx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0 + 20, OPSZ_4));
    instr_t *i48 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RDI, DR_REG_NULL, 0, 0, OPSZ_4), op_ecx);

    /* =========================================================
     *  Lane 6
     * ========================================================= */
    instr_t *i49 = INSTR_CREATE_bt(dcontext, op_rdx, opnd_create_immed_int(6, OPSZ_1));
    instr_t *i50 = INSTR_CREATE_jcc(dcontext, OP_jnb_short, opnd_create_instr(SKIP6));
    instr_t *i51 =
        INSTR_CREATE_mov_ld(dcontext, op_eax, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32 + 24, OPSZ_4));
    instr_t *i52 = INSTR_CREATE_lea(dcontext, op_rdi, opnd_create_base_disp(DR_REG_RBX, DR_REG_RAX, 4, 0, OPSZ_lea));
    instr_t *i53 =
        INSTR_CREATE_mov_ld(dcontext, op_ecx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0 + 24, OPSZ_4));
    instr_t *i54 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RDI, DR_REG_NULL, 0, 0, OPSZ_4), op_ecx);

    /* =========================================================
     *  Lane 7
     * ========================================================= */
    instr_t *i55 = INSTR_CREATE_bt(dcontext, op_rdx, opnd_create_immed_int(7, OPSZ_1));
    instr_t *i56 = INSTR_CREATE_jcc(dcontext, OP_jnb_short, opnd_create_instr(SKIP7));
    instr_t *i57 =
        INSTR_CREATE_mov_ld(dcontext, op_eax, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 32 + 28, OPSZ_4));
    instr_t *i58 = INSTR_CREATE_lea(dcontext, op_rdi, opnd_create_base_disp(DR_REG_RBX, DR_REG_RAX, 4, 0, OPSZ_lea));
    instr_t *i59 =
        INSTR_CREATE_mov_ld(dcontext, op_ecx, opnd_create_base_disp(DR_REG_RSP, DR_REG_NULL, 0, 0 + 28, OPSZ_4));
    instr_t *i60 = INSTR_CREATE_mov_st(dcontext, opnd_create_base_disp(DR_REG_RDI, DR_REG_NULL, 0, 0, OPSZ_4), op_ecx);

    /* ---- 5. clean up ---- */
    instr_t *i61 = INSTR_CREATE_xor(dcontext, op_rax, op_rax);               /* RAX = 0    */
    instr_t *i62 = SAVE_TO_TLS(dcontext, DR_REG_RAX, TLS_K_idx_SLOT(k_idx)); /* k to 0?      */

    instr_t *i63 =
        INSTR_CREATE_add(dcontext, opnd_create_reg(DR_REG_RSP), opnd_create_immed_int(SIZE_OF_YMM * 2, OPSZ_4));
    instr_t *i64 = INSTR_CREATE_popf(dcontext);
    instr_t *i65 = INSTR_CREATE_pop(dcontext, op_rcx);
    instr_t *i66 = INSTR_CREATE_pop(dcontext, op_rdi);
    instr_t *i67 = INSTR_CREATE_pop(dcontext, op_rbx);
    instr_t *i68 = INSTR_CREATE_pop(dcontext, op_rdx);
    instr_t *i69 = INSTR_CREATE_pop(dcontext, op_rax);

#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 77, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16,
                                 i17, i18, SKIP0, i19, i20, i21, i22, i23, i24, SKIP1, i25, i26, i27, i28, i29, i30,
                                 SKIP2, i31, i32, i33, i34, i35, i36, SKIP3, i37, i38, i39, i40, i41, i42, SKIP4, i43,
                                 i44, i45, i46, i47, i48, SKIP5, i49, i50, i51, i52, i53, i54, SKIP6, i55, i56, i57,
                                 i58, i59, i60, SKIP7, i61, i62, i63, i64, i65, i66, i67, i68, i69);
#endif

    instrlist_concat_next_instr(ilist, 77, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17,
                                i18, SKIP0, i19, i20, i21, i22, i23, i24, SKIP1, i25, i26, i27, i28, i29, i30, SKIP2,
                                i31, i32, i33, i34, i35, i36, SKIP3, i37, i38, i39, i40, i41, i42, SKIP4, i43, i44, i45,
                                i46, i47, i48, SKIP5, i49, i50, i51, i52, i53, i54, SKIP6, i55, i56, i57, i58, i59, i60,
                                SKIP7, i61, i62, i63, i64, i65, i66, i67, i68, i69);
    return i1;
}

instr_t *
vpscatterdd_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg1, reg_id_t src_reg2,
                    opnd_t dst_opnd, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t * /* 700 */
rw_func_vpscatterdd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vpscatterdd {%k2} %ymm0 -> (%rax,%ymm7,4)[4byte] %k2
    opnd_t mask_opnd = instr_get_src(instr, 0); // %k2
    opnd_t src_opnd = instr_get_src(instr, 1);  // %ymm0
    opnd_t dst_opnd = instr_get_dst(instr, 0);  // (%rax,%ymm7,4)[4byte]
    // output mask and input mask are the same, so we can use the same mask register

    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t src_data_reg = opnd_get_reg(src_opnd);
    reg_id_t dst_index_reg = opnd_get_index(dst_opnd);

#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting vpscatterdd at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, mask_opnd, "  src mask:");
    dr_print_opnd(dcontext, STD_OUTF, src_opnd, "  src:");
    dr_print_opnd(dcontext, STD_OUTF, dst_opnd, "  dst:");
    // theoretically, dst2 is the mask_finished_opnd, and should be the same reg as mask_reg
    opnd_t mask_finished_opnd = instr_get_dst(instr, 1);
    dr_print_opnd(dcontext, STD_OUTF, mask_finished_opnd, "  dst mask:");
#endif

    if (IS_YMM_REG(src_data_reg)) {
        return vpscatterdd_ymm_gen(dcontext, ilist, instr, src_data_reg, dst_index_reg, dst_opnd, mask_reg);
    }
    if (IS_XMM_REG(src_data_reg)) {
        return vpscatterdd_xmm_gen(dcontext, ilist, instr, src_data_reg, dst_index_reg, dst_opnd, mask_reg);
    }
    if (IS_ZMM_REG(src_data_reg)) {
        return vpscatterdd_zmm_gen(dcontext, ilist, instr, src_data_reg, dst_index_reg, dst_opnd, mask_reg);
    }
    return NULL_INSTR;
}

instr_t *
rw_func_vpscatterdq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    return NULL_INSTR;
}

instr_t *
rw_func_vpscatterqd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    return NULL_INSTR;
}

instr_t *
rw_func_vpscatterqq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vpxord
 * ============================================= */

instr_t *
vpxord_xmm_and_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src1_reg, reg_id_t src2_reg,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    if (src1_reg == src2_reg) {
        const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
        if (src1_reg == dst_reg) { /* src1 == src2 == dst*/
            switch (src1_need_spill_flag) {
            case 0: { /* all don't need spill */
                // rewrite vpxor
                // vpxor src1_reg, src2_reg -> dst_reg
                instr_t *i1 = INSTR_CREATE_vpxor(dcontext, opnd_create_reg(dst_reg), opnd_create_reg(src1_reg),
                                                 opnd_create_reg(src2_reg));
#ifdef DEBUG
                print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
                return i1;
            } break;
            case 1: { /* all needs spill */
                // NOTE: quick path: if src1 == src2, and need spill, then we don't care what's in src, since after xor,
                // it will be 0 find spill reg
                reg_id_t spill_reg_ymm = find_one_available_spill_ymm(src1_reg);
                reg_id_t spill_reg_xmm = YMM_TO_XMM(spill_reg_ymm);
                // spill_reg -> tls_slot(spill_reg)
                instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg_ymm,
                                                     TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_reg_ymm)), OPSZ_32);
                // vpxor spill_reg, spill_reg, spill_reg
                instr_t *i2 = INSTR_CREATE_vpxor(dcontext, opnd_create_reg(spill_reg_xmm),
                                                 opnd_create_reg(spill_reg_xmm), opnd_create_reg(spill_reg_xmm));
                // spill_reg -> tls_slot(src1/src2/dst_reg)
                instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_reg_ymm,
                                                     TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_32);
                // tls_slot(spill_reg) -> spill_reg
                instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_reg_ymm,
                                                          TLS_ZMM_idx_SLOT(TO_YMM_REG_INDEX(spill_reg_ymm)), OPSZ_32);

#ifdef DEBUG
                print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
                instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
                return i1;
            } break;
            default: REWRITE_ERROR(STD_ERRF, "vpxord pattern not support");
            }
        } else { /* src1 == src2, src1 != dst, src2 != dst */
            const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 2 : 0;
            const uint need_spill_flag = src1_need_spill_flag | dst_need_spill_flag;
            switch (need_spill_flag) {
            case 0: { /* all don't need spill */
                // rewrite vpxor
                // vpxor src1_reg, src2_reg -> dst_reg
                instr_t *i1 = INSTR_CREATE_vpxor(dcontext, opnd_create_reg(dst_reg), opnd_create_reg(src1_reg),
                                                 opnd_create_reg(src2_reg));
#ifdef DEBUG
                print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
                return i1;
            } break;
            case 1: { /* src1==src2 needs spill */
                // src1 == src2, result is 0, dst doesn't need spill
                // vpxor dst_reg, dst_reg, dst_reg - clear dst to 0
                instr_t *i1 = INSTR_CREATE_vpxor(dcontext, opnd_create_reg(dst_reg), opnd_create_reg(dst_reg),
                                                 opnd_create_reg(dst_reg));
#ifdef DEBUG
                print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
                return i1;
            } break;
            case 2: { /* dst needs spill */
                // src1 == src2 (no spill), dst needs spill, result is 0
                reg_id_t spill_dst_reg = find_one_available_spill_xmm(dst_reg);
                // spill_dst_reg -> tls_slot(spill_dst_reg)
                instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                     TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
                // vpxor spill_dst_reg, spill_dst_reg, spill_dst_reg - clear to 0
                instr_t *i2 = INSTR_CREATE_vpxor(dcontext, opnd_create_reg(spill_dst_reg),
                                                 opnd_create_reg(spill_dst_reg), opnd_create_reg(spill_dst_reg));
                // spill_dst_reg -> tls_slot(dst_reg)
                instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                     TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
                // tls_slot(spill_dst_reg) -> spill_dst_reg
                instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                          TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
                print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
                instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
                return i1;
            } break;
            default: REWRITE_ERROR(STD_ERRF, "vpxord pattern not support");
            }
        }
    } else { /* src1 != src2 */
        const uint src1_need_spill_flag = NEED_SPILL_XMM(src1_reg) ? 1 : 0;
        const uint src2_need_spill_flag = NEED_SPILL_XMM(src2_reg) ? 2 : 0;
        const uint dst_need_spill_flag = NEED_SPILL_XMM(dst_reg) ? 4 : 0;

        const uint need_spill_flag = src1_need_spill_flag | src2_need_spill_flag | dst_need_spill_flag;

        switch (need_spill_flag) {
        case 0: { /* no spill */
            // rewrite vpxor
            // vpxor src1_reg, src2_reg -> dst_reg
            instr_t *i1 = INSTR_CREATE_vpxor(dcontext, opnd_create_reg(dst_reg), opnd_create_reg(src1_reg),
                                             opnd_create_reg(src2_reg));
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
            return i1;
        } break;
        case 1: { /* src1 needs spill */
            reg_id_t spill_src1_reg = find_one_available_spill_xmm(src1_reg);
            // spill_src1_reg -> tls_slot(spill_src1_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls_slot(src1_reg) -> spill_src1_reg
            instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // vpxor spill_src1_reg, src2_reg -> dst_reg
            instr_t *i3 = INSTR_CREATE_vpxor(dcontext, opnd_create_reg(dst_reg), opnd_create_reg(spill_src1_reg),
                                             opnd_create_reg(src2_reg));
            // tls_slot(spill_src1_reg) -> spill_src1_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
            instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
            return i1;
        } break;
        case 2: { /* src2 needs spill */
            reg_id_t spill_src2_reg = find_one_available_spill_xmm(src2_reg);
            // spill_src2_reg -> tls_slot(spill_src2_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls_slot(src2_reg) -> spill_src2_reg
            instr_t *i2 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vpxor src1_reg, spill_src2_reg -> dst_reg
            instr_t *i3 = INSTR_CREATE_vpxor(dcontext, opnd_create_reg(dst_reg), opnd_create_reg(src1_reg),
                                             opnd_create_reg(spill_src2_reg));
            // tls_slot(spill_src2_reg) -> spill_src2_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
            instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
            return i1;
        } break;
        case 3: { /* src1, src2 spill, dst not spill */
            reg_id_t spill_src1_reg = find_available_spill_xmm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
            reg_id_t spill_src2_reg = find_available_spill_xmm_avoiding(spill_src1_reg, dst_reg, DR_REG_NULL);
            // spill_src1_reg -> tls_slot(spill_src1_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2_reg -> tls_slot(spill_src2_reg)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls_slot(src1_reg) -> spill_src1_reg
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls_slot(src2_reg) -> spill_src2_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vpxor spill_src1_reg, spill_src2_reg -> dst_reg
            instr_t *i5 = INSTR_CREATE_vpxor(dcontext, opnd_create_reg(dst_reg), opnd_create_reg(spill_src1_reg),
                                             opnd_create_reg(spill_src2_reg));
            // tls_slot(spill_src1_reg) -> spill_src1_reg
            instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls_slot(spill_src2_reg) -> spill_src2_reg
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
            instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
            return i1;
        } break;
        case 4: { /* dst needs spill */
            reg_id_t spill_dst_reg = find_one_available_spill_xmm(dst_reg);
            // spill_dst_reg -> tls_slot(spill_dst_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
            // vpxor src1_reg, src2_reg -> spill_dst_reg
            instr_t *i2 = INSTR_CREATE_vpxor(dcontext, opnd_create_reg(spill_dst_reg), opnd_create_reg(src1_reg),
                                             opnd_create_reg(src2_reg));
            // spill_dst_reg -> tls_slot(dst_reg)
            instr_t *i3 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls_slot(spill_dst_reg) -> spill_dst_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
            instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
            return i1;
        } break;
        case 5: { /* src1 need spill, dst need spill */
            reg_id_t spill_src1_reg = find_available_spill_xmm_avoiding(src2_reg, dst_reg, DR_REG_NULL);
            reg_id_t spill_dst_reg = find_available_spill_xmm_avoiding(src1_reg, spill_src1_reg, DR_REG_NULL);
            // spill_src1_reg -> tls_slot(spill_src1_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_dst_reg -> tls_slot(spill_dst_reg)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
            // tls_slot(src1_reg) -> spill_src1_reg
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // vpxor spill_src1_reg, src2_reg -> spill_dst_reg
            instr_t *i4 = INSTR_CREATE_vpxor(dcontext, opnd_create_reg(spill_dst_reg), opnd_create_reg(spill_src1_reg),
                                             opnd_create_reg(src2_reg));
            // spill_dst_reg -> tls_slot(dst_reg)
            instr_t *i5 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls_slot(spill_src1_reg) -> spill_src1_reg
            instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls_slot(spill_dst_reg) -> spill_dst_reg
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
            instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
            return i1;
        } break;
        case 6: { /* src2 need spill, dst need spill */
            reg_id_t spill_src2_reg = find_available_spill_xmm_avoiding(src1_reg, dst_reg, DR_REG_NULL);
            reg_id_t spill_dst_reg = find_available_spill_xmm_avoiding(src2_reg, spill_src2_reg, DR_REG_NULL);
            // spill_src2_reg -> tls_slot(spill_src2_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // spill_dst_reg -> tls_slot(spill_dst_reg)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
            // tls_slot(src2_reg) -> spill_src2_reg
            instr_t *i3 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vpxor src1_reg, spill_src2_reg -> spill_dst_reg
            instr_t *i4 = INSTR_CREATE_vpxor(dcontext, opnd_create_reg(spill_dst_reg), opnd_create_reg(src1_reg),
                                             opnd_create_reg(spill_src2_reg));
            // spill_dst_reg -> tls_slot(dst_reg)
            instr_t *i5 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls_slot(spill_src2_reg) -> spill_src2_reg
            instr_t *i6 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls_slot(spill_dst_reg) -> spill_dst_reg
            instr_t *i7 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
            instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
            return i1;
        } break;
        case 7: { /* src1 need spill, src2 need spill, dst need spill */
            reg_id_t spill_src1_reg = XMM_SPILL_SLOT0;
            reg_id_t spill_src2_reg = XMM_SPILL_SLOT1;
            reg_id_t spill_dst_reg = XMM_SPILL_SLOT2;
            // spill_src1_reg -> tls_slot(spill_src1_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src1_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // spill_src2_reg -> tls_slot(spill_src2_reg)
            instr_t *i2 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_src2_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // spill_dst_reg -> tls_slot(spill_dst_reg)
            instr_t *i3 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
            // tls_slot(src1_reg) -> spill_src1_reg
            instr_t *i4 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src1_reg)), OPSZ_16);
            // tls_slot(src2_reg) -> spill_src2_reg
            instr_t *i5 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(src2_reg)), OPSZ_16);
            // vpxor spill_src1_reg, spill_src2_reg -> spill_dst_reg
            instr_t *i6 = INSTR_CREATE_vpxor(dcontext, opnd_create_reg(spill_dst_reg), opnd_create_reg(spill_src1_reg),
                                             opnd_create_reg(spill_src2_reg));
            // spill_dst_reg -> tls_slot(dst_reg)
            instr_t *i7 =
                SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_dst_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(dst_reg)), OPSZ_16);
            // tls_slot(spill_src1_reg) -> spill_src1_reg
            instr_t *i8 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src1_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src1_reg)), OPSZ_16);
            // tls_slot(spill_src2_reg) -> spill_src2_reg
            instr_t *i9 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_src2_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_src2_reg)), OPSZ_16);
            // tls_slot(spill_dst_reg) -> spill_dst_reg
            instr_t *i10 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_dst_reg,
                                                       TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_dst_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 10, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);
#endif
            instrlist_concat_next_instr(ilist, 10, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);
            return i1;
        } break;
        default: REWRITE_ERROR(STD_ERRF, "vpxord pattern not support");
        }
    }
    return NULL_INSTR;
}

instr_t *
vpxord_ymm_and_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg1, reg_id_t src_reg2,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    opnd_t src_opnd1 = create_mapping_ymm_opnd(dcontext, src_reg1);
    opnd_t src_opnd2 = create_mapping_ymm_opnd(dcontext, src_reg2);
    opnd_t dst_opnd = create_mapping_ymm_opnd(dcontext, dst_reg);

    int k_idx = TO_K_REG_INDEX(mask_reg);
    if (k_idx == 0) {
        instr_t *new_instr1 = instr_create_1dst_2src(dcontext, OP_vpxor, dst_opnd, src_opnd1, src_opnd2);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
        return new_instr1;
    } else {
        // unsigned char imm8 = rewrite_reserved_opmask[k_idx];
    }
    return NULL_INSTR;
}

instr_t *
vpxord_zmm_and_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg1, reg_id_t src_reg2,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{
    return NULL_INSTR;
}

instr_t *
rw_func_vpxord(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src_opnd1 = instr_get_src(instr, 1);
    opnd_t src_opnd2 = instr_get_src(instr, 2);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpxord", true, true, true, true);
#endif
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t src_reg1 = opnd_get_reg(src_opnd1);
    reg_id_t src_reg2 = opnd_get_reg(src_opnd2);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    if (IS_ZMM_REG(src_reg1))
        return vpxord_zmm_and_zmm_gen(dcontext, ilist, instr, src_reg1, src_reg2, dst_reg, mask_reg);
    if (IS_YMM_REG(src_reg1))
        return vpxord_ymm_and_ymm_gen(dcontext, ilist, instr, src_reg1, src_reg2, dst_reg, mask_reg);
    if (IS_XMM_REG(src_reg1))
        return vpxord_xmm_and_xmm_gen(dcontext, ilist, instr, src_reg1, src_reg2, dst_reg, mask_reg);
    REWRITE_INFO(STD_OUTF, "vpxord pattern not support");
    return NULL_INSTR;
}

/* ==============================================
 *         Helper func for vpxorq
 * ============================================= */

instr_t *
vpxorq_zmm_and_zmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg1, reg_id_t src_reg2,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "vpxorq zmm zmm, zmm not support");
#endif
    return NULL_INSTR;
}

instr_t *
vpxorq_ymm_and_ymm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg1, reg_id_t src_reg2,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    opnd_t src_opnd1 = create_mapping_ymm_opnd(dcontext, src_reg1);
    opnd_t src_opnd2 = create_mapping_ymm_opnd(dcontext, src_reg2);
    opnd_t dst_opnd = create_mapping_ymm_opnd(dcontext, dst_reg);

    spill_state_t *state = &dcontext->local_state->spill_space;

    int k_idx = TO_K_REG_INDEX(mask_reg);
    if (k_idx == 0) {
        // if k0 = 0 means no mask operation no blend, if 0x02 = 128(xmm)/64(quardword) means all elements include
        if (state->k_regs[k_idx] == 0 || state->k_regs[k_idx] == 0x02) {
            // vex.256 encoded version
            instr_t *new_instr1 = instr_create_1dst_2src(dcontext, OP_vpxor, dst_opnd, src_opnd1, src_opnd2);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
            return new_instr1;
        }
    } else {
        // unsigned char imm8 = rewrite_reserved_opmask[k_idx];
    }
    return NULL_INSTR;
}

instr_t *
vpxorq_xmm_and_xmm_gen(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, reg_id_t src_reg1, reg_id_t src_reg2,
                       reg_id_t dst_reg, reg_id_t mask_reg)
{
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    opnd_t src_opnd1 = create_mapping_xmm_opnd(dcontext, src_reg1);
    opnd_t src_opnd2 = create_mapping_xmm_opnd(dcontext, src_reg2);
    opnd_t dst_opnd = create_mapping_xmm_opnd(dcontext, dst_reg);

    spill_state_t *state = &dcontext->local_state->spill_space;

    int k_idx = TO_K_REG_INDEX(mask_reg);
    if (k_idx == 0) {
        // if k0 = 0 means no mask operation no blend, if 0x02 = 128(xmm)/64(quardword) means all elements include
        if (state->k_regs[k_idx] == 0 || state->k_regs[k_idx] == 0x02) {
            // vex.128 encoded version
            instr_t *new_instr1 = instr_create_1dst_2src(dcontext, OP_vpxor, dst_opnd, src_opnd1, src_opnd2);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
            return new_instr1;
        }
    } else {
        // unsigned char imm8 = rewrite_reserved_opmask[k_idx];
    }
    return NULL_INSTR;
}

/**
 * @brief 720 vpxorq rewrite function
 */
instr_t *
rw_func_vpxorq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src_opnd1 = instr_get_src(instr, 1);
    opnd_t src_opnd2 = instr_get_src(instr, 2);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vpxorq", true, true, true, true);
#endif
    reg_id_t mask_reg = opnd_get_reg(mask_opnd);
    reg_id_t src_reg1 = opnd_get_reg(src_opnd1);
    reg_id_t src_reg2 = opnd_get_reg(src_opnd2);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    if (IS_ZMM_REG(src_reg1))
        return vpxorq_zmm_and_zmm_gen(dcontext, ilist, instr, src_reg1, src_reg2, dst_reg, mask_reg);
    if (IS_YMM_REG(src_reg1))
        return vpxorq_ymm_and_ymm_gen(dcontext, ilist, instr, src_reg1, src_reg2, dst_reg, mask_reg);
    if (IS_XMM_REG(src_reg1))
        return vpxorq_xmm_and_xmm_gen(dcontext, ilist, instr, src_reg1, src_reg2, dst_reg, mask_reg);
    REWRITE_INFO(STD_OUTF, "vpxorq pattern not support");
    return NULL_INSTR;
}

instr_t * /* 738 */
rw_func_vrndscaleps(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vrndscaleps {%k0} $0x00 %ymm4 -> %ymm4
    // opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t imm8_opnd = instr_get_src(instr, 1);
    opnd_t src_opnd = instr_get_src(instr, 2); // src2 can be reg/mem
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "vrndscaleps", true, true, true, true);
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    int imm8 = opnd_get_immed_int(imm8_opnd);
    if (imm8 == 0x0) {
        instr_t *i1 = INSTR_CREATE_vroundps(dcontext, dst_opnd, src_opnd, opnd_create_immed_int(0x00, OPSZ_1));
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
        return i1;
    }
    return NULL_INSTR;
}

instr_t * /* 740 */
rw_func_vrndscaless(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vrndscaless {%k0} $0x09 %xmm0[12byte] %xmm0[4byte] -> %xmm0
    // opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src2_opnd = instr_get_src(instr, 2);
    opnd_t src3_opnd = instr_get_src(instr, 3); // src3 can be reg/mem
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    opnd_t src1_opnd = instr_get_src(instr, 1);
    REWRITE_INFO(STD_OUTF, "rewrite %s at %p :", "vrndscaless", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    // dr_print_opnd(dcontext, STD_OUTF, mask_opnd, "mask:");
    dr_print_opnd(dcontext, STD_OUTF, src1_opnd, "src1:");
    dr_print_opnd(dcontext, STD_OUTF, src2_opnd, "src2:");
    dr_print_opnd(dcontext, STD_OUTF, src3_opnd, "src3:");
    dr_print_opnd(dcontext, STD_OUTF, dst_opnd, "dst:");
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    reg_id_t src2_xmm = opnd_get_reg(src2_opnd);
    reg_id_t src3_xmm = opnd_get_reg(src3_opnd);
    reg_id_t dst_xmm = opnd_get_reg(dst_opnd);
    src2_opnd = opnd_create_reg(src2_xmm);
    src3_opnd = opnd_create_reg(src3_xmm);
    dst_opnd = opnd_create_reg(dst_xmm);
    if (src2_xmm == src3_xmm && src3_xmm == dst_xmm) {
        reg_id_t spill_xmm_reg = find_one_available_spill_xmm(src2_xmm);
        opnd_t spill_xmm_opnd = opnd_create_reg(spill_xmm_reg);
        reg_id_t rax_reg = DR_REG_RAX;
        reg_id_t eax_reg = DR_REG_EAX;
        opnd_t rax_opnd = opnd_create_reg(rax_reg);
        opnd_t eax_opnd = opnd_create_reg(eax_reg);
        // spill_xmm_reg -> tls_slot(spill_xmm_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_xmm_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_xmm_reg)), OPSZ_16);
        // push %rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, rax_opnd);
        // extractps $3, %xmm0 %eax
        instr_t *i3 = INSTR_CREATE_extractps(dcontext, eax_opnd, src3_opnd, opnd_create_immed_int(3, OPSZ_1));
        // movd %rax, %spill_xmm_reg
        instr_t *i4 = INSTR_CREATE_movd(dcontext, spill_xmm_opnd, eax_opnd);
        // vbroadcastss %spill_xmm_reg, %spill_xmm_reg
        instr_t *i5 = INSTR_CREATE_vbroadcastss(dcontext, spill_xmm_opnd, spill_xmm_opnd);
        // pop %rax
        instr_t *i6 = INSTR_CREATE_pop(dcontext, rax_opnd);
        // vroundss $0x09, spill_xmm_reg, spill_xmm_reg -> spill_xmm_reg
        instr_t *i7 = INSTR_CREATE_vroundss(dcontext, spill_xmm_opnd, spill_xmm_opnd, spill_xmm_opnd,
                                            opnd_create_immed_int(0x09, OPSZ_1));
        // vinsertps $0x10, src2[12byte], spill_xmm_reg -> dst[16byte]
        instr_t *i8 =
            INSTR_CREATE_vinsertps(dcontext, dst_opnd, opnd_create_immed_int(0x00, OPSZ_1), src2_opnd, spill_xmm_opnd);
        // tls_slot(spill_xmm_reg) -> spill_xmm_reg
        instr_t *i9 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_xmm_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_xmm_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 9, i1, i2, i3, i4, i5, i6, i7, i8, i9);
#endif
        instrlist_concat_next_instr(ilist, 9, i1, i2, i3, i4, i5, i6, i7, i8, i9);
        return i1;
    } else { // not all the three operands are same registers
        if (src2_xmm == dst_xmm) {
            // vrndscaless {%k0} $0x09 %xmm2[12byte] %xmm1[4byte] -> %xmm2[16byte] | onlye 4 byte are changed
            //                    src1  src2          src3            dst
            reg_id_t spill_xmm_reg = find_available_spill_xmm_avoiding(src2_xmm, dst_xmm, DR_REG_NULL);
            opnd_t spill_xmm_opnd = opnd_create_reg(spill_xmm_reg);
            reg_id_t rax_reg = DR_REG_RAX;
            reg_id_t eax_reg = DR_REG_EAX;
            opnd_t rax_opnd = opnd_create_reg(rax_reg);
            opnd_t eax_opnd = opnd_create_reg(eax_reg);
            // spill_xmm_reg -> tls_slot(spill_xmm_reg)
            instr_t *i1 = SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_xmm_reg,
                                                 TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_xmm_reg)), OPSZ_16);
            // push %rax
            instr_t *i2 = INSTR_CREATE_push(dcontext, rax_opnd);
            // extractps $3, %xmm0 %eax
            instr_t *i3 = INSTR_CREATE_extractps(dcontext, eax_opnd, src3_opnd, opnd_create_immed_int(3, OPSZ_1));
            // movd %rax, %spill_xmm_reg
            instr_t *i4 = INSTR_CREATE_movd(dcontext, spill_xmm_opnd, eax_opnd);
            // vbroadcastss %spill_xmm_reg, %spill_xmm_reg
            instr_t *i5 = INSTR_CREATE_vbroadcastss(dcontext, spill_xmm_opnd, spill_xmm_opnd);
            // pop %rax
            instr_t *i6 = INSTR_CREATE_pop(dcontext, rax_opnd);
            // vroundss $0x09, spill_xmm_reg, spill_xmm_reg -> spill_xmm_reg
            instr_t *i7 = INSTR_CREATE_vroundss(dcontext, spill_xmm_opnd, spill_xmm_opnd, spill_xmm_opnd,
                                                opnd_create_immed_int(0x09, OPSZ_1));
            // vinsertps $0x10, src2[12byte], spill_xmm_reg -> dst[16byte]
            instr_t *i8 = INSTR_CREATE_vinsertps(dcontext, dst_opnd, opnd_create_immed_int(0x00, OPSZ_1), src2_opnd,
                                                 spill_xmm_opnd);
            // tls_slot(spill_xmm_reg) -> spill_xmm_reg
            instr_t *i9 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_xmm_reg,
                                                      TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_xmm_reg)), OPSZ_16);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 9, i1, i2, i3, i4, i5, i6, i7, i8, i9);
#endif
            instrlist_concat_next_instr(ilist, 9, i1, i2, i3, i4, i5, i6, i7, i8, i9);
            return i1;
        }
        reg_id_t spill_xmm_reg = find_available_spill_xmm_avoiding_variadic(3, src2_xmm, src3_xmm, dst_xmm);
        opnd_t spill_xmm_opnd = opnd_create_reg(spill_xmm_reg);
        reg_id_t rax_reg = DR_REG_RAX;
        reg_id_t eax_reg = DR_REG_EAX;
        opnd_t rax_opnd = opnd_create_reg(rax_reg);
        opnd_t eax_opnd = opnd_create_reg(eax_reg);
        // spill_xmm_reg -> tls_slot(spill_xmm_reg)
        instr_t *i1 =
            SAVE_SIMD_TO_SIZED_TLS(dcontext, spill_xmm_reg, TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_xmm_reg)), OPSZ_16);
        // push %rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, rax_opnd);
        // extractps $3, %xmm0 %eax
        instr_t *i3 = INSTR_CREATE_extractps(dcontext, eax_opnd, src3_opnd, opnd_create_immed_int(3, OPSZ_1));
        // movd %rax, %spill_xmm_reg
        instr_t *i4 = INSTR_CREATE_movd(dcontext, spill_xmm_opnd, eax_opnd);
        // vbroadcastss %spill_xmm_reg, %spill_xmm_reg
        instr_t *i5 = INSTR_CREATE_vbroadcastss(dcontext, spill_xmm_opnd, spill_xmm_opnd);
        // pop %rax
        instr_t *i6 = INSTR_CREATE_pop(dcontext, rax_opnd);
        // vroundss $0x09, spill_xmm_reg, spill_xmm_reg -> spill_xmm_reg
        instr_t *i7 = INSTR_CREATE_vroundss(dcontext, spill_xmm_opnd, spill_xmm_opnd, spill_xmm_opnd,
                                            opnd_create_immed_int(0x09, OPSZ_1));
        // vinsertps $0x10, src2[12byte], spill_xmm_reg -> dst[16byte]
        instr_t *i8 =
            INSTR_CREATE_vinsertps(dcontext, dst_opnd, opnd_create_immed_int(0x00, OPSZ_1), src2_opnd, spill_xmm_opnd);
        // tls_slot(spill_xmm_reg) -> spill_xmm_reg
        instr_t *i9 = RESTORE_SIMD_FROM_SIZED_TLS(dcontext, spill_xmm_reg,
                                                  TLS_ZMM_idx_SLOT(TO_XMM_REG_INDEX(spill_xmm_reg)), OPSZ_16);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 9, i1, i2, i3, i4, i5, i6, i7, i8, i9);
#endif
        instrlist_concat_next_instr(ilist, 9, i1, i2, i3, i4, i5, i6, i7, i8, i9);
        return i1;
    }
    return NULL_INSTR;
}

instr_t * /* 779 */
rw_func_vrndscalesd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vrndscalesd {%k0} $0x09 %xmm0[8byte] 0xffffffa0(%rbp)[8byte] -> %xmm0
    // opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src_opnd1 = instr_get_src(instr, 1);
    opnd_t src_opnd2 = instr_get_src(instr, 2);
    opnd_t src_opnd3 = instr_get_src(instr, 3); // src3 can be reg/mem
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "rewrite %s at %p :", "vrndscalesd", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    // dr_print_opnd(dcontext, STD_OUTF, mask_opnd, "mask:");
    dr_print_opnd(dcontext, STD_OUTF, src_opnd1, "src1:");
    dr_print_opnd(dcontext, STD_OUTF, src_opnd2, "src2:");
    dr_print_opnd(dcontext, STD_OUTF, src_opnd3, "src3:");
    dr_print_opnd(dcontext, STD_OUTF, dst_opnd, "dst:");
#endif
    ptr_int_t imm8 = opnd_get_immed_int(src_opnd1);
    reg_id_t src_reg1 = opnd_get_reg(src_opnd2);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    if (src_opnd3.kind == REG_kind) {
        reg_id_t src_reg2 = opnd_get_reg(src_opnd3);
        instr_t *new_instr1 =
            instr_create_1dst_3src(dcontext, OP_vroundsd, create_mapping_xmm_opnd(dcontext, dst_reg),
                                   create_mapping_xmm_opnd(dcontext, src_reg1),
                                   create_mapping_xmm_opnd(dcontext, src_reg2), opnd_create_immed_int(imm8, OPSZ_1));
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
        instrlist_remove(ilist, instr);
        instr_destroy(dcontext, instr);
        return new_instr1;
    }
    if (src_opnd3.kind == BASE_DISP_kind) {
        // mem
        instr_t *new_instr1 = instr_create_1dst_3src(dcontext, OP_vroundsd, create_mapping_xmm_opnd(dcontext, dst_reg),
                                                     create_mapping_xmm_opnd(dcontext, src_reg1), src_opnd3,
                                                     opnd_create_immed_int(imm8, OPSZ_1));
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
        instrlist_remove(ilist, instr);
        instr_destroy(dcontext, instr);
        return new_instr1;
    }
    return NULL_INSTR;
}

instr_t * /* 767 */
rw_func_vshufi32x4(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // vshufi32x4 {%k0} $0x02 %ymm1 %ymm6 -> %ymm1
    opnd_t mask_opnd = instr_get_src(instr, 0);
    opnd_t src1_opnd = instr_get_src(instr, 1);
    opnd_t src2_opnd = instr_get_src(instr, 2);
    opnd_t src3_opnd = instr_get_src(instr, 3);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "rewrite %s at %p :", "vshufi32x4", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, mask_opnd, "mask:");
    dr_print_opnd(dcontext, STD_OUTF, src1_opnd, "src1:");
    dr_print_opnd(dcontext, STD_OUTF, src2_opnd, "src2:");
    dr_print_opnd(dcontext, STD_OUTF, src3_opnd, "src3:");
    dr_print_opnd(dcontext, STD_OUTF, dst_opnd, "dst:");
#endif
    int k_idx = TO_K_REG_INDEX(opnd_get_reg(mask_opnd));
    int imm8 = opnd_get_immed_int(src1_opnd);
    if (k_idx == 0) {
        instrlist_remove(ilist, instr);
        instr_destroy(dcontext, instr);
        switch (imm8) {
        case 0x02: {
            // vshufi32x4 $0x02: low 128 from src2, high 128 from src3[31:16]
            // vperm2i128 $0x20: low 128 from src1, high 128 from src2[31:16]
            opnd_t imm_0x30 = opnd_create_immed_int(0x30, OPSZ_1);
            instr_t *i1 = instr_create_1dst_3src(dcontext, OP_vperm2i128, dst_opnd, src2_opnd, src3_opnd, imm_0x30);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
            return i1;
        } break;
        default: {
            REWRITE_ERROR(STD_OUTF, "vshufi32x4 imm8 %d not supported", imm8);
            return NULL_INSTR;
        }
        }
        return NULL_INSTR;
    } else {
        return NULL_INSTR;
    }
    return NULL_INSTR;
}

/* =======================================================
 *      mask register related instr rewrite functions
 * ======================================================= */

instr_t * /* 472 */
rw_func_kmovw(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    opnd_t src_opnd = instr_get_src(instr, 0);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "kmovw", /* is_src_read? */ true,
                       /* is_src_written? */ false,
                       /* is_dst_read? */ false, /* is_dst_written? */ true);
#endif
    reg_id_t src_reg = opnd_get_reg(src_opnd);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);

    const uint src_mask_flag = IS_MASK_REG(src_reg) ? 1 : 0;
    const uint dst_mask_flag = IS_MASK_REG(dst_reg) ? 2 : 0;
    const uint mask_flag = src_mask_flag | dst_mask_flag;

    instr_t *new1 = NULL_INSTR, *new2 = NULL_INSTR;
    instr_t *new3 = NULL_INSTR, *new4 = NULL_INSTR;
    instr_t *new5 = NULL_INSTR;

    switch (mask_flag) {
    case 0x1: { /* mask -> GPR */
        int k_idx = TO_K_REG_INDEX(src_reg);
        /* make sure we write into the 16-bit subreg */
        if (IS_DWORD_GPR(dst_reg))
            dst_reg = GPR_DWORD_TO_WORD(dst_reg);
        else if (IS_QWORD_GPR(dst_reg))
            dst_reg = GPR_QWORD_TO_WORD(dst_reg);
        /* restore the 2-byte mask value into the GPR */
        new1 = RESTORE_FROM_SIZED_TLS(dcontext, dst_reg, TLS_K_idx_SLOT(k_idx), OPSZ_2);
        new2 = INSTR_CREATE_movzx(dcontext, opnd_create_reg(DR_REG_EAX), opnd_create_reg(DR_REG_AX));
        new1->next = new2;
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 2, new1, new2);
#endif
    } break;
    case 0x2: { /* GPR -> mask */
        int k_idx = TO_K_REG_INDEX(dst_reg);
        reg_id_t tmp_reg = DR_REG_RAX;
        /* read from the 16-bit subreg of the GPR */
        if (IS_DWORD_GPR(src_reg))
            src_reg = GPR_DWORD_TO_WORD(src_reg);
        else if (IS_QWORD_GPR(src_reg))
            src_reg = GPR_QWORD_TO_WORD(src_reg);
        /* Clear upper bits: zero entire 8-byte slot first, then write 2 bytes */
        new1 = SAVE_TO_TLS(dcontext, tmp_reg, TLS_REG1_SLOT);
        new2 = INSTR_CREATE_xor(dcontext, opnd_create_reg(tmp_reg), opnd_create_reg(tmp_reg));
        new3 = SAVE_TO_TLS(dcontext, tmp_reg, TLS_K_idx_SLOT(k_idx));
        new4 = SAVE_TO_SIZED_TLS(dcontext, src_reg, TLS_K_idx_SLOT(k_idx), OPSZ_2);
        new5 = RESTORE_FROM_TLS(dcontext, tmp_reg, TLS_REG1_SLOT);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, new1, new2, new3, new4, new5);
#endif
        instrlist_concat_next_instr(ilist, 5, new1, new2, new3, new4, new5);
    } break;

    case 0x3: { /* mask -> mask */
        int src_k = TO_K_REG_INDEX(src_reg);
        int dst_k = TO_K_REG_INDEX(dst_reg);
        reg_id_t tmp = DR_REG_RAX; /* scratch GPR */

        /* spill RAX */
        new1 = SAVE_TO_TLS(dcontext, tmp, TLS_REG1_SLOT);
        /* load full 8-byte mask into RAX */
        new2 = RESTORE_FROM_SIZED_TLS(dcontext, tmp, TLS_K_idx_SLOT(src_k), OPSZ_8);
        /* save its low 2 bytes into the destination k-slot */
        new3 = SAVE_TO_SIZED_TLS(dcontext, GPR_QWORD_TO_WORD(tmp), TLS_K_idx_SLOT(dst_k), OPSZ_2);
        /* restore RAX */
        new4 = RESTORE_FROM_TLS(dcontext, tmp, TLS_REG1_SLOT);

        instrlist_concat_next_instr(ilist, 4, new1, new2, new3, new4);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, new1, new2, new3, new4);
#endif
    } break;

    default:
        /* invalid kmovw form (no mask regs) */
        break;
    }

    /* remove the original kmovw */
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    return new1;
}

instr_t * /* 473 */
rw_func_kmovb(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kmovb %ecx -> %k1,
    // %k1 = tls(rdi + offset)
    // <=> movb %cl, tls(rdi + offset)
    opnd_t src_opnd = instr_get_src(instr, 0);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "kmovb", true, false, false, true);
#endif
    reg_id_t src_reg = opnd_get_reg(src_opnd);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);

    const uint src_mask_flag = IS_MASK_REG(src_reg) ? 1 : 0;
    const uint dst_mask_flag = IS_MASK_REG(dst_reg) ? 2 : 0;
    const uint mask_flag = src_mask_flag | dst_mask_flag;

    instr_t *new_instr1 = NULL_INSTR;
    instr_t *new_instr2 = NULL_INSTR;
    instr_t *new_instr3 = NULL_INSTR;
    instr_t *new_instr4 = NULL_INSTR;
    instr_t *new_instr5 = NULL_INSTR;
    instr_t *new_instr6 = NULL_INSTR;
    instr_t *new_instr7 = NULL_INSTR;
    instr_t *new_instr8 = NULL_INSTR;
    instr_t *new_instr9 = NULL_INSTR;
    instr_t *new_instr10 = NULL_INSTR;

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    switch (mask_flag) {
    case 0x1: { // src reg is mask, dst reg is gpr
        // kmovb %k1 -> %rax
        int k_idx = TO_K_REG_INDEX(src_reg);

        // kmovb should zero-extend to the full destination register
        if (IS_QWORD_GPR(dst_reg)) {
            // For 64-bit GPR, zero the full register then load 1 byte
            new_instr1 = INSTR_CREATE_pushf(dcontext);
            new_instr2 = INSTR_CREATE_xor(dcontext, opnd_create_reg(dst_reg), opnd_create_reg(dst_reg));
            new_instr3 = RESTORE_FROM_SIZED_TLS(dcontext, GPR_QWORD_TO_BYTE(dst_reg), TLS_K_idx_SLOT(k_idx), OPSZ_1);
            new_instr4 = INSTR_CREATE_popf(dcontext);

            instrlist_concat_next_instr(ilist, 4, new_instr1, new_instr2, new_instr3, new_instr4);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, new_instr1, new_instr2, new_instr3, new_instr4);
#endif
        } else if (IS_DWORD_GPR(dst_reg)) {
            // For 32-bit GPR, zero the register then load 1 byte (x64 auto-zeros upper 32 bits)
            new_instr1 = INSTR_CREATE_pushf(dcontext);
            new_instr2 = INSTR_CREATE_xor(dcontext, opnd_create_reg(dst_reg), opnd_create_reg(dst_reg));
            new_instr3 = RESTORE_FROM_SIZED_TLS(dcontext, GPR_DWORD_TO_BYTE(dst_reg), TLS_K_idx_SLOT(k_idx), OPSZ_1);
            new_instr4 = INSTR_CREATE_popf(dcontext);

            instrlist_concat_next_instr(ilist, 4, new_instr1, new_instr2, new_instr3, new_instr4);
#ifdef DEBUG
            print_rewrite_variadic_instr(dcontext, 4, new_instr1, new_instr2, new_instr3, new_instr4);
#endif
        }
    } break;
    case 0x2: { // src reg is gpr, dst reg is mask
        // kmovb %rax -> %k1
        int k_idx = TO_K_REG_INDEX(dst_reg);
        reg_id_t tmp_reg = DR_REG_R15;
        if (IS_DWORD_GPR(src_reg)) {
            src_reg = GPR_DWORD_TO_BYTE(src_reg);
        } else if (IS_QWORD_GPR(src_reg)) {
            src_reg = GPR_QWORD_TO_BYTE(src_reg);
        } else if (IS_WORD_GPR(src_reg)) {
            src_reg = GPR_WORD_TO_BYTE(src_reg);
        }
        // Clear upper bits: zero entire 8-byte slot first, then write 1 byte
        new_instr1 = INSTR_CREATE_pushf(dcontext);
        new_instr2 = INSTR_CREATE_push(dcontext, opnd_create_reg(tmp_reg));
        // instr3,4 cleanup the high
        new_instr3 = INSTR_CREATE_xor(dcontext, opnd_create_reg(tmp_reg), opnd_create_reg(tmp_reg));
        new_instr4 = SAVE_TO_TLS(dcontext, tmp_reg, TLS_K_idx_SLOT(k_idx));
        new_instr5 = SAVE_TO_SIZED_TLS(dcontext, src_reg, TLS_K_idx_SLOT(k_idx), OPSZ_1);
        new_instr6 = INSTR_CREATE_pop(dcontext, opnd_create_reg(tmp_reg));
        new_instr7 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5,
                                     new_instr6, new_instr7);
#endif
        instrlist_concat_next_instr(ilist, 7, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5, new_instr6,
                                    new_instr7);
    } break;
    // note that we don't convert gpr width here, becasue %k_ to a gpr and gpr to %k_ will retain the %k_ value,
    // so no need to convert gpr width here to add complexity
    case 0x3: { // src reg is mask, dst reg is mask
        // kmovb %k1 -> %k2
        // mov %gs:offset -> %gs:offset, but is not allowed in x64
        // so we need to use a gpr as intermediate, mov %gs:offset -> gpr -> %gs:offset
        int src_k_idx = TO_K_REG_INDEX(src_reg);
        int dst_k_idx = TO_K_REG_INDEX(dst_reg);
        reg_id_t tmp_reg = DR_REG_R11;
        reg_id_t tmp_reg2 = DR_REG_R12;

        new_instr1 = INSTR_CREATE_pushf(dcontext);
        // spill tmp regs
        new_instr2 = SAVE_TO_TLS(dcontext, tmp_reg, TLS_REG1_SLOT);
        new_instr3 = SAVE_TO_TLS(dcontext, tmp_reg2, TLS_REG2_SLOT);
        // Clear upper bits: zero tmp_reg2 and store to destination
        new_instr4 = INSTR_CREATE_xor(dcontext, opnd_create_reg(tmp_reg2), opnd_create_reg(tmp_reg2));
        new_instr5 = SAVE_TO_TLS(dcontext, tmp_reg2, TLS_K_idx_SLOT(dst_k_idx));
        // Load 1 byte from source and store to destination (overwrites lower 8 bits)
        new_instr6 = RESTORE_FROM_SIZED_TLS(dcontext, GPR_QWORD_TO_BYTE(tmp_reg), TLS_K_idx_SLOT(src_k_idx), OPSZ_1);
        new_instr7 = SAVE_TO_SIZED_TLS(dcontext, GPR_QWORD_TO_BYTE(tmp_reg), TLS_K_idx_SLOT(dst_k_idx), OPSZ_1);
        // restore tmp regs
        new_instr8 = RESTORE_FROM_TLS(dcontext, tmp_reg2, TLS_REG2_SLOT);
        new_instr9 = RESTORE_FROM_TLS(dcontext, tmp_reg, TLS_REG1_SLOT);
        new_instr10 = INSTR_CREATE_popf(dcontext);
        instrlist_concat_next_instr(ilist, 10, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5, new_instr6,
                                    new_instr7, new_instr8, new_instr9, new_instr10);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 10, new_instr1, new_instr2, new_instr3, new_instr4, new_instr5,
                                     new_instr6, new_instr7, new_instr8, new_instr9, new_instr10);
#endif
    } break;
    default: // kmovb will not contain no mask register, which is invalid
        break;
    }

    return new_instr1;
}

instr_t * /* 474 */
rw_func_kmovq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kmovq %rax -> %k0,
    // %k0 = tls(rdi + offset)
    // <=> movq %rax, tls(rdi + offset)
    opnd_t src_opnd = instr_get_src(instr, 0);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "kmovq", true, false, false, true);
#endif
    reg_id_t src_reg = opnd_get_reg(src_opnd);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);

    const uint src_mask_flag = IS_MASK_REG(src_reg) ? 1 : 0;
    const uint dst_mask_flag = IS_MASK_REG(dst_reg) ? 2 : 0;
    const uint mask_flag = src_mask_flag | dst_mask_flag;

    instr_t *new_instr1 = NULL_INSTR;
    instr_t *new_instr2 = NULL_INSTR;
    instr_t *new_instr3 = NULL_INSTR;
    instr_t *new_instr4 = NULL_INSTR;

    switch (mask_flag) {
    case 0x1: { // src reg is mask, dst reg is gpr
        int k_idx = TO_K_REG_INDEX(src_reg);
        // mov %gs:offset -> gpr(dst_reg)
        new_instr1 = RESTORE_FROM_TLS(dcontext, dst_reg, TLS_K_idx_SLOT(k_idx));
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    } break;
    case 0x2: { // src reg is gpr, dst reg is mask
        int k_idx = TO_K_REG_INDEX(dst_reg);
        // mov gpr -> %gs:offset
        new_instr1 = SAVE_TO_TLS(dcontext, src_reg, TLS_K_idx_SLOT(k_idx));
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, new_instr1);
#endif
    } break;
    case 0x3: { // src reg is mask, dst reg is mask
        // mov %gs:offset -> %gs:offset, but is not allowed in x64
        // so we need to use a gpr as intermediate, mov %gs:offset -> gpr -> %gs:offset
        int src_k_idx = TO_K_REG_INDEX(src_reg);
        int dst_k_idx = TO_K_REG_INDEX(dst_reg);
        reg_id_t tmp_reg = DR_REG_RAX; // use r11 as intermediate register, 
        // save tmp reg, spill tmp reg
        new_instr1 = SAVE_TO_TLS(dcontext, tmp_reg, TLS_REG1_SLOT);
        // mov %gs:offset -> gpr
        new_instr2 = RESTORE_FROM_TLS(dcontext, tmp_reg, TLS_K_idx_SLOT(src_k_idx));
        // mov gpr -> %gs:offset
        new_instr3 = SAVE_TO_TLS(dcontext, tmp_reg, TLS_K_idx_SLOT(dst_k_idx));
        // restore tmp reg
        new_instr4 = RESTORE_FROM_TLS(dcontext, tmp_reg, TLS_REG1_SLOT);
        instrlist_concat_next_instr(ilist, 4, new_instr1, new_instr2, new_instr3, new_instr4);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, new_instr1, new_instr2, new_instr3, new_instr4);
#endif
    } break;
    default: // kmovq will not contain no mask register, which is invalid
        break;
    }

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    return new_instr1;
}

instr_t * /* 475 */
rw_func_kmovd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kmovd %edi, %k1
    opnd_t src_opnd = instr_get_src(instr, 0);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "kmovd", true, false, false, true);
#endif
    reg_id_t src_reg = opnd_get_reg(src_opnd);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);

    // NOTE: whether we need to convert the src_reg to 32bit or not

    const uint src_mask_flag = IS_MASK_REG(src_reg) ? 1 : 0;
    const uint dst_mask_flag = IS_MASK_REG(dst_reg) ? 2 : 0;
    const uint mask_flag = src_mask_flag | dst_mask_flag;

    instr_t *i1 = NULL_INSTR;
    instr_t *i2 = NULL_INSTR;
    instr_t *i3 = NULL_INSTR;
    instr_t *i4 = NULL_INSTR;
    instr_t *i5 = NULL_INSTR;
    instr_t *i6 = NULL_INSTR;
    instr_t *i7 = NULL_INSTR;
    instr_t *i8 = NULL_INSTR;

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    switch (mask_flag) {
    case 0x1: { // src reg is mask, dst reg is gpr
        int k_idx = TO_K_REG_INDEX(src_reg);
        // mov %gs:offset -> gpr(dst_reg)
        i1 = RESTORE_FROM_SIZED_TLS(dcontext, dst_reg, TLS_K_idx_SLOT(k_idx), OPSZ_4);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 1, i1);
#endif
    } break;
    case 0x2: { // src reg is gpr, dst reg is mask
        int k_idx = TO_K_REG_INDEX(dst_reg);
        reg_id_t tmp_reg = DR_REG_RAX;
        // Clear upper bits: zero entire 8-byte slot first, then write 4 bytes
        i1 = SAVE_TO_TLS(dcontext, tmp_reg, TLS_REG1_SLOT);
        i2 = INSTR_CREATE_xor(dcontext, opnd_create_reg(tmp_reg), opnd_create_reg(tmp_reg));
        i3 = SAVE_TO_TLS(dcontext, tmp_reg, TLS_K_idx_SLOT(k_idx));
        i4 = SAVE_TO_SIZED_TLS(dcontext, src_reg, TLS_K_idx_SLOT(k_idx), OPSZ_4);
        i5 = RESTORE_FROM_TLS(dcontext, tmp_reg, TLS_REG1_SLOT);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 5, i1, i2, i3, i4, i5);
#endif
        instrlist_concat_next_instr(ilist, 5, i1, i2, i3, i4, i5);
    } break;
    case 0x3: { // src reg is mask, dst reg is mask
        // mov %gs:offset -> %gs:offset, but is not allowed in x64
        // so we need to use a gpr as intermediate, mov %gs:offset -> gpr -> %gs:offset
        int src_k_idx = TO_K_REG_INDEX(src_reg);
        int dst_k_idx = TO_K_REG_INDEX(dst_reg);
        reg_id_t tmp_reg = DR_REG_RAX;
        reg_id_t tmp_reg2 = DR_REG_RCX;
        // save tmp regs
        i1 = SAVE_TO_TLS(dcontext, tmp_reg, TLS_REG1_SLOT);
        i2 = SAVE_TO_TLS(dcontext, tmp_reg2, TLS_REG2_SLOT);
        // Clear upper bits: zero tmp_reg2 and store to destination
        i3 = INSTR_CREATE_xor(dcontext, opnd_create_reg(tmp_reg2), opnd_create_reg(tmp_reg2));
        i4 = SAVE_TO_TLS(dcontext, tmp_reg2, TLS_K_idx_SLOT(dst_k_idx));
        // Load 4 bytes from source and store to destination (overwrites lower 32 bits)
        i5 = RESTORE_FROM_SIZED_TLS(dcontext, tmp_reg, TLS_K_idx_SLOT(src_k_idx), OPSZ_4);
        i6 = SAVE_TO_SIZED_TLS(dcontext, tmp_reg, TLS_K_idx_SLOT(dst_k_idx), OPSZ_4);
        // restore tmp regs
        i7 = RESTORE_FROM_TLS(dcontext, tmp_reg2, TLS_REG2_SLOT);
        i8 = RESTORE_FROM_TLS(dcontext, tmp_reg, TLS_REG1_SLOT);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
        instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
    } break;
    default: // kmovd will not contain no mask register, which is invalid
        break;
    }

    return i1;
}

/**
 * @brief kand_ template function
 */
instr_t *
rw_func_kand_(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start, int opcode,
              const char *instr_name)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "rewrite kandw not support");
#endif
    return NULL_INSTR;
}

instr_t * /* 476 */
rw_func_kandw(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kandw %k1, %k2, %k3 - 16-bit K register AND operation
    // DEST[15:0] := SRC1[15:0] AND SRC2[15:0]
    // DEST[MAX_KL-1:16] := 0
    opnd_t src1_opnd = instr_get_src(instr, 0);
    opnd_t src2_opnd = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting kandw at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src1_opnd, "input src1: ");
    dr_print_opnd(dcontext, STD_OUTF, src2_opnd, "input src2: ");
    dr_print_opnd(dcontext, STD_OUTF, dst_opnd, "output dst: ");
#endif
    reg_id_t input_mask1 = opnd_get_reg(src1_opnd);
    reg_id_t input_mask2 = opnd_get_reg(src2_opnd);
    reg_id_t output_mask = opnd_get_reg(dst_opnd);
    uint input_k1_idx = TO_K_REG_INDEX(input_mask1);
    uint input_k2_idx = TO_K_REG_INDEX(input_mask2);
    uint output_k_idx = TO_K_REG_INDEX(output_mask);

    reg_id_t spill_gpr64_1 = DR_REG_RAX;
    reg_id_t spill_gpr64_2 = DR_REG_RBX;
    reg_id_t spill_gpr16_1 = DR_REG_AX;
    reg_id_t spill_gpr16_2 = DR_REG_BX;

    opnd_t spill_gpr64_1_opnd = opnd_create_reg(spill_gpr64_1);
    opnd_t spill_gpr64_2_opnd = opnd_create_reg(spill_gpr64_2);
    opnd_t spill_gpr16_1_opnd = opnd_create_reg(spill_gpr16_1);
    opnd_t spill_gpr16_2_opnd = opnd_create_reg(spill_gpr16_2);

    // pushfq
    instr_t *i1 = INSTR_CREATE_pushf(dcontext);
    // push rax
    instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_1_opnd);
    // push rbx
    instr_t *i3 = INSTR_CREATE_push(dcontext, spill_gpr64_2_opnd);
    // tls_slot(input_mask1) -> %ax
    instr_t *i4 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr16_1, TLS_K_idx_SLOT(input_k1_idx), OPSZ_2);
    // tls_slot(input_mask2) -> %bx
    instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr16_2, TLS_K_idx_SLOT(input_k2_idx), OPSZ_2);
    // and %bx, %ax
    instr_t *i6 = INSTR_CREATE_and(dcontext, spill_gpr16_1_opnd, spill_gpr16_2_opnd);
    // mov %ax, tls_slot(output_mask)
    instr_t *i7 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr16_1, TLS_K_idx_SLOT(output_k_idx), OPSZ_2);
    // pop rbx
    instr_t *i8 = INSTR_CREATE_pop(dcontext, spill_gpr64_2_opnd);
    // pop rax
    instr_t *i9 = INSTR_CREATE_pop(dcontext, spill_gpr64_1_opnd);
    // popfq
    instr_t *i10 = INSTR_CREATE_popf(dcontext);

#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 10, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);
#endif
    instrlist_concat_next_instr(ilist, 10, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);
    return i1;
}

instr_t * /* 477 */
rw_func_kandb(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kandb %k1, %k2, %k3 - 8-bit K register AND operation
    // DEST[7:0] := SRC1[7:0] AND SRC2[7:0]
    // DEST[MAX_KL-1:8] := 0
    opnd_t src1_opnd = instr_get_src(instr, 0);
    opnd_t src2_opnd = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting kandb at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src1_opnd, "input src1: ");
    dr_print_opnd(dcontext, STD_OUTF, src2_opnd, "input src2: ");
    dr_print_opnd(dcontext, STD_OUTF, dst_opnd, "output dst: ");
#endif
    reg_id_t input_mask1 = opnd_get_reg(src1_opnd);
    reg_id_t input_mask2 = opnd_get_reg(src2_opnd);
    reg_id_t output_mask = opnd_get_reg(dst_opnd);
    uint input_k1_idx = TO_K_REG_INDEX(input_mask1);
    uint input_k2_idx = TO_K_REG_INDEX(input_mask2);
    uint output_k_idx = TO_K_REG_INDEX(output_mask);

    reg_id_t spill_gpr64_1 = DR_REG_RAX;
    reg_id_t spill_gpr64_2 = DR_REG_RBX;
    reg_id_t spill_gpr8_1 = DR_REG_AL;
    reg_id_t spill_gpr8_2 = DR_REG_BL;

    opnd_t spill_gpr64_1_opnd = opnd_create_reg(spill_gpr64_1);
    opnd_t spill_gpr64_2_opnd = opnd_create_reg(spill_gpr64_2);
    opnd_t spill_gpr8_1_opnd = opnd_create_reg(spill_gpr8_1);
    opnd_t spill_gpr8_2_opnd = opnd_create_reg(spill_gpr8_2);

    // pushfq
    instr_t *i1 = INSTR_CREATE_pushf(dcontext);
    // push rax
    instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_1_opnd);
    // push rbx
    instr_t *i3 = INSTR_CREATE_push(dcontext, spill_gpr64_2_opnd);
    // tls_slot(input_mask1) -> %al
    instr_t *i4 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr8_1, TLS_K_idx_SLOT(input_k1_idx), OPSZ_1);
    // tls_slot(input_mask2) -> %bl
    instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr8_2, TLS_K_idx_SLOT(input_k2_idx), OPSZ_1);
    // and %bl, %al
    instr_t *i6 = INSTR_CREATE_and(dcontext, spill_gpr8_1_opnd, spill_gpr8_2_opnd);
    // mov %al, tls_slot(output_mask)
    instr_t *i7 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr8_1, TLS_K_idx_SLOT(output_k_idx), OPSZ_1);
    // pop rbx
    instr_t *i8 = INSTR_CREATE_pop(dcontext, spill_gpr64_2_opnd);
    // pop rax
    instr_t *i9 = INSTR_CREATE_pop(dcontext, spill_gpr64_1_opnd);
    // popfq
    instr_t *i10 = INSTR_CREATE_popf(dcontext);

#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 10, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);
#endif
    instrlist_concat_next_instr(ilist, 10, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);
    return i1;
}

instr_t * /* 478 */
rw_func_kandq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kandq %k1, %k2, %k3 - 64-bit K register AND operation
    // DEST[63:0] := SRC1[63:0] AND SRC2[63:0]
    opnd_t src1_opnd = instr_get_src(instr, 0);
    opnd_t src2_opnd = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting kandq at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src1_opnd, "input src1: ");
    dr_print_opnd(dcontext, STD_OUTF, src2_opnd, "input src2: ");
    dr_print_opnd(dcontext, STD_OUTF, dst_opnd, "output dst: ");
#endif
    reg_id_t input_mask1 = opnd_get_reg(src1_opnd);
    reg_id_t input_mask2 = opnd_get_reg(src2_opnd);
    reg_id_t output_mask = opnd_get_reg(dst_opnd);
    uint input_k1_idx = TO_K_REG_INDEX(input_mask1);
    uint input_k2_idx = TO_K_REG_INDEX(input_mask2);
    uint output_k_idx = TO_K_REG_INDEX(output_mask);

    reg_id_t spill_gpr64_1 = DR_REG_RAX;
    reg_id_t spill_gpr64_2 = DR_REG_RBX;

    opnd_t spill_gpr64_1_opnd = opnd_create_reg(spill_gpr64_1);
    opnd_t spill_gpr64_2_opnd = opnd_create_reg(spill_gpr64_2);

    // pushfq
    instr_t *i1 = INSTR_CREATE_pushf(dcontext);
    // push rax
    instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_1_opnd);
    // push rbx
    instr_t *i3 = INSTR_CREATE_push(dcontext, spill_gpr64_2_opnd);
    // tls_slot(input_mask1) -> %rax
    instr_t *i4 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr64_1, TLS_K_idx_SLOT(input_k1_idx), OPSZ_8);
    // tls_slot(input_mask2) -> %rbx
    instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr64_2, TLS_K_idx_SLOT(input_k2_idx), OPSZ_8);
    // and %rbx, %rax
    instr_t *i6 = INSTR_CREATE_and(dcontext, spill_gpr64_1_opnd, spill_gpr64_2_opnd);
    // mov %rax, tls_slot(output_mask)
    instr_t *i7 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr64_1, TLS_K_idx_SLOT(output_k_idx), OPSZ_8);
    // pop rbx
    instr_t *i8 = INSTR_CREATE_pop(dcontext, spill_gpr64_2_opnd);
    // pop rax
    instr_t *i9 = INSTR_CREATE_pop(dcontext, spill_gpr64_1_opnd);
    // popfq
    instr_t *i10 = INSTR_CREATE_popf(dcontext);

#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 10, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);
#endif
    instrlist_concat_next_instr(ilist, 10, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);
    return i1;
}

instr_t * /* 479 */
rw_func_kandd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kandd %k1, %k2, %k3 - 32-bit K register AND operation
    // DEST[31:0] := SRC1[31:0] AND SRC2[31:0]
    // DEST[MAX_KL-1:32] := 0
    opnd_t src1_opnd = instr_get_src(instr, 0);
    opnd_t src2_opnd = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting kandd at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src1_opnd, "input src1: ");
    dr_print_opnd(dcontext, STD_OUTF, src2_opnd, "input src2: ");
    dr_print_opnd(dcontext, STD_OUTF, dst_opnd, "output dst: ");
#endif
    reg_id_t input_mask1 = opnd_get_reg(src1_opnd);
    reg_id_t input_mask2 = opnd_get_reg(src2_opnd);
    reg_id_t output_mask = opnd_get_reg(dst_opnd);
    uint input_k1_idx = TO_K_REG_INDEX(input_mask1);
    uint input_k2_idx = TO_K_REG_INDEX(input_mask2);
    uint output_k_idx = TO_K_REG_INDEX(output_mask);

    reg_id_t spill_gpr64_1 = DR_REG_RAX;
    reg_id_t spill_gpr64_2 = DR_REG_RBX;
    reg_id_t spill_gpr32_1 = DR_REG_EAX;
    reg_id_t spill_gpr32_2 = DR_REG_EBX;

    opnd_t spill_gpr64_1_opnd = opnd_create_reg(spill_gpr64_1);
    opnd_t spill_gpr64_2_opnd = opnd_create_reg(spill_gpr64_2);
    opnd_t spill_gpr32_1_opnd = opnd_create_reg(spill_gpr32_1);
    opnd_t spill_gpr32_2_opnd = opnd_create_reg(spill_gpr32_2);

    // pushfq
    instr_t *i1 = INSTR_CREATE_pushf(dcontext);
    // push rax
    instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_1_opnd);
    // push rbx
    instr_t *i3 = INSTR_CREATE_push(dcontext, spill_gpr64_2_opnd);
    // tls_slot(input_mask1) -> %eax
    instr_t *i4 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr32_1, TLS_K_idx_SLOT(input_k1_idx), OPSZ_4);
    // tls_slot(input_mask2) -> %ebx
    instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr32_2, TLS_K_idx_SLOT(input_k2_idx), OPSZ_4);
    // and %ebx, %eax
    instr_t *i6 = INSTR_CREATE_and(dcontext, spill_gpr32_1_opnd, spill_gpr32_2_opnd);
    // mov %eax, tls_slot(output_mask)
    instr_t *i7 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr32_1, TLS_K_idx_SLOT(output_k_idx), OPSZ_4);
    // pop rbx
    instr_t *i8 = INSTR_CREATE_pop(dcontext, spill_gpr64_2_opnd);
    // pop rax
    instr_t *i9 = INSTR_CREATE_pop(dcontext, spill_gpr64_1_opnd);
    // popfq
    instr_t *i10 = INSTR_CREATE_popf(dcontext);

#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 10, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);
#endif
    instrlist_concat_next_instr(ilist, 10, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);
    return i1;
}

/**
 * @brief kandn_ template function
 */
instr_t * /* 480 */
rw_func_kandn_(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "rewrite kandn_ not support");
#endif
    return NULL_INSTR;
}

instr_t * /* 480 */
rw_func_kandnw(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kandnw %k1, %k2, %k3 - 16-bit K register AND NOT operation
    // DEST[15:0] := (~SRC1[15:0]) AND SRC2[15:0]
    // DEST[MAX_KL-1:16] := 0
    opnd_t src1_opnd = instr_get_src(instr, 0);
    opnd_t src2_opnd = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting kandnw at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src1_opnd, "input src1: ");
    dr_print_opnd(dcontext, STD_OUTF, src2_opnd, "input src2: ");
    dr_print_opnd(dcontext, STD_OUTF, dst_opnd, "output dst: ");
#endif
    reg_id_t input_mask1 = opnd_get_reg(src1_opnd);
    reg_id_t input_mask2 = opnd_get_reg(src2_opnd);
    reg_id_t output_mask = opnd_get_reg(dst_opnd);
    uint input_k1_idx = TO_K_REG_INDEX(input_mask1);
    uint input_k2_idx = TO_K_REG_INDEX(input_mask2);
    uint output_k_idx = TO_K_REG_INDEX(output_mask);

    reg_id_t spill_gpr64_1 = DR_REG_RAX;
    reg_id_t spill_gpr64_2 = DR_REG_RBX;
    reg_id_t spill_gpr16_1 = DR_REG_AX;
    reg_id_t spill_gpr16_2 = DR_REG_BX;

    opnd_t spill_gpr64_1_opnd = opnd_create_reg(spill_gpr64_1);
    opnd_t spill_gpr64_2_opnd = opnd_create_reg(spill_gpr64_2);
    opnd_t spill_gpr16_1_opnd = opnd_create_reg(spill_gpr16_1);
    opnd_t spill_gpr16_2_opnd = opnd_create_reg(spill_gpr16_2);

    // pushfq
    instr_t *i1 = INSTR_CREATE_pushf(dcontext);
    // push rax
    instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_1_opnd);
    // push rbx
    instr_t *i3 = INSTR_CREATE_push(dcontext, spill_gpr64_2_opnd);
    // tls_slot(input_mask1) -> %ax
    instr_t *i4 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr16_1, TLS_K_idx_SLOT(input_k1_idx), OPSZ_2);
    // tls_slot(input_mask2) -> %bx
    instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr16_2, TLS_K_idx_SLOT(input_k2_idx), OPSZ_2);
    // not %ax - bitwise NOT of src1
    instr_t *i6 = INSTR_CREATE_not(dcontext, spill_gpr16_1_opnd);
    // and %bx, %ax - AND with src2
    instr_t *i7 = INSTR_CREATE_and(dcontext, spill_gpr16_1_opnd, spill_gpr16_2_opnd);
    // mov %ax, tls_slot(output_mask)
    instr_t *i8 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr16_1, TLS_K_idx_SLOT(output_k_idx), OPSZ_2);
    // pop rbx
    instr_t *i9 = INSTR_CREATE_pop(dcontext, spill_gpr64_2_opnd);
    // pop rax
    instr_t *i10 = INSTR_CREATE_pop(dcontext, spill_gpr64_1_opnd);
    // popfq
    instr_t *i11 = INSTR_CREATE_popf(dcontext);

#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 11, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);
#endif
    instrlist_concat_next_instr(ilist, 11, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);
    return i1;
}

instr_t * /* 481 */
rw_func_kandnb(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kandnb %k1, %k2, %k3 - 8-bit K register AND NOT operation
    // DEST[7:0] := (~SRC1[7:0]) AND SRC2[7:0]
    // DEST[MAX_KL-1:8] := 0
    opnd_t src1_opnd = instr_get_src(instr, 0);
    opnd_t src2_opnd = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting kandnb at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src1_opnd, "input src1: ");
    dr_print_opnd(dcontext, STD_OUTF, src2_opnd, "input src2: ");
    dr_print_opnd(dcontext, STD_OUTF, dst_opnd, "output dst: ");
#endif
    reg_id_t input_mask1 = opnd_get_reg(src1_opnd);
    reg_id_t input_mask2 = opnd_get_reg(src2_opnd);
    reg_id_t output_mask = opnd_get_reg(dst_opnd);
    uint input_k1_idx = TO_K_REG_INDEX(input_mask1);
    uint input_k2_idx = TO_K_REG_INDEX(input_mask2);
    uint output_k_idx = TO_K_REG_INDEX(output_mask);

    reg_id_t spill_gpr64_1 = DR_REG_RAX;
    reg_id_t spill_gpr64_2 = DR_REG_RBX;
    reg_id_t spill_gpr8_1 = DR_REG_AL;
    reg_id_t spill_gpr8_2 = DR_REG_BL;

    opnd_t spill_gpr64_1_opnd = opnd_create_reg(spill_gpr64_1);
    opnd_t spill_gpr64_2_opnd = opnd_create_reg(spill_gpr64_2);
    opnd_t spill_gpr8_1_opnd = opnd_create_reg(spill_gpr8_1);
    opnd_t spill_gpr8_2_opnd = opnd_create_reg(spill_gpr8_2);

    // pushfq
    instr_t *i1 = INSTR_CREATE_pushf(dcontext);
    // push rax
    instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_1_opnd);
    // push rbx
    instr_t *i3 = INSTR_CREATE_push(dcontext, spill_gpr64_2_opnd);
    // tls_slot(input_mask1) -> %al
    instr_t *i4 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr8_1, TLS_K_idx_SLOT(input_k1_idx), OPSZ_1);
    // tls_slot(input_mask2) -> %bl
    instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr8_2, TLS_K_idx_SLOT(input_k2_idx), OPSZ_1);
    // not %al - bitwise NOT of src1
    instr_t *i6 = INSTR_CREATE_not(dcontext, spill_gpr8_1_opnd);
    // and %bl, %al - AND with src2
    instr_t *i7 = INSTR_CREATE_and(dcontext, spill_gpr8_1_opnd, spill_gpr8_2_opnd);
    // mov %al, tls_slot(output_mask)
    instr_t *i8 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr8_1, TLS_K_idx_SLOT(output_k_idx), OPSZ_1);
    // pop rbx
    instr_t *i9 = INSTR_CREATE_pop(dcontext, spill_gpr64_2_opnd);
    // pop rax
    instr_t *i10 = INSTR_CREATE_pop(dcontext, spill_gpr64_1_opnd);
    // popfq
    instr_t *i11 = INSTR_CREATE_popf(dcontext);

#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 11, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);
#endif
    instrlist_concat_next_instr(ilist, 11, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);
    return i1;
}

instr_t * /* 482 */
rw_func_kandnq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kandnq %k1, %k2, %k3 - 64-bit K register AND NOT operation
    // DEST[63:0] := (~SRC1[63:0]) AND SRC2[63:0]
    opnd_t src1_opnd = instr_get_src(instr, 0);
    opnd_t src2_opnd = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting kandnq at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src1_opnd, "input src1: ");
    dr_print_opnd(dcontext, STD_OUTF, src2_opnd, "input src2: ");
    dr_print_opnd(dcontext, STD_OUTF, dst_opnd, "output dst: ");
#endif
    reg_id_t input_mask1 = opnd_get_reg(src1_opnd);
    reg_id_t input_mask2 = opnd_get_reg(src2_opnd);
    reg_id_t output_mask = opnd_get_reg(dst_opnd);
    uint input_k1_idx = TO_K_REG_INDEX(input_mask1);
    uint input_k2_idx = TO_K_REG_INDEX(input_mask2);
    uint output_k_idx = TO_K_REG_INDEX(output_mask);

    reg_id_t spill_gpr64_1 = DR_REG_RAX;
    reg_id_t spill_gpr64_2 = DR_REG_RBX;

    opnd_t spill_gpr64_1_opnd = opnd_create_reg(spill_gpr64_1);
    opnd_t spill_gpr64_2_opnd = opnd_create_reg(spill_gpr64_2);

    // pushfq
    instr_t *i1 = INSTR_CREATE_pushf(dcontext);
    // push rax
    instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_1_opnd);
    // push rbx
    instr_t *i3 = INSTR_CREATE_push(dcontext, spill_gpr64_2_opnd);
    // tls_slot(input_mask1) -> %rax
    instr_t *i4 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr64_1, TLS_K_idx_SLOT(input_k1_idx), OPSZ_8);
    // tls_slot(input_mask2) -> %rbx
    instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr64_2, TLS_K_idx_SLOT(input_k2_idx), OPSZ_8);
    // not %rax - bitwise NOT of src1
    instr_t *i6 = INSTR_CREATE_not(dcontext, spill_gpr64_1_opnd);
    // and %rbx, %rax - AND with src2
    instr_t *i7 = INSTR_CREATE_and(dcontext, spill_gpr64_1_opnd, spill_gpr64_2_opnd);
    // mov %rax, tls_slot(output_mask)
    instr_t *i8 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr64_1, TLS_K_idx_SLOT(output_k_idx), OPSZ_8);
    // pop rbx
    instr_t *i9 = INSTR_CREATE_pop(dcontext, spill_gpr64_2_opnd);
    // pop rax
    instr_t *i10 = INSTR_CREATE_pop(dcontext, spill_gpr64_1_opnd);
    // popfq
    instr_t *i11 = INSTR_CREATE_popf(dcontext);

#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 11, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);
#endif
    instrlist_concat_next_instr(ilist, 11, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);
    return i1;
}

instr_t * /* 483 */
rw_func_kandnd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kandnd %k1, %k2, %k3 - 32-bit K register AND NOT operation
    // DEST[31:0] := (~SRC1[31:0]) AND SRC2[31:0]
    // DEST[MAX_KL-1:32] := 0
    opnd_t src1_opnd = instr_get_src(instr, 0);
    opnd_t src2_opnd = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting kandnd at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src1_opnd, "input src1: ");
    dr_print_opnd(dcontext, STD_OUTF, src2_opnd, "input src2: ");
    dr_print_opnd(dcontext, STD_OUTF, dst_opnd, "output dst: ");
#endif
    reg_id_t input_mask1 = opnd_get_reg(src1_opnd);
    reg_id_t input_mask2 = opnd_get_reg(src2_opnd);
    reg_id_t output_mask = opnd_get_reg(dst_opnd);
    uint input_k1_idx = TO_K_REG_INDEX(input_mask1);
    uint input_k2_idx = TO_K_REG_INDEX(input_mask2);
    uint output_k_idx = TO_K_REG_INDEX(output_mask);

    reg_id_t spill_gpr64_1 = DR_REG_RAX;
    reg_id_t spill_gpr64_2 = DR_REG_RBX;
    reg_id_t spill_gpr32_1 = DR_REG_EAX;
    reg_id_t spill_gpr32_2 = DR_REG_EBX;

    opnd_t spill_gpr64_1_opnd = opnd_create_reg(spill_gpr64_1);
    opnd_t spill_gpr64_2_opnd = opnd_create_reg(spill_gpr64_2);
    opnd_t spill_gpr32_1_opnd = opnd_create_reg(spill_gpr32_1);
    opnd_t spill_gpr32_2_opnd = opnd_create_reg(spill_gpr32_2);

    // pushfq
    instr_t *i1 = INSTR_CREATE_pushf(dcontext);
    // push rax
    instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_1_opnd);
    // push rbx
    instr_t *i3 = INSTR_CREATE_push(dcontext, spill_gpr64_2_opnd);
    // tls_slot(input_mask1) -> %eax
    instr_t *i4 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr32_1, TLS_K_idx_SLOT(input_k1_idx), OPSZ_4);
    // tls_slot(input_mask2) -> %ebx
    instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr32_2, TLS_K_idx_SLOT(input_k2_idx), OPSZ_4);
    // not %eax - bitwise NOT of src1
    instr_t *i6 = INSTR_CREATE_not(dcontext, spill_gpr32_1_opnd);
    // and %ebx, %eax - AND with src2
    instr_t *i7 = INSTR_CREATE_and(dcontext, spill_gpr32_1_opnd, spill_gpr32_2_opnd);
    // mov %eax, tls_slot(output_mask)
    instr_t *i8 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr32_1, TLS_K_idx_SLOT(output_k_idx), OPSZ_4);
    // pop rbx
    instr_t *i9 = INSTR_CREATE_pop(dcontext, spill_gpr64_2_opnd);
    // pop rax
    instr_t *i10 = INSTR_CREATE_pop(dcontext, spill_gpr64_1_opnd);
    // popfq
    instr_t *i11 = INSTR_CREATE_popf(dcontext);

#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 11, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);
#endif
    instrlist_concat_next_instr(ilist, 11, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);
    return i1;
}

/**
 * @brief kunpck_ template function
 */
instr_t *
rw_func_kunpck_(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "rewrite kunpck_ not support");
#endif
    return NULL_INSTR;
}

instr_t * /* 484 */
rw_func_kunpckbw(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kunpckbw %k1 %k2 -> %k1
    opnd_t src1_opnd = instr_get_src(instr, 0);
    opnd_t src2_opnd = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
    // DEST[7:0] := SRC2[7:0]
    // DEST[15:8] := SRC1[7:0]
    // DEST[MAX_KL-1:16] := 0

#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting kunpckbw at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src1_opnd, "  src1:");
    dr_print_opnd(dcontext, STD_OUTF, src2_opnd, "  src2:");
    dr_print_opnd(dcontext, STD_OUTF, dst_opnd, "  dst:");
    NEWLINE(STD_OUTF);
#endif
    reg_id_t src1_mask_reg = opnd_get_reg(src1_opnd);
    reg_id_t src2_mask_reg = opnd_get_reg(src2_opnd);
    reg_id_t dst_mask_reg = opnd_get_reg(dst_opnd);

    /* we need only two scratch registers, one for mask1, one for mask2
    we choose rax, rcx as our scratch registers */
    reg_id_t src1_spill_reg = DR_REG_RAX;
    reg_id_t src2_spill_reg = DR_REG_RCX;
    opnd_t src1_spill_opnd = opnd_create_reg(src1_spill_reg);
    opnd_t src2_spill_opnd = opnd_create_reg(src2_spill_reg);

    // save tmp reg
    instr_t *i1 = SAVE_TO_TLS(dcontext, src1_spill_reg, TLS_REG1_SLOT);
    // save tmp reg
    instr_t *i2 = SAVE_TO_TLS(dcontext, src2_spill_reg, TLS_REG3_SLOT);
    // tls(mask1) -> src1_spill_reg
    instr_t *i3 = RESTORE_FROM_TLS(dcontext, src1_spill_reg, TLS_K_idx_SLOT(TO_K_REG_INDEX(src1_mask_reg)));
    // tls(mask2) -> src2_spill_reg
    instr_t *i4 = RESTORE_FROM_TLS(dcontext, src2_spill_reg, TLS_K_idx_SLOT(TO_K_REG_INDEX(src2_mask_reg)));
    // shl src1_spill_reg, 8
    instr_t *i5 = INSTR_CREATE_shl(dcontext, src1_spill_opnd, OPND_CREATE_INT8(0x08));
    // and src1_spill_reg, 0xff00
    instr_t *i6 = INSTR_CREATE_and(dcontext, src1_spill_opnd, OPND_CREATE_INT32(0xff00));
    // and src2_spill_reg, 0xff
    instr_t *i7 = INSTR_CREATE_and(dcontext, src2_spill_opnd, OPND_CREATE_INT32(0x00ff));
    // or src2_spill_reg, src1_spill_reg
    instr_t *i8 = INSTR_CREATE_or(dcontext, src2_spill_opnd, src1_spill_opnd);
    // mov src2_spill_reg, tls(dst_mask_reg)
    instr_t *i9 = SAVE_TO_TLS(dcontext, src2_spill_reg, TLS_K_idx_SLOT(TO_K_REG_INDEX(dst_mask_reg)));
    // pop rcx
    instr_t *i10 = RESTORE_FROM_TLS(dcontext, src2_spill_reg, TLS_REG3_SLOT);
    // pop rax
    instr_t *i11 = RESTORE_FROM_TLS(dcontext, src1_spill_reg, TLS_REG1_SLOT);

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 11, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);
#endif

    instrlist_concat_next_instr(ilist, 11, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);

    return i1;
}

instr_t * /* 485 */
rw_func_kunpckwd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kunpckwd %k1 %k0 -> %k1
    opnd_t src1_opnd = instr_get_src(instr, 0);
    opnd_t src2_opnd = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
    // DEST[15:0] := SRC2[15:0]
    // DEST[31:16] := SRC1[15:0]
    // DEST[MAX_KL-1:32] := 0

#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting kunpckwd at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src1_opnd, "  src1:");
    dr_print_opnd(dcontext, STD_OUTF, src2_opnd, "  src2:");
    dr_print_opnd(dcontext, STD_OUTF, dst_opnd, "  dst:");
    NEWLINE(STD_OUTF);
#endif
    reg_id_t src1_mask_reg = opnd_get_reg(src1_opnd);
    reg_id_t src2_mask_reg = opnd_get_reg(src2_opnd);
    reg_id_t dst_mask_reg = opnd_get_reg(dst_opnd);

    /* we need only two scratch registers, one for mask1, one for mask2
    we choose rax, rcx as our scratch registers */
    reg_id_t src1_spill_reg = DR_REG_RAX;
    reg_id_t src2_spill_reg = DR_REG_RCX;
    reg_id_t src3_spill_reg = DR_REG_RDX;
    opnd_t src1_spill_opnd = opnd_create_reg(src1_spill_reg);
    opnd_t src2_spill_opnd = opnd_create_reg(src2_spill_reg);
    opnd_t src3_spill_opnd = opnd_create_reg(src3_spill_reg);

    // push rax
    instr_t *i1 = SAVE_TO_TLS(dcontext, src1_spill_reg, TLS_REG1_SLOT);
    // push rcx
    instr_t *i2 = SAVE_TO_TLS(dcontext, src2_spill_reg, TLS_REG3_SLOT);
    // push rdx
    instr_t *i3 = SAVE_TO_TLS(dcontext, src3_spill_reg, TLS_REG2_SLOT);
    // tls(mask1) -> src1_spill_reg
    instr_t *i4 = RESTORE_FROM_TLS(dcontext, src1_spill_reg, TLS_K_idx_SLOT(TO_K_REG_INDEX(src1_mask_reg)));
    // tls(mask2) -> src2_spill_reg
    instr_t *i5 = RESTORE_FROM_TLS(dcontext, src2_spill_reg, TLS_K_idx_SLOT(TO_K_REG_INDEX(src2_mask_reg)));
    // shl src1_spill_reg, 16
    instr_t *i6 = INSTR_CREATE_shl(dcontext, src1_spill_opnd, OPND_CREATE_INT8(0x10));
    // mov 0xffff0000 -> src3_spill_reg
    instr_t *i7 = INSTR_CREATE_mov_imm(dcontext, src3_spill_opnd, OPND_CREATE_INT64(0x00000000ffff0000));
    // and src1_spill_reg, 0xffff0000
    instr_t *i8 = INSTR_CREATE_and(dcontext, src1_spill_opnd, src3_spill_opnd);
    // mov 0x0000ffff -> src3_spill_reg
    instr_t *i9 = INSTR_CREATE_mov_imm(dcontext, src3_spill_opnd, OPND_CREATE_INT64(0x000000000000ffff));
    // and src2_spill_reg, src3_spill_reg
    instr_t *i10 = INSTR_CREATE_and(dcontext, src2_spill_opnd, src3_spill_opnd);
    // or src2_spill_reg, src1_spill_reg
    instr_t *i11 = INSTR_CREATE_or(dcontext, src2_spill_opnd, src1_spill_opnd);
    // mov src2_spill_reg, tls(dst_mask_reg)
    instr_t *i12 = SAVE_TO_TLS(dcontext, src2_spill_reg, TLS_K_idx_SLOT(TO_K_REG_INDEX(dst_mask_reg)));
    // pop rdx
    instr_t *i13 = RESTORE_FROM_TLS(dcontext, src3_spill_reg, TLS_REG2_SLOT);
    // pop rcx
    instr_t *i14 = RESTORE_FROM_TLS(dcontext, src2_spill_reg, TLS_REG3_SLOT);
    // pop rax
    instr_t *i15 = RESTORE_FROM_TLS(dcontext, src1_spill_reg, TLS_REG1_SLOT);

    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 15, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15);
#endif

    instrlist_concat_next_instr(ilist, 15, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15);

    return i1;
}

instr_t * /* 486 */
rw_func_kunpckdq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "rewrite kunpckdq not support");
#endif
    return NULL_INSTR;
}

/**
 * @brief knot_ template function
 */
instr_t *
rw_func_knot_(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "rewrite knot_ not support");
#endif
    return NULL_INSTR;
}

instr_t * /* 487 */
rw_func_knotw(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "rewrite knotw not support");
#endif
    return NULL_INSTR;
}

instr_t * /* 488 */
rw_func_knotb(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "rewrite knotb not support");
#endif
    return NULL_INSTR;
}

instr_t * /* 489 */
rw_func_knotq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "rewrite knotq not support");
#endif
    return NULL_INSTR;
}

instr_t * /* 490 */
rw_func_knotd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "rewrite knotd not support");
#endif
    return NULL_INSTR;
}

/**
 * @brief kor_ template function
 *
 */
instr_t *
rw_func_kor_(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "rewrite kor_ not support");
#endif
    return NULL_INSTR;
}

instr_t * /* 491 */
rw_func_korw(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "rewrite korw not support");
#endif
    return NULL_INSTR;
}

instr_t * /* 492 */
rw_func_korb(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "rewrite korb not support");
#endif
    return NULL_INSTR;
}

instr_t * /* 493 */
rw_func_korq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "rewrite korq not support");
#endif
    return NULL_INSTR;
}

instr_t * /* 494 */
rw_func_kord(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "rewrite kord not support");
#endif
    return NULL_INSTR;
}

/**
 * @brief kxnor_ template function
 */
instr_t *
rw_func_kxnor_(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "rewrite kxnor_ not support");
#endif
    return NULL_INSTR;
}

instr_t * /* 495 */
rw_func_kxnorw(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "kxnorw", true, true, false, true);
#endif
    opnd_t src_opnd1 = instr_get_src(instr, 0);
    opnd_t src_opnd2 = instr_get_src(instr, 1);
    reg_id_t src_reg1 = opnd_get_reg(src_opnd1);
    reg_id_t src_reg2 = opnd_get_reg(src_opnd2);
    if (src_reg1 == src_reg2) { // if kxnor_ operate on same register, then directly assign all 1s to the dst opnd
        instrlist_remove(ilist, instr);
        instr_destroy(dcontext, instr);

        reg_id_t reg_rax = DR_REG_RAX;
        opnd_t op_rax = opnd_create_reg(reg_rax);
        // kxnorw %k1,%k1,%k1
        // (gdb) p/x $k1
        // $2 = 0xffff
        int k_idx = TO_K_REG_INDEX(src_reg1);
        // push rax
        instr_t *i1 = INSTR_CREATE_push(dcontext, op_rax);
        // mov 0x00ffff %rax
        instr_t *i2 = INSTR_CREATE_mov_imm(dcontext, op_rax, OPND_CREATE_INT64(0x000000000000ffff));
        // mov %rax tls_slot(k1)
        instr_t *i3 = SAVE_TO_TLS(dcontext, DR_REG_RAX, TLS_K_idx_SLOT(k_idx));
        // pop rax
        instr_t *i4 = INSTR_CREATE_pop(dcontext, op_rax);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    }
    return NULL_INSTR;
}

instr_t * /* 496 */
rw_func_kxnorb(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kxnorb %k1 %k1 -> %k1, same 1, diff 0
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "kxnorw", true, true, false, true);
#endif
    opnd_t src_opnd1 = instr_get_src(instr, 0);
    opnd_t src_opnd2 = instr_get_src(instr, 1);
    reg_id_t src_reg1 = opnd_get_reg(src_opnd1);
    reg_id_t src_reg2 = opnd_get_reg(src_opnd2);
    if (src_reg1 == src_reg2) { // if kxnor_ operate on same register, then directly assign all 1s to the dst opnd
        instrlist_remove(ilist, instr);
        instr_destroy(dcontext, instr);
        // kxnorb %k1,%k1,%k1
        // (gdb) p/x $k1
        //  $2 = 0xff

        reg_id_t reg_rax = DR_REG_RAX;
        opnd_t op_rax = opnd_create_reg(reg_rax);
        int k_idx = TO_K_REG_INDEX(src_reg1);
        // push rax
        instr_t *i1 = INSTR_CREATE_push(dcontext, op_rax);
        // mov 0x0000ff %rax
        instr_t *i2 = INSTR_CREATE_mov_imm(dcontext, op_rax, OPND_CREATE_INT64(0x00000000000000ff));
        // mov %rax tls_slot(k1)
        instr_t *i3 = SAVE_TO_TLS(dcontext, DR_REG_RAX, TLS_K_idx_SLOT(k_idx));
        // pop rax
        instr_t *i4 = INSTR_CREATE_pop(dcontext, op_rax);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    }
    return NULL_INSTR;
}

instr_t * /* 497 */
rw_func_kxnorq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "kxnorw", true, true, false, true);
#endif
    opnd_t src_opnd1 = instr_get_src(instr, 0);
    opnd_t src_opnd2 = instr_get_src(instr, 1);
    reg_id_t src_reg1 = opnd_get_reg(src_opnd1);
    reg_id_t src_reg2 = opnd_get_reg(src_opnd2);
    if (src_reg1 == src_reg2) { // if kxnor_ operate on same register, then directly assign all 1s to the dst opnd
        instrlist_remove(ilist, instr);
        instr_destroy(dcontext, instr);
        // kxnorw %k1,%k1,%k1
        // (gdb) p/x $k1
        // $3 = 0xffffffffffffffff
        int k_idx = TO_K_REG_INDEX(src_reg1);
        reg_id_t reg_rax = DR_REG_RAX;
        opnd_t op_rax = opnd_create_reg(reg_rax);
        // push rax
        instr_t *i1 = INSTR_CREATE_push(dcontext, op_rax);
        // mov 0xffffffffffffffff rax
        instr_t *i2 = INSTR_CREATE_mov_imm(dcontext, op_rax, OPND_CREATE_INT64(0xffffffffffffffff));
        // mov rax tls_slot(k1)
        instr_t *i3 = SAVE_TO_TLS(dcontext, DR_REG_RAX, TLS_K_idx_SLOT(k_idx));
        // pop rax
        instr_t *i4 = INSTR_CREATE_pop(dcontext, op_rax);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } else {
#ifdef DEBUG
        REWRITE_INFO(STD_OUTF, "kxnorq src1 != src2 not implemented\n");
#endif
        return NULL_INSTR;
    }
    return NULL_INSTR;
}

instr_t * /* 498 */
rw_func_kxnord(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "kxnorw", true, true, false, true);
#endif
    opnd_t src_opnd1 = instr_get_src(instr, 0);
    opnd_t src_opnd2 = instr_get_src(instr, 1);
    reg_id_t src_reg1 = opnd_get_reg(src_opnd1);
    reg_id_t src_reg2 = opnd_get_reg(src_opnd2);
    if (src_reg1 == src_reg2) { // if kxnor_ operate on same register, then directly assign all 1s to the dst opnd
        instrlist_remove(ilist, instr);
        instr_destroy(dcontext, instr);
        // kxnorw %k1,%k1,%k1
        // (gdb) p/x $k1
        // $3 = 0xffffffff

        reg_id_t reg_rax = DR_REG_RAX;
        opnd_t op_rax = opnd_create_reg(reg_rax);
        int k_idx = TO_K_REG_INDEX(src_reg1);
        // push rax
        instr_t *i1 = INSTR_CREATE_push(dcontext, op_rax);
        // mov 0x00ffffffff %rax
        instr_t *i2 = INSTR_CREATE_mov_imm(dcontext, op_rax, OPND_CREATE_INT64(0x00ffffffff));
        // mov %rax tls_slot(k1)
        instr_t *i3 = SAVE_TO_TLS(dcontext, DR_REG_RAX, TLS_K_idx_SLOT(k_idx));
        // pop rax
        instr_t *i4 = INSTR_CREATE_pop(dcontext, op_rax);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 4, i1, i2, i3, i4);
#endif
        instrlist_concat_next_instr(ilist, 4, i1, i2, i3, i4);
        return i1;
    } else {
#ifdef DEBUG
        REWRITE_INFO(STD_OUTF, "kxnord src1 != src2 not implmented\n");
#endif
    }
    return NULL_INSTR;
}

/**
 * @brief kxor_ template function
 */
instr_t *
rw_func_kxor_(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "rewrite kxor_ not support");
#endif
    return NULL_INSTR;
}

instr_t * /* 499 */
rw_func_kxorw(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "kxorw", true, true, false, true);
#endif
    opnd_t src_opnd1 = instr_get_src(instr, 0);
    opnd_t src_opnd2 = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
    
    reg_id_t src_reg1 = opnd_get_reg(src_opnd1);
    reg_id_t src_reg2 = opnd_get_reg(src_opnd2);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    
    uint src1_k_idx = TO_K_REG_INDEX(src_reg1);
    uint src2_k_idx = TO_K_REG_INDEX(src_reg2);
    uint dst_k_idx = TO_K_REG_INDEX(dst_reg);
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    
    reg_id_t spill_gpr64 = DR_REG_RAX;
    reg_id_t spill_gpr16 = DR_REG_AX;
    opnd_t spill_gpr64_opnd = opnd_create_reg(spill_gpr64);
    opnd_t spill_gpr16_opnd = opnd_create_reg(spill_gpr16);
    
    // pushfq
    instr_t *i1 = INSTR_CREATE_pushf(dcontext);
    // push rax
    instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
    // tls_slot(src1_k_idx) -> %ax
    instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr16, TLS_K_idx_SLOT(src1_k_idx), OPSZ_2);
    // xor tls_slot(src2_k_idx), %ax
    instr_t *i4 = INSTR_CREATE_xor(dcontext, spill_gpr16_opnd, 
                                  OPND_CREATE_MEM16(DR_REG_NULL, TLS_K_idx_SLOT(src2_k_idx)));
    // mov %ax, tls_slot(dst_k_idx)
    instr_t *i5 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr16, TLS_K_idx_SLOT(dst_k_idx), OPSZ_2);
    // pop rax
    instr_t *i6 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
    // popfq
    instr_t *i7 = INSTR_CREATE_popf(dcontext);
    
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
    instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
    return i1;
}

instr_t * /* 500 */
rw_func_kxorb(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "kxorb", true, true, false, true);
#endif
    opnd_t src_opnd1 = instr_get_src(instr, 0);
    opnd_t src_opnd2 = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
    
    reg_id_t src_reg1 = opnd_get_reg(src_opnd1);
    reg_id_t src_reg2 = opnd_get_reg(src_opnd2);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    
    uint src1_k_idx = TO_K_REG_INDEX(src_reg1);
    uint src2_k_idx = TO_K_REG_INDEX(src_reg2);
    uint dst_k_idx = TO_K_REG_INDEX(dst_reg);
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    
    reg_id_t spill_gpr64 = DR_REG_RAX;
    reg_id_t spill_gpr8 = DR_REG_AL;
    opnd_t spill_gpr64_opnd = opnd_create_reg(spill_gpr64);
    opnd_t spill_gpr8_opnd = opnd_create_reg(spill_gpr8);
    
    // pushfq
    instr_t *i1 = INSTR_CREATE_pushf(dcontext);
    // push rax
    instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
    // tls_slot(src1_k_idx) -> %al
    instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr8, TLS_K_idx_SLOT(src1_k_idx), OPSZ_1);
    // xor tls_slot(src2_k_idx), %al
    instr_t *i4 = INSTR_CREATE_xor(dcontext, spill_gpr8_opnd, 
                                  OPND_CREATE_MEM8(DR_REG_NULL, TLS_K_idx_SLOT(src2_k_idx)));
    // mov %al, tls_slot(dst_k_idx)
    instr_t *i5 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr8, TLS_K_idx_SLOT(dst_k_idx), OPSZ_1);
    // pop rax
    instr_t *i6 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
    // popfq
    instr_t *i7 = INSTR_CREATE_popf(dcontext);
    
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
    instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
    return i1;
}

instr_t * /* 501 */
rw_func_kxorq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "kxorq", true, true, false, true);
#endif
    opnd_t src_opnd1 = instr_get_src(instr, 0);
    opnd_t src_opnd2 = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
    
    reg_id_t src_reg1 = opnd_get_reg(src_opnd1);
    reg_id_t src_reg2 = opnd_get_reg(src_opnd2);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    
    uint src1_k_idx = TO_K_REG_INDEX(src_reg1);
    uint src2_k_idx = TO_K_REG_INDEX(src_reg2);
    uint dst_k_idx = TO_K_REG_INDEX(dst_reg);
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    
    reg_id_t spill_gpr64 = DR_REG_RAX;
    opnd_t spill_gpr64_opnd = opnd_create_reg(spill_gpr64);
    
    // pushfq
    instr_t *i1 = INSTR_CREATE_pushf(dcontext);
    // push rax
    instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
    // tls_slot(src1_k_idx) -> %rax
    instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr64, TLS_K_idx_SLOT(src1_k_idx), OPSZ_8);
    // xor tls_slot(src2_k_idx), %rax
    instr_t *i4 = INSTR_CREATE_xor(dcontext, spill_gpr64_opnd, 
                                  OPND_CREATE_MEM64(DR_REG_NULL, TLS_K_idx_SLOT(src2_k_idx)));
    // mov %rax, tls_slot(dst_k_idx)
    instr_t *i5 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr64, TLS_K_idx_SLOT(dst_k_idx), OPSZ_8);
    // pop rax
    instr_t *i6 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
    // popfq
    instr_t *i7 = INSTR_CREATE_popf(dcontext);
    
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
    instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
    return i1;
}

instr_t * /* 502 */
rw_func_kxord(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "kxord", true, true, false, true);
#endif
    opnd_t src_opnd1 = instr_get_src(instr, 0);
    opnd_t src_opnd2 = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
    
    reg_id_t src_reg1 = opnd_get_reg(src_opnd1);
    reg_id_t src_reg2 = opnd_get_reg(src_opnd2);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    
    uint src1_k_idx = TO_K_REG_INDEX(src_reg1);
    uint src2_k_idx = TO_K_REG_INDEX(src_reg2);
    uint dst_k_idx = TO_K_REG_INDEX(dst_reg);
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    
    reg_id_t spill_gpr64 = DR_REG_RAX;
    reg_id_t spill_gpr32 = DR_REG_EAX;
    opnd_t spill_gpr64_opnd = opnd_create_reg(spill_gpr64);
    opnd_t spill_gpr32_opnd = opnd_create_reg(spill_gpr32);
    
    // pushfq
    instr_t *i1 = INSTR_CREATE_pushf(dcontext);
    // push rax
    instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
    // tls_slot(src1_k_idx) -> %eax
    instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr32, TLS_K_idx_SLOT(src1_k_idx), OPSZ_4);
    // xor tls_slot(src2_k_idx), %eax
    instr_t *i4 = INSTR_CREATE_xor(dcontext, spill_gpr32_opnd, 
                                  OPND_CREATE_MEM32(DR_REG_NULL, TLS_K_idx_SLOT(src2_k_idx)));
    // mov %eax, tls_slot(dst_k_idx)
    instr_t *i5 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr32, TLS_K_idx_SLOT(dst_k_idx), OPSZ_4);
    // pop rax
    instr_t *i6 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
    // popfq
    instr_t *i7 = INSTR_CREATE_popf(dcontext);
    
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
    instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
    return i1;
}

/**
 * @brief kadd_ template function
 */
instr_t *
rw_func_kadd_(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "rewrite kadd_ not support");
#endif
    return NULL_INSTR;
}

instr_t * /* 503 */
rw_func_kaddw(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "kaddw", true, true, false, true);
#endif
    opnd_t src_opnd1 = instr_get_src(instr, 0);
    opnd_t src_opnd2 = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
    
    reg_id_t src_reg1 = opnd_get_reg(src_opnd1);
    reg_id_t src_reg2 = opnd_get_reg(src_opnd2);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    
    uint src1_k_idx = TO_K_REG_INDEX(src_reg1);
    uint src2_k_idx = TO_K_REG_INDEX(src_reg2);
    uint dst_k_idx = TO_K_REG_INDEX(dst_reg);
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    
    reg_id_t spill_gpr64 = DR_REG_RAX;
    reg_id_t spill_gpr16 = DR_REG_AX;
    opnd_t spill_gpr64_opnd = opnd_create_reg(spill_gpr64);
    opnd_t spill_gpr16_opnd = opnd_create_reg(spill_gpr16);
    
    // pushfq
    instr_t *i1 = INSTR_CREATE_pushf(dcontext);
    // push rax
    instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
    // tls_slot(src1_k_idx) -> %ax
    instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr16, TLS_K_idx_SLOT(src1_k_idx), OPSZ_2);
    // add tls_slot(src2_k_idx), %ax
    instr_t *i4 = INSTR_CREATE_add(dcontext, spill_gpr16_opnd, 
                                  OPND_CREATE_MEM16(DR_REG_NULL, TLS_K_idx_SLOT(src2_k_idx)));
    // mov %ax, tls_slot(dst_k_idx)
    instr_t *i5 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr16, TLS_K_idx_SLOT(dst_k_idx), OPSZ_2);
    // pop rax
    instr_t *i6 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
    // popfq
    instr_t *i7 = INSTR_CREATE_popf(dcontext);
    
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
    instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
    return i1;
}

instr_t * /* 504 */
rw_func_kaddb(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "kaddb", true, true, false, true);
#endif
    opnd_t src_opnd1 = instr_get_src(instr, 0);
    opnd_t src_opnd2 = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
    
    reg_id_t src_reg1 = opnd_get_reg(src_opnd1);
    reg_id_t src_reg2 = opnd_get_reg(src_opnd2);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    
    uint src1_k_idx = TO_K_REG_INDEX(src_reg1);
    uint src2_k_idx = TO_K_REG_INDEX(src_reg2);
    uint dst_k_idx = TO_K_REG_INDEX(dst_reg);
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    
    reg_id_t spill_gpr64 = DR_REG_RAX;
    reg_id_t spill_gpr8 = DR_REG_AL;
    opnd_t spill_gpr64_opnd = opnd_create_reg(spill_gpr64);
    opnd_t spill_gpr8_opnd = opnd_create_reg(spill_gpr8);
    
    // pushfq
    instr_t *i1 = INSTR_CREATE_pushf(dcontext);
    // push rax
    instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
    // tls_slot(src1_k_idx) -> %al
    instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr8, TLS_K_idx_SLOT(src1_k_idx), OPSZ_1);
    // add tls_slot(src2_k_idx), %al
    instr_t *i4 = INSTR_CREATE_add(dcontext, spill_gpr8_opnd, 
                                  OPND_CREATE_MEM8(DR_REG_NULL, TLS_K_idx_SLOT(src2_k_idx)));
    // mov %al, tls_slot(dst_k_idx)
    instr_t *i5 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr8, TLS_K_idx_SLOT(dst_k_idx), OPSZ_1);
    // pop rax
    instr_t *i6 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
    // popfq
    instr_t *i7 = INSTR_CREATE_popf(dcontext);
    
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
    instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
    return i1;
}

instr_t * /* 505 */
rw_func_kaddq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "kaddq", true, true, false, true);
#endif
    opnd_t src_opnd1 = instr_get_src(instr, 0);
    opnd_t src_opnd2 = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
    
    reg_id_t src_reg1 = opnd_get_reg(src_opnd1);
    reg_id_t src_reg2 = opnd_get_reg(src_opnd2);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    
    uint src1_k_idx = TO_K_REG_INDEX(src_reg1);
    uint src2_k_idx = TO_K_REG_INDEX(src_reg2);
    uint dst_k_idx = TO_K_REG_INDEX(dst_reg);
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    
    reg_id_t spill_gpr64 = DR_REG_RAX;
    opnd_t spill_gpr64_opnd = opnd_create_reg(spill_gpr64);
    
    // pushfq
    instr_t *i1 = INSTR_CREATE_pushf(dcontext);
    // push rax
    instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
    // tls_slot(src1_k_idx) -> %rax
    instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr64, TLS_K_idx_SLOT(src1_k_idx), OPSZ_8);
    // add tls_slot(src2_k_idx), %rax
    instr_t *i4 = INSTR_CREATE_add(dcontext, spill_gpr64_opnd, 
                                  OPND_CREATE_MEM64(DR_REG_NULL, TLS_K_idx_SLOT(src2_k_idx)));
    // mov %rax, tls_slot(dst_k_idx)
    instr_t *i5 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr64, TLS_K_idx_SLOT(dst_k_idx), OPSZ_8);
    // pop rax
    instr_t *i6 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
    // popfq
    instr_t *i7 = INSTR_CREATE_popf(dcontext);
    
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
    instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
    return i1;
}

instr_t * /* 506 */
rw_func_kaddd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "kaddd", true, true, false, true);
#endif
    opnd_t src_opnd1 = instr_get_src(instr, 0);
    opnd_t src_opnd2 = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
    
    reg_id_t src_reg1 = opnd_get_reg(src_opnd1);
    reg_id_t src_reg2 = opnd_get_reg(src_opnd2);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    
    uint src1_k_idx = TO_K_REG_INDEX(src_reg1);
    uint src2_k_idx = TO_K_REG_INDEX(src_reg2);
    uint dst_k_idx = TO_K_REG_INDEX(dst_reg);
    
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);
    
    reg_id_t spill_gpr64 = DR_REG_RAX;
    reg_id_t spill_gpr32 = DR_REG_EAX;
    opnd_t spill_gpr64_opnd = opnd_create_reg(spill_gpr64);
    opnd_t spill_gpr32_opnd = opnd_create_reg(spill_gpr32);
    
    // pushfq
    instr_t *i1 = INSTR_CREATE_pushf(dcontext);
    // push rax
    instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
    // tls_slot(src1_k_idx) -> %eax
    instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr32, TLS_K_idx_SLOT(src1_k_idx), OPSZ_4);
    // add tls_slot(src2_k_idx), %eax
    instr_t *i4 = INSTR_CREATE_add(dcontext, spill_gpr32_opnd, 
                                  OPND_CREATE_MEM32(DR_REG_NULL, TLS_K_idx_SLOT(src2_k_idx)));
    // mov %eax, tls_slot(dst_k_idx)
    instr_t *i5 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr32, TLS_K_idx_SLOT(dst_k_idx), OPSZ_4);
    // pop rax
    instr_t *i6 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
    // popfq
    instr_t *i7 = INSTR_CREATE_popf(dcontext);
    
#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
    instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
    return i1;
}

instr_t * /* 507 */
rw_func_kortestw(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kortestw %k2 -> %k2
    // TMP[15:0] := DEST[15:0] BITWISE OR SRC[15:0]
    // IF(TMP[15:0]=0)
    //     THEN ZF := 1
    //     ELSE ZF := 0
    // FI;
    // IF(TMP[15:0]=FFFFh)
    //     THEN CF := 1
    //     ELSE CF := 0
    // FI;
    opnd_t src_opnd = instr_get_src(instr, 0);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "kortestw", true, false, false, true);
#endif
    reg_id_t src_reg = opnd_get_reg(src_opnd);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    if (src_reg == dst_reg) {
        instrlist_remove(ilist, instr);
        instr_destroy(dcontext, instr);

        /* Label */
        instr_t *L_MASK_ZERO = INSTR_CREATE_label(dcontext);
        instr_t *L_MASK_FFFF = INSTR_CREATE_label(dcontext);
        instr_t *L_MASK_DONE = INSTR_CREATE_label(dcontext);

        /* reg */
        reg_id_t src_k_idx = TO_K_REG_INDEX(src_reg);
        reg_id_t scratch_gpr64 = DR_REG_RAX;
        reg_id_t scratch_gpr32 = DR_REG_EAX;
        reg_id_t scratch_gpr16 = DR_REG_AX;

        /* opnd */
        opnd_t gpr64_opnd = opnd_create_reg(scratch_gpr64);
        opnd_t gpr32_opnd = opnd_create_reg(scratch_gpr32);
        opnd_t gpr16_opnd = opnd_create_reg(scratch_gpr16);

        // push    %rax
        instr_t *i1 = INSTR_CREATE_push(dcontext, gpr64_opnd);
        // tls_slot(src_reg) -> %rax
        instr_t *i2 = RESTORE_FROM_TLS(dcontext, DR_REG_RAX, TLS_K_idx_SLOT(src_k_idx));
        // movzwl  %ax, %eax (16 -> 32)
        instr_t *i3 = INSTR_CREATE_movzx(dcontext, gpr32_opnd, gpr16_opnd);
        // test    %ax, %ax
        instr_t *i4 = INSTR_CREATE_test(dcontext, gpr16_opnd, gpr16_opnd);

        // jz      .L_mask_zero
        instr_t *i5 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(L_MASK_ZERO));
        // cmp     $0xFFFF, %eax
        instr_t *i6 = INSTR_CREATE_cmp(dcontext, gpr32_opnd, opnd_create_immed_int(0x00FFFF, OPSZ_4));
        // je      .L_mask_ffff
        instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(L_MASK_FFFF));
        // clc
        instr_t *i8 = INSTR_CREATE_clc(dcontext);
        // jmp     .L_mask_done
        instr_t *i9 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(L_MASK_DONE));

        // NOTE: .L_mask_zero:
        // clc
        instr_t *i10 = INSTR_CREATE_clc(dcontext);
        // jmp     .L_mask_done
        instr_t *i11 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(L_MASK_DONE));

        // NOTE: .L_mask_ffff:
        // test %ax, %ax
        instr_t *i12 = INSTR_CREATE_test(dcontext, gpr16_opnd, gpr16_opnd); // ZF <- 0
        // stc
        instr_t *i13 = INSTR_CREATE_stc(dcontext); // CF <- 1

        // NOTE: .L_mask_done:
        // pop     %rax
        instr_t *i14 = INSTR_CREATE_pop(dcontext, gpr64_opnd);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 17, i1, i2, i3, i4, i5, i6, i7, i8, i9, L_MASK_ZERO, i10, i11,
                                     L_MASK_FFFF, i12, i13, L_MASK_DONE, i14);
#endif
        instrlist_concat_next_instr(ilist, 17, i1, i2, i3, i4, i5, i6, i7, i8, i9, L_MASK_ZERO, i10, i11, L_MASK_FFFF,
                                    i12, i13, L_MASK_DONE, i14);
        return i1;
    } else {
        instrlist_remove(ilist, instr);
        instr_destroy(dcontext, instr);

        /* Label */
        instr_t *L_MASK_ZERO = INSTR_CREATE_label(dcontext);
        instr_t *L_MASK_FFFF = INSTR_CREATE_label(dcontext);
        instr_t *L_MASK_DONE = INSTR_CREATE_label(dcontext);

        /* reg */
        reg_id_t src_k_idx = TO_K_REG_INDEX(src_reg);
        reg_id_t dst_k_idx = TO_K_REG_INDEX(dst_reg);
        reg_id_t scratch1_gpr64 = DR_REG_RAX;
        reg_id_t scratch1_gpr32 = DR_REG_EAX;
        reg_id_t scratch1_gpr16 = DR_REG_AX;
        reg_id_t scratch2_gpr64 = DR_REG_RDX;
        reg_id_t scratch2_gpr32 = DR_REG_EDX;
        reg_id_t scratch2_gpr16 = DR_REG_DX;

        /* opnd */
        opnd_t gpr64_opnd1 = opnd_create_reg(scratch1_gpr64);
        opnd_t gpr32_opnd1 = opnd_create_reg(scratch1_gpr32);
        opnd_t gpr16_opnd1 = opnd_create_reg(scratch1_gpr16);
        opnd_t gpr64_opnd2 = opnd_create_reg(scratch2_gpr64);
        opnd_t gpr32_opnd2 = opnd_create_reg(scratch2_gpr32);
        opnd_t gpr16_opnd2 = opnd_create_reg(scratch2_gpr16);

        // push    %rax
        instr_t *i1 = INSTR_CREATE_push(dcontext, gpr64_opnd1);
        // push    %rdx
        instr_t *i2 = INSTR_CREATE_push(dcontext, gpr64_opnd2);
        // tls_slot(src_reg) -> %rax
        instr_t *i3 = RESTORE_FROM_TLS(dcontext, DR_REG_RAX, TLS_K_idx_SLOT(src_k_idx));
        // tls_slot(dst_reg) -> %rdx
        instr_t *i4 = RESTORE_FROM_TLS(dcontext, DR_REG_RDX, TLS_K_idx_SLOT(dst_k_idx));
        // movzwl  %ax, %eax
        instr_t *i5 = INSTR_CREATE_movzx(dcontext, gpr32_opnd1, gpr16_opnd1);
        // movzwl  %bx, %edx
        instr_t *i6 = INSTR_CREATE_movzx(dcontext, gpr32_opnd2, gpr16_opnd2);
        // or      %dx, %ax
        instr_t *i7 = INSTR_CREATE_or(dcontext, gpr16_opnd1, gpr16_opnd2);
        // test    %ax, %ax
        instr_t *i8 = INSTR_CREATE_test(dcontext, gpr16_opnd1, gpr16_opnd1);
        // jz      .L_mask_zero
        instr_t *i9 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(L_MASK_ZERO));

        // cmp     $0x00FFFF, %ax
        instr_t *i10 = INSTR_CREATE_cmp(dcontext, gpr32_opnd1, opnd_create_immed_int(0x00FFFF, OPSZ_4));
        // je      .L_mask_ffff
        instr_t *i11 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(L_MASK_FFFF));
        // clc
        instr_t *i12 = INSTR_CREATE_clc(dcontext);
        // jmp     .L_mask_done
        instr_t *i13 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(L_MASK_DONE));

        // NOTE: .L_mask_zero:
        // clc
        instr_t *i14 = INSTR_CREATE_clc(dcontext);
        // jmp     .L_k1k2_done
        instr_t *i15 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(L_MASK_DONE));

        // NOTE: .L_mask_ffff:
        // test %ax, %ax
        instr_t *i16 = INSTR_CREATE_test(dcontext, gpr16_opnd1, gpr16_opnd1);
        // stc
        instr_t *i17 = INSTR_CREATE_stc(dcontext);

        // NOTE: .L_mask_done:
        // pop     %rdx
        instr_t *i18 = INSTR_CREATE_pop(dcontext, gpr64_opnd2);
        // pop     %rax
        instr_t *i19 = INSTR_CREATE_pop(dcontext, gpr64_opnd1);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 22, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, L_MASK_ZERO,
                                     i14, i15, L_MASK_FFFF, i16, i17, L_MASK_DONE, i18, i19);
#endif
        instrlist_concat_next_instr(ilist, 22, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, L_MASK_ZERO, i14,
                                    i15, L_MASK_FFFF, i16, i17, L_MASK_DONE, i18, i19);
        return i1;
    }
    return NULL_INSTR;
}

instr_t * /* 508 */
rw_func_kortestb(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kortestb %k1 -> %k1
    // TMP[7:0] := DEST[7:0] BITWISE OR SRC[7:0]
    // IF(TMP[7:0]=0)
    //     THEN ZF := 1
    //     ELSE ZF := 0
    // FI;
    // IF(TMP[7:0]==FFh)
    //     THEN CF := 1
    //     ELSE CF := 0
    // FI;
    opnd_t src_opnd = instr_get_src(instr, 0);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    print_rewrite_info(dcontext, ilist, instr, instr_start, "kortestb", true, false, false, true);
#endif
    reg_id_t src_reg = opnd_get_reg(src_opnd);
    reg_id_t dst_reg = opnd_get_reg(dst_opnd);
    if (src_reg == dst_reg) {
        instrlist_remove(ilist, instr);
        instr_destroy(dcontext, instr);

        /* Label */
        instr_t *L_MASK_ZERO = INSTR_CREATE_label(dcontext);
        instr_t *L_MASK_FFFF = INSTR_CREATE_label(dcontext);
        instr_t *L_MASK_DONE = INSTR_CREATE_label(dcontext);

        /* reg */
        reg_id_t src_k_idx = TO_K_REG_INDEX(src_reg);
        reg_id_t scratch_gpr64 = DR_REG_RAX;
        reg_id_t scratch_gpr32 = DR_REG_EAX;
        reg_id_t scratch_gpr8 = DR_REG_AL;

        /* opnd */
        opnd_t gpr64_opnd = opnd_create_reg(scratch_gpr64);
        opnd_t gpr32_opnd = opnd_create_reg(scratch_gpr32);
        opnd_t gpr8_opnd = opnd_create_reg(scratch_gpr8);

        // push    %rax
        instr_t *i1 = INSTR_CREATE_push(dcontext, gpr64_opnd);
        // tls_slot(src_reg) -> %rax
        instr_t *i2 = RESTORE_FROM_TLS(dcontext, DR_REG_RAX, TLS_K_idx_SLOT(src_k_idx));
        // movzbl  %al, %eax (8 -> 32)
        instr_t *i3 = INSTR_CREATE_movzx(dcontext, gpr32_opnd, gpr8_opnd);
        // test    %al, %al
        instr_t *i4 = INSTR_CREATE_test(dcontext, gpr8_opnd, gpr8_opnd);

        // jz      .L_mask_zero
        instr_t *i5 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(L_MASK_ZERO));
        // cmp     $0xFF, %eax
        instr_t *i6 = INSTR_CREATE_cmp(dcontext, gpr32_opnd, opnd_create_immed_int(0x00FF, OPSZ_4));
        // je      .L_mask_ffff
        instr_t *i7 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(L_MASK_FFFF));
        // clc
        instr_t *i8 = INSTR_CREATE_clc(dcontext);
        // jmp     .L_mask_done
        instr_t *i9 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(L_MASK_DONE));

        // NOTE: .L_mask_zero:
        // clc
        instr_t *i10 = INSTR_CREATE_clc(dcontext);
        // jmp     .L_mask_done
        instr_t *i11 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(L_MASK_DONE));

        // NOTE: .L_mask_ffff:
        // test %al, %al
        instr_t *i12 = INSTR_CREATE_test(dcontext, gpr8_opnd, gpr8_opnd); // ZF <- 0
        // stc
        instr_t *i13 = INSTR_CREATE_stc(dcontext); // CF <- 1

        // NOTE: .L_mask_done:
        // pop     %rax
        instr_t *i14 = INSTR_CREATE_pop(dcontext, gpr64_opnd);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 17, i1, i2, i3, i4, i5, i6, i7, i8, i9, L_MASK_ZERO, i10, i11,
                                     L_MASK_FFFF, i12, i13, L_MASK_DONE, i14);
#endif
        instrlist_concat_next_instr(ilist, 17, i1, i2, i3, i4, i5, i6, i7, i8, i9, L_MASK_ZERO, i10, i11, L_MASK_FFFF,
                                    i12, i13, L_MASK_DONE, i14);
        return i1;
    } else {
        instrlist_remove(ilist, instr);
        instr_destroy(dcontext, instr);

        /* Label */
        instr_t *L_MASK_ZERO = INSTR_CREATE_label(dcontext);
        instr_t *L_MASK_FFFF = INSTR_CREATE_label(dcontext);
        instr_t *L_MASK_DONE = INSTR_CREATE_label(dcontext);

        /* reg */
        reg_id_t src_k_idx = TO_K_REG_INDEX(src_reg);
        reg_id_t dst_k_idx = TO_K_REG_INDEX(dst_reg);
        reg_id_t scratch1_gpr64 = DR_REG_RAX;
        reg_id_t scratch1_gpr32 = DR_REG_EAX;
        reg_id_t scratch1_gpr8 = DR_REG_AL;
        reg_id_t scratch2_gpr64 = DR_REG_RDX;
        reg_id_t scratch2_gpr32 = DR_REG_EDX;
        reg_id_t scratch2_gpr8 = DR_REG_DL;

        /* opnd */
        opnd_t gpr64_opnd1 = opnd_create_reg(scratch1_gpr64);
        opnd_t gpr32_opnd1 = opnd_create_reg(scratch1_gpr32);
        opnd_t gpr8_opnd1 = opnd_create_reg(scratch1_gpr8);
        opnd_t gpr64_opnd2 = opnd_create_reg(scratch2_gpr64);
        opnd_t gpr32_opnd2 = opnd_create_reg(scratch2_gpr32);
        opnd_t gpr8_opnd2 = opnd_create_reg(scratch2_gpr8);

        // push    %rax
        instr_t *i1 = INSTR_CREATE_push(dcontext, gpr64_opnd1);
        // push    %rdx
        instr_t *i2 = INSTR_CREATE_push(dcontext, gpr64_opnd2);
        // tls_slot(src_reg) -> %rax
        instr_t *i3 = RESTORE_FROM_TLS(dcontext, DR_REG_RAX, TLS_K_idx_SLOT(src_k_idx));
        // tls_slot(dst_reg) -> %rdx
        instr_t *i4 = RESTORE_FROM_TLS(dcontext, DR_REG_RDX, TLS_K_idx_SLOT(dst_k_idx));
        // movzbl  %al, %eax
        instr_t *i5 = INSTR_CREATE_movzx(dcontext, gpr32_opnd1, gpr8_opnd1);
        // movzbl  %dl, %edx
        instr_t *i6 = INSTR_CREATE_movzx(dcontext, gpr32_opnd2, gpr8_opnd2);
        // or      %dl, %al
        instr_t *i7 = INSTR_CREATE_or(dcontext, gpr8_opnd1, gpr8_opnd2);
        // test    %al, %al
        instr_t *i8 = INSTR_CREATE_test(dcontext, gpr8_opnd1, gpr8_opnd1);
        // jz      .L_mask_zero
        instr_t *i9 = INSTR_CREATE_jcc(dcontext, OP_jz, opnd_create_instr(L_MASK_ZERO));

        // cmp     $0x00FF, %eax
        instr_t *i10 = INSTR_CREATE_cmp(dcontext, gpr32_opnd1, opnd_create_immed_int(0x00FF, OPSZ_4));
        // je      .L_mask_ffff
        instr_t *i11 = INSTR_CREATE_jcc(dcontext, OP_je, opnd_create_instr(L_MASK_FFFF));
        // clc
        instr_t *i12 = INSTR_CREATE_clc(dcontext);
        // jmp     .L_mask_done
        instr_t *i13 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(L_MASK_DONE));

        // NOTE: .L_mask_zero:
        // clc
        instr_t *i14 = INSTR_CREATE_clc(dcontext);
        // jmp     .L_mask_done
        instr_t *i15 = INSTR_CREATE_jmp(dcontext, opnd_create_instr(L_MASK_DONE));

        // NOTE: .L_mask_ffff:
        // test %al, %al
        instr_t *i16 = INSTR_CREATE_test(dcontext, gpr8_opnd1, gpr8_opnd1);
        // stc
        instr_t *i17 = INSTR_CREATE_stc(dcontext);

        // NOTE: .L_mask_done:
        // pop     %rdx
        instr_t *i18 = INSTR_CREATE_pop(dcontext, gpr64_opnd2);
        // pop     %rax
        instr_t *i19 = INSTR_CREATE_pop(dcontext, gpr64_opnd1);

#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 22, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, L_MASK_ZERO,
                                     i14, i15, L_MASK_FFFF, i16, i17, L_MASK_DONE, i18, i19);
#endif
        instrlist_concat_next_instr(ilist, 22, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, L_MASK_ZERO, i14,
                                    i15, L_MASK_FFFF, i16, i17, L_MASK_DONE, i18, i19);
        return i1;
    }
    return NULL_INSTR;
}

instr_t * /* 509 */
rw_func_kortestq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kortestq %k1, %k2 - Test 64-bit mask registers and set flags
    // TEMP1 := SRC1[63:0] OR SRC2[63:0]
    // SF := 0; OF := 0; AF := 0; PF := 0
    // IF TEMP1 = 0 THEN ZF := 1 ELSE ZF := 0 FI
    // TEMP2 := SRC1[63:0] AND SRC2[63:0]
    // IF TEMP2 = 0 THEN CF := 1 ELSE CF := 0 FI
    opnd_t src1_opnd = instr_get_src(instr, 0);
    opnd_t src2_opnd = instr_get_src(instr, 1);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting kortestq at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src1_opnd, "input src1: ");
    dr_print_opnd(dcontext, STD_OUTF, src2_opnd, "input src2: ");
#endif
    reg_id_t input_mask1 = opnd_get_reg(src1_opnd);
    reg_id_t input_mask2 = opnd_get_reg(src2_opnd);
    uint input_k1_idx = TO_K_REG_INDEX(input_mask1);
    uint input_k2_idx = TO_K_REG_INDEX(input_mask2);

    reg_id_t spill_gpr64_1 = DR_REG_RAX;
    reg_id_t spill_gpr64_2 = DR_REG_RBX;

    opnd_t spill_gpr64_1_opnd = opnd_create_reg(spill_gpr64_1);
    opnd_t spill_gpr64_2_opnd = opnd_create_reg(spill_gpr64_2);

    // pushfq
    instr_t *i1 = INSTR_CREATE_pushf(dcontext);
    // push rax
    instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_1_opnd);
    // push rbx
    instr_t *i3 = INSTR_CREATE_push(dcontext, spill_gpr64_2_opnd);
    // tls_slot(input_mask1) -> %rax
    instr_t *i4 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr64_1, TLS_K_idx_SLOT(input_k1_idx), OPSZ_8);
    // tls_slot(input_mask2) -> %rbx
    instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr64_2, TLS_K_idx_SLOT(input_k2_idx), OPSZ_8);
    // or %rbx, %rax - compute OR for ZF
    instr_t *i6 = INSTR_CREATE_or(dcontext, spill_gpr64_1_opnd, spill_gpr64_2_opnd);
    // tls_slot(input_mask1) -> %rax (reload for AND operation)
    instr_t *i7 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr64_1, TLS_K_idx_SLOT(input_k1_idx), OPSZ_8);
    // and %rbx, %rax - compute AND for CF
    instr_t *i8 = INSTR_CREATE_and(dcontext, spill_gpr64_1_opnd, spill_gpr64_2_opnd);
    // pop rbx
    instr_t *i9 = INSTR_CREATE_pop(dcontext, spill_gpr64_2_opnd);
    // pop rax
    instr_t *i10 = INSTR_CREATE_pop(dcontext, spill_gpr64_1_opnd);
    // popfq
    instr_t *i11 = INSTR_CREATE_popf(dcontext);

#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 11, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);
#endif
    instrlist_concat_next_instr(ilist, 11, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);
    return i1;
}

instr_t * /* 510 */
rw_func_kortestd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kortestd %k1, %k2 - Test 32-bit mask registers and set flags
    // TEMP1 := SRC1[31:0] OR SRC2[31:0]
    // SF := 0; OF := 0; AF := 0; PF := 0
    // IF TEMP1 = 0 THEN ZF := 1 ELSE ZF := 0 FI
    // TEMP2 := SRC1[31:0] AND SRC2[31:0]
    // IF TEMP2 = 0 THEN CF := 1 ELSE CF := 0 FI
    opnd_t src1_opnd = instr_get_src(instr, 0);
    opnd_t src2_opnd = instr_get_src(instr, 1);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting kortestd at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src1_opnd, "input src1: ");
    dr_print_opnd(dcontext, STD_OUTF, src2_opnd, "input src2: ");
#endif
    reg_id_t input_mask1 = opnd_get_reg(src1_opnd);
    reg_id_t input_mask2 = opnd_get_reg(src2_opnd);
    uint input_k1_idx = TO_K_REG_INDEX(input_mask1);
    uint input_k2_idx = TO_K_REG_INDEX(input_mask2);

    reg_id_t spill_gpr32_1 = DR_REG_EAX;
    reg_id_t spill_gpr32_2 = DR_REG_EBX;

    opnd_t spill_gpr32_1_opnd = opnd_create_reg(spill_gpr32_1);
    opnd_t spill_gpr32_2_opnd = opnd_create_reg(spill_gpr32_2);

    // pushfq
    instr_t *i1 = INSTR_CREATE_pushf(dcontext);
    // push rax
    instr_t *i2 = INSTR_CREATE_push(dcontext, opnd_create_reg(DR_REG_RAX));
    // push rbx
    instr_t *i3 = INSTR_CREATE_push(dcontext, opnd_create_reg(DR_REG_RBX));
    // tls_slot(input_mask1) -> %eax
    instr_t *i4 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr32_1, TLS_K_idx_SLOT(input_k1_idx), OPSZ_4);
    // tls_slot(input_mask2) -> %ebx
    instr_t *i5 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr32_2, TLS_K_idx_SLOT(input_k2_idx), OPSZ_4);
    // or %ebx, %eax - compute OR for ZF
    instr_t *i6 = INSTR_CREATE_or(dcontext, spill_gpr32_1_opnd, spill_gpr32_2_opnd);
    // tls_slot(input_mask1) -> %eax (reload for AND operation)
    instr_t *i7 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr32_1, TLS_K_idx_SLOT(input_k1_idx), OPSZ_4);
    // and %ebx, %eax - compute AND for CF
    instr_t *i8 = INSTR_CREATE_and(dcontext, spill_gpr32_1_opnd, spill_gpr32_2_opnd);
    // pop rbx
    instr_t *i9 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RBX));
    // pop rax
    instr_t *i10 = INSTR_CREATE_pop(dcontext, opnd_create_reg(DR_REG_RAX));
    // popfq
    instr_t *i11 = INSTR_CREATE_popf(dcontext);

#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 11, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);
#endif
    instrlist_concat_next_instr(ilist, 11, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);
    return i1;
}

instr_t * /* 511 */
rw_func_kshiftlw(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kshiftlw %k1, $0x04, %k2 - Shift left 16-bit mask register
    // COUNT := imm8[7:0]
    // DEST[MAX_KL-1:0] := 0
    // IF COUNT <=15
    //     THEN DEST[15:0] := SRC1[15:0] << COUNT;
    // FI;
    opnd_t src_opnd = instr_get_src(instr, 0);
    opnd_t imm_opnd = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting kshiftlw at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src_opnd, "input src: ");
    dr_print_opnd(dcontext, STD_OUTF, imm_opnd, "input imm: ");
    dr_print_opnd(dcontext, STD_OUTF, dst_opnd, "output dst: ");
#endif
    reg_id_t input_mask = opnd_get_reg(src_opnd);
    reg_id_t output_mask = opnd_get_reg(dst_opnd);
    uint input_k_idx = TO_K_REG_INDEX(input_mask);
    uint output_k_idx = TO_K_REG_INDEX(output_mask);

    reg_id_t spill_gpr64 = DR_REG_RAX;
    reg_id_t spill_gpr16 = DR_REG_AX;

    opnd_t spill_gpr64_opnd = opnd_create_reg(spill_gpr64);
    opnd_t spill_gpr16_opnd = opnd_create_reg(spill_gpr16);

    int imm8 = opnd_get_immed_int(imm_opnd);

    // imm8 guided specialization
    if (imm8 <= 15) { // shift
        // pushfq
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // push rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
        // tls_slot(input_mask) -> %ax
        instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr16, TLS_K_idx_SLOT(input_k_idx), OPSZ_2);
        // movzx %ax, %rax | 16 -> 64
        instr_t *i4 = INSTR_CREATE_movzx(dcontext, spill_gpr64_opnd, spill_gpr16_opnd);
        // shl $imm8, %rax
        instr_t *i5 = INSTR_CREATE_shl(dcontext, spill_gpr64_opnd, imm_opnd);
        // mov %ax, tls_slot(output_mask)
        instr_t *i6 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr16, TLS_K_idx_SLOT(output_k_idx), OPSZ_2);
        // pop rax
        instr_t *i7 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
        // popfq
        instr_t *i8 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
        instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
        return i1;
    } else { // clear to 0
        // pushfq
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // push rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
        // xor %rax, %rax | XOR r/m64, r64
        instr_t *i3 = INSTR_CREATE_xor(dcontext, spill_gpr64_opnd, spill_gpr64_opnd);
        // mov %ax, tls_slot(output_mask)
        instr_t *i4 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr16, TLS_K_idx_SLOT(output_k_idx), OPSZ_2);
        // pop rax
        instr_t *i5 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
        // popfq
        instr_t *i6 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 6, i1, i2, i3, i4, i5, i6);
#endif
        instrlist_concat_next_instr(ilist, 6, i1, i2, i3, i4, i5, i6);
        return i1;
    }
    return NULL_INSTR;
}

instr_t * /* 512 */
rw_func_kshiftlb(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kshiftlb %k1, $0x04, %k2 - Shift left 8-bit mask register
    // COUNT := imm8[7:0]
    // DEST[MAX_KL-1:0] := 0
    // IF COUNT <=7
    //     THEN DEST[7:0] := SRC1[7:0] << COUNT;
    // FI;
    opnd_t src_opnd = instr_get_src(instr, 0);
    opnd_t imm_opnd = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting kshiftlb at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src_opnd, "input src: ");
    dr_print_opnd(dcontext, STD_OUTF, imm_opnd, "input imm: ");
    dr_print_opnd(dcontext, STD_OUTF, dst_opnd, "output dst: ");
#endif
    reg_id_t input_mask = opnd_get_reg(src_opnd);
    reg_id_t output_mask = opnd_get_reg(dst_opnd);
    uint input_k_idx = TO_K_REG_INDEX(input_mask);
    uint output_k_idx = TO_K_REG_INDEX(output_mask);

    reg_id_t spill_gpr64 = DR_REG_RAX;
    reg_id_t spill_gpr8 = DR_REG_AL;

    opnd_t spill_gpr64_opnd = opnd_create_reg(spill_gpr64);
    opnd_t spill_gpr8_opnd = opnd_create_reg(spill_gpr8);

    int imm8 = opnd_get_immed_int(imm_opnd);

    // imm8 guided specialization
    if (imm8 <= 7) { // shift
        // pushfq
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // push rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
        // tls_slot(input_mask) -> %al
        instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr8, TLS_K_idx_SLOT(input_k_idx), OPSZ_1);
        // movzx %al, %rax | 8 -> 64
        instr_t *i4 = INSTR_CREATE_movzx(dcontext, spill_gpr64_opnd, spill_gpr8_opnd);
        // shl $imm8, %rax
        instr_t *i5 = INSTR_CREATE_shl(dcontext, spill_gpr64_opnd, imm_opnd);
        // mov %al, tls_slot(output_mask)
        instr_t *i6 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr8, TLS_K_idx_SLOT(output_k_idx), OPSZ_1);
        // pop rax
        instr_t *i7 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
        // popfq
        instr_t *i8 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
        instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
        return i1;
    } else { // clear to 0
        // pushfq
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // push rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
        // xor %rax, %rax | XOR r/m64, r64
        instr_t *i3 = INSTR_CREATE_xor(dcontext, spill_gpr64_opnd, spill_gpr64_opnd);
        // mov %al, tls_slot(output_mask)
        instr_t *i4 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr8, TLS_K_idx_SLOT(output_k_idx), OPSZ_1);
        // pop rax
        instr_t *i5 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
        // popfq
        instr_t *i6 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 6, i1, i2, i3, i4, i5, i6);
#endif
        instrlist_concat_next_instr(ilist, 6, i1, i2, i3, i4, i5, i6);
        return i1;
    }
    return NULL_INSTR;
}

instr_t * /* 513 */
rw_func_kshiftlq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kshiftlq %k1, $0x04, %k2 - Shift left 64-bit mask register
    // COUNT := imm8[7:0]
    // DEST[MAX_KL-1:0] := 0
    // IF COUNT <=63
    //     THEN DEST[63:0] := SRC1[63:0] << COUNT;
    // FI;
    opnd_t src_opnd = instr_get_src(instr, 0);
    opnd_t imm_opnd = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting kshiftlq at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src_opnd, "input src: ");
    dr_print_opnd(dcontext, STD_OUTF, imm_opnd, "input imm: ");
    dr_print_opnd(dcontext, STD_OUTF, dst_opnd, "output dst: ");
#endif
    reg_id_t input_mask = opnd_get_reg(src_opnd);
    reg_id_t output_mask = opnd_get_reg(dst_opnd);
    uint input_k_idx = TO_K_REG_INDEX(input_mask);
    uint output_k_idx = TO_K_REG_INDEX(output_mask);

    reg_id_t spill_gpr64 = DR_REG_RAX;
    opnd_t spill_gpr64_opnd = opnd_create_reg(spill_gpr64);

    int imm8 = opnd_get_immed_int(imm_opnd);

    // imm8 guided specialization
    if (imm8 <= 63) { // shift
        // pushfq
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // push rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
        // tls_slot(input_mask) -> %rax
        instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr64, TLS_K_idx_SLOT(input_k_idx), OPSZ_8);
        // shl $imm8, %rax
        instr_t *i4 = INSTR_CREATE_shl(dcontext, spill_gpr64_opnd, imm_opnd);
        // mov %rax, tls_slot(output_mask)
        instr_t *i5 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr64, TLS_K_idx_SLOT(output_k_idx), OPSZ_8);
        // pop rax
        instr_t *i6 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
        // popfq
        instr_t *i7 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } else { // clear to 0
        // pushfq
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // push rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
        // xor %rax, %rax | XOR r/m64, r64
        instr_t *i3 = INSTR_CREATE_xor(dcontext, spill_gpr64_opnd, spill_gpr64_opnd);
        // mov %rax, tls_slot(output_mask)
        instr_t *i4 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr64, TLS_K_idx_SLOT(output_k_idx), OPSZ_8);
        // pop rax
        instr_t *i5 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
        // popfq
        instr_t *i6 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 6, i1, i2, i3, i4, i5, i6);
#endif
        instrlist_concat_next_instr(ilist, 6, i1, i2, i3, i4, i5, i6);
        return i1;
    }
    return NULL_INSTR;
}

instr_t * /* 514 */
rw_func_kshiftld(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kshiftld %k1, $0x04, %k2 - Shift left 32-bit mask register
    // COUNT := imm8[7:0]
    // DEST[MAX_KL-1:0] := 0
    // IF COUNT <=31
    //     THEN DEST[31:0] := SRC1[31:0] << COUNT;
    // FI;
    opnd_t src_opnd = instr_get_src(instr, 0);
    opnd_t imm_opnd = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting kshiftld at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src_opnd, "input src: ");
    dr_print_opnd(dcontext, STD_OUTF, imm_opnd, "input imm: ");
    dr_print_opnd(dcontext, STD_OUTF, dst_opnd, "output dst: ");
#endif
    reg_id_t input_mask = opnd_get_reg(src_opnd);
    reg_id_t output_mask = opnd_get_reg(dst_opnd);
    uint input_k_idx = TO_K_REG_INDEX(input_mask);
    uint output_k_idx = TO_K_REG_INDEX(output_mask);

    reg_id_t spill_gpr64 = DR_REG_RAX;
    reg_id_t spill_gpr32 = DR_REG_EAX;

    opnd_t spill_gpr64_opnd = opnd_create_reg(spill_gpr64);
    opnd_t spill_gpr32_opnd = opnd_create_reg(spill_gpr32);

    int imm8 = opnd_get_immed_int(imm_opnd);

    // imm8 guided specialization
    if (imm8 <= 31) { // shift
        // pushfq
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // push rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
        // tls_slot(input_mask) -> %eax
        instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr32, TLS_K_idx_SLOT(input_k_idx), OPSZ_4);
        // shl $imm8, %eax
        instr_t *i4 = INSTR_CREATE_shl(dcontext, spill_gpr32_opnd, imm_opnd);
        // mov %eax, tls_slot(output_mask)
        instr_t *i5 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr32, TLS_K_idx_SLOT(output_k_idx), OPSZ_4);
        // pop rax
        instr_t *i6 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
        // popfq
        instr_t *i7 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } else { // clear to 0
        // pushfq
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // push rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
        // xor %rax, %rax | XOR r/m64, r64
        instr_t *i3 = INSTR_CREATE_xor(dcontext, spill_gpr64_opnd, spill_gpr64_opnd);
        // mov %eax, tls_slot(output_mask)
        instr_t *i4 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr32, TLS_K_idx_SLOT(output_k_idx), OPSZ_4);
        // pop rax
        instr_t *i5 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
        // popfq
        instr_t *i6 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 6, i1, i2, i3, i4, i5, i6);
#endif
        instrlist_concat_next_instr(ilist, 6, i1, i2, i3, i4, i5, i6);
        return i1;
    }
    return NULL_INSTR;
}

instr_t * /* 515 */
rw_func_kshiftrw(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kshiftrw %k1, $0x04, %k2 - Shift right 16-bit mask register
    // COUNT := imm8[7:0]
    // DEST[MAX_KL-1:0] := 0
    // IF COUNT <=15
    //     THEN DEST[15:0] := SRC1[15:0] >> COUNT;
    // FI;
    opnd_t src_opnd = instr_get_src(instr, 0);
    opnd_t imm_opnd = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting kshiftrw at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src_opnd, "input src: ");
    dr_print_opnd(dcontext, STD_OUTF, imm_opnd, "input imm: ");
    dr_print_opnd(dcontext, STD_OUTF, dst_opnd, "output dst: ");
#endif
    reg_id_t input_mask = opnd_get_reg(src_opnd);
    reg_id_t output_mask = opnd_get_reg(dst_opnd);
    uint input_k_idx = TO_K_REG_INDEX(input_mask);
    uint output_k_idx = TO_K_REG_INDEX(output_mask);

    reg_id_t spill_gpr64 = DR_REG_RAX;
    reg_id_t spill_gpr16 = DR_REG_AX;

    opnd_t spill_gpr64_opnd = opnd_create_reg(spill_gpr64);
    opnd_t spill_gpr16_opnd = opnd_create_reg(spill_gpr16);

    int imm8 = opnd_get_immed_int(imm_opnd);

    // imm8 guided specialization
    if (imm8 <= 15) { // shift
        // pushfq
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // push rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
        // tls_slot(input_mask) -> %ax
        instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr16, TLS_K_idx_SLOT(input_k_idx), OPSZ_2);
        // movzx %ax, %rax | 16 -> 64
        instr_t *i4 = INSTR_CREATE_movzx(dcontext, spill_gpr64_opnd, spill_gpr16_opnd);
        // shr $imm8, %rax
        instr_t *i5 = INSTR_CREATE_shr(dcontext, spill_gpr64_opnd, imm_opnd);
        // mov %ax, tls_slot(output_mask)
        instr_t *i6 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr16, TLS_K_idx_SLOT(output_k_idx), OPSZ_2);
        // pop rax
        instr_t *i7 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
        // popfq
        instr_t *i8 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
        instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
        return i1;
    } else { // clear to 0
        // pushfq
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // push rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
        // xor %rax, %rax | XOR r/m64, r64
        instr_t *i3 = INSTR_CREATE_xor(dcontext, spill_gpr64_opnd, spill_gpr64_opnd);
        // mov %ax, tls_slot(output_mask)
        instr_t *i4 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr16, TLS_K_idx_SLOT(output_k_idx), OPSZ_2);
        // pop rax
        instr_t *i5 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
        // popfq
        instr_t *i6 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 6, i1, i2, i3, i4, i5, i6);
#endif
        instrlist_concat_next_instr(ilist, 6, i1, i2, i3, i4, i5, i6);
        return i1;
    }
    return NULL_INSTR;
}

instr_t * /* 516 */
rw_func_kshiftrb(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kshiftrb %k1 $0x04 -> %k1
    // COUNT := imm8[7:0]
    // DEST[MAX_KL-1:0] := 0
    // IF COUNT <=7
    //     THEN DEST[7:0] := SRC1[7:0] >> COUNT;
    // FI;
    opnd_t src_opnd = instr_get_src(instr, 0);
    opnd_t imm_opnd = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting kshiftrb at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src_opnd, "input src: ");
    dr_print_opnd(dcontext, STD_OUTF, imm_opnd, "input imm: ");
    dr_print_opnd(dcontext, STD_OUTF, dst_opnd, "output dst: ");
#endif
    instrlist_remove(ilist, instr);
    instr_destroy(dcontext, instr);

    reg_id_t input_mask = opnd_get_reg(src_opnd);
    reg_id_t output_mask = opnd_get_reg(dst_opnd);
    uint input_k_idx = TO_K_REG_INDEX(input_mask);
    uint output_k_idx = TO_K_REG_INDEX(output_mask);

    reg_id_t spill_gpr64 = DR_REG_RAX;
    reg_id_t spill_gpr8 = DR_REG_AL;

    opnd_t spill_gpr64_opnd = opnd_create_reg(spill_gpr64);
    opnd_t spill_gpr8_opnd = opnd_create_reg(spill_gpr8);

    int imm8 = opnd_get_immed_int(imm_opnd);

    // imm8 guided specialization
    if (imm8 <= 7) { // shift
        // pushfq
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // push rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
        // tls_slot(input_mask) -> %al
        instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr8, TLS_K_idx_SLOT(input_k_idx), OPSZ_1);
        // movzx %al, %rax | 8 -> 64
        instr_t *i4 = INSTR_CREATE_movzx(dcontext, spill_gpr64_opnd, spill_gpr8_opnd);
        // shr $imm8, %rax
        instr_t *i5 = INSTR_CREATE_shr(dcontext, spill_gpr64_opnd, imm_opnd);
        // %rax -> tls_slot(output_mask)
        instr_t *i6 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr64, TLS_K_idx_SLOT(output_k_idx), OPSZ_8);
        // pop rax
        instr_t *i7 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
        // popf
        instr_t *i8 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 8, i1, i2, i3, i4, i5, i6, i7, i8);
#endif
        instrlist_concat_next_instr(ilist, 8, i1, i2, i3, i4, i5, i6, i7, i8);
        return i1;
    } else { // clear to 0
        // pushf
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // push rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
        // xor %rax, %rax | XOR r/m64, r64
        instr_t *i3 = INSTR_CREATE_xor(dcontext, spill_gpr64_opnd, spill_gpr64_opnd);
        // mov %rax -> tls_slot(output_mask)
        instr_t *i4 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr64, TLS_K_idx_SLOT(output_k_idx), OPSZ_8);
        // pop rax
        instr_t *i5 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
        // popf
        instr_t *i6 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 6, i1, i2, i3, i4, i5, i6);
#endif
        instrlist_concat_next_instr(ilist, 6, i1, i2, i3, i4, i5, i6);
        return i1;
    }
    /* compared to the original no specialization implementation, we could save more than 50% instructions,
       original 16 instrs(8 save-restore), 8 if-else loop */
    return NULL_INSTR;
}

instr_t * /* 517 */
rw_func_kshiftrq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kshiftrq %k1, $0x04, %k2 - Shift right 64-bit mask register
    // COUNT := imm8[7:0]
    // DEST[MAX_KL-1:0] := 0
    // IF COUNT <=63
    //     THEN DEST[63:0] := SRC1[63:0] >> COUNT;
    // FI;
    opnd_t src_opnd = instr_get_src(instr, 0);
    opnd_t imm_opnd = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting kshiftrq at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src_opnd, "input src: ");
    dr_print_opnd(dcontext, STD_OUTF, imm_opnd, "input imm: ");
    dr_print_opnd(dcontext, STD_OUTF, dst_opnd, "output dst: ");
#endif
    reg_id_t input_mask = opnd_get_reg(src_opnd);
    reg_id_t output_mask = opnd_get_reg(dst_opnd);
    uint input_k_idx = TO_K_REG_INDEX(input_mask);
    uint output_k_idx = TO_K_REG_INDEX(output_mask);

    reg_id_t spill_gpr64 = DR_REG_RAX;
    opnd_t spill_gpr64_opnd = opnd_create_reg(spill_gpr64);

    int imm8 = opnd_get_immed_int(imm_opnd);

    // imm8 guided specialization
    if (imm8 <= 63) { // shift
        // pushfq
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // push rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
        // tls_slot(input_mask) -> %rax
        instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr64, TLS_K_idx_SLOT(input_k_idx), OPSZ_8);
        // shr $imm8, %rax
        instr_t *i4 = INSTR_CREATE_shr(dcontext, spill_gpr64_opnd, imm_opnd);
        // mov %rax, tls_slot(output_mask)
        instr_t *i5 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr64, TLS_K_idx_SLOT(output_k_idx), OPSZ_8);
        // pop rax
        instr_t *i6 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
        // popfq
        instr_t *i7 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } else { // clear to 0
        // pushfq
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // push rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
        // xor %rax, %rax | XOR r/m64, r64
        instr_t *i3 = INSTR_CREATE_xor(dcontext, spill_gpr64_opnd, spill_gpr64_opnd);
        // mov %rax, tls_slot(output_mask)
        instr_t *i4 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr64, TLS_K_idx_SLOT(output_k_idx), OPSZ_8);
        // pop rax
        instr_t *i5 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
        // popfq
        instr_t *i6 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 6, i1, i2, i3, i4, i5, i6);
#endif
        instrlist_concat_next_instr(ilist, 6, i1, i2, i3, i4, i5, i6);
        return i1;
    }
    return NULL_INSTR;
}

instr_t * /* 518 */
rw_func_kshiftrd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // kshiftrd %k1, $0x04, %k2 - Shift right 32-bit mask register
    // COUNT := imm8[7:0]
    // DEST[MAX_KL-1:0] := 0
    // IF COUNT <=31
    //     THEN DEST[31:0] := SRC1[31:0] >> COUNT;
    // FI;
    opnd_t src_opnd = instr_get_src(instr, 0);
    opnd_t imm_opnd = instr_get_src(instr, 1);
    opnd_t dst_opnd = instr_get_dst(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting kshiftrd at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src_opnd, "input src: ");
    dr_print_opnd(dcontext, STD_OUTF, imm_opnd, "input imm: ");
    dr_print_opnd(dcontext, STD_OUTF, dst_opnd, "output dst: ");
#endif
    reg_id_t input_mask = opnd_get_reg(src_opnd);
    reg_id_t output_mask = opnd_get_reg(dst_opnd);
    uint input_k_idx = TO_K_REG_INDEX(input_mask);
    uint output_k_idx = TO_K_REG_INDEX(output_mask);

    reg_id_t spill_gpr64 = DR_REG_RAX;
    reg_id_t spill_gpr32 = DR_REG_EAX;

    opnd_t spill_gpr64_opnd = opnd_create_reg(spill_gpr64);
    opnd_t spill_gpr32_opnd = opnd_create_reg(spill_gpr32);

    int imm8 = opnd_get_immed_int(imm_opnd);

    // imm8 guided specialization
    if (imm8 <= 31) { // shift
        // pushfq
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // push rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
        // tls_slot(input_mask) -> %eax
        instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr32, TLS_K_idx_SLOT(input_k_idx), OPSZ_4);
        // shr $imm8, %eax
        instr_t *i4 = INSTR_CREATE_shr(dcontext, spill_gpr32_opnd, imm_opnd);
        // mov %eax, tls_slot(output_mask)
        instr_t *i5 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr32, TLS_K_idx_SLOT(output_k_idx), OPSZ_4);
        // pop rax
        instr_t *i6 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
        // popfq
        instr_t *i7 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
        instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
        return i1;
    } else { // clear to 0
        // pushfq
        instr_t *i1 = INSTR_CREATE_pushf(dcontext);
        // push rax
        instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
        // xor %rax, %rax | XOR r/m64, r64
        instr_t *i3 = INSTR_CREATE_xor(dcontext, spill_gpr64_opnd, spill_gpr64_opnd);
        // mov %eax, tls_slot(output_mask)
        instr_t *i4 = SAVE_TO_SIZED_TLS(dcontext, spill_gpr32, TLS_K_idx_SLOT(output_k_idx), OPSZ_4);
        // pop rax
        instr_t *i5 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
        // popfq
        instr_t *i6 = INSTR_CREATE_popf(dcontext);
#ifdef DEBUG
        print_rewrite_variadic_instr(dcontext, 6, i1, i2, i3, i4, i5, i6);
#endif
        instrlist_concat_next_instr(ilist, 6, i1, i2, i3, i4, i5, i6);
        return i1;
    }
    return NULL_INSTR;
}

/**
 * @brief ktest_ template function
 */
instr_t *
rw_func_ktest_(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
#ifdef DEBUG
    REWRITE_ERROR(STD_ERRF, "rewrite ktest_ not support");
#endif
    return NULL_INSTR;
}

instr_t * /* 519 */
rw_func_ktestw(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // ktestw %k1 - Test 16-bit mask register and set flags
    // SF := 0; OF := 0; AF := 0; PF := 0
    // IF SRC[15:0] = 0 THEN ZF := 1 ELSE ZF := 0 FI
    // IF SRC[15:0] = 0xFFFF THEN CF := 1 ELSE CF := 0 FI
    opnd_t src_opnd = instr_get_src(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting ktestw at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src_opnd, "input src: ");
#endif
    reg_id_t input_mask = opnd_get_reg(src_opnd);
    uint input_k_idx = TO_K_REG_INDEX(input_mask);

    reg_id_t spill_gpr64 = DR_REG_RAX;
    reg_id_t spill_gpr16 = DR_REG_AX;

    opnd_t spill_gpr64_opnd = opnd_create_reg(spill_gpr64);
    opnd_t spill_gpr16_opnd = opnd_create_reg(spill_gpr16);

    // pushfq
    instr_t *i1 = INSTR_CREATE_pushf(dcontext);
    // push rax
    instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
    // tls_slot(input_mask) -> %ax
    instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr16, TLS_K_idx_SLOT(input_k_idx), OPSZ_2);
    // test %ax, %ax - test for zero (sets ZF)
    instr_t *i4 = INSTR_CREATE_test(dcontext, spill_gpr16_opnd, spill_gpr16_opnd);
    // cmp $0xFFFF, %ax - test for all ones (sets CF if equal)
    instr_t *i5 = INSTR_CREATE_cmp(dcontext, spill_gpr16_opnd, opnd_create_immed_int(0xFFFF, OPSZ_2));
    // pop rax
    instr_t *i6 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
    // popfq
    instr_t *i7 = INSTR_CREATE_popf(dcontext);

#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
    instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
    return i1;
}

instr_t * /* 520 */
rw_func_ktestb(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // ktestb %k1 - Test 8-bit mask register and set flags
    // SF := 0; OF := 0; AF := 0; PF := 0
    // IF SRC[7:0] = 0 THEN ZF := 1 ELSE ZF := 0 FI
    // IF SRC[7:0] = 0xFF THEN CF := 1 ELSE CF := 0 FI
    opnd_t src_opnd = instr_get_src(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting ktestb at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src_opnd, "input src: ");
#endif
    reg_id_t input_mask = opnd_get_reg(src_opnd);
    uint input_k_idx = TO_K_REG_INDEX(input_mask);

    reg_id_t spill_gpr64 = DR_REG_RAX;
    reg_id_t spill_gpr8 = DR_REG_AL;

    opnd_t spill_gpr64_opnd = opnd_create_reg(spill_gpr64);
    opnd_t spill_gpr8_opnd = opnd_create_reg(spill_gpr8);

    // pushfq
    instr_t *i1 = INSTR_CREATE_pushf(dcontext);
    // push rax
    instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
    // tls_slot(input_mask) -> %al
    instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr8, TLS_K_idx_SLOT(input_k_idx), OPSZ_1);
    // test %al, %al - test for zero (sets ZF)
    instr_t *i4 = INSTR_CREATE_test(dcontext, spill_gpr8_opnd, spill_gpr8_opnd);
    // cmp $0xFF, %al - test for all ones (sets CF if equal)
    instr_t *i5 = INSTR_CREATE_cmp(dcontext, spill_gpr8_opnd, opnd_create_immed_int(0xFF, OPSZ_1));
    // pop rax
    instr_t *i6 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
    // popfq
    instr_t *i7 = INSTR_CREATE_popf(dcontext);

#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
    instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
    return i1;
}

instr_t * /* 521 */
rw_func_ktestq(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // ktestq %k1 - Test 64-bit mask register and set flags
    // SF := 0; OF := 0; AF := 0; PF := 0
    // IF SRC[63:0] = 0 THEN ZF := 1 ELSE ZF := 0 FI
    // IF SRC[63:0] = 0xFFFFFFFFFFFFFFFF THEN CF := 1 ELSE CF := 0 FI
    opnd_t src_opnd = instr_get_src(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting ktestq at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src_opnd, "input src: ");
#endif
    reg_id_t input_mask = opnd_get_reg(src_opnd);
    uint input_k_idx = TO_K_REG_INDEX(input_mask);

    reg_id_t spill_gpr64 = DR_REG_RAX;
    opnd_t spill_gpr64_opnd = opnd_create_reg(spill_gpr64);

    // pushfq
    instr_t *i1 = INSTR_CREATE_pushf(dcontext);
    // push rax
    instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
    // tls_slot(input_mask) -> %rax
    instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr64, TLS_K_idx_SLOT(input_k_idx), OPSZ_8);
    // test %rax, %rax - test for zero (sets ZF)
    instr_t *i4 = INSTR_CREATE_test(dcontext, spill_gpr64_opnd, spill_gpr64_opnd);
    // cmp $-1, %rax - test for all ones (sets CF if equal)
    instr_t *i5 = INSTR_CREATE_cmp(dcontext, spill_gpr64_opnd, opnd_create_immed_int(-1, OPSZ_8));
    // pop rax
    instr_t *i6 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
    // popfq
    instr_t *i7 = INSTR_CREATE_popf(dcontext);

#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
    instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
    return i1;
}

instr_t * /* 522 */
rw_func_ktestd(dcontext_t *dcontext, instrlist_t *ilist, instr_t *instr, app_pc instr_start)
{
    // ktestd %k1 - Test 32-bit mask register and set flags
    // SF := 0; OF := 0; AF := 0; PF := 0
    // IF SRC[31:0] = 0 THEN ZF := 1 ELSE ZF := 0 FI
    // IF SRC[31:0] = 0xFFFFFFFF THEN CF := 1 ELSE CF := 0 FI
    opnd_t src_opnd = instr_get_src(instr, 0);
#ifdef DEBUG
    REWRITE_INFO(STD_OUTF, "==== Rewriting ktestd at %p ====", instr_start);
    instr_disassemble(dcontext, instr, STD_OUTF);
    NEWLINE(STD_OUTF);
    dr_print_opnd(dcontext, STD_OUTF, src_opnd, "input src: ");
#endif
    reg_id_t input_mask = opnd_get_reg(src_opnd);
    uint input_k_idx = TO_K_REG_INDEX(input_mask);

    reg_id_t spill_gpr64 = DR_REG_RAX;
    reg_id_t spill_gpr32 = DR_REG_EAX;

    opnd_t spill_gpr64_opnd = opnd_create_reg(spill_gpr64);
    opnd_t spill_gpr32_opnd = opnd_create_reg(spill_gpr32);

    // pushfq
    instr_t *i1 = INSTR_CREATE_pushf(dcontext);
    // push rax
    instr_t *i2 = INSTR_CREATE_push(dcontext, spill_gpr64_opnd);
    // tls_slot(input_mask) -> %eax
    instr_t *i3 = RESTORE_FROM_SIZED_TLS(dcontext, spill_gpr32, TLS_K_idx_SLOT(input_k_idx), OPSZ_4);
    // test %eax, %eax - test for zero (sets ZF)
    instr_t *i4 = INSTR_CREATE_test(dcontext, spill_gpr32_opnd, spill_gpr32_opnd);
    // cmp $-1, %eax - test for all ones (sets CF if equal)
    instr_t *i5 = INSTR_CREATE_cmp(dcontext, spill_gpr32_opnd, opnd_create_immed_int(-1, OPSZ_4));
    // pop rax
    instr_t *i6 = INSTR_CREATE_pop(dcontext, spill_gpr64_opnd);
    // popfq
    instr_t *i7 = INSTR_CREATE_popf(dcontext);

#ifdef DEBUG
    print_rewrite_variadic_instr(dcontext, 7, i1, i2, i3, i4, i5, i6, i7);
#endif
    instrlist_concat_next_instr(ilist, 7, i1, i2, i3, i4, i5, i6, i7);
    return i1;
}
